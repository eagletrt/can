/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2018-2019 Erik Moqvist
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/**
 * This file was generated by cantools version 38.0.2 Sat Nov 11 17:46:51 2023.
 */

#include <string.h>

#include "simulator_network.h"

static uint8_t pack_left_shift_u8(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value << shift) & mask);
}

static uint8_t pack_left_shift_u16(
    uint16_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value << shift) & mask);
}

static uint8_t pack_left_shift_u32(
    uint32_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value << shift) & mask);
}

static uint8_t pack_right_shift_u16(
    uint16_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value >> shift) & mask);
}

static uint8_t pack_right_shift_u32(
    uint32_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value >> shift) & mask);
}

static uint16_t unpack_left_shift_u16(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint16_t)((uint16_t)(value & mask) << shift);
}

static uint32_t unpack_left_shift_u32(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint32_t)((uint32_t)(value & mask) << shift);
}

static uint8_t unpack_right_shift_u8(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value & mask) >> shift);
}

static uint16_t unpack_right_shift_u16(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint16_t)((uint16_t)(value & mask) >> shift);
}

static uint32_t unpack_right_shift_u32(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint32_t)((uint32_t)(value & mask) >> shift);
}

int simulator_imu_angular_rate_pack(
    uint8_t *dst_p,
    const simulator_imu_angular_rate_t *src_p,
    size_t byte_size)
{
    uint16_t ang_rate_x;
    uint16_t ang_rate_y;
    uint16_t ang_rate_z;

    if (byte_size < 6u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 6);

    ang_rate_x = (uint16_t)src_p->ang_rate_x;
    dst_p[0] |= pack_right_shift_u16(ang_rate_x, 8u, 0xffu);
    dst_p[1] |= pack_left_shift_u16(ang_rate_x, 0u, 0xffu);
    ang_rate_y = (uint16_t)src_p->ang_rate_y;
    dst_p[2] |= pack_right_shift_u16(ang_rate_y, 8u, 0xffu);
    dst_p[3] |= pack_left_shift_u16(ang_rate_y, 0u, 0xffu);
    ang_rate_z = (uint16_t)src_p->ang_rate_z;
    dst_p[4] |= pack_right_shift_u16(ang_rate_z, 8u, 0xffu);
    dst_p[5] |= pack_left_shift_u16(ang_rate_z, 0u, 0xffu);

    return (6);
}

int simulator_imu_angular_rate_unpack(
    simulator_imu_angular_rate_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    )
{
    uint16_t ang_rate_x;
    uint16_t ang_rate_y;
    uint16_t ang_rate_z;

    if (byte_size < 6u) {
        return (-EINVAL);
    }
#ifdef CANLIB_TIMESTAMP
    dst_p->_timestamp = _timestamp;
#endif // CANLIB_TIMESTAMP

    ang_rate_x =  unpack_left_shift_u16(src_p[0], 8u, 0xffu);
    ang_rate_x |=  unpack_right_shift_u16(src_p[1], 0u, 0xffu);
    dst_p->ang_rate_x = (int16_t)ang_rate_x;
    ang_rate_y =  unpack_left_shift_u16(src_p[2], 8u, 0xffu);
    ang_rate_y |=  unpack_right_shift_u16(src_p[3], 0u, 0xffu);
    dst_p->ang_rate_y = (int16_t)ang_rate_y;
    ang_rate_z =  unpack_left_shift_u16(src_p[4], 8u, 0xffu);
    ang_rate_z |=  unpack_right_shift_u16(src_p[5], 0u, 0xffu);
    dst_p->ang_rate_z = (int16_t)ang_rate_z;

    return (0);
}

int16_t simulator_imu_angular_rate_ang_rate_x_encode(float value)
{
    return (int16_t)(canlib_max(-32768, canlib_min(32767, value / 0.1f)));
}

float simulator_imu_angular_rate_ang_rate_x_decode(int16_t value)
{
    return ((float)value * 0.1f);
}

bool simulator_imu_angular_rate_ang_rate_x_is_in_range(int16_t value)
{
    return ((value >= 0) && (value <= 2450));
}

int16_t simulator_imu_angular_rate_ang_rate_y_encode(float value)
{
    return (int16_t)(canlib_max(-32768, canlib_min(32767, value / 0.1f)));
}

float simulator_imu_angular_rate_ang_rate_y_decode(int16_t value)
{
    return ((float)value * 0.1f);
}

bool simulator_imu_angular_rate_ang_rate_y_is_in_range(int16_t value)
{
    return ((value >= 0) && (value <= 2450));
}

int16_t simulator_imu_angular_rate_ang_rate_z_encode(float value)
{
    return (int16_t)(canlib_max(-32768, canlib_min(32767, value / 0.1f)));
}

float simulator_imu_angular_rate_ang_rate_z_decode(int16_t value)
{
    return ((float)value * 0.1f);
}

bool simulator_imu_angular_rate_ang_rate_z_is_in_range(int16_t value)
{
    return ((value >= 0) && (value <= 2450));
}


void simulator_imu_angular_rate_raw_to_conversion(
    simulator_imu_angular_rate_converted_t *conversion,
    float ang_rate_x,
    float ang_rate_y,
    float ang_rate_z
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
){
#ifdef CANLIB_TIMESTAMP
    conversion->_timestamp = _timestamp;
#endif // CANLIB_TIMESTAMP
    conversion->ang_rate_x = simulator_imu_angular_rate_ang_rate_x_decode(ang_rate_x);
    conversion->ang_rate_y = simulator_imu_angular_rate_ang_rate_y_decode(ang_rate_y);
    conversion->ang_rate_z = simulator_imu_angular_rate_ang_rate_z_decode(ang_rate_z);
}


void simulator_imu_angular_rate_conversion_to_raw(
    simulator_imu_angular_rate_t *raw,
    float ang_rate_x,
    float ang_rate_y,
    float ang_rate_z
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
){
#ifdef CANLIB_TIMESTAMP
    raw->_timestamp = _timestamp;
#endif // CANLIB_TIMESTAMP
    raw->ang_rate_x = simulator_imu_angular_rate_ang_rate_x_encode(ang_rate_x);
    raw->ang_rate_y = simulator_imu_angular_rate_ang_rate_y_encode(ang_rate_y);
    raw->ang_rate_z = simulator_imu_angular_rate_ang_rate_z_encode(ang_rate_z);
}


void simulator_imu_angular_rate_raw_to_conversion_struct(
    simulator_imu_angular_rate_converted_t *conversion, 
    const simulator_imu_angular_rate_t *raw)
{
#ifdef CANLIB_TIMESTAMP
    conversion->_timestamp = raw->_timestamp;
#endif // CANLIB_TIMESTAMP
    conversion->ang_rate_x = simulator_imu_angular_rate_ang_rate_x_decode(raw->ang_rate_x);
    conversion->ang_rate_y = simulator_imu_angular_rate_ang_rate_y_decode(raw->ang_rate_y);
    conversion->ang_rate_z = simulator_imu_angular_rate_ang_rate_z_decode(raw->ang_rate_z);
}


void simulator_imu_angular_rate_conversion_to_raw_struct(
    simulator_imu_angular_rate_t *raw,
    const simulator_imu_angular_rate_converted_t *conversion)
{
#ifdef CANLIB_TIMESTAMP
    raw->_timestamp = conversion->_timestamp;
#endif // CANLIB_TIMESTAMP
    raw->ang_rate_x = simulator_imu_angular_rate_ang_rate_x_encode(conversion->ang_rate_x);
    raw->ang_rate_y = simulator_imu_angular_rate_ang_rate_y_encode(conversion->ang_rate_y);
    raw->ang_rate_z = simulator_imu_angular_rate_ang_rate_z_encode(conversion->ang_rate_z);
}

int simulator_imu_angular_rate_converted_to_string(simulator_imu_angular_rate_converted_t *message, char *buffer){
    return sprintf(
        buffer,
        ""
        #ifdef CANLIB_TIMESTAMP
        "%" PRIu64 ","
        #endif // CANLIB_TIMESTAMP
    "%f"","
    "%f"","
    "%f",

#ifdef CANLIB_TIMESTAMP
    message->_timestamp,
#endif // CANLIB_TIMESTAMP
    message->ang_rate_x,
    message->ang_rate_y,
    message->ang_rate_z
);
}

int simulator_imu_angular_rate_converted_to_string_file(simulator_imu_angular_rate_converted_t *message, FILE *buffer){
    return fprintf(
        buffer,
        ""
        #ifdef CANLIB_TIMESTAMP
        "%" PRIu64 ","
        #endif // CANLIB_TIMESTAMP
    "%f"","
    "%f"","
    "%f",

#ifdef CANLIB_TIMESTAMP
    message->_timestamp,
#endif // CANLIB_TIMESTAMP
    message->ang_rate_x,
    message->ang_rate_y,
    message->ang_rate_z
);
}

int simulator_imu_angular_rate_fields(char *buffer){
    return sprintf(
        buffer,
        ""
        #ifdef CANLIB_TIMESTAMP
            "_timestamp" ","
        #endif // CANLIB_TIMESTAMP
    "ang_rate_x"","
    "ang_rate_y"","
    "ang_rate_z");
}

int simulator_imu_angular_rate_fields_file(FILE *buffer){
    return fprintf(
        buffer,
        ""
        #ifdef CANLIB_TIMESTAMP
            "_timestamp" ","
        #endif // CANLIB_TIMESTAMP
    "ang_rate_x"","
    "ang_rate_y"","
    "ang_rate_z");
}


int simulator_imu_acceleration_pack(
    uint8_t *dst_p,
    const simulator_imu_acceleration_t *src_p,
    size_t byte_size)
{
    uint16_t accel_x;
    uint16_t accel_y;
    uint16_t accel_z;
    uint16_t temperature;

    if (byte_size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    accel_x = (uint16_t)src_p->accel_x;
    dst_p[0] |= pack_right_shift_u16(accel_x, 8u, 0xffu);
    dst_p[1] |= pack_left_shift_u16(accel_x, 0u, 0xffu);
    accel_y = (uint16_t)src_p->accel_y;
    dst_p[2] |= pack_right_shift_u16(accel_y, 8u, 0xffu);
    dst_p[3] |= pack_left_shift_u16(accel_y, 0u, 0xffu);
    accel_z = (uint16_t)src_p->accel_z;
    dst_p[4] |= pack_right_shift_u16(accel_z, 8u, 0xffu);
    dst_p[5] |= pack_left_shift_u16(accel_z, 0u, 0xffu);
    temperature = (uint16_t)src_p->temperature;
    dst_p[6] |= pack_right_shift_u16(temperature, 8u, 0xffu);
    dst_p[7] |= pack_left_shift_u16(temperature, 0u, 0xffu);

    return (8);
}

int simulator_imu_acceleration_unpack(
    simulator_imu_acceleration_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    )
{
    uint16_t accel_x;
    uint16_t accel_y;
    uint16_t accel_z;
    uint16_t temperature;

    if (byte_size < 8u) {
        return (-EINVAL);
    }
#ifdef CANLIB_TIMESTAMP
    dst_p->_timestamp = _timestamp;
#endif // CANLIB_TIMESTAMP

    accel_x =  unpack_left_shift_u16(src_p[0], 8u, 0xffu);
    accel_x |=  unpack_right_shift_u16(src_p[1], 0u, 0xffu);
    dst_p->accel_x = (int16_t)accel_x;
    accel_y =  unpack_left_shift_u16(src_p[2], 8u, 0xffu);
    accel_y |=  unpack_right_shift_u16(src_p[3], 0u, 0xffu);
    dst_p->accel_y = (int16_t)accel_y;
    accel_z =  unpack_left_shift_u16(src_p[4], 8u, 0xffu);
    accel_z |=  unpack_right_shift_u16(src_p[5], 0u, 0xffu);
    dst_p->accel_z = (int16_t)accel_z;
    temperature =  unpack_left_shift_u16(src_p[6], 8u, 0xffu);
    temperature |=  unpack_right_shift_u16(src_p[7], 0u, 0xffu);
    dst_p->temperature = (int16_t)temperature;

    return (0);
}

int16_t simulator_imu_acceleration_accel_x_encode(float value)
{
    return (int16_t)(canlib_max(-32768, canlib_min(32767, value / 0.01f)));
}

float simulator_imu_acceleration_accel_x_decode(int16_t value)
{
    return ((float)value * 0.01f);
}

bool simulator_imu_acceleration_accel_x_is_in_range(int16_t value)
{
    return ((value >= 0) && (value <= 800));
}

int16_t simulator_imu_acceleration_accel_y_encode(float value)
{
    return (int16_t)(canlib_max(-32768, canlib_min(32767, value / 0.01f)));
}

float simulator_imu_acceleration_accel_y_decode(int16_t value)
{
    return ((float)value * 0.01f);
}

bool simulator_imu_acceleration_accel_y_is_in_range(int16_t value)
{
    return ((value >= 0) && (value <= 800));
}

int16_t simulator_imu_acceleration_accel_z_encode(float value)
{
    return (int16_t)(canlib_max(-32768, canlib_min(32767, value / 0.01f)));
}

float simulator_imu_acceleration_accel_z_decode(int16_t value)
{
    return ((float)value * 0.01f);
}

bool simulator_imu_acceleration_accel_z_is_in_range(int16_t value)
{
    return ((value >= 0) && (value <= 800));
}

bool simulator_imu_acceleration_temperature_is_in_range(int16_t value)
{
    return (value >= 0);
}


void simulator_imu_acceleration_raw_to_conversion(
    simulator_imu_acceleration_converted_t *conversion,
    float accel_x,
    float accel_y,
    float accel_z,
    int16_t temperature
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
){
#ifdef CANLIB_TIMESTAMP
    conversion->_timestamp = _timestamp;
#endif // CANLIB_TIMESTAMP
    conversion->accel_x = simulator_imu_acceleration_accel_x_decode(accel_x);
    conversion->accel_y = simulator_imu_acceleration_accel_y_decode(accel_y);
    conversion->accel_z = simulator_imu_acceleration_accel_z_decode(accel_z);
    conversion->temperature = temperature;
}


void simulator_imu_acceleration_conversion_to_raw(
    simulator_imu_acceleration_t *raw,
    float accel_x,
    float accel_y,
    float accel_z,
    int16_t temperature
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
){
#ifdef CANLIB_TIMESTAMP
    raw->_timestamp = _timestamp;
#endif // CANLIB_TIMESTAMP
    raw->accel_x = simulator_imu_acceleration_accel_x_encode(accel_x);
    raw->accel_y = simulator_imu_acceleration_accel_y_encode(accel_y);
    raw->accel_z = simulator_imu_acceleration_accel_z_encode(accel_z);
    raw->temperature = temperature;
}


void simulator_imu_acceleration_raw_to_conversion_struct(
    simulator_imu_acceleration_converted_t *conversion, 
    const simulator_imu_acceleration_t *raw)
{
#ifdef CANLIB_TIMESTAMP
    conversion->_timestamp = raw->_timestamp;
#endif // CANLIB_TIMESTAMP
    conversion->accel_x = simulator_imu_acceleration_accel_x_decode(raw->accel_x);
    conversion->accel_y = simulator_imu_acceleration_accel_y_decode(raw->accel_y);
    conversion->accel_z = simulator_imu_acceleration_accel_z_decode(raw->accel_z);
    conversion->temperature = raw->temperature;
}


void simulator_imu_acceleration_conversion_to_raw_struct(
    simulator_imu_acceleration_t *raw,
    const simulator_imu_acceleration_converted_t *conversion)
{
#ifdef CANLIB_TIMESTAMP
    raw->_timestamp = conversion->_timestamp;
#endif // CANLIB_TIMESTAMP
    raw->accel_x = simulator_imu_acceleration_accel_x_encode(conversion->accel_x);
    raw->accel_y = simulator_imu_acceleration_accel_y_encode(conversion->accel_y);
    raw->accel_z = simulator_imu_acceleration_accel_z_encode(conversion->accel_z);
    raw->temperature = conversion->temperature;
}

int simulator_imu_acceleration_converted_to_string(simulator_imu_acceleration_converted_t *message, char *buffer){
    return sprintf(
        buffer,
        ""
        #ifdef CANLIB_TIMESTAMP
        "%" PRIu64 ","
        #endif // CANLIB_TIMESTAMP
    "%f"","
    "%f"","
    "%f"","
    "%" PRIi16 "",

#ifdef CANLIB_TIMESTAMP
    message->_timestamp,
#endif // CANLIB_TIMESTAMP
    message->accel_x,
    message->accel_y,
    message->accel_z,
    message->temperature
);
}

int simulator_imu_acceleration_converted_to_string_file(simulator_imu_acceleration_converted_t *message, FILE *buffer){
    return fprintf(
        buffer,
        ""
        #ifdef CANLIB_TIMESTAMP
        "%" PRIu64 ","
        #endif // CANLIB_TIMESTAMP
    "%f"","
    "%f"","
    "%f"","
    "%" PRIi16 "",

#ifdef CANLIB_TIMESTAMP
    message->_timestamp,
#endif // CANLIB_TIMESTAMP
    message->accel_x,
    message->accel_y,
    message->accel_z,
    message->temperature
);
}

int simulator_imu_acceleration_fields(char *buffer){
    return sprintf(
        buffer,
        ""
        #ifdef CANLIB_TIMESTAMP
            "_timestamp" ","
        #endif // CANLIB_TIMESTAMP
    "accel_x"","
    "accel_y"","
    "accel_z"","
    "temperature");
}

int simulator_imu_acceleration_fields_file(FILE *buffer){
    return fprintf(
        buffer,
        ""
        #ifdef CANLIB_TIMESTAMP
            "_timestamp" ","
        #endif // CANLIB_TIMESTAMP
    "accel_x"","
    "accel_y"","
    "accel_z"","
    "temperature");
}


int simulator_pedals_output_pack(
    uint8_t *dst_p,
    const simulator_pedals_output_t *src_p,
    size_t byte_size)
{
    if (byte_size < 5u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 5);

    dst_p[0] |= pack_left_shift_u8(src_p->apps, 0u, 0xffu);
    dst_p[1] |= pack_left_shift_u16(src_p->bse_front, 0u, 0xffu);
    dst_p[2] |= pack_right_shift_u16(src_p->bse_front, 8u, 0xffu);
    dst_p[3] |= pack_left_shift_u16(src_p->bse_rear, 0u, 0xffu);
    dst_p[4] |= pack_right_shift_u16(src_p->bse_rear, 8u, 0xffu);

    return (5);
}

int simulator_pedals_output_unpack(
    simulator_pedals_output_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    )
{
    if (byte_size < 5u) {
        return (-EINVAL);
    }
#ifdef CANLIB_TIMESTAMP
    dst_p->_timestamp = _timestamp;
#endif // CANLIB_TIMESTAMP

    dst_p->apps =  unpack_right_shift_u8(src_p[0], 0u, 0xffu);
    dst_p->bse_front =  unpack_right_shift_u16(src_p[1], 0u, 0xffu);
    dst_p->bse_front |=  unpack_left_shift_u16(src_p[2], 8u, 0xffu);
    dst_p->bse_rear =  unpack_right_shift_u16(src_p[3], 0u, 0xffu);
    dst_p->bse_rear |=  unpack_left_shift_u16(src_p[4], 8u, 0xffu);

    return (0);
}

bool simulator_pedals_output_apps_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint16_t simulator_pedals_output_bse_front_encode(float value)
{
    return (uint16_t)(canlib_max(0, canlib_min(65535, value / 0.0015259021896696422f)));
}

float simulator_pedals_output_bse_front_decode(uint16_t value)
{
    return ((float)value * 0.0015259021896696422f);
}

bool simulator_pedals_output_bse_front_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t simulator_pedals_output_bse_rear_encode(float value)
{
    return (uint16_t)(canlib_max(0, canlib_min(65535, value / 0.0015259021896696422f)));
}

float simulator_pedals_output_bse_rear_decode(uint16_t value)
{
    return ((float)value * 0.0015259021896696422f);
}

bool simulator_pedals_output_bse_rear_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}


void simulator_pedals_output_raw_to_conversion(
    simulator_pedals_output_converted_t *conversion,
    uint8_t apps,
    float bse_front,
    float bse_rear
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
){
#ifdef CANLIB_TIMESTAMP
    conversion->_timestamp = _timestamp;
#endif // CANLIB_TIMESTAMP
    conversion->apps = apps;
    conversion->bse_front = simulator_pedals_output_bse_front_decode(bse_front);
    conversion->bse_rear = simulator_pedals_output_bse_rear_decode(bse_rear);
}


void simulator_pedals_output_conversion_to_raw(
    simulator_pedals_output_t *raw,
    uint8_t apps,
    float bse_front,
    float bse_rear
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
){
#ifdef CANLIB_TIMESTAMP
    raw->_timestamp = _timestamp;
#endif // CANLIB_TIMESTAMP
    raw->apps = apps;
    raw->bse_front = simulator_pedals_output_bse_front_encode(bse_front);
    raw->bse_rear = simulator_pedals_output_bse_rear_encode(bse_rear);
}


void simulator_pedals_output_raw_to_conversion_struct(
    simulator_pedals_output_converted_t *conversion, 
    const simulator_pedals_output_t *raw)
{
#ifdef CANLIB_TIMESTAMP
    conversion->_timestamp = raw->_timestamp;
#endif // CANLIB_TIMESTAMP
    conversion->apps = raw->apps;
    conversion->bse_front = simulator_pedals_output_bse_front_decode(raw->bse_front);
    conversion->bse_rear = simulator_pedals_output_bse_rear_decode(raw->bse_rear);
}


void simulator_pedals_output_conversion_to_raw_struct(
    simulator_pedals_output_t *raw,
    const simulator_pedals_output_converted_t *conversion)
{
#ifdef CANLIB_TIMESTAMP
    raw->_timestamp = conversion->_timestamp;
#endif // CANLIB_TIMESTAMP
    raw->apps = conversion->apps;
    raw->bse_front = simulator_pedals_output_bse_front_encode(conversion->bse_front);
    raw->bse_rear = simulator_pedals_output_bse_rear_encode(conversion->bse_rear);
}

int simulator_pedals_output_converted_to_string(simulator_pedals_output_converted_t *message, char *buffer){
    return sprintf(
        buffer,
        ""
        #ifdef CANLIB_TIMESTAMP
        "%" PRIu64 ","
        #endif // CANLIB_TIMESTAMP
    "%" PRIu8  ""","
    "%f"","
    "%f",

#ifdef CANLIB_TIMESTAMP
    message->_timestamp,
#endif // CANLIB_TIMESTAMP
    message->apps,
    message->bse_front,
    message->bse_rear
);
}

int simulator_pedals_output_converted_to_string_file(simulator_pedals_output_converted_t *message, FILE *buffer){
    return fprintf(
        buffer,
        ""
        #ifdef CANLIB_TIMESTAMP
        "%" PRIu64 ","
        #endif // CANLIB_TIMESTAMP
    "%" PRIu8  ""","
    "%f"","
    "%f",

#ifdef CANLIB_TIMESTAMP
    message->_timestamp,
#endif // CANLIB_TIMESTAMP
    message->apps,
    message->bse_front,
    message->bse_rear
);
}

int simulator_pedals_output_fields(char *buffer){
    return sprintf(
        buffer,
        ""
        #ifdef CANLIB_TIMESTAMP
            "_timestamp" ","
        #endif // CANLIB_TIMESTAMP
    "apps"","
    "bse_front"","
    "bse_rear");
}

int simulator_pedals_output_fields_file(FILE *buffer){
    return fprintf(
        buffer,
        ""
        #ifdef CANLIB_TIMESTAMP
            "_timestamp" ","
        #endif // CANLIB_TIMESTAMP
    "apps"","
    "bse_front"","
    "bse_rear");
}


int simulator_steering_angle_pack(
    uint8_t *dst_p,
    const simulator_steering_angle_t *src_p,
    size_t byte_size)
{
    if (byte_size < 4u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 4);

    dst_p[0] |= pack_left_shift_u32(src_p->angle, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(src_p->angle, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(src_p->angle, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(src_p->angle, 24u, 0xffu);

    return (4);
}

int simulator_steering_angle_unpack(
    simulator_steering_angle_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    )
{
    if (byte_size < 4u) {
        return (-EINVAL);
    }
#ifdef CANLIB_TIMESTAMP
    dst_p->_timestamp = _timestamp;
#endif // CANLIB_TIMESTAMP

    dst_p->angle =  unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    dst_p->angle |=  unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    dst_p->angle |=  unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    dst_p->angle |=  unpack_left_shift_u32(src_p[3], 24u, 0xffu);

    return (0);
}

uint32_t simulator_steering_angle_angle_encode(float value)
{
    return (uint32_t)(canlib_max(0, canlib_min(4294967295, (value - -360.0f) / 1.676380634698174e-07f)));
}

float simulator_steering_angle_angle_decode(uint32_t value)
{
    return (((float)value * 1.676380634698174e-07f) + -360.0f);
}

bool simulator_steering_angle_angle_is_in_range(uint32_t value)
{
    (void)value;

    return (true);
}


void simulator_steering_angle_raw_to_conversion(
    simulator_steering_angle_converted_t *conversion,
    float angle
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
){
#ifdef CANLIB_TIMESTAMP
    conversion->_timestamp = _timestamp;
#endif // CANLIB_TIMESTAMP
    conversion->angle = simulator_steering_angle_angle_decode(angle);
}


void simulator_steering_angle_conversion_to_raw(
    simulator_steering_angle_t *raw,
    float angle
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
){
#ifdef CANLIB_TIMESTAMP
    raw->_timestamp = _timestamp;
#endif // CANLIB_TIMESTAMP
    raw->angle = simulator_steering_angle_angle_encode(angle);
}


void simulator_steering_angle_raw_to_conversion_struct(
    simulator_steering_angle_converted_t *conversion, 
    const simulator_steering_angle_t *raw)
{
#ifdef CANLIB_TIMESTAMP
    conversion->_timestamp = raw->_timestamp;
#endif // CANLIB_TIMESTAMP
    conversion->angle = simulator_steering_angle_angle_decode(raw->angle);
}


void simulator_steering_angle_conversion_to_raw_struct(
    simulator_steering_angle_t *raw,
    const simulator_steering_angle_converted_t *conversion)
{
#ifdef CANLIB_TIMESTAMP
    raw->_timestamp = conversion->_timestamp;
#endif // CANLIB_TIMESTAMP
    raw->angle = simulator_steering_angle_angle_encode(conversion->angle);
}

int simulator_steering_angle_converted_to_string(simulator_steering_angle_converted_t *message, char *buffer){
    return sprintf(
        buffer,
        ""
        #ifdef CANLIB_TIMESTAMP
        "%" PRIu64 ","
        #endif // CANLIB_TIMESTAMP
    "%f",

#ifdef CANLIB_TIMESTAMP
    message->_timestamp,
#endif // CANLIB_TIMESTAMP
    message->angle
);
}

int simulator_steering_angle_converted_to_string_file(simulator_steering_angle_converted_t *message, FILE *buffer){
    return fprintf(
        buffer,
        ""
        #ifdef CANLIB_TIMESTAMP
        "%" PRIu64 ","
        #endif // CANLIB_TIMESTAMP
    "%f",

#ifdef CANLIB_TIMESTAMP
    message->_timestamp,
#endif // CANLIB_TIMESTAMP
    message->angle
);
}

int simulator_steering_angle_fields(char *buffer){
    return sprintf(
        buffer,
        ""
        #ifdef CANLIB_TIMESTAMP
            "_timestamp" ","
        #endif // CANLIB_TIMESTAMP
    "angle");
}

int simulator_steering_angle_fields_file(FILE *buffer){
    return fprintf(
        buffer,
        ""
        #ifdef CANLIB_TIMESTAMP
            "_timestamp" ","
        #endif // CANLIB_TIMESTAMP
    "angle");
}


int simulator_control_state_pack(
    uint8_t *dst_p,
    const simulator_control_state_t *src_p,
    size_t byte_size)
{
    if (byte_size < 3u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 3);

    dst_p[0] |= pack_left_shift_u8(src_p->map_pw, 0u, 0xffu);
    dst_p[1] |= pack_left_shift_u8(src_p->map_sc, 0u, 0xffu);
    dst_p[2] |= pack_left_shift_u8(src_p->map_tv, 0u, 0xffu);

    return (3);
}

int simulator_control_state_unpack(
    simulator_control_state_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    )
{
    if (byte_size < 3u) {
        return (-EINVAL);
    }
#ifdef CANLIB_TIMESTAMP
    dst_p->_timestamp = _timestamp;
#endif // CANLIB_TIMESTAMP

    dst_p->map_pw =  unpack_right_shift_u8(src_p[0], 0u, 0xffu);
    dst_p->map_sc =  unpack_right_shift_u8(src_p[1], 0u, 0xffu);
    dst_p->map_tv =  unpack_right_shift_u8(src_p[2], 0u, 0xffu);

    return (0);
}

uint8_t simulator_control_state_map_pw_encode(float value)
{
    return (uint8_t)(canlib_max(0, canlib_min(255, (value - -0.5f) / 0.01f)));
}

float simulator_control_state_map_pw_decode(uint8_t value)
{
    return (((float)value * 0.01f) + -0.5f);
}

bool simulator_control_state_map_pw_is_in_range(uint8_t value)
{
    return (value <= 150u);
}

uint8_t simulator_control_state_map_sc_encode(float value)
{
    return (uint8_t)(canlib_max(0, canlib_min(255, value / 0.01f)));
}

float simulator_control_state_map_sc_decode(uint8_t value)
{
    return ((float)value * 0.01f);
}

bool simulator_control_state_map_sc_is_in_range(uint8_t value)
{
    return (value <= 100u);
}

uint8_t simulator_control_state_map_tv_encode(float value)
{
    return (uint8_t)(canlib_max(0, canlib_min(255, value / 0.01f)));
}

float simulator_control_state_map_tv_decode(uint8_t value)
{
    return ((float)value * 0.01f);
}

bool simulator_control_state_map_tv_is_in_range(uint8_t value)
{
    return (value <= 100u);
}


void simulator_control_state_raw_to_conversion(
    simulator_control_state_converted_t *conversion,
    float map_pw,
    float map_sc,
    float map_tv
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
){
#ifdef CANLIB_TIMESTAMP
    conversion->_timestamp = _timestamp;
#endif // CANLIB_TIMESTAMP
    conversion->map_pw = simulator_control_state_map_pw_decode(map_pw);
    conversion->map_sc = simulator_control_state_map_sc_decode(map_sc);
    conversion->map_tv = simulator_control_state_map_tv_decode(map_tv);
}


void simulator_control_state_conversion_to_raw(
    simulator_control_state_t *raw,
    float map_pw,
    float map_sc,
    float map_tv
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
){
#ifdef CANLIB_TIMESTAMP
    raw->_timestamp = _timestamp;
#endif // CANLIB_TIMESTAMP
    raw->map_pw = simulator_control_state_map_pw_encode(map_pw);
    raw->map_sc = simulator_control_state_map_sc_encode(map_sc);
    raw->map_tv = simulator_control_state_map_tv_encode(map_tv);
}


void simulator_control_state_raw_to_conversion_struct(
    simulator_control_state_converted_t *conversion, 
    const simulator_control_state_t *raw)
{
#ifdef CANLIB_TIMESTAMP
    conversion->_timestamp = raw->_timestamp;
#endif // CANLIB_TIMESTAMP
    conversion->map_pw = simulator_control_state_map_pw_decode(raw->map_pw);
    conversion->map_sc = simulator_control_state_map_sc_decode(raw->map_sc);
    conversion->map_tv = simulator_control_state_map_tv_decode(raw->map_tv);
}


void simulator_control_state_conversion_to_raw_struct(
    simulator_control_state_t *raw,
    const simulator_control_state_converted_t *conversion)
{
#ifdef CANLIB_TIMESTAMP
    raw->_timestamp = conversion->_timestamp;
#endif // CANLIB_TIMESTAMP
    raw->map_pw = simulator_control_state_map_pw_encode(conversion->map_pw);
    raw->map_sc = simulator_control_state_map_sc_encode(conversion->map_sc);
    raw->map_tv = simulator_control_state_map_tv_encode(conversion->map_tv);
}

int simulator_control_state_converted_to_string(simulator_control_state_converted_t *message, char *buffer){
    return sprintf(
        buffer,
        ""
        #ifdef CANLIB_TIMESTAMP
        "%" PRIu64 ","
        #endif // CANLIB_TIMESTAMP
    "%f"","
    "%f"","
    "%f",

#ifdef CANLIB_TIMESTAMP
    message->_timestamp,
#endif // CANLIB_TIMESTAMP
    message->map_pw,
    message->map_sc,
    message->map_tv
);
}

int simulator_control_state_converted_to_string_file(simulator_control_state_converted_t *message, FILE *buffer){
    return fprintf(
        buffer,
        ""
        #ifdef CANLIB_TIMESTAMP
        "%" PRIu64 ","
        #endif // CANLIB_TIMESTAMP
    "%f"","
    "%f"","
    "%f",

#ifdef CANLIB_TIMESTAMP
    message->_timestamp,
#endif // CANLIB_TIMESTAMP
    message->map_pw,
    message->map_sc,
    message->map_tv
);
}

int simulator_control_state_fields(char *buffer){
    return sprintf(
        buffer,
        ""
        #ifdef CANLIB_TIMESTAMP
            "_timestamp" ","
        #endif // CANLIB_TIMESTAMP
    "map_pw"","
    "map_sc"","
    "map_tv");
}

int simulator_control_state_fields_file(FILE *buffer){
    return fprintf(
        buffer,
        ""
        #ifdef CANLIB_TIMESTAMP
            "_timestamp" ","
        #endif // CANLIB_TIMESTAMP
    "map_pw"","
    "map_sc"","
    "map_tv");
}


int simulator_control_output_pack(
    uint8_t *dst_p,
    const simulator_control_output_t *src_p,
    size_t byte_size)
{
    if (byte_size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u16(src_p->estimated_velocity, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(src_p->estimated_velocity, 8u, 0xffu);
    dst_p[2] |= pack_left_shift_u8(src_p->tmax_r, 0u, 0xffu);
    dst_p[3] |= pack_left_shift_u8(src_p->tmax_l, 0u, 0xffu);
    dst_p[4] |= pack_left_shift_u16(src_p->torque_l, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(src_p->torque_l, 8u, 0xffu);
    dst_p[6] |= pack_left_shift_u16(src_p->torque_r, 0u, 0xffu);
    dst_p[7] |= pack_right_shift_u16(src_p->torque_r, 8u, 0xffu);

    return (8);
}

int simulator_control_output_unpack(
    simulator_control_output_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    )
{
    if (byte_size < 8u) {
        return (-EINVAL);
    }
#ifdef CANLIB_TIMESTAMP
    dst_p->_timestamp = _timestamp;
#endif // CANLIB_TIMESTAMP

    dst_p->estimated_velocity =  unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    dst_p->estimated_velocity |=  unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->tmax_r =  unpack_right_shift_u8(src_p[2], 0u, 0xffu);
    dst_p->tmax_l =  unpack_right_shift_u8(src_p[3], 0u, 0xffu);
    dst_p->torque_l =  unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    dst_p->torque_l |=  unpack_left_shift_u16(src_p[5], 8u, 0xffu);
    dst_p->torque_r =  unpack_right_shift_u16(src_p[6], 0u, 0xffu);
    dst_p->torque_r |=  unpack_left_shift_u16(src_p[7], 8u, 0xffu);

    return (0);
}

uint16_t simulator_control_output_estimated_velocity_encode(float value)
{
    return (uint16_t)(canlib_max(0, canlib_min(65535, (value - -10.0f) / 0.0009155413138017853f)));
}

float simulator_control_output_estimated_velocity_decode(uint16_t value)
{
    return (((float)value * 0.0009155413138017853f) + -10.0f);
}

bool simulator_control_output_estimated_velocity_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint8_t simulator_control_output_tmax_r_encode(float value)
{
    return (uint8_t)(canlib_max(0, canlib_min(255, value / 0.3137254901960784f)));
}

float simulator_control_output_tmax_r_decode(uint8_t value)
{
    return ((float)value * 0.3137254901960784f);
}

bool simulator_control_output_tmax_r_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t simulator_control_output_tmax_l_encode(float value)
{
    return (uint8_t)(canlib_max(0, canlib_min(255, value / 0.3137254901960784f)));
}

float simulator_control_output_tmax_l_decode(uint8_t value)
{
    return ((float)value * 0.3137254901960784f);
}

bool simulator_control_output_tmax_l_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint16_t simulator_control_output_torque_l_encode(float value)
{
    return (uint16_t)(canlib_max(0, canlib_min(65535, value / 0.0012207217517357137f)));
}

float simulator_control_output_torque_l_decode(uint16_t value)
{
    return ((float)value * 0.0012207217517357137f);
}

bool simulator_control_output_torque_l_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t simulator_control_output_torque_r_encode(float value)
{
    return (uint16_t)(canlib_max(0, canlib_min(65535, value / 0.0012207217517357137f)));
}

float simulator_control_output_torque_r_decode(uint16_t value)
{
    return ((float)value * 0.0012207217517357137f);
}

bool simulator_control_output_torque_r_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}


void simulator_control_output_raw_to_conversion(
    simulator_control_output_converted_t *conversion,
    float estimated_velocity,
    float tmax_r,
    float tmax_l,
    float torque_l,
    float torque_r
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
){
#ifdef CANLIB_TIMESTAMP
    conversion->_timestamp = _timestamp;
#endif // CANLIB_TIMESTAMP
    conversion->estimated_velocity = simulator_control_output_estimated_velocity_decode(estimated_velocity);
    conversion->tmax_r = simulator_control_output_tmax_r_decode(tmax_r);
    conversion->tmax_l = simulator_control_output_tmax_l_decode(tmax_l);
    conversion->torque_l = simulator_control_output_torque_l_decode(torque_l);
    conversion->torque_r = simulator_control_output_torque_r_decode(torque_r);
}


void simulator_control_output_conversion_to_raw(
    simulator_control_output_t *raw,
    float estimated_velocity,
    float tmax_r,
    float tmax_l,
    float torque_l,
    float torque_r
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
){
#ifdef CANLIB_TIMESTAMP
    raw->_timestamp = _timestamp;
#endif // CANLIB_TIMESTAMP
    raw->estimated_velocity = simulator_control_output_estimated_velocity_encode(estimated_velocity);
    raw->tmax_r = simulator_control_output_tmax_r_encode(tmax_r);
    raw->tmax_l = simulator_control_output_tmax_l_encode(tmax_l);
    raw->torque_l = simulator_control_output_torque_l_encode(torque_l);
    raw->torque_r = simulator_control_output_torque_r_encode(torque_r);
}


void simulator_control_output_raw_to_conversion_struct(
    simulator_control_output_converted_t *conversion, 
    const simulator_control_output_t *raw)
{
#ifdef CANLIB_TIMESTAMP
    conversion->_timestamp = raw->_timestamp;
#endif // CANLIB_TIMESTAMP
    conversion->estimated_velocity = simulator_control_output_estimated_velocity_decode(raw->estimated_velocity);
    conversion->tmax_r = simulator_control_output_tmax_r_decode(raw->tmax_r);
    conversion->tmax_l = simulator_control_output_tmax_l_decode(raw->tmax_l);
    conversion->torque_l = simulator_control_output_torque_l_decode(raw->torque_l);
    conversion->torque_r = simulator_control_output_torque_r_decode(raw->torque_r);
}


void simulator_control_output_conversion_to_raw_struct(
    simulator_control_output_t *raw,
    const simulator_control_output_converted_t *conversion)
{
#ifdef CANLIB_TIMESTAMP
    raw->_timestamp = conversion->_timestamp;
#endif // CANLIB_TIMESTAMP
    raw->estimated_velocity = simulator_control_output_estimated_velocity_encode(conversion->estimated_velocity);
    raw->tmax_r = simulator_control_output_tmax_r_encode(conversion->tmax_r);
    raw->tmax_l = simulator_control_output_tmax_l_encode(conversion->tmax_l);
    raw->torque_l = simulator_control_output_torque_l_encode(conversion->torque_l);
    raw->torque_r = simulator_control_output_torque_r_encode(conversion->torque_r);
}

int simulator_control_output_converted_to_string(simulator_control_output_converted_t *message, char *buffer){
    return sprintf(
        buffer,
        ""
        #ifdef CANLIB_TIMESTAMP
        "%" PRIu64 ","
        #endif // CANLIB_TIMESTAMP
    "%f"","
    "%f"","
    "%f"","
    "%f"","
    "%f",

#ifdef CANLIB_TIMESTAMP
    message->_timestamp,
#endif // CANLIB_TIMESTAMP
    message->estimated_velocity,
    message->tmax_r,
    message->tmax_l,
    message->torque_l,
    message->torque_r
);
}

int simulator_control_output_converted_to_string_file(simulator_control_output_converted_t *message, FILE *buffer){
    return fprintf(
        buffer,
        ""
        #ifdef CANLIB_TIMESTAMP
        "%" PRIu64 ","
        #endif // CANLIB_TIMESTAMP
    "%f"","
    "%f"","
    "%f"","
    "%f"","
    "%f",

#ifdef CANLIB_TIMESTAMP
    message->_timestamp,
#endif // CANLIB_TIMESTAMP
    message->estimated_velocity,
    message->tmax_r,
    message->tmax_l,
    message->torque_l,
    message->torque_r
);
}

int simulator_control_output_fields(char *buffer){
    return sprintf(
        buffer,
        ""
        #ifdef CANLIB_TIMESTAMP
            "_timestamp" ","
        #endif // CANLIB_TIMESTAMP
    "estimated_velocity"","
    "tmax_r"","
    "tmax_l"","
    "torque_l"","
    "torque_r");
}

int simulator_control_output_fields_file(FILE *buffer){
    return fprintf(
        buffer,
        ""
        #ifdef CANLIB_TIMESTAMP
            "_timestamp" ","
        #endif // CANLIB_TIMESTAMP
    "estimated_velocity"","
    "tmax_r"","
    "tmax_l"","
    "torque_l"","
    "torque_r");
}


int simulator_speed_pack(
    uint8_t *dst_p,
    const simulator_speed_t *src_p,
    size_t byte_size)
{
    if (byte_size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u16(src_p->encoder_l, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(src_p->encoder_l, 8u, 0xffu);
    dst_p[2] |= pack_left_shift_u16(src_p->encoder_r, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(src_p->encoder_r, 8u, 0xffu);
    dst_p[4] |= pack_left_shift_u16(src_p->inverter_l, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(src_p->inverter_l, 8u, 0xffu);
    dst_p[6] |= pack_left_shift_u16(src_p->inverter_r, 0u, 0xffu);
    dst_p[7] |= pack_right_shift_u16(src_p->inverter_r, 8u, 0xffu);

    return (8);
}

int simulator_speed_unpack(
    simulator_speed_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    )
{
    if (byte_size < 8u) {
        return (-EINVAL);
    }
#ifdef CANLIB_TIMESTAMP
    dst_p->_timestamp = _timestamp;
#endif // CANLIB_TIMESTAMP

    dst_p->encoder_l =  unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    dst_p->encoder_l |=  unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->encoder_r =  unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    dst_p->encoder_r |=  unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->inverter_l =  unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    dst_p->inverter_l |=  unpack_left_shift_u16(src_p[5], 8u, 0xffu);
    dst_p->inverter_r =  unpack_right_shift_u16(src_p[6], 0u, 0xffu);
    dst_p->inverter_r |=  unpack_left_shift_u16(src_p[7], 8u, 0xffu);

    return (0);
}

uint16_t simulator_speed_encoder_l_encode(float value)
{
    return (uint16_t)(canlib_max(0, canlib_min(65535, (value - -200.0f) / 0.006103608758678569f)));
}

float simulator_speed_encoder_l_decode(uint16_t value)
{
    return (((float)value * 0.006103608758678569f) + -200.0f);
}

bool simulator_speed_encoder_l_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t simulator_speed_encoder_r_encode(float value)
{
    return (uint16_t)(canlib_max(0, canlib_min(65535, (value - -200.0f) / 0.006103608758678569f)));
}

float simulator_speed_encoder_r_decode(uint16_t value)
{
    return (((float)value * 0.006103608758678569f) + -200.0f);
}

bool simulator_speed_encoder_r_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t simulator_speed_inverter_l_encode(float value)
{
    return (uint16_t)(canlib_max(0, canlib_min(65535, (value - -200.0f) / 0.006103608758678569f)));
}

float simulator_speed_inverter_l_decode(uint16_t value)
{
    return (((float)value * 0.006103608758678569f) + -200.0f);
}

bool simulator_speed_inverter_l_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t simulator_speed_inverter_r_encode(float value)
{
    return (uint16_t)(canlib_max(0, canlib_min(65535, (value - -200.0f) / 0.006103608758678569f)));
}

float simulator_speed_inverter_r_decode(uint16_t value)
{
    return (((float)value * 0.006103608758678569f) + -200.0f);
}

bool simulator_speed_inverter_r_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}


void simulator_speed_raw_to_conversion(
    simulator_speed_converted_t *conversion,
    float encoder_l,
    float encoder_r,
    float inverter_l,
    float inverter_r
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
){
#ifdef CANLIB_TIMESTAMP
    conversion->_timestamp = _timestamp;
#endif // CANLIB_TIMESTAMP
    conversion->encoder_l = simulator_speed_encoder_l_decode(encoder_l);
    conversion->encoder_r = simulator_speed_encoder_r_decode(encoder_r);
    conversion->inverter_l = simulator_speed_inverter_l_decode(inverter_l);
    conversion->inverter_r = simulator_speed_inverter_r_decode(inverter_r);
}


void simulator_speed_conversion_to_raw(
    simulator_speed_t *raw,
    float encoder_l,
    float encoder_r,
    float inverter_l,
    float inverter_r
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
){
#ifdef CANLIB_TIMESTAMP
    raw->_timestamp = _timestamp;
#endif // CANLIB_TIMESTAMP
    raw->encoder_l = simulator_speed_encoder_l_encode(encoder_l);
    raw->encoder_r = simulator_speed_encoder_r_encode(encoder_r);
    raw->inverter_l = simulator_speed_inverter_l_encode(inverter_l);
    raw->inverter_r = simulator_speed_inverter_r_encode(inverter_r);
}


void simulator_speed_raw_to_conversion_struct(
    simulator_speed_converted_t *conversion, 
    const simulator_speed_t *raw)
{
#ifdef CANLIB_TIMESTAMP
    conversion->_timestamp = raw->_timestamp;
#endif // CANLIB_TIMESTAMP
    conversion->encoder_l = simulator_speed_encoder_l_decode(raw->encoder_l);
    conversion->encoder_r = simulator_speed_encoder_r_decode(raw->encoder_r);
    conversion->inverter_l = simulator_speed_inverter_l_decode(raw->inverter_l);
    conversion->inverter_r = simulator_speed_inverter_r_decode(raw->inverter_r);
}


void simulator_speed_conversion_to_raw_struct(
    simulator_speed_t *raw,
    const simulator_speed_converted_t *conversion)
{
#ifdef CANLIB_TIMESTAMP
    raw->_timestamp = conversion->_timestamp;
#endif // CANLIB_TIMESTAMP
    raw->encoder_l = simulator_speed_encoder_l_encode(conversion->encoder_l);
    raw->encoder_r = simulator_speed_encoder_r_encode(conversion->encoder_r);
    raw->inverter_l = simulator_speed_inverter_l_encode(conversion->inverter_l);
    raw->inverter_r = simulator_speed_inverter_r_encode(conversion->inverter_r);
}

int simulator_speed_converted_to_string(simulator_speed_converted_t *message, char *buffer){
    return sprintf(
        buffer,
        ""
        #ifdef CANLIB_TIMESTAMP
        "%" PRIu64 ","
        #endif // CANLIB_TIMESTAMP
    "%f"","
    "%f"","
    "%f"","
    "%f",

#ifdef CANLIB_TIMESTAMP
    message->_timestamp,
#endif // CANLIB_TIMESTAMP
    message->encoder_l,
    message->encoder_r,
    message->inverter_l,
    message->inverter_r
);
}

int simulator_speed_converted_to_string_file(simulator_speed_converted_t *message, FILE *buffer){
    return fprintf(
        buffer,
        ""
        #ifdef CANLIB_TIMESTAMP
        "%" PRIu64 ","
        #endif // CANLIB_TIMESTAMP
    "%f"","
    "%f"","
    "%f"","
    "%f",

#ifdef CANLIB_TIMESTAMP
    message->_timestamp,
#endif // CANLIB_TIMESTAMP
    message->encoder_l,
    message->encoder_r,
    message->inverter_l,
    message->inverter_r
);
}

int simulator_speed_fields(char *buffer){
    return sprintf(
        buffer,
        ""
        #ifdef CANLIB_TIMESTAMP
            "_timestamp" ","
        #endif // CANLIB_TIMESTAMP
    "encoder_l"","
    "encoder_r"","
    "inverter_l"","
    "inverter_r");
}

int simulator_speed_fields_file(FILE *buffer){
    return fprintf(
        buffer,
        ""
        #ifdef CANLIB_TIMESTAMP
            "_timestamp" ","
        #endif // CANLIB_TIMESTAMP
    "encoder_l"","
    "encoder_r"","
    "inverter_l"","
    "inverter_r");
}


bool simulator_id_is_message(uint16_t id){
    switch(id){
        case SIMULATOR_IMU_ANGULAR_RATE_FRAME_ID:
        case SIMULATOR_IMU_ACCELERATION_FRAME_ID:
        case SIMULATOR_PEDALS_OUTPUT_FRAME_ID:
        case SIMULATOR_STEERING_ANGLE_FRAME_ID:
        case SIMULATOR_CONTROL_STATE_FRAME_ID:
        case SIMULATOR_CONTROL_OUTPUT_FRAME_ID:
        case SIMULATOR_SPEED_FRAME_ID:
        return true;
        break;
    default:
        return false;
    }
}

int simulator_message_name_from_id(uint16_t id, char* buffer) {
    switch (id) {
		case 1260: return sprintf(buffer, "%s", "imu_angular_rate");
		case 1261: return sprintf(buffer, "%s", "imu_acceleration");
		case 769: return sprintf(buffer, "%s", "pedals_output");
		case 258: return sprintf(buffer, "%s", "steering_angle");
		case 1280: return sprintf(buffer, "%s", "control_state");
		case 257: return sprintf(buffer, "%s", "control_output");
		case 513: return sprintf(buffer, "%s", "speed");
    }
    return 0;
}

int simulator_index_from_id(uint16_t id) {
    switch (id) {
		case 1260: return SIMULATOR_IMU_ANGULAR_RATE_INDEX;
		case 1261: return SIMULATOR_IMU_ACCELERATION_INDEX;
		case 769: return SIMULATOR_PEDALS_OUTPUT_INDEX;
		case 258: return SIMULATOR_STEERING_ANGLE_INDEX;
		case 1280: return SIMULATOR_CONTROL_STATE_INDEX;
		case 257: return SIMULATOR_CONTROL_OUTPUT_INDEX;
		case 513: return SIMULATOR_SPEED_INDEX;
    }
    return -1;
}

int simulator_id_from_index(int index){
    switch (index) {
		case SIMULATOR_IMU_ANGULAR_RATE_INDEX: return 1260;
		case SIMULATOR_IMU_ACCELERATION_INDEX: return 1261;
		case SIMULATOR_PEDALS_OUTPUT_INDEX: return 769;
		case SIMULATOR_STEERING_ANGLE_INDEX: return 258;
		case SIMULATOR_CONTROL_STATE_INDEX: return 1280;
		case SIMULATOR_CONTROL_OUTPUT_INDEX: return 257;
		case SIMULATOR_SPEED_INDEX: return 513;
    }
    return -1;
}

int simulator_to_string_from_id(uint16_t message_id,
                                void* message,
                                char* buffer
) {
    switch (message_id) {
        case 1260:
            return simulator_imu_angular_rate_converted_to_string((simulator_imu_angular_rate_converted_t*) message,
                                                buffer);
        case 1261:
            return simulator_imu_acceleration_converted_to_string((simulator_imu_acceleration_converted_t*) message,
                                                buffer);
        case 769:
            return simulator_pedals_output_converted_to_string((simulator_pedals_output_converted_t*) message,
                                                buffer);
        case 258:
            return simulator_steering_angle_converted_to_string((simulator_steering_angle_converted_t*) message,
                                                buffer);
        case 1280:
            return simulator_control_state_converted_to_string((simulator_control_state_converted_t*) message,
                                                buffer);
        case 257:
            return simulator_control_output_converted_to_string((simulator_control_output_converted_t*) message,
                                                buffer);
        case 513:
            return simulator_speed_converted_to_string((simulator_speed_converted_t*) message,
                                                buffer);
    }
	return 0;
}

int simulator_fields_from_id(uint16_t message_id, char* buffer) {
    switch (message_id) {
        case 1260:
            return simulator_imu_angular_rate_fields(buffer);
        case 1261:
            return simulator_imu_acceleration_fields(buffer);
        case 769:
            return simulator_pedals_output_fields(buffer);
        case 258:
            return simulator_steering_angle_fields(buffer);
        case 1280:
            return simulator_control_state_fields(buffer);
        case 257:
            return simulator_control_output_fields(buffer);
        case 513:
            return simulator_speed_fields(buffer);
    }
	return 0;
}

int simulator_to_string_file_from_id(uint16_t message_id, void* message, FILE* buffer) {
    switch (message_id) {
        case 1260:
            return simulator_imu_angular_rate_converted_to_string_file((simulator_imu_angular_rate_converted_t*) message, buffer);
        case 1261:
            return simulator_imu_acceleration_converted_to_string_file((simulator_imu_acceleration_converted_t*) message, buffer);
        case 769:
            return simulator_pedals_output_converted_to_string_file((simulator_pedals_output_converted_t*) message, buffer);
        case 258:
            return simulator_steering_angle_converted_to_string_file((simulator_steering_angle_converted_t*) message, buffer);
        case 1280:
            return simulator_control_state_converted_to_string_file((simulator_control_state_converted_t*) message, buffer);
        case 257:
            return simulator_control_output_converted_to_string_file((simulator_control_output_converted_t*) message, buffer);
        case 513:
            return simulator_speed_converted_to_string_file((simulator_speed_converted_t*) message, buffer);
    }
	return 0;
}

int simulator_fields_file_from_id(uint16_t message_id, FILE* buffer) {
    switch (message_id) {
        case 1260:
            return simulator_imu_angular_rate_fields_file(buffer);
        case 1261:
            return simulator_imu_acceleration_fields_file(buffer);
        case 769:
            return simulator_pedals_output_fields_file(buffer);
        case 258:
            return simulator_steering_angle_fields_file(buffer);
        case 1280:
            return simulator_control_state_fields_file(buffer);
        case 257:
            return simulator_control_output_fields_file(buffer);
        case 513:
            return simulator_speed_fields_file(buffer);
    }
	return 0;
}


void simulator_devices_deserialize_from_id(
    device_t* device,
    uint16_t message_id,
    uint8_t* data
    #ifdef CANLIB_TIMESTAMP
    , uint64_t timestamp
    #endif // CANLIB_TIMESTAMP
)
{
    switch(message_id){
        case 1260: {
            if(sizeof(simulator_imu_angular_rate_t) > device->_size_raw) {
                free(device->_raw);
                device->_raw = malloc(sizeof(simulator_imu_angular_rate_t));
                device->_size_raw = sizeof(simulator_imu_angular_rate_t);
            }
            simulator_imu_angular_rate_unpack(
                (simulator_imu_angular_rate_t*) device->_raw,
                data,
                6
                #ifdef CANLIB_TIMESTAMP
                , timestamp
                #endif
            );
            device->message = device->_raw;
            
            if(sizeof(simulator_imu_angular_rate_converted_t) > device->_size_converted) {
                free(device->_converted);
                device->_converted = malloc(sizeof(simulator_imu_angular_rate_converted_t));
                device->_size_converted = sizeof(simulator_imu_angular_rate_converted_t);
            }
            simulator_imu_angular_rate_raw_to_conversion_struct(
                (simulator_imu_angular_rate_converted_t*) device->_converted,
                (simulator_imu_angular_rate_t*) device->_raw
            );
            device->message = device->_converted;

            return;
        }
        case 1261: {
            if(sizeof(simulator_imu_acceleration_t) > device->_size_raw) {
                free(device->_raw);
                device->_raw = malloc(sizeof(simulator_imu_acceleration_t));
                device->_size_raw = sizeof(simulator_imu_acceleration_t);
            }
            simulator_imu_acceleration_unpack(
                (simulator_imu_acceleration_t*) device->_raw,
                data,
                8
                #ifdef CANLIB_TIMESTAMP
                , timestamp
                #endif
            );
            device->message = device->_raw;
            
            if(sizeof(simulator_imu_acceleration_converted_t) > device->_size_converted) {
                free(device->_converted);
                device->_converted = malloc(sizeof(simulator_imu_acceleration_converted_t));
                device->_size_converted = sizeof(simulator_imu_acceleration_converted_t);
            }
            simulator_imu_acceleration_raw_to_conversion_struct(
                (simulator_imu_acceleration_converted_t*) device->_converted,
                (simulator_imu_acceleration_t*) device->_raw
            );
            device->message = device->_converted;

            return;
        }
        case 769: {
            if(sizeof(simulator_pedals_output_t) > device->_size_raw) {
                free(device->_raw);
                device->_raw = malloc(sizeof(simulator_pedals_output_t));
                device->_size_raw = sizeof(simulator_pedals_output_t);
            }
            simulator_pedals_output_unpack(
                (simulator_pedals_output_t*) device->_raw,
                data,
                5
                #ifdef CANLIB_TIMESTAMP
                , timestamp
                #endif
            );
            device->message = device->_raw;
            
            if(sizeof(simulator_pedals_output_converted_t) > device->_size_converted) {
                free(device->_converted);
                device->_converted = malloc(sizeof(simulator_pedals_output_converted_t));
                device->_size_converted = sizeof(simulator_pedals_output_converted_t);
            }
            simulator_pedals_output_raw_to_conversion_struct(
                (simulator_pedals_output_converted_t*) device->_converted,
                (simulator_pedals_output_t*) device->_raw
            );
            device->message = device->_converted;

            return;
        }
        case 258: {
            if(sizeof(simulator_steering_angle_t) > device->_size_raw) {
                free(device->_raw);
                device->_raw = malloc(sizeof(simulator_steering_angle_t));
                device->_size_raw = sizeof(simulator_steering_angle_t);
            }
            simulator_steering_angle_unpack(
                (simulator_steering_angle_t*) device->_raw,
                data,
                4
                #ifdef CANLIB_TIMESTAMP
                , timestamp
                #endif
            );
            device->message = device->_raw;
            
            if(sizeof(simulator_steering_angle_converted_t) > device->_size_converted) {
                free(device->_converted);
                device->_converted = malloc(sizeof(simulator_steering_angle_converted_t));
                device->_size_converted = sizeof(simulator_steering_angle_converted_t);
            }
            simulator_steering_angle_raw_to_conversion_struct(
                (simulator_steering_angle_converted_t*) device->_converted,
                (simulator_steering_angle_t*) device->_raw
            );
            device->message = device->_converted;

            return;
        }
        case 1280: {
            if(sizeof(simulator_control_state_t) > device->_size_raw) {
                free(device->_raw);
                device->_raw = malloc(sizeof(simulator_control_state_t));
                device->_size_raw = sizeof(simulator_control_state_t);
            }
            simulator_control_state_unpack(
                (simulator_control_state_t*) device->_raw,
                data,
                3
                #ifdef CANLIB_TIMESTAMP
                , timestamp
                #endif
            );
            device->message = device->_raw;
            
            if(sizeof(simulator_control_state_converted_t) > device->_size_converted) {
                free(device->_converted);
                device->_converted = malloc(sizeof(simulator_control_state_converted_t));
                device->_size_converted = sizeof(simulator_control_state_converted_t);
            }
            simulator_control_state_raw_to_conversion_struct(
                (simulator_control_state_converted_t*) device->_converted,
                (simulator_control_state_t*) device->_raw
            );
            device->message = device->_converted;

            return;
        }
        case 257: {
            if(sizeof(simulator_control_output_t) > device->_size_raw) {
                free(device->_raw);
                device->_raw = malloc(sizeof(simulator_control_output_t));
                device->_size_raw = sizeof(simulator_control_output_t);
            }
            simulator_control_output_unpack(
                (simulator_control_output_t*) device->_raw,
                data,
                8
                #ifdef CANLIB_TIMESTAMP
                , timestamp
                #endif
            );
            device->message = device->_raw;
            
            if(sizeof(simulator_control_output_converted_t) > device->_size_converted) {
                free(device->_converted);
                device->_converted = malloc(sizeof(simulator_control_output_converted_t));
                device->_size_converted = sizeof(simulator_control_output_converted_t);
            }
            simulator_control_output_raw_to_conversion_struct(
                (simulator_control_output_converted_t*) device->_converted,
                (simulator_control_output_t*) device->_raw
            );
            device->message = device->_converted;

            return;
        }
        case 513: {
            if(sizeof(simulator_speed_t) > device->_size_raw) {
                free(device->_raw);
                device->_raw = malloc(sizeof(simulator_speed_t));
                device->_size_raw = sizeof(simulator_speed_t);
            }
            simulator_speed_unpack(
                (simulator_speed_t*) device->_raw,
                data,
                8
                #ifdef CANLIB_TIMESTAMP
                , timestamp
                #endif
            );
            device->message = device->_raw;
            
            if(sizeof(simulator_speed_converted_t) > device->_size_converted) {
                free(device->_converted);
                device->_converted = malloc(sizeof(simulator_speed_converted_t));
                device->_size_converted = sizeof(simulator_speed_converted_t);
            }
            simulator_speed_raw_to_conversion_struct(
                (simulator_speed_converted_t*) device->_converted,
                (simulator_speed_t*) device->_raw
            );
            device->message = device->_converted;

            return;
        }

    }
}
