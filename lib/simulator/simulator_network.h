/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2018-2019 Erik Moqvist
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/**
 * This file was generated by cantools version 38.0.2 Tue Apr  9 11:16:18 2024.
 */

#ifndef SIMULATOR_H
#define SIMULATOR_H

#include <stdio.h>
#include <stdlib.h>
#include <inttypes.h>

#ifdef __cplusplus
extern "C" {
#endif

#include <stdint.h>
#include <stdbool.h>
#include <stddef.h>

#ifndef CANLIB_BUILD
#define CANLIB_BUILD
#define CANLIB_BUILD_TIME 1712661378
#endif // CANLIB_BUILD

#define canlib_min(a,b) (((a) < (b)) ? (a) : (b))
#define canlib_max(a,b) (((a) > (b)) ? (a) : (b))

#ifndef CANLIB_PARKING
/* We know it's PACKING but PARKING sounds a bit better ;) */
#if defined(__MINGW32__)
#define CANLIB_PARKING                                                           __attribute__((__gcc_struct__, __packed__)) // , __aligned__(1)))
#else
#define CANLIB_PARKING __attribute__((__packed__)) // , __aligned__(1)))
#endif                                             // defined(__MINGW32__)
#endif                                             // CANLIB_PARKING

#ifndef EINVAL
#    define EINVAL 22
#endif

/* General defines */
#define SIMULATOR_ONESHOT (-1)

/* Frame ids. */
#define SIMULATOR_IMU_ANGULAR_RATE_FRAME_ID (0x4ecu)
#define SIMULATOR_IMU_ACCELERATION_FRAME_ID (0x4edu)
#define SIMULATOR_PEDAL_THROTTLE_FRAME_ID (0x600u)
#define SIMULATOR_PEDAL_BRAKES_PRESSURE_FRAME_ID (0x608u)
#define SIMULATOR_STEER_ANGLE_FRAME_ID (0x610u)
#define SIMULATOR_CONTROL_OUTPUT_FRAME_ID (0x200u)
#define SIMULATOR_CONTROL_STATUS_FRAME_ID (0x208u)
#define SIMULATOR_SPEED_FRAME_ID (0x618u)
#define SIMULATOR_DEBUG_SIGNAL_2_FRAME_ID (0x620u)

/* Frame lengths in bytes. */
#define SIMULATOR_IMU_ANGULAR_RATE_BYTE_SIZE (6u)
#define SIMULATOR_IMU_ACCELERATION_BYTE_SIZE (8u)
#define SIMULATOR_PEDAL_THROTTLE_BYTE_SIZE (2u)
#define SIMULATOR_PEDAL_BRAKES_PRESSURE_BYTE_SIZE (4u)
#define SIMULATOR_STEER_ANGLE_BYTE_SIZE (4u)
#define SIMULATOR_CONTROL_OUTPUT_BYTE_SIZE (8u)
#define SIMULATOR_CONTROL_STATUS_BYTE_SIZE (3u)
#define SIMULATOR_SPEED_BYTE_SIZE (4u)
#define SIMULATOR_DEBUG_SIGNAL_2_BYTE_SIZE (8u)

/* Extended or standard frame types. */
#define SIMULATOR_IMU_ANGULAR_RATE_IS_EXTENDED (0)
#define SIMULATOR_IMU_ACCELERATION_IS_EXTENDED (0)
#define SIMULATOR_PEDAL_THROTTLE_IS_EXTENDED (0)
#define SIMULATOR_PEDAL_BRAKES_PRESSURE_IS_EXTENDED (0)
#define SIMULATOR_STEER_ANGLE_IS_EXTENDED (0)
#define SIMULATOR_CONTROL_OUTPUT_IS_EXTENDED (0)
#define SIMULATOR_CONTROL_STATUS_IS_EXTENDED (0)
#define SIMULATOR_SPEED_IS_EXTENDED (0)
#define SIMULATOR_DEBUG_SIGNAL_2_IS_EXTENDED (0)

/* Frame cycle times in milliseconds. */
#define SIMULATOR_PEDAL_THROTTLE_CYCLE_TIME_MS (10u)
#define SIMULATOR_PEDAL_BRAKES_PRESSURE_CYCLE_TIME_MS (10u)
#define SIMULATOR_STEER_ANGLE_CYCLE_TIME_MS (10u)
#define SIMULATOR_CONTROL_OUTPUT_CYCLE_TIME_MS (20u)
#define SIMULATOR_CONTROL_STATUS_CYCLE_TIME_MS (20u)
#define SIMULATOR_SPEED_CYCLE_TIME_MS (10u)
#define SIMULATOR_DEBUG_SIGNAL_2_CYCLE_TIME_MS (10u)
#define SIMULATOR_IMU_ANGULAR_RATE_CYCLE_TIME_MS (SIMULATOR_ONESHOT)
#define SIMULATOR_IMU_ACCELERATION_CYCLE_TIME_MS (SIMULATOR_ONESHOT)

/* Topics masks */
/* TOPIC FIXED_IDS */
#define SIMULATOR_TOPIC_MASK_FIXED_IDS 0b00000011111

#define SIMULATOR_ID_IMU_ANGULAR_RATE 0x4EC // dec: 1260 bin: 0b10011101100
#define SIMULATOR_ID_IMU_ACCELERATION 0x4ED // dec: 1261 bin: 0b10011101101

/* TOPIC HYDRA */
#define SIMULATOR_TOPIC_MASK_HYDRA 0b00000011111

#define SIMULATOR_TOPIC_FILTER_HYDRA 0x0 // dec: 0 bin: 0b00000000000

#define SIMULATOR_ID_PEDAL_THROTTLE 0x600 // dec: 1536 bin: 0b11000000000
#define SIMULATOR_ID_PEDAL_BRAKES_PRESSURE 0x608 // dec: 1544 bin: 0b11000001000
#define SIMULATOR_ID_STEER_ANGLE 0x610 // dec: 1552 bin: 0b11000010000
#define SIMULATOR_ID_CONTROL_OUTPUT 0x200 // dec: 512 bin: 0b01000000000
#define SIMULATOR_ID_CONTROL_STATUS 0x208 // dec: 520 bin: 0b01000001000
#define SIMULATOR_ID_SPEED 0x618 // dec: 1560 bin: 0b11000011000
#define SIMULATOR_ID_DEBUG_SIGNAL_2 0x620 // dec: 1568 bin: 0b11000100000



/* Signal choices. */


/* Indexes */
#define SIMULATOR_IMU_ANGULAR_RATE_INDEX 0
#define SIMULATOR_IMU_ACCELERATION_INDEX 1
#define SIMULATOR_PEDAL_THROTTLE_INDEX 2
#define SIMULATOR_PEDAL_BRAKES_PRESSURE_INDEX 3
#define SIMULATOR_STEER_ANGLE_INDEX 4
#define SIMULATOR_CONTROL_OUTPUT_INDEX 5
#define SIMULATOR_CONTROL_STATUS_INDEX 6
#define SIMULATOR_SPEED_INDEX 7
#define SIMULATOR_DEBUG_SIGNAL_2_INDEX 8


#define simulator_MESSAGE_COUNT 9

#ifndef CANLIB_DEVICE_T
#define CANLIB_DEVICE_T
typedef struct {
    void* message;
    void* _converted;
    void* _raw;
    int _size_raw;
    int _size_converted;
} device_t;
void device_init(device_t *device);
void device_preallocate(device_t *device, int bytes);
void device_free(device_t *device);
void device_set_address(device_t *device, void* raw, size_t raw_size, void *converted, size_t converted_size);
#endif // CANLIB_DEVICE_T

#ifdef CANLIB_DEVICE_IMPLEMENTATION
#undef CANLIB_DEVICE_IMPLEMENTATION
void device_init(device_t *device) {
    device->message = NULL;
    device->_converted = NULL;
    device->_raw = NULL;
    device->_size_raw = 0;
    device->_size_converted = 0;
}
void device_preallocate(device_t *device, int bytes){
    if(device->_size_raw > 0)
        free(device->_raw);
    if(device->_size_converted > 0)
        free(device->_converted);
    device->_raw = malloc(bytes);
    device->_converted = malloc(bytes);
    device->_size_converted = device->_size_raw = bytes;
}
void device_free(device_t *device) {
    free(device->_raw);
    free(device->_converted);
    device->message = NULL;
    device->_raw = NULL;
    device->_converted = NULL;
    device->_size_raw = 0;
    device->_size_converted = 0;
}
void device_set_address(device_t *device, void* raw, size_t raw_size, void *converted, size_t converted_size) {
    device->_raw = raw;
    device->_converted = converted;
    device->_size_raw = raw_size;
    device->_size_converted = converted_size;
}
#endif // CANLIB_DEVICE_IMPLEMENTATION

void simulator_devices_deserialize_from_id(
    device_t* device,
    uint16_t message_id,
    uint8_t* data
#ifdef CANLIB_TIMESTAMP
    , uint64_t timestamp
#endif // CANLIB_TIMESTAMP
);

int simulator_message_name_from_id(uint16_t id, char* buffer);
int simulator_index_from_id(uint16_t id);
int simulator_id_from_index(int index);

/**
 * Signals in message IMU_ANGULAR_RATE.
 *
 * Inertial Measurement Unit [x,y,z]-axis angular rate value. 0.01dps per bit, Big-Endian, 16bit Total, signed
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..2450 (0..245 -)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t x;

    /**
     * Range: 0..2450 (0..245 -)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t y;

    /**
     * Range: 0..2450 (0..245 -)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t z;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} simulator_imu_angular_rate_t;

/**
 * Signals in message IMU_ANGULAR_RATE.
 *
 * Inertial Measurement Unit [x,y,z]-axis angular rate value. 0.01dps per bit, Big-Endian, 16bit Total, signed
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..2450 (0..245 -)
     * Scale: 0.1
     * Offset: 0
     */
    float x;

    /**
     * Range: 0..2450 (0..245 -)
     * Scale: 0.1
     * Offset: 0
     */
    float y;

    /**
     * Range: 0..2450 (0..245 -)
     * Scale: 0.1
     * Offset: 0
     */
    float z;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} simulator_imu_angular_rate_converted_t;

/**
 * Signals in message IMU_ACCELERATION.
 *
 * Inertial Measurement Unit [x,y,z]-axis acceleration value. 0.01g per bit, Big-Endian, 16bit Total, signed
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..800 (0..8 -)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t x;

    /**
     * Range: 0..800 (0..8 -)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t y;

    /**
     * Range: 0..800 (0..8 -)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t z;

    /**
     * Range: 0..65535 (-32768..32767 -)
     * Scale: 1
     * Offset: -32768
     */
    int16_t imu_temperature;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} simulator_imu_acceleration_t;

/**
 * Signals in message IMU_ACCELERATION.
 *
 * Inertial Measurement Unit [x,y,z]-axis acceleration value. 0.01g per bit, Big-Endian, 16bit Total, signed
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..800 (0..8 -)
     * Scale: 0.01
     * Offset: 0
     */
    float x;

    /**
     * Range: 0..800 (0..8 -)
     * Scale: 0.01
     * Offset: 0
     */
    float y;

    /**
     * Range: 0..800 (0..8 -)
     * Scale: 0.01
     * Offset: 0
     */
    float z;

    /**
     * Range: 0..65535 (-32768..32767 -)
     * Scale: 1
     * Offset: -32768
     */
    int16_t imu_temperature;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} simulator_imu_acceleration_converted_t;

/**
 * Signals in message PEDAL_THROTTLE.
 *
 * Pedal Throttle , already calibrated
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (0..1 -)
     * Scale: 1.5259021896696422e-05
     * Offset: 0
     */
    uint16_t throttle;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} simulator_pedal_throttle_t;

/**
 * Signals in message PEDAL_THROTTLE.
 *
 * Pedal Throttle , already calibrated
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (0..1 -)
     * Scale: 1.5259021896696422e-05
     * Offset: 0
     */
    float throttle;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} simulator_pedal_throttle_converted_t;

/**
 * Signals in message PEDAL_BRAKES_PRESSURE.
 *
 * Pedal brakes pressures in bar, already calibrated
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (0..100 -)
     * Scale: 0.0015259021896696422
     * Offset: 0
     */
    uint16_t front;

    /**
     * Range: 0..65535 (0..100 -)
     * Scale: 0.0015259021896696422
     * Offset: 0
     */
    uint16_t rear;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} simulator_pedal_brakes_pressure_t;

/**
 * Signals in message PEDAL_BRAKES_PRESSURE.
 *
 * Pedal brakes pressures in bar, already calibrated
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (0..100 -)
     * Scale: 0.0015259021896696422
     * Offset: 0
     */
    float front;

    /**
     * Range: 0..65535 (0..100 -)
     * Scale: 0.0015259021896696422
     * Offset: 0
     */
    float rear;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} simulator_pedal_brakes_pressure_converted_t;

/**
 * Signals in message STEER_ANGLE.
 *
 * Steering angle in degrees
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..4294967295 (-180..180 -)
     * Scale: 8.38190317349087e-08
     * Offset: -180
     */
    uint32_t angle;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} simulator_steer_angle_t;

/**
 * Signals in message STEER_ANGLE.
 *
 * Steering angle in degrees
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..4294967295 (-180..180 -)
     * Scale: 8.38190317349087e-08
     * Offset: -180
     */
    float angle;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} simulator_steer_angle_converted_t;

/**
 * Signals in message CONTROL_OUTPUT.
 *
 * Torques and signals calculated by the controls algorithms
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65534.99999999999 (-10..35 -)
     * Scale: 0.000686655985351339
     * Offset: -10
     */
    uint16_t estimated_velocity;

    /**
     * Range: 0..255 (0..100 -)
     * Scale: 0.39215686274509803
     * Offset: 0
     */
    uint8_t torque_max_l;

    /**
     * Range: 0..255 (0..100 -)
     * Scale: 0.39215686274509803
     * Offset: 0
     */
    uint8_t torque_max_r;

    /**
     * Range: 0..65535 (0..100 -)
     * Scale: 0.0015259021896696422
     * Offset: 0
     */
    uint16_t torque_l;

    /**
     * Range: 0..65535 (0..100 -)
     * Scale: 0.0015259021896696422
     * Offset: 0
     */
    uint16_t torque_r;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} simulator_control_output_t;

/**
 * Signals in message CONTROL_OUTPUT.
 *
 * Torques and signals calculated by the controls algorithms
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65534.99999999999 (-10..35 -)
     * Scale: 0.000686655985351339
     * Offset: -10
     */
    float estimated_velocity;

    /**
     * Range: 0..255 (0..100 -)
     * Scale: 0.39215686274509803
     * Offset: 0
     */
    float torque_max_l;

    /**
     * Range: 0..255 (0..100 -)
     * Scale: 0.39215686274509803
     * Offset: 0
     */
    float torque_max_r;

    /**
     * Range: 0..65535 (0..100 -)
     * Scale: 0.0015259021896696422
     * Offset: 0
     */
    float torque_l;

    /**
     * Range: 0..65535 (0..100 -)
     * Scale: 0.0015259021896696422
     * Offset: 0
     */
    float torque_r;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} simulator_control_output_converted_t;

/**
 * Signals in message CONTROL_STATUS.
 *
 * Power maps used by the control algotirhm. (ECU checks if are coherent with the ones in the ECU)
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..150 (-0.5..1 -)
     * Scale: 0.01
     * Offset: -0.5
     */
    uint8_t map_pw;

    /**
     * Range: 0..100 (0..1 -)
     * Scale: 0.01
     * Offset: 0
     */
    uint8_t map_sc;

    /**
     * Range: 0..100 (0..1 -)
     * Scale: 0.01
     * Offset: 0
     */
    uint8_t map_tv;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} simulator_control_status_t;

/**
 * Signals in message CONTROL_STATUS.
 *
 * Power maps used by the control algotirhm. (ECU checks if are coherent with the ones in the ECU)
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..150 (-0.5..1 -)
     * Scale: 0.01
     * Offset: -0.5
     */
    float map_pw;

    /**
     * Range: 0..100 (0..1 -)
     * Scale: 0.01
     * Offset: 0
     */
    float map_sc;

    /**
     * Range: 0..100 (0..1 -)
     * Scale: 0.01
     * Offset: 0
     */
    float map_tv;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} simulator_control_status_converted_t;

/**
 * Signals in message SPEED.
 *
 * Encoder and inverter speed in rad/sec
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (-200..200 -)
     * Scale: 0.006103608758678569
     * Offset: -200
     */
    uint16_t fl;

    /**
     * Range: 0..65535 (-200..200 -)
     * Scale: 0.006103608758678569
     * Offset: -200
     */
    uint16_t fr;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} simulator_speed_t;

/**
 * Signals in message SPEED.
 *
 * Encoder and inverter speed in rad/sec
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (-200..200 -)
     * Scale: 0.006103608758678569
     * Offset: -200
     */
    float fl;

    /**
     * Range: 0..65535 (-200..200 -)
     * Scale: 0.006103608758678569
     * Offset: -200
     */
    float fr;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} simulator_speed_converted_t;

/**
 * Signals in message DEBUG_SIGNAL_2.
 *
 * Debug signals
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (-1..1 -)
     * Scale: 3.0518043793392844e-05
     * Offset: -1
     */
    uint16_t field_1;

    /**
     * Range: 0..65535 (-1..1 -)
     * Scale: 3.0518043793392844e-05
     * Offset: -1
     */
    uint16_t field_2;

    /**
     * Range: 0..65535 (-1..1 -)
     * Scale: 3.0518043793392844e-05
     * Offset: -1
     */
    uint16_t field_3;

    /**
     * Range: 0..65535 (-1..1 -)
     * Scale: 3.0518043793392844e-05
     * Offset: -1
     */
    uint16_t field_4;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} simulator_debug_signal_2_t;

/**
 * Signals in message DEBUG_SIGNAL_2.
 *
 * Debug signals
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (-1..1 -)
     * Scale: 3.0518043793392844e-05
     * Offset: -1
     */
    float field_1;

    /**
     * Range: 0..65535 (-1..1 -)
     * Scale: 3.0518043793392844e-05
     * Offset: -1
     */
    float field_2;

    /**
     * Range: 0..65535 (-1..1 -)
     * Scale: 3.0518043793392844e-05
     * Offset: -1
     */
    float field_3;

    /**
     * Range: 0..65535 (-1..1 -)
     * Scale: 3.0518043793392844e-05
     * Offset: -1
     */
    float field_4;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} simulator_debug_signal_2_converted_t;


void simulator_imu_angular_rate_raw_to_conversion(
    simulator_imu_angular_rate_converted_t *conversion,
    float x,
    float y,
    float z
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void simulator_imu_angular_rate_conversion_to_raw(
    simulator_imu_angular_rate_t *raw,
    float x,
    float y,
    float z
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void simulator_imu_angular_rate_raw_to_conversion_struct(
    simulator_imu_angular_rate_converted_t *conversion, 
    const simulator_imu_angular_rate_t *raw);


void simulator_imu_angular_rate_conversion_to_raw_struct(
    simulator_imu_angular_rate_t *raw,
    const simulator_imu_angular_rate_converted_t *conversion);


int simulator_imu_angular_rate_converted_to_string(simulator_imu_angular_rate_converted_t *message, char *buffer);

int simulator_imu_angular_rate_converted_to_string_file(simulator_imu_angular_rate_converted_t *message, FILE *buffer);

int simulator_imu_angular_rate_fields(char *buffer);

int simulator_imu_angular_rate_fields_file(FILE *buffer);

/**
 * Pack message IMU_ANGULAR_RATE.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int simulator_imu_angular_rate_pack(
    uint8_t *dst_p,
    const simulator_imu_angular_rate_t *src_p,
    size_t byte_size);

/**
 * Unpack message IMU_ANGULAR_RATE.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int simulator_imu_angular_rate_unpack(
    simulator_imu_angular_rate_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t simulator_imu_angular_rate_x_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float simulator_imu_angular_rate_x_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool simulator_imu_angular_rate_x_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t simulator_imu_angular_rate_y_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float simulator_imu_angular_rate_y_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool simulator_imu_angular_rate_y_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t simulator_imu_angular_rate_z_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float simulator_imu_angular_rate_z_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool simulator_imu_angular_rate_z_is_in_range(int16_t value);


void simulator_imu_acceleration_raw_to_conversion(
    simulator_imu_acceleration_converted_t *conversion,
    float x,
    float y,
    float z,
    int16_t imu_temperature
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void simulator_imu_acceleration_conversion_to_raw(
    simulator_imu_acceleration_t *raw,
    float x,
    float y,
    float z,
    int16_t imu_temperature
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void simulator_imu_acceleration_raw_to_conversion_struct(
    simulator_imu_acceleration_converted_t *conversion, 
    const simulator_imu_acceleration_t *raw);


void simulator_imu_acceleration_conversion_to_raw_struct(
    simulator_imu_acceleration_t *raw,
    const simulator_imu_acceleration_converted_t *conversion);


int simulator_imu_acceleration_converted_to_string(simulator_imu_acceleration_converted_t *message, char *buffer);

int simulator_imu_acceleration_converted_to_string_file(simulator_imu_acceleration_converted_t *message, FILE *buffer);

int simulator_imu_acceleration_fields(char *buffer);

int simulator_imu_acceleration_fields_file(FILE *buffer);

/**
 * Pack message IMU_ACCELERATION.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int simulator_imu_acceleration_pack(
    uint8_t *dst_p,
    const simulator_imu_acceleration_t *src_p,
    size_t byte_size);

/**
 * Unpack message IMU_ACCELERATION.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int simulator_imu_acceleration_unpack(
    simulator_imu_acceleration_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t simulator_imu_acceleration_x_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float simulator_imu_acceleration_x_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool simulator_imu_acceleration_x_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t simulator_imu_acceleration_y_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float simulator_imu_acceleration_y_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool simulator_imu_acceleration_y_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t simulator_imu_acceleration_z_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float simulator_imu_acceleration_z_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool simulator_imu_acceleration_z_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool simulator_imu_acceleration_imu_temperature_is_in_range(int16_t value);


void simulator_pedal_throttle_raw_to_conversion(
    simulator_pedal_throttle_converted_t *conversion,
    float throttle
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void simulator_pedal_throttle_conversion_to_raw(
    simulator_pedal_throttle_t *raw,
    float throttle
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void simulator_pedal_throttle_raw_to_conversion_struct(
    simulator_pedal_throttle_converted_t *conversion, 
    const simulator_pedal_throttle_t *raw);


void simulator_pedal_throttle_conversion_to_raw_struct(
    simulator_pedal_throttle_t *raw,
    const simulator_pedal_throttle_converted_t *conversion);


int simulator_pedal_throttle_converted_to_string(simulator_pedal_throttle_converted_t *message, char *buffer);

int simulator_pedal_throttle_converted_to_string_file(simulator_pedal_throttle_converted_t *message, FILE *buffer);

int simulator_pedal_throttle_fields(char *buffer);

int simulator_pedal_throttle_fields_file(FILE *buffer);

/**
 * Pack message PEDAL_THROTTLE.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int simulator_pedal_throttle_pack(
    uint8_t *dst_p,
    const simulator_pedal_throttle_t *src_p,
    size_t byte_size);

/**
 * Unpack message PEDAL_THROTTLE.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int simulator_pedal_throttle_unpack(
    simulator_pedal_throttle_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t simulator_pedal_throttle_throttle_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float simulator_pedal_throttle_throttle_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool simulator_pedal_throttle_throttle_is_in_range(uint16_t value);


void simulator_pedal_brakes_pressure_raw_to_conversion(
    simulator_pedal_brakes_pressure_converted_t *conversion,
    float front,
    float rear
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void simulator_pedal_brakes_pressure_conversion_to_raw(
    simulator_pedal_brakes_pressure_t *raw,
    float front,
    float rear
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void simulator_pedal_brakes_pressure_raw_to_conversion_struct(
    simulator_pedal_brakes_pressure_converted_t *conversion, 
    const simulator_pedal_brakes_pressure_t *raw);


void simulator_pedal_brakes_pressure_conversion_to_raw_struct(
    simulator_pedal_brakes_pressure_t *raw,
    const simulator_pedal_brakes_pressure_converted_t *conversion);


int simulator_pedal_brakes_pressure_converted_to_string(simulator_pedal_brakes_pressure_converted_t *message, char *buffer);

int simulator_pedal_brakes_pressure_converted_to_string_file(simulator_pedal_brakes_pressure_converted_t *message, FILE *buffer);

int simulator_pedal_brakes_pressure_fields(char *buffer);

int simulator_pedal_brakes_pressure_fields_file(FILE *buffer);

/**
 * Pack message PEDAL_BRAKES_PRESSURE.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int simulator_pedal_brakes_pressure_pack(
    uint8_t *dst_p,
    const simulator_pedal_brakes_pressure_t *src_p,
    size_t byte_size);

/**
 * Unpack message PEDAL_BRAKES_PRESSURE.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int simulator_pedal_brakes_pressure_unpack(
    simulator_pedal_brakes_pressure_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t simulator_pedal_brakes_pressure_front_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float simulator_pedal_brakes_pressure_front_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool simulator_pedal_brakes_pressure_front_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t simulator_pedal_brakes_pressure_rear_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float simulator_pedal_brakes_pressure_rear_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool simulator_pedal_brakes_pressure_rear_is_in_range(uint16_t value);


void simulator_steer_angle_raw_to_conversion(
    simulator_steer_angle_converted_t *conversion,
    float angle
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void simulator_steer_angle_conversion_to_raw(
    simulator_steer_angle_t *raw,
    float angle
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void simulator_steer_angle_raw_to_conversion_struct(
    simulator_steer_angle_converted_t *conversion, 
    const simulator_steer_angle_t *raw);


void simulator_steer_angle_conversion_to_raw_struct(
    simulator_steer_angle_t *raw,
    const simulator_steer_angle_converted_t *conversion);


int simulator_steer_angle_converted_to_string(simulator_steer_angle_converted_t *message, char *buffer);

int simulator_steer_angle_converted_to_string_file(simulator_steer_angle_converted_t *message, FILE *buffer);

int simulator_steer_angle_fields(char *buffer);

int simulator_steer_angle_fields_file(FILE *buffer);

/**
 * Pack message STEER_ANGLE.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int simulator_steer_angle_pack(
    uint8_t *dst_p,
    const simulator_steer_angle_t *src_p,
    size_t byte_size);

/**
 * Unpack message STEER_ANGLE.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int simulator_steer_angle_unpack(
    simulator_steer_angle_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t simulator_steer_angle_angle_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float simulator_steer_angle_angle_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool simulator_steer_angle_angle_is_in_range(uint32_t value);


void simulator_control_output_raw_to_conversion(
    simulator_control_output_converted_t *conversion,
    float estimated_velocity,
    float torque_max_l,
    float torque_max_r,
    float torque_l,
    float torque_r
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void simulator_control_output_conversion_to_raw(
    simulator_control_output_t *raw,
    float estimated_velocity,
    float torque_max_l,
    float torque_max_r,
    float torque_l,
    float torque_r
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void simulator_control_output_raw_to_conversion_struct(
    simulator_control_output_converted_t *conversion, 
    const simulator_control_output_t *raw);


void simulator_control_output_conversion_to_raw_struct(
    simulator_control_output_t *raw,
    const simulator_control_output_converted_t *conversion);


int simulator_control_output_converted_to_string(simulator_control_output_converted_t *message, char *buffer);

int simulator_control_output_converted_to_string_file(simulator_control_output_converted_t *message, FILE *buffer);

int simulator_control_output_fields(char *buffer);

int simulator_control_output_fields_file(FILE *buffer);

/**
 * Pack message CONTROL_OUTPUT.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int simulator_control_output_pack(
    uint8_t *dst_p,
    const simulator_control_output_t *src_p,
    size_t byte_size);

/**
 * Unpack message CONTROL_OUTPUT.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int simulator_control_output_unpack(
    simulator_control_output_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t simulator_control_output_estimated_velocity_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float simulator_control_output_estimated_velocity_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool simulator_control_output_estimated_velocity_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t simulator_control_output_torque_max_l_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float simulator_control_output_torque_max_l_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool simulator_control_output_torque_max_l_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t simulator_control_output_torque_max_r_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float simulator_control_output_torque_max_r_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool simulator_control_output_torque_max_r_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t simulator_control_output_torque_l_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float simulator_control_output_torque_l_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool simulator_control_output_torque_l_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t simulator_control_output_torque_r_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float simulator_control_output_torque_r_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool simulator_control_output_torque_r_is_in_range(uint16_t value);


void simulator_control_status_raw_to_conversion(
    simulator_control_status_converted_t *conversion,
    float map_pw,
    float map_sc,
    float map_tv
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void simulator_control_status_conversion_to_raw(
    simulator_control_status_t *raw,
    float map_pw,
    float map_sc,
    float map_tv
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void simulator_control_status_raw_to_conversion_struct(
    simulator_control_status_converted_t *conversion, 
    const simulator_control_status_t *raw);


void simulator_control_status_conversion_to_raw_struct(
    simulator_control_status_t *raw,
    const simulator_control_status_converted_t *conversion);


int simulator_control_status_converted_to_string(simulator_control_status_converted_t *message, char *buffer);

int simulator_control_status_converted_to_string_file(simulator_control_status_converted_t *message, FILE *buffer);

int simulator_control_status_fields(char *buffer);

int simulator_control_status_fields_file(FILE *buffer);

/**
 * Pack message CONTROL_STATUS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int simulator_control_status_pack(
    uint8_t *dst_p,
    const simulator_control_status_t *src_p,
    size_t byte_size);

/**
 * Unpack message CONTROL_STATUS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int simulator_control_status_unpack(
    simulator_control_status_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t simulator_control_status_map_pw_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float simulator_control_status_map_pw_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool simulator_control_status_map_pw_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t simulator_control_status_map_sc_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float simulator_control_status_map_sc_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool simulator_control_status_map_sc_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t simulator_control_status_map_tv_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float simulator_control_status_map_tv_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool simulator_control_status_map_tv_is_in_range(uint8_t value);


void simulator_speed_raw_to_conversion(
    simulator_speed_converted_t *conversion,
    float fl,
    float fr
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void simulator_speed_conversion_to_raw(
    simulator_speed_t *raw,
    float fl,
    float fr
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void simulator_speed_raw_to_conversion_struct(
    simulator_speed_converted_t *conversion, 
    const simulator_speed_t *raw);


void simulator_speed_conversion_to_raw_struct(
    simulator_speed_t *raw,
    const simulator_speed_converted_t *conversion);


int simulator_speed_converted_to_string(simulator_speed_converted_t *message, char *buffer);

int simulator_speed_converted_to_string_file(simulator_speed_converted_t *message, FILE *buffer);

int simulator_speed_fields(char *buffer);

int simulator_speed_fields_file(FILE *buffer);

/**
 * Pack message SPEED.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int simulator_speed_pack(
    uint8_t *dst_p,
    const simulator_speed_t *src_p,
    size_t byte_size);

/**
 * Unpack message SPEED.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int simulator_speed_unpack(
    simulator_speed_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t simulator_speed_fl_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float simulator_speed_fl_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool simulator_speed_fl_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t simulator_speed_fr_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float simulator_speed_fr_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool simulator_speed_fr_is_in_range(uint16_t value);


void simulator_debug_signal_2_raw_to_conversion(
    simulator_debug_signal_2_converted_t *conversion,
    float field_1,
    float field_2,
    float field_3,
    float field_4
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void simulator_debug_signal_2_conversion_to_raw(
    simulator_debug_signal_2_t *raw,
    float field_1,
    float field_2,
    float field_3,
    float field_4
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void simulator_debug_signal_2_raw_to_conversion_struct(
    simulator_debug_signal_2_converted_t *conversion, 
    const simulator_debug_signal_2_t *raw);


void simulator_debug_signal_2_conversion_to_raw_struct(
    simulator_debug_signal_2_t *raw,
    const simulator_debug_signal_2_converted_t *conversion);


int simulator_debug_signal_2_converted_to_string(simulator_debug_signal_2_converted_t *message, char *buffer);

int simulator_debug_signal_2_converted_to_string_file(simulator_debug_signal_2_converted_t *message, FILE *buffer);

int simulator_debug_signal_2_fields(char *buffer);

int simulator_debug_signal_2_fields_file(FILE *buffer);

/**
 * Pack message DEBUG_SIGNAL_2.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int simulator_debug_signal_2_pack(
    uint8_t *dst_p,
    const simulator_debug_signal_2_t *src_p,
    size_t byte_size);

/**
 * Unpack message DEBUG_SIGNAL_2.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int simulator_debug_signal_2_unpack(
    simulator_debug_signal_2_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t simulator_debug_signal_2_field_1_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float simulator_debug_signal_2_field_1_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool simulator_debug_signal_2_field_1_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t simulator_debug_signal_2_field_2_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float simulator_debug_signal_2_field_2_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool simulator_debug_signal_2_field_2_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t simulator_debug_signal_2_field_3_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float simulator_debug_signal_2_field_3_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool simulator_debug_signal_2_field_3_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t simulator_debug_signal_2_field_4_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float simulator_debug_signal_2_field_4_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool simulator_debug_signal_2_field_4_is_in_range(uint16_t value);

bool simulator_id_is_message(uint16_t id);

int simulator_to_string_from_id(uint16_t message_id, void* message, char* buffer);
int simulator_fields_from_id(uint16_t message_id, char* buffer);
int simulator_to_string_file_from_id(uint16_t message_id, void* message, FILE* buffer);
int simulator_fields_file_from_id(uint16_t message_id, FILE* buffer);


typedef union CANLIB_PARKING {
    simulator_imu_angular_rate_t _imu_angular_rate;
    simulator_imu_acceleration_t _imu_acceleration;
    simulator_pedal_throttle_t _pedal_throttle;
    simulator_pedal_brakes_pressure_t _pedal_brakes_pressure;
    simulator_steer_angle_t _steer_angle;
    simulator_control_output_t _control_output;
    simulator_control_status_t _control_status;
    simulator_speed_t _speed;
    simulator_debug_signal_2_t _debug_signal_2;

} _simulator_all_struct_raw;

typedef union CANLIB_PARKING {
    simulator_imu_angular_rate_converted_t _imu_angular_rate;
    simulator_imu_acceleration_converted_t _imu_acceleration;
    simulator_pedal_throttle_converted_t _pedal_throttle;
    simulator_pedal_brakes_pressure_converted_t _pedal_brakes_pressure;
    simulator_steer_angle_converted_t _steer_angle;
    simulator_control_output_converted_t _control_output;
    simulator_control_status_converted_t _control_status;
    simulator_speed_converted_t _speed;
    simulator_debug_signal_2_converted_t _debug_signal_2;

} _simulator_all_struct_converted;



#define simulator_MAX_STRUCT_SIZE_RAW sizeof(_simulator_all_struct_raw)
#define simulator_MAX_STRUCT_SIZE_CONVERSION sizeof(_simulator_all_struct_converted)

#ifdef __cplusplus
}
#endif

#endif
