/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2018-2019 Erik Moqvist
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/**
 * This file was generated by cantools version 38.0.2 Tue Dec 12 21:26:04 2023.
 */

#ifndef SIMULATOR_H
#define SIMULATOR_H

#include <stdio.h>
#include <stdlib.h>
#include <inttypes.h>

#ifdef __cplusplus
extern "C" {
#endif

#include <stdint.h>
#include <stdbool.h>
#include <stddef.h>

#ifndef CANLIB_BUILD
#define CANLIB_BUILD
#define CANLIB_BUILD_TIME 1702416364
#endif // CANLIB_BUILD

#define canlib_min(a,b) (((a) < (b)) ? (a) : (b))
#define canlib_max(a,b) (((a) > (b)) ? (a) : (b))

#ifndef CANLIB_PARKING
/* We know it's PACKING but PARKING sounds a bit better ;) */
#if defined(__MINGW32__)
#define CANLIB_PARKING                                                           __attribute__((__gcc_struct__, __packed__)) // , __aligned__(1)))
#else
#define CANLIB_PARKING __attribute__((__packed__)) // , __aligned__(1)))
#endif                                             // defined(__MINGW32__)
#endif                                             // CANLIB_PARKING

#ifndef EINVAL
#    define EINVAL 22
#endif

/* Frame ids. */
#define SIMULATOR_IMU_ANGULAR_RATE_FRAME_ID (0x4ecu)
#define SIMULATOR_IMU_ACCELERATION_FRAME_ID (0x4edu)
#define SIMULATOR_PEDALS_OUTPUT_FRAME_ID (0x302u)
#define SIMULATOR_STEERING_ANGLE_FRAME_ID (0x103u)
#define SIMULATOR_CONTROL_STATE_FRAME_ID (0x501u)
#define SIMULATOR_CONTROL_OUTPUT_FRAME_ID (0x102u)
#define SIMULATOR_SPEED_FRAME_ID (0x202u)
#define SIMULATOR_DEBUG_SIGNAL_FRAME_ID (0x400u)

/* Frame lengths in bytes. */
#define SIMULATOR_IMU_ANGULAR_RATE_BYTE_SIZE (6u)
#define SIMULATOR_IMU_ACCELERATION_BYTE_SIZE (8u)
#define SIMULATOR_PEDALS_OUTPUT_BYTE_SIZE (6u)
#define SIMULATOR_STEERING_ANGLE_BYTE_SIZE (4u)
#define SIMULATOR_CONTROL_STATE_BYTE_SIZE (3u)
#define SIMULATOR_CONTROL_OUTPUT_BYTE_SIZE (8u)
#define SIMULATOR_SPEED_BYTE_SIZE (8u)
#define SIMULATOR_DEBUG_SIGNAL_BYTE_SIZE (8u)

/* Extended or standard frame types. */
#define SIMULATOR_IMU_ANGULAR_RATE_IS_EXTENDED (0)
#define SIMULATOR_IMU_ACCELERATION_IS_EXTENDED (0)
#define SIMULATOR_PEDALS_OUTPUT_IS_EXTENDED (0)
#define SIMULATOR_STEERING_ANGLE_IS_EXTENDED (0)
#define SIMULATOR_CONTROL_STATE_IS_EXTENDED (0)
#define SIMULATOR_CONTROL_OUTPUT_IS_EXTENDED (0)
#define SIMULATOR_SPEED_IS_EXTENDED (0)
#define SIMULATOR_DEBUG_SIGNAL_IS_EXTENDED (0)

/* Frame cycle times in milliseconds. */
#define SIMULATOR_PEDALS_OUTPUT_CYCLE_TIME_MS (10u)
#define SIMULATOR_STEERING_ANGLE_CYCLE_TIME_MS (10u)
#define SIMULATOR_CONTROL_STATE_CYCLE_TIME_MS (100u)
#define SIMULATOR_CONTROL_OUTPUT_CYCLE_TIME_MS (100u)
#define SIMULATOR_SPEED_CYCLE_TIME_MS (10u)
#define SIMULATOR_DEBUG_SIGNAL_CYCLE_TIME_MS (10u)

/* Topics masks */
/* TOPIC FIXED_IDS */
#define SIMULATOR_TOPIC_MASK_FIXED_IDS 0b00000011111

#define SIMULATOR_ID_IMU_ANGULAR_RATE 0x4EC // dec: 1260 bin: 0b10011101100
#define SIMULATOR_ID_IMU_ACCELERATION 0x4ED // dec: 1261 bin: 0b10011101101

/* TOPIC STEER */
#define SIMULATOR_TOPIC_MASK_STEER 0b00000011111

#define SIMULATOR_TOPIC_FILTER_STEER 0x2 // dec: 2 bin: 0b00000000010

#define SIMULATOR_ID_PEDALS_OUTPUT 0x302 // dec: 770 bin: 0b01100000010
#define SIMULATOR_ID_CONTROL_OUTPUT 0x102 // dec: 258 bin: 0b00100000010
#define SIMULATOR_ID_SPEED 0x202 // dec: 514 bin: 0b01000000010

/* TOPIC TELEMETRY */
#define SIMULATOR_TOPIC_MASK_TELEMETRY 0b00000011111

#define SIMULATOR_TOPIC_FILTER_TELEMETRY 0x3 // dec: 3 bin: 0b00000000011

#define SIMULATOR_ID_STEERING_ANGLE 0x103 // dec: 259 bin: 0b00100000011

/* TOPIC DAS */
#define SIMULATOR_TOPIC_MASK_DAS 0b00000011111

#define SIMULATOR_TOPIC_FILTER_DAS 0x1 // dec: 1 bin: 0b00000000001

#define SIMULATOR_ID_CONTROL_STATE 0x501 // dec: 1281 bin: 0b10100000001

/* TOPIC BROADCAST */
#define SIMULATOR_TOPIC_MASK_BROADCAST 0b00000011111

#define SIMULATOR_TOPIC_FILTER_BROADCAST 0x0 // dec: 0 bin: 0b00000000000

#define SIMULATOR_ID_DEBUG_SIGNAL 0x400 // dec: 1024 bin: 0b10000000000



/* Signal choices. */


/* Indexes */
#define SIMULATOR_IMU_ANGULAR_RATE_INDEX 0
#define SIMULATOR_IMU_ACCELERATION_INDEX 1
#define SIMULATOR_PEDALS_OUTPUT_INDEX 2
#define SIMULATOR_STEERING_ANGLE_INDEX 3
#define SIMULATOR_CONTROL_STATE_INDEX 4
#define SIMULATOR_CONTROL_OUTPUT_INDEX 5
#define SIMULATOR_SPEED_INDEX 6
#define SIMULATOR_DEBUG_SIGNAL_INDEX 7


#define simulator_MESSAGE_COUNT 8

#ifndef CANLIB_DEVICE_T
#define CANLIB_DEVICE_T
typedef struct {
    void* message;
    void* _converted;
    void* _raw;
    int _size_raw;
    int _size_converted;
} device_t;
void device_init(device_t *device);
void device_preallocate(device_t *device, int bytes);
void device_free(device_t *device);
void device_set_address(device_t *device, void* raw, size_t raw_size, void *converted, size_t converted_size);
#endif // CANLIB_DEVICE_T

#ifdef CANLIB_DEVICE_IMPLEMENTATION
#undef CANLIB_DEVICE_IMPLEMENTATION
void device_init(device_t *device) {
    device->message = NULL;
    device->_converted = NULL;
    device->_raw = NULL;
    device->_size_raw = 0;
    device->_size_converted = 0;
}
void device_preallocate(device_t *device, int bytes){
    if(device->_size_raw > 0)
        free(device->_raw);
    if(device->_size_converted > 0)
        free(device->_converted);
    device->_raw = malloc(bytes);
    device->_converted = malloc(bytes);
    device->_size_converted = device->_size_raw = bytes;
}
void device_free(device_t *device) {
    free(device->_raw);
    free(device->_converted);
    device->message = NULL;
    device->_raw = NULL;
    device->_converted = NULL;
    device->_size_raw = 0;
    device->_size_converted = 0;
}
void device_set_address(device_t *device, void* raw, size_t raw_size, void *converted, size_t converted_size) {
    device->_raw = raw;
    device->_converted = converted;
    device->_size_raw = raw_size;
    device->_size_converted = converted_size;
}
#endif // CANLIB_DEVICE_IMPLEMENTATION

void simulator_devices_deserialize_from_id(
    device_t* device,
    uint16_t message_id,
    uint8_t* data
#ifdef CANLIB_TIMESTAMP
    , uint64_t timestamp
#endif // CANLIB_TIMESTAMP
);

int simulator_message_name_from_id(uint16_t id, char* buffer);
int simulator_index_from_id(uint16_t id);
int simulator_id_from_index(int index);

/**
 * Signals in message IMU_ANGULAR_RATE.
 *
 * Inertial Measurement Unit [x,y,z]-axis angular rate value. 0.01dps per bit, Big-Endian, 16bit Total, signed
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (-245..245 -)
     * Scale: 0.007476920729381247
     * Offset: -245
     */
    uint16_t ang_rate_x;

    /**
     * Range: 0..65535 (-245..245 -)
     * Scale: 0.007476920729381247
     * Offset: -245
     */
    uint16_t ang_rate_y;

    /**
     * Range: 0..65535 (-245..245 -)
     * Scale: 0.007476920729381247
     * Offset: -245
     */
    uint16_t ang_rate_z;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} simulator_imu_angular_rate_t;

/**
 * Signals in message IMU_ANGULAR_RATE.
 *
 * Inertial Measurement Unit [x,y,z]-axis angular rate value. 0.01dps per bit, Big-Endian, 16bit Total, signed
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (-245..245 -)
     * Scale: 0.007476920729381247
     * Offset: -245
     */
    float ang_rate_x;

    /**
     * Range: 0..65535 (-245..245 -)
     * Scale: 0.007476920729381247
     * Offset: -245
     */
    float ang_rate_y;

    /**
     * Range: 0..65535 (-245..245 -)
     * Scale: 0.007476920729381247
     * Offset: -245
     */
    float ang_rate_z;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} simulator_imu_angular_rate_converted_t;

/**
 * Signals in message IMU_ACCELERATION.
 *
 * Inertial Measurement Unit [x,y,z]-axis acceleration value. 0.01g per bit, Big-Endian, 16bit Total, signed
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (-8..8 -)
     * Scale: 0.00024414435034714275
     * Offset: -8
     */
    uint16_t accel_x;

    /**
     * Range: 0..65535 (-8..8 -)
     * Scale: 0.00024414435034714275
     * Offset: -8
     */
    uint16_t accel_y;

    /**
     * Range: 0..65535 (-8..8 -)
     * Scale: 0.00024414435034714275
     * Offset: -8
     */
    uint16_t accel_z;

    /**
     * Range: 0..65535 (-32768..32767 -)
     * Scale: 1
     * Offset: -32768
     */
    int16_t temperature;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} simulator_imu_acceleration_t;

/**
 * Signals in message IMU_ACCELERATION.
 *
 * Inertial Measurement Unit [x,y,z]-axis acceleration value. 0.01g per bit, Big-Endian, 16bit Total, signed
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (-8..8 -)
     * Scale: 0.00024414435034714275
     * Offset: -8
     */
    float accel_x;

    /**
     * Range: 0..65535 (-8..8 -)
     * Scale: 0.00024414435034714275
     * Offset: -8
     */
    float accel_y;

    /**
     * Range: 0..65535 (-8..8 -)
     * Scale: 0.00024414435034714275
     * Offset: -8
     */
    float accel_z;

    /**
     * Range: 0..65535 (-32768..32767 -)
     * Scale: 1
     * Offset: -32768
     */
    int16_t temperature;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} simulator_imu_acceleration_converted_t;

/**
 * Signals in message PEDALS_OUTPUT.
 *
 * Pedal output, already calibrated
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (0..100 -)
     * Scale: 0.0015259021896696422
     * Offset: 0
     */
    uint16_t apps;

    /**
     * Range: 0..65535 (0..100 -)
     * Scale: 0.0015259021896696422
     * Offset: 0
     */
    uint16_t bse_front;

    /**
     * Range: 0..65535 (0..100 -)
     * Scale: 0.0015259021896696422
     * Offset: 0
     */
    uint16_t bse_rear;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} simulator_pedals_output_t;

/**
 * Signals in message PEDALS_OUTPUT.
 *
 * Pedal output, already calibrated
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (0..100 -)
     * Scale: 0.0015259021896696422
     * Offset: 0
     */
    float apps;

    /**
     * Range: 0..65535 (0..100 -)
     * Scale: 0.0015259021896696422
     * Offset: 0
     */
    float bse_front;

    /**
     * Range: 0..65535 (0..100 -)
     * Scale: 0.0015259021896696422
     * Offset: 0
     */
    float bse_rear;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} simulator_pedals_output_converted_t;

/**
 * Signals in message STEERING_ANGLE.
 *
 * Steering angle in degrees
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..4294967295 (-360..360 -)
     * Scale: 1.676380634698174e-07
     * Offset: -360
     */
    uint32_t angle;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} simulator_steering_angle_t;

/**
 * Signals in message STEERING_ANGLE.
 *
 * Steering angle in degrees
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..4294967295 (-360..360 -)
     * Scale: 1.676380634698174e-07
     * Offset: -360
     */
    float angle;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} simulator_steering_angle_converted_t;

/**
 * Signals in message CONTROL_STATE.
 *
 * Send status of traction control
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..150 (-0.5..1 -)
     * Scale: 0.01
     * Offset: -0.5
     */
    uint8_t map_pw;

    /**
     * Range: 0..100 (0..1 -)
     * Scale: 0.01
     * Offset: 0
     */
    uint8_t map_sc;

    /**
     * Range: 0..100 (0..1 -)
     * Scale: 0.01
     * Offset: 0
     */
    uint8_t map_tv;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} simulator_control_state_t;

/**
 * Signals in message CONTROL_STATE.
 *
 * Send status of traction control
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..150 (-0.5..1 -)
     * Scale: 0.01
     * Offset: -0.5
     */
    float map_pw;

    /**
     * Range: 0..100 (0..1 -)
     * Scale: 0.01
     * Offset: 0
     */
    float map_sc;

    /**
     * Range: 0..100 (0..1 -)
     * Scale: 0.01
     * Offset: 0
     */
    float map_tv;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} simulator_control_state_converted_t;

/**
 * Signals in message CONTROL_OUTPUT.
 *
 * Control output, N*m
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (-10..50 -)
     * Scale: 0.0009155413138017853
     * Offset: -10
     */
    uint16_t estimated_velocity;

    /**
     * Range: 0..255 (0..80 -)
     * Scale: 0.3137254901960784
     * Offset: 0
     */
    uint8_t tmax_r;

    /**
     * Range: 0..255 (0..80 -)
     * Scale: 0.3137254901960784
     * Offset: 0
     */
    uint8_t tmax_l;

    /**
     * Range: 0..65535 (0..80 -)
     * Scale: 0.0012207217517357137
     * Offset: 0
     */
    uint16_t torque_l;

    /**
     * Range: 0..65535 (0..80 -)
     * Scale: 0.0012207217517357137
     * Offset: 0
     */
    uint16_t torque_r;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} simulator_control_output_t;

/**
 * Signals in message CONTROL_OUTPUT.
 *
 * Control output, N*m
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (-10..50 -)
     * Scale: 0.0009155413138017853
     * Offset: -10
     */
    float estimated_velocity;

    /**
     * Range: 0..255 (0..80 -)
     * Scale: 0.3137254901960784
     * Offset: 0
     */
    float tmax_r;

    /**
     * Range: 0..255 (0..80 -)
     * Scale: 0.3137254901960784
     * Offset: 0
     */
    float tmax_l;

    /**
     * Range: 0..65535 (0..80 -)
     * Scale: 0.0012207217517357137
     * Offset: 0
     */
    float torque_l;

    /**
     * Range: 0..65535 (0..80 -)
     * Scale: 0.0012207217517357137
     * Offset: 0
     */
    float torque_r;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} simulator_control_output_converted_t;

/**
 * Signals in message SPEED.
 *
 * Encoder and inverter speed in rad/s
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65534.99999999999 (-20..200 -)
     * Scale: 0.003356984817273213
     * Offset: -20
     */
    uint16_t encoder_l;

    /**
     * Range: 0..65534.99999999999 (-20..200 -)
     * Scale: 0.003356984817273213
     * Offset: -20
     */
    uint16_t encoder_r;

    /**
     * Range: 0..65534.99999999999 (-20..200 -)
     * Scale: 0.003356984817273213
     * Offset: -20
     */
    uint16_t inverter_l;

    /**
     * Range: 0..65534.99999999999 (-20..200 -)
     * Scale: 0.003356984817273213
     * Offset: -20
     */
    uint16_t inverter_r;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} simulator_speed_t;

/**
 * Signals in message SPEED.
 *
 * Encoder and inverter speed in rad/s
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65534.99999999999 (-20..200 -)
     * Scale: 0.003356984817273213
     * Offset: -20
     */
    float encoder_l;

    /**
     * Range: 0..65534.99999999999 (-20..200 -)
     * Scale: 0.003356984817273213
     * Offset: -20
     */
    float encoder_r;

    /**
     * Range: 0..65534.99999999999 (-20..200 -)
     * Scale: 0.003356984817273213
     * Offset: -20
     */
    float inverter_l;

    /**
     * Range: 0..65534.99999999999 (-20..200 -)
     * Scale: 0.003356984817273213
     * Offset: -20
     */
    float inverter_r;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} simulator_speed_converted_t;

/**
 * Signals in message DEBUG_SIGNAL.
 *
 * Debug signals
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (-1..1 -)
     * Scale: 3.0518043793392844e-05
     * Offset: -1
     */
    uint16_t field_1;

    /**
     * Range: 0..65535 (-1..1 -)
     * Scale: 3.0518043793392844e-05
     * Offset: -1
     */
    uint16_t field_2;

    /**
     * Range: 0..65535 (-1..1 -)
     * Scale: 3.0518043793392844e-05
     * Offset: -1
     */
    uint16_t field_3;

    /**
     * Range: 0..65535 (-1..1 -)
     * Scale: 3.0518043793392844e-05
     * Offset: -1
     */
    uint16_t field_4;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} simulator_debug_signal_t;

/**
 * Signals in message DEBUG_SIGNAL.
 *
 * Debug signals
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (-1..1 -)
     * Scale: 3.0518043793392844e-05
     * Offset: -1
     */
    float field_1;

    /**
     * Range: 0..65535 (-1..1 -)
     * Scale: 3.0518043793392844e-05
     * Offset: -1
     */
    float field_2;

    /**
     * Range: 0..65535 (-1..1 -)
     * Scale: 3.0518043793392844e-05
     * Offset: -1
     */
    float field_3;

    /**
     * Range: 0..65535 (-1..1 -)
     * Scale: 3.0518043793392844e-05
     * Offset: -1
     */
    float field_4;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} simulator_debug_signal_converted_t;


void simulator_imu_angular_rate_raw_to_conversion(
    simulator_imu_angular_rate_converted_t *conversion,
    float ang_rate_x,
    float ang_rate_y,
    float ang_rate_z
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void simulator_imu_angular_rate_conversion_to_raw(
    simulator_imu_angular_rate_t *raw,
    float ang_rate_x,
    float ang_rate_y,
    float ang_rate_z
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void simulator_imu_angular_rate_raw_to_conversion_struct(
    simulator_imu_angular_rate_converted_t *conversion, 
    const simulator_imu_angular_rate_t *raw);


void simulator_imu_angular_rate_conversion_to_raw_struct(
    simulator_imu_angular_rate_t *raw,
    const simulator_imu_angular_rate_converted_t *conversion);


int simulator_imu_angular_rate_converted_to_string(simulator_imu_angular_rate_converted_t *message, char *buffer);

int simulator_imu_angular_rate_converted_to_string_file(simulator_imu_angular_rate_converted_t *message, FILE *buffer);

int simulator_imu_angular_rate_fields(char *buffer);

int simulator_imu_angular_rate_fields_file(FILE *buffer);

/**
 * Pack message IMU_ANGULAR_RATE.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int simulator_imu_angular_rate_pack(
    uint8_t *dst_p,
    const simulator_imu_angular_rate_t *src_p,
    size_t byte_size);

/**
 * Unpack message IMU_ANGULAR_RATE.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int simulator_imu_angular_rate_unpack(
    simulator_imu_angular_rate_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t simulator_imu_angular_rate_ang_rate_x_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float simulator_imu_angular_rate_ang_rate_x_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool simulator_imu_angular_rate_ang_rate_x_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t simulator_imu_angular_rate_ang_rate_y_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float simulator_imu_angular_rate_ang_rate_y_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool simulator_imu_angular_rate_ang_rate_y_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t simulator_imu_angular_rate_ang_rate_z_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float simulator_imu_angular_rate_ang_rate_z_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool simulator_imu_angular_rate_ang_rate_z_is_in_range(uint16_t value);


void simulator_imu_acceleration_raw_to_conversion(
    simulator_imu_acceleration_converted_t *conversion,
    float accel_x,
    float accel_y,
    float accel_z,
    int16_t temperature
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void simulator_imu_acceleration_conversion_to_raw(
    simulator_imu_acceleration_t *raw,
    float accel_x,
    float accel_y,
    float accel_z,
    int16_t temperature
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void simulator_imu_acceleration_raw_to_conversion_struct(
    simulator_imu_acceleration_converted_t *conversion, 
    const simulator_imu_acceleration_t *raw);


void simulator_imu_acceleration_conversion_to_raw_struct(
    simulator_imu_acceleration_t *raw,
    const simulator_imu_acceleration_converted_t *conversion);


int simulator_imu_acceleration_converted_to_string(simulator_imu_acceleration_converted_t *message, char *buffer);

int simulator_imu_acceleration_converted_to_string_file(simulator_imu_acceleration_converted_t *message, FILE *buffer);

int simulator_imu_acceleration_fields(char *buffer);

int simulator_imu_acceleration_fields_file(FILE *buffer);

/**
 * Pack message IMU_ACCELERATION.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int simulator_imu_acceleration_pack(
    uint8_t *dst_p,
    const simulator_imu_acceleration_t *src_p,
    size_t byte_size);

/**
 * Unpack message IMU_ACCELERATION.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int simulator_imu_acceleration_unpack(
    simulator_imu_acceleration_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t simulator_imu_acceleration_accel_x_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float simulator_imu_acceleration_accel_x_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool simulator_imu_acceleration_accel_x_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t simulator_imu_acceleration_accel_y_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float simulator_imu_acceleration_accel_y_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool simulator_imu_acceleration_accel_y_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t simulator_imu_acceleration_accel_z_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float simulator_imu_acceleration_accel_z_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool simulator_imu_acceleration_accel_z_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool simulator_imu_acceleration_temperature_is_in_range(int16_t value);


void simulator_pedals_output_raw_to_conversion(
    simulator_pedals_output_converted_t *conversion,
    float apps,
    float bse_front,
    float bse_rear
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void simulator_pedals_output_conversion_to_raw(
    simulator_pedals_output_t *raw,
    float apps,
    float bse_front,
    float bse_rear
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void simulator_pedals_output_raw_to_conversion_struct(
    simulator_pedals_output_converted_t *conversion, 
    const simulator_pedals_output_t *raw);


void simulator_pedals_output_conversion_to_raw_struct(
    simulator_pedals_output_t *raw,
    const simulator_pedals_output_converted_t *conversion);


int simulator_pedals_output_converted_to_string(simulator_pedals_output_converted_t *message, char *buffer);

int simulator_pedals_output_converted_to_string_file(simulator_pedals_output_converted_t *message, FILE *buffer);

int simulator_pedals_output_fields(char *buffer);

int simulator_pedals_output_fields_file(FILE *buffer);

/**
 * Pack message PEDALS_OUTPUT.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int simulator_pedals_output_pack(
    uint8_t *dst_p,
    const simulator_pedals_output_t *src_p,
    size_t byte_size);

/**
 * Unpack message PEDALS_OUTPUT.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int simulator_pedals_output_unpack(
    simulator_pedals_output_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t simulator_pedals_output_apps_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float simulator_pedals_output_apps_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool simulator_pedals_output_apps_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t simulator_pedals_output_bse_front_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float simulator_pedals_output_bse_front_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool simulator_pedals_output_bse_front_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t simulator_pedals_output_bse_rear_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float simulator_pedals_output_bse_rear_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool simulator_pedals_output_bse_rear_is_in_range(uint16_t value);


void simulator_steering_angle_raw_to_conversion(
    simulator_steering_angle_converted_t *conversion,
    float angle
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void simulator_steering_angle_conversion_to_raw(
    simulator_steering_angle_t *raw,
    float angle
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void simulator_steering_angle_raw_to_conversion_struct(
    simulator_steering_angle_converted_t *conversion, 
    const simulator_steering_angle_t *raw);


void simulator_steering_angle_conversion_to_raw_struct(
    simulator_steering_angle_t *raw,
    const simulator_steering_angle_converted_t *conversion);


int simulator_steering_angle_converted_to_string(simulator_steering_angle_converted_t *message, char *buffer);

int simulator_steering_angle_converted_to_string_file(simulator_steering_angle_converted_t *message, FILE *buffer);

int simulator_steering_angle_fields(char *buffer);

int simulator_steering_angle_fields_file(FILE *buffer);

/**
 * Pack message STEERING_ANGLE.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int simulator_steering_angle_pack(
    uint8_t *dst_p,
    const simulator_steering_angle_t *src_p,
    size_t byte_size);

/**
 * Unpack message STEERING_ANGLE.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int simulator_steering_angle_unpack(
    simulator_steering_angle_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t simulator_steering_angle_angle_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float simulator_steering_angle_angle_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool simulator_steering_angle_angle_is_in_range(uint32_t value);


void simulator_control_state_raw_to_conversion(
    simulator_control_state_converted_t *conversion,
    float map_pw,
    float map_sc,
    float map_tv
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void simulator_control_state_conversion_to_raw(
    simulator_control_state_t *raw,
    float map_pw,
    float map_sc,
    float map_tv
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void simulator_control_state_raw_to_conversion_struct(
    simulator_control_state_converted_t *conversion, 
    const simulator_control_state_t *raw);


void simulator_control_state_conversion_to_raw_struct(
    simulator_control_state_t *raw,
    const simulator_control_state_converted_t *conversion);


int simulator_control_state_converted_to_string(simulator_control_state_converted_t *message, char *buffer);

int simulator_control_state_converted_to_string_file(simulator_control_state_converted_t *message, FILE *buffer);

int simulator_control_state_fields(char *buffer);

int simulator_control_state_fields_file(FILE *buffer);

/**
 * Pack message CONTROL_STATE.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int simulator_control_state_pack(
    uint8_t *dst_p,
    const simulator_control_state_t *src_p,
    size_t byte_size);

/**
 * Unpack message CONTROL_STATE.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int simulator_control_state_unpack(
    simulator_control_state_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t simulator_control_state_map_pw_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float simulator_control_state_map_pw_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool simulator_control_state_map_pw_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t simulator_control_state_map_sc_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float simulator_control_state_map_sc_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool simulator_control_state_map_sc_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t simulator_control_state_map_tv_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float simulator_control_state_map_tv_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool simulator_control_state_map_tv_is_in_range(uint8_t value);


void simulator_control_output_raw_to_conversion(
    simulator_control_output_converted_t *conversion,
    float estimated_velocity,
    float tmax_r,
    float tmax_l,
    float torque_l,
    float torque_r
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void simulator_control_output_conversion_to_raw(
    simulator_control_output_t *raw,
    float estimated_velocity,
    float tmax_r,
    float tmax_l,
    float torque_l,
    float torque_r
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void simulator_control_output_raw_to_conversion_struct(
    simulator_control_output_converted_t *conversion, 
    const simulator_control_output_t *raw);


void simulator_control_output_conversion_to_raw_struct(
    simulator_control_output_t *raw,
    const simulator_control_output_converted_t *conversion);


int simulator_control_output_converted_to_string(simulator_control_output_converted_t *message, char *buffer);

int simulator_control_output_converted_to_string_file(simulator_control_output_converted_t *message, FILE *buffer);

int simulator_control_output_fields(char *buffer);

int simulator_control_output_fields_file(FILE *buffer);

/**
 * Pack message CONTROL_OUTPUT.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int simulator_control_output_pack(
    uint8_t *dst_p,
    const simulator_control_output_t *src_p,
    size_t byte_size);

/**
 * Unpack message CONTROL_OUTPUT.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int simulator_control_output_unpack(
    simulator_control_output_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t simulator_control_output_estimated_velocity_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float simulator_control_output_estimated_velocity_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool simulator_control_output_estimated_velocity_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t simulator_control_output_tmax_r_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float simulator_control_output_tmax_r_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool simulator_control_output_tmax_r_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t simulator_control_output_tmax_l_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float simulator_control_output_tmax_l_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool simulator_control_output_tmax_l_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t simulator_control_output_torque_l_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float simulator_control_output_torque_l_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool simulator_control_output_torque_l_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t simulator_control_output_torque_r_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float simulator_control_output_torque_r_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool simulator_control_output_torque_r_is_in_range(uint16_t value);


void simulator_speed_raw_to_conversion(
    simulator_speed_converted_t *conversion,
    float encoder_l,
    float encoder_r,
    float inverter_l,
    float inverter_r
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void simulator_speed_conversion_to_raw(
    simulator_speed_t *raw,
    float encoder_l,
    float encoder_r,
    float inverter_l,
    float inverter_r
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void simulator_speed_raw_to_conversion_struct(
    simulator_speed_converted_t *conversion, 
    const simulator_speed_t *raw);


void simulator_speed_conversion_to_raw_struct(
    simulator_speed_t *raw,
    const simulator_speed_converted_t *conversion);


int simulator_speed_converted_to_string(simulator_speed_converted_t *message, char *buffer);

int simulator_speed_converted_to_string_file(simulator_speed_converted_t *message, FILE *buffer);

int simulator_speed_fields(char *buffer);

int simulator_speed_fields_file(FILE *buffer);

/**
 * Pack message SPEED.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int simulator_speed_pack(
    uint8_t *dst_p,
    const simulator_speed_t *src_p,
    size_t byte_size);

/**
 * Unpack message SPEED.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int simulator_speed_unpack(
    simulator_speed_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t simulator_speed_encoder_l_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float simulator_speed_encoder_l_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool simulator_speed_encoder_l_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t simulator_speed_encoder_r_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float simulator_speed_encoder_r_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool simulator_speed_encoder_r_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t simulator_speed_inverter_l_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float simulator_speed_inverter_l_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool simulator_speed_inverter_l_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t simulator_speed_inverter_r_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float simulator_speed_inverter_r_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool simulator_speed_inverter_r_is_in_range(uint16_t value);


void simulator_debug_signal_raw_to_conversion(
    simulator_debug_signal_converted_t *conversion,
    float field_1,
    float field_2,
    float field_3,
    float field_4
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void simulator_debug_signal_conversion_to_raw(
    simulator_debug_signal_t *raw,
    float field_1,
    float field_2,
    float field_3,
    float field_4
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void simulator_debug_signal_raw_to_conversion_struct(
    simulator_debug_signal_converted_t *conversion, 
    const simulator_debug_signal_t *raw);


void simulator_debug_signal_conversion_to_raw_struct(
    simulator_debug_signal_t *raw,
    const simulator_debug_signal_converted_t *conversion);


int simulator_debug_signal_converted_to_string(simulator_debug_signal_converted_t *message, char *buffer);

int simulator_debug_signal_converted_to_string_file(simulator_debug_signal_converted_t *message, FILE *buffer);

int simulator_debug_signal_fields(char *buffer);

int simulator_debug_signal_fields_file(FILE *buffer);

/**
 * Pack message DEBUG_SIGNAL.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int simulator_debug_signal_pack(
    uint8_t *dst_p,
    const simulator_debug_signal_t *src_p,
    size_t byte_size);

/**
 * Unpack message DEBUG_SIGNAL.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int simulator_debug_signal_unpack(
    simulator_debug_signal_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t simulator_debug_signal_field_1_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float simulator_debug_signal_field_1_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool simulator_debug_signal_field_1_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t simulator_debug_signal_field_2_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float simulator_debug_signal_field_2_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool simulator_debug_signal_field_2_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t simulator_debug_signal_field_3_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float simulator_debug_signal_field_3_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool simulator_debug_signal_field_3_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t simulator_debug_signal_field_4_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float simulator_debug_signal_field_4_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool simulator_debug_signal_field_4_is_in_range(uint16_t value);

bool simulator_id_is_message(uint16_t id);

int simulator_to_string_from_id(uint16_t message_id, void* message, char* buffer);
int simulator_fields_from_id(uint16_t message_id, char* buffer);
int simulator_to_string_file_from_id(uint16_t message_id, void* message, FILE* buffer);
int simulator_fields_file_from_id(uint16_t message_id, FILE* buffer);


typedef union CANLIB_PARKING {
    simulator_imu_angular_rate_t _imu_angular_rate;
    simulator_imu_acceleration_t _imu_acceleration;
    simulator_pedals_output_t _pedals_output;
    simulator_steering_angle_t _steering_angle;
    simulator_control_state_t _control_state;
    simulator_control_output_t _control_output;
    simulator_speed_t _speed;
    simulator_debug_signal_t _debug_signal;

} _simulator_all_struct_raw;

typedef union CANLIB_PARKING {
    simulator_imu_angular_rate_converted_t _imu_angular_rate;
    simulator_imu_acceleration_converted_t _imu_acceleration;
    simulator_pedals_output_converted_t _pedals_output;
    simulator_steering_angle_converted_t _steering_angle;
    simulator_control_state_converted_t _control_state;
    simulator_control_output_converted_t _control_output;
    simulator_speed_converted_t _speed;
    simulator_debug_signal_converted_t _debug_signal;

} _simulator_all_struct_converted;



#define simulator_MAX_STRUCT_SIZE_RAW sizeof(_simulator_all_struct_raw)
#define simulator_MAX_STRUCT_SIZE_CONVERSION sizeof(_simulator_all_struct_converted)

#ifdef __cplusplus
}
#endif

#endif
