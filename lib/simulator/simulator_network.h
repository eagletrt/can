/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2018-2019 Erik Moqvist
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/**
 * This file was generated by cantools version 38.0.2 Mon Oct 30 14:09:09 2023.
 */

#ifndef SIMULATOR_H
#define SIMULATOR_H

#include <stdio.h>
#include <stdlib.h>
#include <inttypes.h>

#ifdef __cplusplus
extern "C" {
#endif

#include <stdint.h>
#include <stdbool.h>
#include <stddef.h>

#ifndef CANLIB_BUILD
#define CANLIB_BUILD
#define CANLIB_BUILD_TIME 1698674949
#endif // CANLIB_BUILD

#define canlib_min(a,b) (((a) < (b)) ? (a) : (b))
#define canlib_max(a,b) (((a) > (b)) ? (a) : (b))

#ifndef CANLIB_PARKING
/* We know it's PACKING but PARKING sounds a bit better ;) */
#if defined(__MINGW32__)
#define CANLIB_PARKING                                                           __attribute__((__gcc_struct__, __packed__)) // , __aligned__(1)))
#else
#define CANLIB_PARKING __attribute__((__packed__)) // , __aligned__(1)))
#endif                                             // defined(__MINGW32__)
#endif                                             // CANLIB_PARKING

#ifndef EINVAL
#    define EINVAL 22
#endif

/* Frame ids. */
#define SIMULATOR_ANGULAR_RATE_FRAME_ID (0x4ecu)
#define SIMULATOR_ACCELERATION_FRAME_ID (0x4edu)
#define SIMULATOR_PEDALS_FRAME_ID (0x301u)
#define SIMULATOR_STEERING_ANGLE_FRAME_ID (0x102u)
#define SIMULATOR_CONTROL_STATE_FRAME_ID (0x500u)
#define SIMULATOR_CONTROL_OUTPUT_FRAME_ID (0x101u)
#define SIMULATOR_SPEED_FRAME_ID (0x201u)

/* Frame lengths in bytes. */
#define SIMULATOR_ANGULAR_RATE_BYTE_SIZE (6u)
#define SIMULATOR_ACCELERATION_BYTE_SIZE (8u)
#define SIMULATOR_PEDALS_BYTE_SIZE (5u)
#define SIMULATOR_STEERING_ANGLE_BYTE_SIZE (4u)
#define SIMULATOR_CONTROL_STATE_BYTE_SIZE (3u)
#define SIMULATOR_CONTROL_OUTPUT_BYTE_SIZE (8u)
#define SIMULATOR_SPEED_BYTE_SIZE (8u)

/* Extended or standard frame types. */
#define SIMULATOR_ANGULAR_RATE_IS_EXTENDED (0)
#define SIMULATOR_ACCELERATION_IS_EXTENDED (0)
#define SIMULATOR_PEDALS_IS_EXTENDED (0)
#define SIMULATOR_STEERING_ANGLE_IS_EXTENDED (0)
#define SIMULATOR_CONTROL_STATE_IS_EXTENDED (0)
#define SIMULATOR_CONTROL_OUTPUT_IS_EXTENDED (0)
#define SIMULATOR_SPEED_IS_EXTENDED (0)

/* Frame cycle times in milliseconds. */
#define SIMULATOR_PEDALS_CYCLE_TIME_MS (10u)
#define SIMULATOR_STEERING_ANGLE_CYCLE_TIME_MS (10u)
#define SIMULATOR_CONTROL_STATE_CYCLE_TIME_MS (100u)
#define SIMULATOR_CONTROL_OUTPUT_CYCLE_TIME_MS (100u)
#define SIMULATOR_SPEED_CYCLE_TIME_MS (10u)

/* Topics masks */
/* TOPIC FIXED_IDS */
#define SIMULATOR_TOPIC_MASK_FIXED_IDS 0b00000011111

#define SIMULATOR_ID_ANGULAR_RATE 0x4EC // dec: 1260 bin: 0b10011101100
#define SIMULATOR_ID_ACCELERATION 0x4ED // dec: 1261 bin: 0b10011101101

/* TOPIC STEER */
#define SIMULATOR_TOPIC_MASK_STEER 0b00000011111

#define SIMULATOR_TOPIC_FILTER_STEER 0x1 // dec: 1 bin: 0b00000000001

#define SIMULATOR_ID_PEDALS 0x301 // dec: 769 bin: 0b01100000001
#define SIMULATOR_ID_CONTROL_OUTPUT 0x101 // dec: 257 bin: 0b00100000001
#define SIMULATOR_ID_SPEED 0x201 // dec: 513 bin: 0b01000000001

/* TOPIC TELEMETRY */
#define SIMULATOR_TOPIC_MASK_TELEMETRY 0b00000011111

#define SIMULATOR_TOPIC_FILTER_TELEMETRY 0x2 // dec: 2 bin: 0b00000000010

#define SIMULATOR_ID_STEERING_ANGLE 0x102 // dec: 258 bin: 0b00100000010

/* TOPIC DAS */
#define SIMULATOR_TOPIC_MASK_DAS 0b00000011111

#define SIMULATOR_TOPIC_FILTER_DAS 0x0 // dec: 0 bin: 0b00000000000

#define SIMULATOR_ID_CONTROL_STATE 0x500 // dec: 1280 bin: 0b10100000000



/* Signal choices. */


/* Indexes */
#define SIMULATOR_ANGULAR_RATE_INDEX 0
#define SIMULATOR_ACCELERATION_INDEX 1
#define SIMULATOR_PEDALS_INDEX 2
#define SIMULATOR_STEERING_ANGLE_INDEX 3
#define SIMULATOR_CONTROL_STATE_INDEX 4
#define SIMULATOR_CONTROL_OUTPUT_INDEX 5
#define SIMULATOR_SPEED_INDEX 6


#define simulator_MESSAGE_COUNT 7

#ifndef CANLIB_DEVICE_T
#define CANLIB_DEVICE_T
typedef struct {
    void* message;
    void* _converted;
    void* _raw;
    int _size_raw;
    int _size_converted;
} device_t;
void device_init(device_t *device);
void device_preallocate(device_t *device, int bytes);
void device_free(device_t *device);
void device_set_address(device_t *device, void* raw, size_t raw_size, void *converted, size_t converted_size);
#endif // CANLIB_DEVICE_T

#ifdef CANLIB_DEVICE_IMPLEMENTATION
#undef CANLIB_DEVICE_IMPLEMENTATION
void device_init(device_t *device) {
    device->message = NULL;
    device->_converted = NULL;
    device->_raw = NULL;
    device->_size_raw = 0;
    device->_size_converted = 0;
}
void device_preallocate(device_t *device, int bytes){
    if(device->_size_raw > 0)
        free(device->_raw);
    if(device->_size_converted > 0)
        free(device->_converted);
    device->_raw = malloc(bytes);
    device->_converted = malloc(bytes);
    device->_size_converted = device->_size_raw = bytes;
}
void device_free(device_t *device) {
    free(device->_raw);
    free(device->_converted);
    device->message = NULL;
    device->_raw = NULL;
    device->_converted = NULL;
    device->_size_raw = 0;
    device->_size_converted = 0;
}
void device_set_address(device_t *device, void* raw, size_t raw_size, void *converted, size_t converted_size) {
    device->_raw = raw;
    device->_converted = converted;
    device->_size_raw = raw_size;
    device->_size_converted = converted_size;
}
#endif // CANLIB_DEVICE_IMPLEMENTATION

void simulator_devices_deserialize_from_id(
    device_t* device,
    uint16_t message_id,
    uint8_t* data
#ifdef CANLIB_TIMESTAMP
    , uint64_t timestamp
#endif // CANLIB_TIMESTAMP
);

int simulator_message_name_from_id(uint16_t id, char* buffer);
int simulator_index_from_id(uint16_t id);
int simulator_id_from_index(int index);

/**
 * Signals in message ANGULAR_RATE.
 *
 * Inertial Measurement Unit [x,y,z]-axis angular rate value. 0.01dps per bit, Big-Endian, 16bit Total, signed
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..2450 (0..245 -)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t x;

    /**
     * Range: 0..2450 (0..245 -)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t y;

    /**
     * Range: 0..2450 (0..245 -)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t z;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} simulator_angular_rate_t;

/**
 * Signals in message ANGULAR_RATE.
 *
 * Inertial Measurement Unit [x,y,z]-axis angular rate value. 0.01dps per bit, Big-Endian, 16bit Total, signed
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..2450 (0..245 -)
     * Scale: 0.1
     * Offset: 0
     */
    float x;

    /**
     * Range: 0..2450 (0..245 -)
     * Scale: 0.1
     * Offset: 0
     */
    float y;

    /**
     * Range: 0..2450 (0..245 -)
     * Scale: 0.1
     * Offset: 0
     */
    float z;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} simulator_angular_rate_converted_t;

/**
 * Signals in message ACCELERATION.
 *
 * Inertial Measurement Unit [x,y,z]-axis acceleration value. 0.01g per bit, Big-Endian, 16bit Total, signed
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..800 (0..8 -)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t x;

    /**
     * Range: 0..800 (0..8 -)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t y;

    /**
     * Range: 0..800 (0..8 -)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t z;

    /**
     * Range: 0..65535 (-32768..32767 -)
     * Scale: 1
     * Offset: -32768
     */
    int16_t temperature;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} simulator_acceleration_t;

/**
 * Signals in message ACCELERATION.
 *
 * Inertial Measurement Unit [x,y,z]-axis acceleration value. 0.01g per bit, Big-Endian, 16bit Total, signed
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..800 (0..8 -)
     * Scale: 0.01
     * Offset: 0
     */
    float x;

    /**
     * Range: 0..800 (0..8 -)
     * Scale: 0.01
     * Offset: 0
     */
    float y;

    /**
     * Range: 0..800 (0..8 -)
     * Scale: 0.01
     * Offset: 0
     */
    float z;

    /**
     * Range: 0..65535 (-32768..32767 -)
     * Scale: 1
     * Offset: -32768
     */
    int16_t temperature;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} simulator_acceleration_converted_t;

/**
 * Signals in message PEDALS.
 *
 * Pedal output, already calibrated
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t throttle;

    /**
     * Range: 0..65535 (0..100 -)
     * Scale: 0.0015259021896696422
     * Offset: 0
     */
    uint16_t brake_front;

    /**
     * Range: 0..65535 (0..100 -)
     * Scale: 0.0015259021896696422
     * Offset: 0
     */
    uint16_t brake_rear;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} simulator_pedals_t;

/**
 * Signals in message PEDALS.
 *
 * Pedal output, already calibrated
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t throttle;

    /**
     * Range: 0..65535 (0..100 -)
     * Scale: 0.0015259021896696422
     * Offset: 0
     */
    float brake_front;

    /**
     * Range: 0..65535 (0..100 -)
     * Scale: 0.0015259021896696422
     * Offset: 0
     */
    float brake_rear;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} simulator_pedals_converted_t;

/**
 * Signals in message STEERING_ANGLE.
 *
 * Steering angle in degrees
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..4294967295 (-360..360 -)
     * Scale: 1.676380634698174e-07
     * Offset: -360
     */
    uint32_t angle;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} simulator_steering_angle_t;

/**
 * Signals in message STEERING_ANGLE.
 *
 * Steering angle in degrees
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..4294967295 (-360..360 -)
     * Scale: 1.676380634698174e-07
     * Offset: -360
     */
    float angle;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} simulator_steering_angle_converted_t;

/**
 * Signals in message CONTROL_STATE.
 *
 * Send status of traction control
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..150 (-0.5..1 -)
     * Scale: 0.01
     * Offset: -0.5
     */
    uint8_t map_pw;

    /**
     * Range: 0..100 (0..1 -)
     * Scale: 0.01
     * Offset: 0
     */
    uint8_t map_sc;

    /**
     * Range: 0..100 (0..1 -)
     * Scale: 0.01
     * Offset: 0
     */
    uint8_t map_tv;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} simulator_control_state_t;

/**
 * Signals in message CONTROL_STATE.
 *
 * Send status of traction control
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..150 (-0.5..1 -)
     * Scale: 0.01
     * Offset: -0.5
     */
    float map_pw;

    /**
     * Range: 0..100 (0..1 -)
     * Scale: 0.01
     * Offset: 0
     */
    float map_sc;

    /**
     * Range: 0..100 (0..1 -)
     * Scale: 0.01
     * Offset: 0
     */
    float map_tv;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} simulator_control_state_converted_t;

/**
 * Signals in message CONTROL_OUTPUT.
 *
 * Control output, N*m
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (-10..50 -)
     * Scale: 0.0009155413138017853
     * Offset: -10
     */
    uint16_t estimated_velocity;

    /**
     * Range: 0..255 (0..80 -)
     * Scale: 0.3137254901960784
     * Offset: 0
     */
    uint8_t tmax_r;

    /**
     * Range: 0..255 (0..80 -)
     * Scale: 0.3137254901960784
     * Offset: 0
     */
    uint8_t tmax_l;

    /**
     * Range: 0..65535 (0..80 -)
     * Scale: 0.0012207217517357137
     * Offset: 0
     */
    uint16_t torque_l;

    /**
     * Range: 0..65535 (0..80 -)
     * Scale: 0.0012207217517357137
     * Offset: 0
     */
    uint16_t torque_r;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} simulator_control_output_t;

/**
 * Signals in message CONTROL_OUTPUT.
 *
 * Control output, N*m
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (-10..50 -)
     * Scale: 0.0009155413138017853
     * Offset: -10
     */
    float estimated_velocity;

    /**
     * Range: 0..255 (0..80 -)
     * Scale: 0.3137254901960784
     * Offset: 0
     */
    float tmax_r;

    /**
     * Range: 0..255 (0..80 -)
     * Scale: 0.3137254901960784
     * Offset: 0
     */
    float tmax_l;

    /**
     * Range: 0..65535 (0..80 -)
     * Scale: 0.0012207217517357137
     * Offset: 0
     */
    float torque_l;

    /**
     * Range: 0..65535 (0..80 -)
     * Scale: 0.0012207217517357137
     * Offset: 0
     */
    float torque_r;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} simulator_control_output_converted_t;

/**
 * Signals in message SPEED.
 *
 * Encoder and inverter speed in rad/s
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (-200..200 -)
     * Scale: 0.006103608758678569
     * Offset: -200
     */
    uint16_t fl;

    /**
     * Range: 0..65535 (-200..200 -)
     * Scale: 0.006103608758678569
     * Offset: -200
     */
    uint16_t fr;

    /**
     * Range: 0..65535 (-200..200 -)
     * Scale: 0.006103608758678569
     * Offset: -200
     */
    uint16_t rl;

    /**
     * Range: 0..65535 (-200..200 -)
     * Scale: 0.006103608758678569
     * Offset: -200
     */
    uint16_t rr;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} simulator_speed_t;

/**
 * Signals in message SPEED.
 *
 * Encoder and inverter speed in rad/s
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (-200..200 -)
     * Scale: 0.006103608758678569
     * Offset: -200
     */
    float fl;

    /**
     * Range: 0..65535 (-200..200 -)
     * Scale: 0.006103608758678569
     * Offset: -200
     */
    float fr;

    /**
     * Range: 0..65535 (-200..200 -)
     * Scale: 0.006103608758678569
     * Offset: -200
     */
    float rl;

    /**
     * Range: 0..65535 (-200..200 -)
     * Scale: 0.006103608758678569
     * Offset: -200
     */
    float rr;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} simulator_speed_converted_t;


void simulator_angular_rate_raw_to_conversion(
    simulator_angular_rate_converted_t *conversion,
    float x,
    float y,
    float z
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void simulator_angular_rate_conversion_to_raw(
    simulator_angular_rate_t *raw,
    float x,
    float y,
    float z
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void simulator_angular_rate_raw_to_conversion_struct(
    simulator_angular_rate_converted_t *conversion, 
    const simulator_angular_rate_t *raw);


void simulator_angular_rate_conversion_to_raw_struct(
    simulator_angular_rate_t *raw,
    const simulator_angular_rate_converted_t *conversion);


int simulator_angular_rate_converted_to_string(simulator_angular_rate_converted_t *message, char *buffer);

int simulator_angular_rate_converted_to_string_file(simulator_angular_rate_converted_t *message, FILE *buffer);

int simulator_angular_rate_fields(char *buffer);

int simulator_angular_rate_fields_file(FILE *buffer);

/**
 * Pack message ANGULAR_RATE.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int simulator_angular_rate_pack(
    uint8_t *dst_p,
    const simulator_angular_rate_t *src_p,
    size_t byte_size);

/**
 * Unpack message ANGULAR_RATE.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int simulator_angular_rate_unpack(
    simulator_angular_rate_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t simulator_angular_rate_x_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float simulator_angular_rate_x_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool simulator_angular_rate_x_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t simulator_angular_rate_y_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float simulator_angular_rate_y_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool simulator_angular_rate_y_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t simulator_angular_rate_z_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float simulator_angular_rate_z_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool simulator_angular_rate_z_is_in_range(int16_t value);


void simulator_acceleration_raw_to_conversion(
    simulator_acceleration_converted_t *conversion,
    float x,
    float y,
    float z,
    int16_t temperature
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void simulator_acceleration_conversion_to_raw(
    simulator_acceleration_t *raw,
    float x,
    float y,
    float z,
    int16_t temperature
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void simulator_acceleration_raw_to_conversion_struct(
    simulator_acceleration_converted_t *conversion, 
    const simulator_acceleration_t *raw);


void simulator_acceleration_conversion_to_raw_struct(
    simulator_acceleration_t *raw,
    const simulator_acceleration_converted_t *conversion);


int simulator_acceleration_converted_to_string(simulator_acceleration_converted_t *message, char *buffer);

int simulator_acceleration_converted_to_string_file(simulator_acceleration_converted_t *message, FILE *buffer);

int simulator_acceleration_fields(char *buffer);

int simulator_acceleration_fields_file(FILE *buffer);

/**
 * Pack message ACCELERATION.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int simulator_acceleration_pack(
    uint8_t *dst_p,
    const simulator_acceleration_t *src_p,
    size_t byte_size);

/**
 * Unpack message ACCELERATION.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int simulator_acceleration_unpack(
    simulator_acceleration_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t simulator_acceleration_x_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float simulator_acceleration_x_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool simulator_acceleration_x_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t simulator_acceleration_y_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float simulator_acceleration_y_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool simulator_acceleration_y_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t simulator_acceleration_z_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float simulator_acceleration_z_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool simulator_acceleration_z_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool simulator_acceleration_temperature_is_in_range(int16_t value);


void simulator_pedals_raw_to_conversion(
    simulator_pedals_converted_t *conversion,
    uint8_t throttle,
    float brake_front,
    float brake_rear
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void simulator_pedals_conversion_to_raw(
    simulator_pedals_t *raw,
    uint8_t throttle,
    float brake_front,
    float brake_rear
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void simulator_pedals_raw_to_conversion_struct(
    simulator_pedals_converted_t *conversion, 
    const simulator_pedals_t *raw);


void simulator_pedals_conversion_to_raw_struct(
    simulator_pedals_t *raw,
    const simulator_pedals_converted_t *conversion);


int simulator_pedals_converted_to_string(simulator_pedals_converted_t *message, char *buffer);

int simulator_pedals_converted_to_string_file(simulator_pedals_converted_t *message, FILE *buffer);

int simulator_pedals_fields(char *buffer);

int simulator_pedals_fields_file(FILE *buffer);

/**
 * Pack message PEDALS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int simulator_pedals_pack(
    uint8_t *dst_p,
    const simulator_pedals_t *src_p,
    size_t byte_size);

/**
 * Unpack message PEDALS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int simulator_pedals_unpack(
    simulator_pedals_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool simulator_pedals_throttle_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t simulator_pedals_brake_front_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float simulator_pedals_brake_front_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool simulator_pedals_brake_front_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t simulator_pedals_brake_rear_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float simulator_pedals_brake_rear_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool simulator_pedals_brake_rear_is_in_range(uint16_t value);


void simulator_steering_angle_raw_to_conversion(
    simulator_steering_angle_converted_t *conversion,
    float angle
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void simulator_steering_angle_conversion_to_raw(
    simulator_steering_angle_t *raw,
    float angle
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void simulator_steering_angle_raw_to_conversion_struct(
    simulator_steering_angle_converted_t *conversion, 
    const simulator_steering_angle_t *raw);


void simulator_steering_angle_conversion_to_raw_struct(
    simulator_steering_angle_t *raw,
    const simulator_steering_angle_converted_t *conversion);


int simulator_steering_angle_converted_to_string(simulator_steering_angle_converted_t *message, char *buffer);

int simulator_steering_angle_converted_to_string_file(simulator_steering_angle_converted_t *message, FILE *buffer);

int simulator_steering_angle_fields(char *buffer);

int simulator_steering_angle_fields_file(FILE *buffer);

/**
 * Pack message STEERING_ANGLE.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int simulator_steering_angle_pack(
    uint8_t *dst_p,
    const simulator_steering_angle_t *src_p,
    size_t byte_size);

/**
 * Unpack message STEERING_ANGLE.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int simulator_steering_angle_unpack(
    simulator_steering_angle_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t simulator_steering_angle_angle_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float simulator_steering_angle_angle_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool simulator_steering_angle_angle_is_in_range(uint32_t value);


void simulator_control_state_raw_to_conversion(
    simulator_control_state_converted_t *conversion,
    float map_pw,
    float map_sc,
    float map_tv
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void simulator_control_state_conversion_to_raw(
    simulator_control_state_t *raw,
    float map_pw,
    float map_sc,
    float map_tv
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void simulator_control_state_raw_to_conversion_struct(
    simulator_control_state_converted_t *conversion, 
    const simulator_control_state_t *raw);


void simulator_control_state_conversion_to_raw_struct(
    simulator_control_state_t *raw,
    const simulator_control_state_converted_t *conversion);


int simulator_control_state_converted_to_string(simulator_control_state_converted_t *message, char *buffer);

int simulator_control_state_converted_to_string_file(simulator_control_state_converted_t *message, FILE *buffer);

int simulator_control_state_fields(char *buffer);

int simulator_control_state_fields_file(FILE *buffer);

/**
 * Pack message CONTROL_STATE.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int simulator_control_state_pack(
    uint8_t *dst_p,
    const simulator_control_state_t *src_p,
    size_t byte_size);

/**
 * Unpack message CONTROL_STATE.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int simulator_control_state_unpack(
    simulator_control_state_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t simulator_control_state_map_pw_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float simulator_control_state_map_pw_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool simulator_control_state_map_pw_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t simulator_control_state_map_sc_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float simulator_control_state_map_sc_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool simulator_control_state_map_sc_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t simulator_control_state_map_tv_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float simulator_control_state_map_tv_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool simulator_control_state_map_tv_is_in_range(uint8_t value);


void simulator_control_output_raw_to_conversion(
    simulator_control_output_converted_t *conversion,
    float estimated_velocity,
    float tmax_r,
    float tmax_l,
    float torque_l,
    float torque_r
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void simulator_control_output_conversion_to_raw(
    simulator_control_output_t *raw,
    float estimated_velocity,
    float tmax_r,
    float tmax_l,
    float torque_l,
    float torque_r
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void simulator_control_output_raw_to_conversion_struct(
    simulator_control_output_converted_t *conversion, 
    const simulator_control_output_t *raw);


void simulator_control_output_conversion_to_raw_struct(
    simulator_control_output_t *raw,
    const simulator_control_output_converted_t *conversion);


int simulator_control_output_converted_to_string(simulator_control_output_converted_t *message, char *buffer);

int simulator_control_output_converted_to_string_file(simulator_control_output_converted_t *message, FILE *buffer);

int simulator_control_output_fields(char *buffer);

int simulator_control_output_fields_file(FILE *buffer);

/**
 * Pack message CONTROL_OUTPUT.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int simulator_control_output_pack(
    uint8_t *dst_p,
    const simulator_control_output_t *src_p,
    size_t byte_size);

/**
 * Unpack message CONTROL_OUTPUT.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int simulator_control_output_unpack(
    simulator_control_output_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t simulator_control_output_estimated_velocity_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float simulator_control_output_estimated_velocity_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool simulator_control_output_estimated_velocity_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t simulator_control_output_tmax_r_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float simulator_control_output_tmax_r_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool simulator_control_output_tmax_r_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t simulator_control_output_tmax_l_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float simulator_control_output_tmax_l_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool simulator_control_output_tmax_l_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t simulator_control_output_torque_l_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float simulator_control_output_torque_l_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool simulator_control_output_torque_l_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t simulator_control_output_torque_r_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float simulator_control_output_torque_r_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool simulator_control_output_torque_r_is_in_range(uint16_t value);


void simulator_speed_raw_to_conversion(
    simulator_speed_converted_t *conversion,
    float fl,
    float fr,
    float rl,
    float rr
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void simulator_speed_conversion_to_raw(
    simulator_speed_t *raw,
    float fl,
    float fr,
    float rl,
    float rr
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void simulator_speed_raw_to_conversion_struct(
    simulator_speed_converted_t *conversion, 
    const simulator_speed_t *raw);


void simulator_speed_conversion_to_raw_struct(
    simulator_speed_t *raw,
    const simulator_speed_converted_t *conversion);


int simulator_speed_converted_to_string(simulator_speed_converted_t *message, char *buffer);

int simulator_speed_converted_to_string_file(simulator_speed_converted_t *message, FILE *buffer);

int simulator_speed_fields(char *buffer);

int simulator_speed_fields_file(FILE *buffer);

/**
 * Pack message SPEED.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int simulator_speed_pack(
    uint8_t *dst_p,
    const simulator_speed_t *src_p,
    size_t byte_size);

/**
 * Unpack message SPEED.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int simulator_speed_unpack(
    simulator_speed_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t simulator_speed_fl_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float simulator_speed_fl_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool simulator_speed_fl_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t simulator_speed_fr_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float simulator_speed_fr_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool simulator_speed_fr_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t simulator_speed_rl_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float simulator_speed_rl_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool simulator_speed_rl_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t simulator_speed_rr_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float simulator_speed_rr_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool simulator_speed_rr_is_in_range(uint16_t value);

bool simulator_id_is_message(uint16_t id);

int simulator_to_string_from_id(uint16_t message_id, void* message, char* buffer);
int simulator_fields_from_id(uint16_t message_id, char* buffer);
int simulator_to_string_file_from_id(uint16_t message_id, void* message, FILE* buffer);
int simulator_fields_file_from_id(uint16_t message_id, FILE* buffer);


typedef union CANLIB_PARKING {
    simulator_angular_rate_t _angular_rate;
    simulator_acceleration_t _acceleration;
    simulator_pedals_t _pedals;
    simulator_steering_angle_t _steering_angle;
    simulator_control_state_t _control_state;
    simulator_control_output_t _control_output;
    simulator_speed_t _speed;

} _simulator_all_struct_raw;

typedef union CANLIB_PARKING {
    simulator_angular_rate_converted_t _angular_rate;
    simulator_acceleration_converted_t _acceleration;
    simulator_pedals_converted_t _pedals;
    simulator_steering_angle_converted_t _steering_angle;
    simulator_control_state_converted_t _control_state;
    simulator_control_output_converted_t _control_output;
    simulator_speed_converted_t _speed;

} _simulator_all_struct_converted;



#define simulator_MAX_STRUCT_SIZE_RAW sizeof(_simulator_all_struct_raw)
#define simulator_MAX_STRUCT_SIZE_CONVERSION sizeof(_simulator_all_struct_converted)

#ifdef __cplusplus
}
#endif

#endif
