/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2018-2019 Erik Moqvist
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/**
 * This file was generated by cantools version 38.0.2 Sun Jun  4 13:30:46 2023.
 */

#ifndef SECONDARY_H
#define SECONDARY_H

#include <stdio.h>
#include <stdlib.h>
#include <inttypes.h>

#ifdef __cplusplus
extern "C" {
#endif

#include <stdint.h>
#include <stdbool.h>
#include <stddef.h>

#ifndef CANLIB_BUILD
#define CANLIB_BUILD
#define CANLIB_BUILD_TIME 1685885446
#endif // CANLIB_BUILD

#ifndef CANLIB_PARKING
/* We know it's PACKING but PARKING sounds a bit better ;) */
#if defined(__MINGW32__)
#define CANLIB_PARKING                                                           __attribute__((__gcc_struct__, __packed__)) // , __aligned__(1)))
#else
#define CANLIB_PARKING __attribute__((__packed__)) // , __aligned__(1)))
#endif                                             // defined(__MINGW32__)
#endif                                             // CANLIB_PARKING

#ifndef EINVAL
#    define EINVAL 22
#endif

/* Frame ids. */
#define SECONDARY_IMU_ANGULAR_RATE_FRAME_ID (0x4ecu)
#define SECONDARY_IMU_ACCELERATION_FRAME_ID (0x4edu)
#define SECONDARY_IRTS_FL_0_FRAME_ID (0x5b4u)
#define SECONDARY_IRTS_FL_1_FRAME_ID (0x5b5u)
#define SECONDARY_IRTS_FL_2_FRAME_ID (0x5b6u)
#define SECONDARY_IRTS_FL_3_FRAME_ID (0x5b7u)
#define SECONDARY_IRTS_FR_0_FRAME_ID (0x5b8u)
#define SECONDARY_IRTS_FR_1_FRAME_ID (0x5b9u)
#define SECONDARY_IRTS_FR_2_FRAME_ID (0x5bau)
#define SECONDARY_IRTS_FR_3_FRAME_ID (0x5bbu)
#define SECONDARY_IRTS_RL_0_FRAME_ID (0x5bcu)
#define SECONDARY_IRTS_RL_1_FRAME_ID (0x5bdu)
#define SECONDARY_IRTS_RL_2_FRAME_ID (0x5beu)
#define SECONDARY_IRTS_RL_3_FRAME_ID (0x5bfu)
#define SECONDARY_IRTS_RR_0_FRAME_ID (0x5c0u)
#define SECONDARY_IRTS_RR_1_FRAME_ID (0x5c1u)
#define SECONDARY_IRTS_RR_2_FRAME_ID (0x5c2u)
#define SECONDARY_IRTS_RR_3_FRAME_ID (0x5c3u)
#define SECONDARY_GPS_COORDS_FRAME_ID (0x401u)
#define SECONDARY_GPS_SPEED_FRAME_ID (0x421u)
#define SECONDARY_LAP_COUNT_FRAME_ID (0x441u)
#define SECONDARY_PEDALS_OUTPUT_FRAME_ID (0x301u)
#define SECONDARY_STEERING_ANGLE_FRAME_ID (0x102u)
#define SECONDARY_CONTROL_STATE_FRAME_ID (0x503u)
#define SECONDARY_TPMS_FRAME_ID (0x201u)
#define SECONDARY_LC_STATUS_FRAME_ID (0x300u)

/* Frame lengths in bytes. */
#define SECONDARY_IMU_ANGULAR_RATE_LENGTH (24u)
#define SECONDARY_IMU_ACCELERATION_LENGTH (40u)
#define SECONDARY_IRTS_FL_0_LENGTH (32u)
#define SECONDARY_IRTS_FL_1_LENGTH (32u)
#define SECONDARY_IRTS_FL_2_LENGTH (32u)
#define SECONDARY_IRTS_FL_3_LENGTH (32u)
#define SECONDARY_IRTS_FR_0_LENGTH (32u)
#define SECONDARY_IRTS_FR_1_LENGTH (32u)
#define SECONDARY_IRTS_FR_2_LENGTH (32u)
#define SECONDARY_IRTS_FR_3_LENGTH (32u)
#define SECONDARY_IRTS_RL_0_LENGTH (32u)
#define SECONDARY_IRTS_RL_1_LENGTH (32u)
#define SECONDARY_IRTS_RL_2_LENGTH (32u)
#define SECONDARY_IRTS_RL_3_LENGTH (32u)
#define SECONDARY_IRTS_RR_0_LENGTH (32u)
#define SECONDARY_IRTS_RR_1_LENGTH (32u)
#define SECONDARY_IRTS_RR_2_LENGTH (32u)
#define SECONDARY_IRTS_RR_3_LENGTH (32u)
#define SECONDARY_GPS_COORDS_LENGTH (64u)
#define SECONDARY_GPS_SPEED_LENGTH (16u)
#define SECONDARY_LAP_COUNT_LENGTH (40u)
#define SECONDARY_PEDALS_OUTPUT_LENGTH (72u)
#define SECONDARY_STEERING_ANGLE_LENGTH (32u)
#define SECONDARY_CONTROL_STATE_LENGTH (24u)
#define SECONDARY_TPMS_LENGTH (64u)
#define SECONDARY_LC_STATUS_LENGTH (48u)

/* Extended or standard frame types. */
#define SECONDARY_IMU_ANGULAR_RATE_IS_EXTENDED (0)
#define SECONDARY_IMU_ACCELERATION_IS_EXTENDED (0)
#define SECONDARY_IRTS_FL_0_IS_EXTENDED (0)
#define SECONDARY_IRTS_FL_1_IS_EXTENDED (0)
#define SECONDARY_IRTS_FL_2_IS_EXTENDED (0)
#define SECONDARY_IRTS_FL_3_IS_EXTENDED (0)
#define SECONDARY_IRTS_FR_0_IS_EXTENDED (0)
#define SECONDARY_IRTS_FR_1_IS_EXTENDED (0)
#define SECONDARY_IRTS_FR_2_IS_EXTENDED (0)
#define SECONDARY_IRTS_FR_3_IS_EXTENDED (0)
#define SECONDARY_IRTS_RL_0_IS_EXTENDED (0)
#define SECONDARY_IRTS_RL_1_IS_EXTENDED (0)
#define SECONDARY_IRTS_RL_2_IS_EXTENDED (0)
#define SECONDARY_IRTS_RL_3_IS_EXTENDED (0)
#define SECONDARY_IRTS_RR_0_IS_EXTENDED (0)
#define SECONDARY_IRTS_RR_1_IS_EXTENDED (0)
#define SECONDARY_IRTS_RR_2_IS_EXTENDED (0)
#define SECONDARY_IRTS_RR_3_IS_EXTENDED (0)
#define SECONDARY_GPS_COORDS_IS_EXTENDED (0)
#define SECONDARY_GPS_SPEED_IS_EXTENDED (0)
#define SECONDARY_LAP_COUNT_IS_EXTENDED (0)
#define SECONDARY_PEDALS_OUTPUT_IS_EXTENDED (0)
#define SECONDARY_STEERING_ANGLE_IS_EXTENDED (0)
#define SECONDARY_CONTROL_STATE_IS_EXTENDED (0)
#define SECONDARY_TPMS_IS_EXTENDED (0)
#define SECONDARY_LC_STATUS_IS_EXTENDED (0)

/* Frame cycle times in milliseconds. */
#define SECONDARY_PEDALS_OUTPUT_CYCLE_TIME_MS (10u)
#define SECONDARY_STEERING_ANGLE_CYCLE_TIME_MS (10u)
#define SECONDARY_CONTROL_STATE_CYCLE_TIME_MS (100u)

/* Signal choices. */


/* Indexes */
#define secondary_imu_angular_rate_INDEX 0
#define secondary_imu_acceleration_INDEX 1
#define secondary_irts_fl_0_INDEX 2
#define secondary_irts_fl_1_INDEX 3
#define secondary_irts_fl_2_INDEX 4
#define secondary_irts_fl_3_INDEX 5
#define secondary_irts_fr_0_INDEX 6
#define secondary_irts_fr_1_INDEX 7
#define secondary_irts_fr_2_INDEX 8
#define secondary_irts_fr_3_INDEX 9
#define secondary_irts_rl_0_INDEX 10
#define secondary_irts_rl_1_INDEX 11
#define secondary_irts_rl_2_INDEX 12
#define secondary_irts_rl_3_INDEX 13
#define secondary_irts_rr_0_INDEX 14
#define secondary_irts_rr_1_INDEX 15
#define secondary_irts_rr_2_INDEX 16
#define secondary_irts_rr_3_INDEX 17
#define secondary_gps_coords_INDEX 18
#define secondary_gps_speed_INDEX 19
#define secondary_lap_count_INDEX 20
#define secondary_pedals_output_INDEX 21
#define secondary_steering_angle_INDEX 22
#define secondary_control_state_INDEX 23
#define secondary_tpms_INDEX 24
#define secondary_lc_status_INDEX 25


#define secondary_MESSAGE_COUNT 26

#ifndef CANLIB_DEVICES_STRUCT
#define CANLIB_DEVICES_STRUCT
typedef struct {
    uint16_t id;
    void* message_raw;
    void* message_conversion;
} devices_t;
#endif // CANLIB_DEVICES_STRUCT

typedef devices_t secondary_devices[secondary_MESSAGE_COUNT];


secondary_devices* secondary_devices_new();
void secondary_devices_free(secondary_devices* devices);
void secondary_devices_deserialize_from_id(
    secondary_devices* devices,
    uint16_t message_id,
    uint8_t* data
#ifdef CANLIB_TIMESTAMP
    , uint64_t timestamp
#endif // CANLIB_TIMESTAMP
);

int secondary_message_name_from_id(uint16_t id, char* buffer);
int secondary_index_from_id(uint16_t id);
int secondary_id_from_index(int index);

/**
 * Signals in message IMU_ANGULAR_RATE.
 *
 * Inertial Measurement Unit [x,y,z]-axis angular rate value. 0.01dps per bit, Big-Endian, 16bit Total, signed
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..3 (0..245 -)
     * Scale: 81.66666666666667
     * Offset: 0
     */
    uint8_t ang_rate_x;

    /**
     * Range: 0..3 (0..245 -)
     * Scale: 81.66666666666667
     * Offset: 0
     */
    uint8_t ang_rate_y;

    /**
     * Range: 0..3 (0..245 -)
     * Scale: 81.66666666666667
     * Offset: 0
     */
    uint8_t ang_rate_z;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_imu_angular_rate_t;

/**
 * Signals in message IMU_ANGULAR_RATE.
 *
 * Inertial Measurement Unit [x,y,z]-axis angular rate value. 0.01dps per bit, Big-Endian, 16bit Total, signed
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..3 (0..245 -)
     * Scale: 81.66666666666667
     * Offset: 0
     */
    float ang_rate_x;

    /**
     * Range: 0..3 (0..245 -)
     * Scale: 81.66666666666667
     * Offset: 0
     */
    float ang_rate_y;

    /**
     * Range: 0..3 (0..245 -)
     * Scale: 81.66666666666667
     * Offset: 0
     */
    float ang_rate_z;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_imu_angular_rate_converted_t;

/**
 * Signals in message IMU_ACCELERATION.
 *
 * Inertial Measurement Unit [x,y,z]-axis acceleration value. 0.01g per bit, Big-Endian, 16bit Total, signed
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..3 (0..8 -)
     * Scale: 2.6666666666666665
     * Offset: 0
     */
    uint8_t accel_x;

    /**
     * Range: 0..3 (0..8 -)
     * Scale: 2.6666666666666665
     * Offset: 0
     */
    uint8_t accel_y;

    /**
     * Range: 0..3 (0..8 -)
     * Scale: 2.6666666666666665
     * Offset: 0
     */
    uint8_t accel_z;

    /**
     * Range: 0..65535 (-32768..32767 -)
     * Scale: 1
     * Offset: -32768
     */
    int16_t temperature;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_imu_acceleration_t;

/**
 * Signals in message IMU_ACCELERATION.
 *
 * Inertial Measurement Unit [x,y,z]-axis acceleration value. 0.01g per bit, Big-Endian, 16bit Total, signed
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..3 (0..8 -)
     * Scale: 2.6666666666666665
     * Offset: 0
     */
    float accel_x;

    /**
     * Range: 0..3 (0..8 -)
     * Scale: 2.6666666666666665
     * Offset: 0
     */
    float accel_y;

    /**
     * Range: 0..3 (0..8 -)
     * Scale: 2.6666666666666665
     * Offset: 0
     */
    float accel_z;

    /**
     * Range: 0..65535 (-32768..32767 -)
     * Scale: 1
     * Offset: -32768
     */
    int16_t temperature;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_imu_acceleration_converted_t;

/**
 * Signals in message IRTS_FL_0.
 *
 * Front Left wheel InfraRed Temperature Sensor data, channels 1 through 4. 0.1˚C per bit, -100˚C offset, Big-Endian, 16bit Total, unsigned.
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..3 (-100..0 -)
     * Scale: 33.333333333333336
     * Offset: -100
     */
    uint8_t channel1;

    /**
     * Range: 0..3 (-100..0 -)
     * Scale: 33.333333333333336
     * Offset: -100
     */
    uint8_t channel2;

    /**
     * Range: 0..3 (-100..0 -)
     * Scale: 33.333333333333336
     * Offset: -100
     */
    uint8_t channel3;

    /**
     * Range: 0..3 (-100..0 -)
     * Scale: 33.333333333333336
     * Offset: -100
     */
    uint8_t channel4;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_irts_fl_0_t;

/**
 * Signals in message IRTS_FL_0.
 *
 * Front Left wheel InfraRed Temperature Sensor data, channels 1 through 4. 0.1˚C per bit, -100˚C offset, Big-Endian, 16bit Total, unsigned.
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..3 (-100..0 -)
     * Scale: 33.333333333333336
     * Offset: -100
     */
    float channel1;

    /**
     * Range: 0..3 (-100..0 -)
     * Scale: 33.333333333333336
     * Offset: -100
     */
    float channel2;

    /**
     * Range: 0..3 (-100..0 -)
     * Scale: 33.333333333333336
     * Offset: -100
     */
    float channel3;

    /**
     * Range: 0..3 (-100..0 -)
     * Scale: 33.333333333333336
     * Offset: -100
     */
    float channel4;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_irts_fl_0_converted_t;

/**
 * Signals in message IRTS_FL_1.
 *
 * Front Left wheel InfraRed Temperature Sensor data, channels 5 through 8. 0.1˚C per bit, -100˚C offset, Big-Endian, 16bit Total, unsigned.
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..3 (-100..0 -)
     * Scale: 33.333333333333336
     * Offset: -100
     */
    uint8_t channel5;

    /**
     * Range: 0..3 (-100..0 -)
     * Scale: 33.333333333333336
     * Offset: -100
     */
    uint8_t channel6;

    /**
     * Range: 0..3 (-100..0 -)
     * Scale: 33.333333333333336
     * Offset: -100
     */
    uint8_t channel7;

    /**
     * Range: 0..3 (-100..0 -)
     * Scale: 33.333333333333336
     * Offset: -100
     */
    uint8_t channel8;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_irts_fl_1_t;

/**
 * Signals in message IRTS_FL_1.
 *
 * Front Left wheel InfraRed Temperature Sensor data, channels 5 through 8. 0.1˚C per bit, -100˚C offset, Big-Endian, 16bit Total, unsigned.
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..3 (-100..0 -)
     * Scale: 33.333333333333336
     * Offset: -100
     */
    float channel5;

    /**
     * Range: 0..3 (-100..0 -)
     * Scale: 33.333333333333336
     * Offset: -100
     */
    float channel6;

    /**
     * Range: 0..3 (-100..0 -)
     * Scale: 33.333333333333336
     * Offset: -100
     */
    float channel7;

    /**
     * Range: 0..3 (-100..0 -)
     * Scale: 33.333333333333336
     * Offset: -100
     */
    float channel8;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_irts_fl_1_converted_t;

/**
 * Signals in message IRTS_FL_2.
 *
 * Front Left wheel InfraRed Temperature Sensor data, channels 9 through 12. 0.1˚C per bit, -100˚C offset, Big-Endian, 16bit Total, unsigned.
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..3 (-100..0 -)
     * Scale: 33.333333333333336
     * Offset: -100
     */
    uint8_t channel9;

    /**
     * Range: 0..3 (-100..0 -)
     * Scale: 33.333333333333336
     * Offset: -100
     */
    uint8_t channel10;

    /**
     * Range: 0..3 (-100..0 -)
     * Scale: 33.333333333333336
     * Offset: -100
     */
    uint8_t channel11;

    /**
     * Range: 0..3 (-100..0 -)
     * Scale: 33.333333333333336
     * Offset: -100
     */
    uint8_t channel12;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_irts_fl_2_t;

/**
 * Signals in message IRTS_FL_2.
 *
 * Front Left wheel InfraRed Temperature Sensor data, channels 9 through 12. 0.1˚C per bit, -100˚C offset, Big-Endian, 16bit Total, unsigned.
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..3 (-100..0 -)
     * Scale: 33.333333333333336
     * Offset: -100
     */
    float channel9;

    /**
     * Range: 0..3 (-100..0 -)
     * Scale: 33.333333333333336
     * Offset: -100
     */
    float channel10;

    /**
     * Range: 0..3 (-100..0 -)
     * Scale: 33.333333333333336
     * Offset: -100
     */
    float channel11;

    /**
     * Range: 0..3 (-100..0 -)
     * Scale: 33.333333333333336
     * Offset: -100
     */
    float channel12;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_irts_fl_2_converted_t;

/**
 * Signals in message IRTS_FL_3.
 *
 * Front Left wheel InfraRed Temperature Sensor data, channels 13 through 16. 0.1˚C per bit, -100˚C offset, Big-Endian, 16bit Total, unsigned.
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..3 (-100..0 -)
     * Scale: 33.333333333333336
     * Offset: -100
     */
    uint8_t channel13;

    /**
     * Range: 0..3 (-100..0 -)
     * Scale: 33.333333333333336
     * Offset: -100
     */
    uint8_t channel14;

    /**
     * Range: 0..3 (-100..0 -)
     * Scale: 33.333333333333336
     * Offset: -100
     */
    uint8_t channel15;

    /**
     * Range: 0..3 (-100..0 -)
     * Scale: 33.333333333333336
     * Offset: -100
     */
    uint8_t channel16;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_irts_fl_3_t;

/**
 * Signals in message IRTS_FL_3.
 *
 * Front Left wheel InfraRed Temperature Sensor data, channels 13 through 16. 0.1˚C per bit, -100˚C offset, Big-Endian, 16bit Total, unsigned.
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..3 (-100..0 -)
     * Scale: 33.333333333333336
     * Offset: -100
     */
    float channel13;

    /**
     * Range: 0..3 (-100..0 -)
     * Scale: 33.333333333333336
     * Offset: -100
     */
    float channel14;

    /**
     * Range: 0..3 (-100..0 -)
     * Scale: 33.333333333333336
     * Offset: -100
     */
    float channel15;

    /**
     * Range: 0..3 (-100..0 -)
     * Scale: 33.333333333333336
     * Offset: -100
     */
    float channel16;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_irts_fl_3_converted_t;

/**
 * Signals in message IRTS_FR_0.
 *
 * Front Right wheel InfraRed Temperature Sensor data, channels 1 through 4. 0.1˚C per bit, -100˚C offset, Big-Endian, 16bit Total, unsigned.
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..3 (-100..0 -)
     * Scale: 33.333333333333336
     * Offset: -100
     */
    uint8_t channel1;

    /**
     * Range: 0..3 (-100..0 -)
     * Scale: 33.333333333333336
     * Offset: -100
     */
    uint8_t channel2;

    /**
     * Range: 0..3 (-100..0 -)
     * Scale: 33.333333333333336
     * Offset: -100
     */
    uint8_t channel3;

    /**
     * Range: 0..3 (-100..0 -)
     * Scale: 33.333333333333336
     * Offset: -100
     */
    uint8_t channel4;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_irts_fr_0_t;

/**
 * Signals in message IRTS_FR_0.
 *
 * Front Right wheel InfraRed Temperature Sensor data, channels 1 through 4. 0.1˚C per bit, -100˚C offset, Big-Endian, 16bit Total, unsigned.
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..3 (-100..0 -)
     * Scale: 33.333333333333336
     * Offset: -100
     */
    float channel1;

    /**
     * Range: 0..3 (-100..0 -)
     * Scale: 33.333333333333336
     * Offset: -100
     */
    float channel2;

    /**
     * Range: 0..3 (-100..0 -)
     * Scale: 33.333333333333336
     * Offset: -100
     */
    float channel3;

    /**
     * Range: 0..3 (-100..0 -)
     * Scale: 33.333333333333336
     * Offset: -100
     */
    float channel4;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_irts_fr_0_converted_t;

/**
 * Signals in message IRTS_FR_1.
 *
 * Front Right wheel InfraRed Temperature Sensor data, channels 5 through 8. 0.1˚C per bit, -100˚C offset, Big-Endian, 16bit Total, unsigned.
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..3 (-100..0 -)
     * Scale: 33.333333333333336
     * Offset: -100
     */
    uint8_t channel5;

    /**
     * Range: 0..3 (-100..0 -)
     * Scale: 33.333333333333336
     * Offset: -100
     */
    uint8_t channel6;

    /**
     * Range: 0..3 (-100..0 -)
     * Scale: 33.333333333333336
     * Offset: -100
     */
    uint8_t channel7;

    /**
     * Range: 0..3 (-100..0 -)
     * Scale: 33.333333333333336
     * Offset: -100
     */
    uint8_t channel8;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_irts_fr_1_t;

/**
 * Signals in message IRTS_FR_1.
 *
 * Front Right wheel InfraRed Temperature Sensor data, channels 5 through 8. 0.1˚C per bit, -100˚C offset, Big-Endian, 16bit Total, unsigned.
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..3 (-100..0 -)
     * Scale: 33.333333333333336
     * Offset: -100
     */
    float channel5;

    /**
     * Range: 0..3 (-100..0 -)
     * Scale: 33.333333333333336
     * Offset: -100
     */
    float channel6;

    /**
     * Range: 0..3 (-100..0 -)
     * Scale: 33.333333333333336
     * Offset: -100
     */
    float channel7;

    /**
     * Range: 0..3 (-100..0 -)
     * Scale: 33.333333333333336
     * Offset: -100
     */
    float channel8;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_irts_fr_1_converted_t;

/**
 * Signals in message IRTS_FR_2.
 *
 * Front Right wheel InfraRed Temperature Sensor data, channels 9 through 12. 0.1˚C per bit, -100˚C offset, Big-Endian, 16bit Total, unsigned.
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..3 (-100..0 -)
     * Scale: 33.333333333333336
     * Offset: -100
     */
    uint8_t channel9;

    /**
     * Range: 0..3 (-100..0 -)
     * Scale: 33.333333333333336
     * Offset: -100
     */
    uint8_t channel10;

    /**
     * Range: 0..3 (-100..0 -)
     * Scale: 33.333333333333336
     * Offset: -100
     */
    uint8_t channel11;

    /**
     * Range: 0..3 (-100..0 -)
     * Scale: 33.333333333333336
     * Offset: -100
     */
    uint8_t channel12;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_irts_fr_2_t;

/**
 * Signals in message IRTS_FR_2.
 *
 * Front Right wheel InfraRed Temperature Sensor data, channels 9 through 12. 0.1˚C per bit, -100˚C offset, Big-Endian, 16bit Total, unsigned.
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..3 (-100..0 -)
     * Scale: 33.333333333333336
     * Offset: -100
     */
    float channel9;

    /**
     * Range: 0..3 (-100..0 -)
     * Scale: 33.333333333333336
     * Offset: -100
     */
    float channel10;

    /**
     * Range: 0..3 (-100..0 -)
     * Scale: 33.333333333333336
     * Offset: -100
     */
    float channel11;

    /**
     * Range: 0..3 (-100..0 -)
     * Scale: 33.333333333333336
     * Offset: -100
     */
    float channel12;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_irts_fr_2_converted_t;

/**
 * Signals in message IRTS_FR_3.
 *
 * Front Right wheel InfraRed Temperature Sensor data, channels 13 through 16. 0.1˚C per bit, -100˚C offset, Big-Endian, 16bit Total, unsigned.
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..3 (-100..0 -)
     * Scale: 33.333333333333336
     * Offset: -100
     */
    uint8_t channel13;

    /**
     * Range: 0..3 (-100..0 -)
     * Scale: 33.333333333333336
     * Offset: -100
     */
    uint8_t channel14;

    /**
     * Range: 0..3 (-100..0 -)
     * Scale: 33.333333333333336
     * Offset: -100
     */
    uint8_t channel15;

    /**
     * Range: 0..3 (-100..0 -)
     * Scale: 33.333333333333336
     * Offset: -100
     */
    uint8_t channel16;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_irts_fr_3_t;

/**
 * Signals in message IRTS_FR_3.
 *
 * Front Right wheel InfraRed Temperature Sensor data, channels 13 through 16. 0.1˚C per bit, -100˚C offset, Big-Endian, 16bit Total, unsigned.
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..3 (-100..0 -)
     * Scale: 33.333333333333336
     * Offset: -100
     */
    float channel13;

    /**
     * Range: 0..3 (-100..0 -)
     * Scale: 33.333333333333336
     * Offset: -100
     */
    float channel14;

    /**
     * Range: 0..3 (-100..0 -)
     * Scale: 33.333333333333336
     * Offset: -100
     */
    float channel15;

    /**
     * Range: 0..3 (-100..0 -)
     * Scale: 33.333333333333336
     * Offset: -100
     */
    float channel16;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_irts_fr_3_converted_t;

/**
 * Signals in message IRTS_RL_0.
 *
 * Rear Left wheel InfraRed Temperature Sensor data, channels 1 through 4. 0.1˚C per bit, -100˚C offset, Big-Endian, 16bit Total, unsigned.
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..3 (-100..0 -)
     * Scale: 33.333333333333336
     * Offset: -100
     */
    uint8_t channel1;

    /**
     * Range: 0..3 (-100..0 -)
     * Scale: 33.333333333333336
     * Offset: -100
     */
    uint8_t channel2;

    /**
     * Range: 0..3 (-100..0 -)
     * Scale: 33.333333333333336
     * Offset: -100
     */
    uint8_t channel3;

    /**
     * Range: 0..3 (-100..0 -)
     * Scale: 33.333333333333336
     * Offset: -100
     */
    uint8_t channel4;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_irts_rl_0_t;

/**
 * Signals in message IRTS_RL_0.
 *
 * Rear Left wheel InfraRed Temperature Sensor data, channels 1 through 4. 0.1˚C per bit, -100˚C offset, Big-Endian, 16bit Total, unsigned.
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..3 (-100..0 -)
     * Scale: 33.333333333333336
     * Offset: -100
     */
    float channel1;

    /**
     * Range: 0..3 (-100..0 -)
     * Scale: 33.333333333333336
     * Offset: -100
     */
    float channel2;

    /**
     * Range: 0..3 (-100..0 -)
     * Scale: 33.333333333333336
     * Offset: -100
     */
    float channel3;

    /**
     * Range: 0..3 (-100..0 -)
     * Scale: 33.333333333333336
     * Offset: -100
     */
    float channel4;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_irts_rl_0_converted_t;

/**
 * Signals in message IRTS_RL_1.
 *
 * Rear Left wheel InfraRed Temperature Sensor data, channels 5 through 8. 0.1˚C per bit, -100˚C offset, Big-Endian, 16bit Total, unsigned.
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..3 (-100..0 -)
     * Scale: 33.333333333333336
     * Offset: -100
     */
    uint8_t channel5;

    /**
     * Range: 0..3 (-100..0 -)
     * Scale: 33.333333333333336
     * Offset: -100
     */
    uint8_t channel6;

    /**
     * Range: 0..3 (-100..0 -)
     * Scale: 33.333333333333336
     * Offset: -100
     */
    uint8_t channel7;

    /**
     * Range: 0..3 (-100..0 -)
     * Scale: 33.333333333333336
     * Offset: -100
     */
    uint8_t channel8;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_irts_rl_1_t;

/**
 * Signals in message IRTS_RL_1.
 *
 * Rear Left wheel InfraRed Temperature Sensor data, channels 5 through 8. 0.1˚C per bit, -100˚C offset, Big-Endian, 16bit Total, unsigned.
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..3 (-100..0 -)
     * Scale: 33.333333333333336
     * Offset: -100
     */
    float channel5;

    /**
     * Range: 0..3 (-100..0 -)
     * Scale: 33.333333333333336
     * Offset: -100
     */
    float channel6;

    /**
     * Range: 0..3 (-100..0 -)
     * Scale: 33.333333333333336
     * Offset: -100
     */
    float channel7;

    /**
     * Range: 0..3 (-100..0 -)
     * Scale: 33.333333333333336
     * Offset: -100
     */
    float channel8;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_irts_rl_1_converted_t;

/**
 * Signals in message IRTS_RL_2.
 *
 * Rear Left wheel InfraRed Temperature Sensor data, channels 9 through 12. 0.1˚C per bit, -100˚C offset, Big-Endian, 16bit Total, unsigned.
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..3 (-100..0 -)
     * Scale: 33.333333333333336
     * Offset: -100
     */
    uint8_t channel9;

    /**
     * Range: 0..3 (-100..0 -)
     * Scale: 33.333333333333336
     * Offset: -100
     */
    uint8_t channel10;

    /**
     * Range: 0..3 (-100..0 -)
     * Scale: 33.333333333333336
     * Offset: -100
     */
    uint8_t channel11;

    /**
     * Range: 0..3 (-100..0 -)
     * Scale: 33.333333333333336
     * Offset: -100
     */
    uint8_t channel12;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_irts_rl_2_t;

/**
 * Signals in message IRTS_RL_2.
 *
 * Rear Left wheel InfraRed Temperature Sensor data, channels 9 through 12. 0.1˚C per bit, -100˚C offset, Big-Endian, 16bit Total, unsigned.
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..3 (-100..0 -)
     * Scale: 33.333333333333336
     * Offset: -100
     */
    float channel9;

    /**
     * Range: 0..3 (-100..0 -)
     * Scale: 33.333333333333336
     * Offset: -100
     */
    float channel10;

    /**
     * Range: 0..3 (-100..0 -)
     * Scale: 33.333333333333336
     * Offset: -100
     */
    float channel11;

    /**
     * Range: 0..3 (-100..0 -)
     * Scale: 33.333333333333336
     * Offset: -100
     */
    float channel12;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_irts_rl_2_converted_t;

/**
 * Signals in message IRTS_RL_3.
 *
 * Rear Left wheel InfraRed Temperature Sensor data, channels 13 through 16. 0.1˚C per bit, -100˚C offset, Big-Endian, 16bit Total, unsigned.
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..3 (-100..0 -)
     * Scale: 33.333333333333336
     * Offset: -100
     */
    uint8_t channel13;

    /**
     * Range: 0..3 (-100..0 -)
     * Scale: 33.333333333333336
     * Offset: -100
     */
    uint8_t channel14;

    /**
     * Range: 0..3 (-100..0 -)
     * Scale: 33.333333333333336
     * Offset: -100
     */
    uint8_t channel15;

    /**
     * Range: 0..3 (-100..0 -)
     * Scale: 33.333333333333336
     * Offset: -100
     */
    uint8_t channel16;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_irts_rl_3_t;

/**
 * Signals in message IRTS_RL_3.
 *
 * Rear Left wheel InfraRed Temperature Sensor data, channels 13 through 16. 0.1˚C per bit, -100˚C offset, Big-Endian, 16bit Total, unsigned.
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..3 (-100..0 -)
     * Scale: 33.333333333333336
     * Offset: -100
     */
    float channel13;

    /**
     * Range: 0..3 (-100..0 -)
     * Scale: 33.333333333333336
     * Offset: -100
     */
    float channel14;

    /**
     * Range: 0..3 (-100..0 -)
     * Scale: 33.333333333333336
     * Offset: -100
     */
    float channel15;

    /**
     * Range: 0..3 (-100..0 -)
     * Scale: 33.333333333333336
     * Offset: -100
     */
    float channel16;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_irts_rl_3_converted_t;

/**
 * Signals in message IRTS_RR_0.
 *
 * Rear Right wheel InfraRed Temperature Sensor data, channels 1 through 4. 0.1˚C per bit, -100˚C offset, Big-Endian, 16bit Total, unsigned.
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..3 (-100..0 -)
     * Scale: 33.333333333333336
     * Offset: -100
     */
    uint8_t channel1;

    /**
     * Range: 0..3 (-100..0 -)
     * Scale: 33.333333333333336
     * Offset: -100
     */
    uint8_t channel2;

    /**
     * Range: 0..3 (-100..0 -)
     * Scale: 33.333333333333336
     * Offset: -100
     */
    uint8_t channel3;

    /**
     * Range: 0..3 (-100..0 -)
     * Scale: 33.333333333333336
     * Offset: -100
     */
    uint8_t channel4;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_irts_rr_0_t;

/**
 * Signals in message IRTS_RR_0.
 *
 * Rear Right wheel InfraRed Temperature Sensor data, channels 1 through 4. 0.1˚C per bit, -100˚C offset, Big-Endian, 16bit Total, unsigned.
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..3 (-100..0 -)
     * Scale: 33.333333333333336
     * Offset: -100
     */
    float channel1;

    /**
     * Range: 0..3 (-100..0 -)
     * Scale: 33.333333333333336
     * Offset: -100
     */
    float channel2;

    /**
     * Range: 0..3 (-100..0 -)
     * Scale: 33.333333333333336
     * Offset: -100
     */
    float channel3;

    /**
     * Range: 0..3 (-100..0 -)
     * Scale: 33.333333333333336
     * Offset: -100
     */
    float channel4;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_irts_rr_0_converted_t;

/**
 * Signals in message IRTS_RR_1.
 *
 * Rear Right wheel InfraRed Temperature Sensor data, channels 5 through 8. 0.1˚C per bit, -100˚C offset, Big-Endian, 16bit Total, unsigned.
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..3 (-100..0 -)
     * Scale: 33.333333333333336
     * Offset: -100
     */
    uint8_t channel5;

    /**
     * Range: 0..3 (-100..0 -)
     * Scale: 33.333333333333336
     * Offset: -100
     */
    uint8_t channel6;

    /**
     * Range: 0..3 (-100..0 -)
     * Scale: 33.333333333333336
     * Offset: -100
     */
    uint8_t channel7;

    /**
     * Range: 0..3 (-100..0 -)
     * Scale: 33.333333333333336
     * Offset: -100
     */
    uint8_t channel8;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_irts_rr_1_t;

/**
 * Signals in message IRTS_RR_1.
 *
 * Rear Right wheel InfraRed Temperature Sensor data, channels 5 through 8. 0.1˚C per bit, -100˚C offset, Big-Endian, 16bit Total, unsigned.
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..3 (-100..0 -)
     * Scale: 33.333333333333336
     * Offset: -100
     */
    float channel5;

    /**
     * Range: 0..3 (-100..0 -)
     * Scale: 33.333333333333336
     * Offset: -100
     */
    float channel6;

    /**
     * Range: 0..3 (-100..0 -)
     * Scale: 33.333333333333336
     * Offset: -100
     */
    float channel7;

    /**
     * Range: 0..3 (-100..0 -)
     * Scale: 33.333333333333336
     * Offset: -100
     */
    float channel8;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_irts_rr_1_converted_t;

/**
 * Signals in message IRTS_RR_2.
 *
 * Rear Right wheel InfraRed Temperature Sensor data, channels 9 through 12. 0.1˚C per bit, -100˚C offset, Big-Endian, 16bit Total, unsigned.
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..3 (-100..0 -)
     * Scale: 33.333333333333336
     * Offset: -100
     */
    uint8_t channel9;

    /**
     * Range: 0..3 (-100..0 -)
     * Scale: 33.333333333333336
     * Offset: -100
     */
    uint8_t channel10;

    /**
     * Range: 0..3 (-100..0 -)
     * Scale: 33.333333333333336
     * Offset: -100
     */
    uint8_t channel11;

    /**
     * Range: 0..3 (-100..0 -)
     * Scale: 33.333333333333336
     * Offset: -100
     */
    uint8_t channel12;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_irts_rr_2_t;

/**
 * Signals in message IRTS_RR_2.
 *
 * Rear Right wheel InfraRed Temperature Sensor data, channels 9 through 12. 0.1˚C per bit, -100˚C offset, Big-Endian, 16bit Total, unsigned.
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..3 (-100..0 -)
     * Scale: 33.333333333333336
     * Offset: -100
     */
    float channel9;

    /**
     * Range: 0..3 (-100..0 -)
     * Scale: 33.333333333333336
     * Offset: -100
     */
    float channel10;

    /**
     * Range: 0..3 (-100..0 -)
     * Scale: 33.333333333333336
     * Offset: -100
     */
    float channel11;

    /**
     * Range: 0..3 (-100..0 -)
     * Scale: 33.333333333333336
     * Offset: -100
     */
    float channel12;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_irts_rr_2_converted_t;

/**
 * Signals in message IRTS_RR_3.
 *
 * Rear Right wheel InfraRed Temperature Sensor data, channels 13 through 16. 0.1˚C per bit, -100˚C offset, Big-Endian, 16bit Total, unsigned.
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..3 (-100..0 -)
     * Scale: 33.333333333333336
     * Offset: -100
     */
    uint8_t channel13;

    /**
     * Range: 0..3 (-100..0 -)
     * Scale: 33.333333333333336
     * Offset: -100
     */
    uint8_t channel14;

    /**
     * Range: 0..3 (-100..0 -)
     * Scale: 33.333333333333336
     * Offset: -100
     */
    uint8_t channel15;

    /**
     * Range: 0..3 (-100..0 -)
     * Scale: 33.333333333333336
     * Offset: -100
     */
    uint8_t channel16;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_irts_rr_3_t;

/**
 * Signals in message IRTS_RR_3.
 *
 * Rear Right wheel InfraRed Temperature Sensor data, channels 13 through 16. 0.1˚C per bit, -100˚C offset, Big-Endian, 16bit Total, unsigned.
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..3 (-100..0 -)
     * Scale: 33.333333333333336
     * Offset: -100
     */
    float channel13;

    /**
     * Range: 0..3 (-100..0 -)
     * Scale: 33.333333333333336
     * Offset: -100
     */
    float channel14;

    /**
     * Range: 0..3 (-100..0 -)
     * Scale: 33.333333333333336
     * Offset: -100
     */
    float channel15;

    /**
     * Range: 0..3 (-100..0 -)
     * Scale: 33.333333333333336
     * Offset: -100
     */
    float channel16;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_irts_rr_3_converted_t;

/**
 * Signals in message GPS_COORDS.
 *
 * Coordinates received from GPS
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..4294967295 (0..4294967295 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t latitude;

    /**
     * Range: 0..4294967295 (0..4294967295 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t longitude;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_gps_coords_t;

/**
 * Signals in message GPS_COORDS.
 *
 * Coordinates received from GPS
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..4294967295 (0..4294967295 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t latitude;

    /**
     * Range: 0..4294967295 (0..4294967295 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t longitude;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_gps_coords_converted_t;

/**
 * Signals in message GPS_SPEED.
 *
 * Speed received from GPS
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t speed;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_gps_speed_t;

/**
 * Signals in message GPS_SPEED.
 *
 * Speed received from GPS
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t speed;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_gps_speed_converted_t;

/**
 * Signals in message LAP_COUNT.
 *
 * Lap counter and associated timestamp
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t lap_count;

    /**
     * Range: 0..4294967295 (0..4294967295 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t lap_time;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_lap_count_t;

/**
 * Signals in message LAP_COUNT.
 *
 * Lap counter and associated timestamp
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t lap_count;

    /**
     * Range: 0..4294967295 (0..4294967295 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t lap_time;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_lap_count_converted_t;

/**
 * Signals in message PEDALS_OUTPUT.
 *
 * Pedal output, already calibrated
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t apps;

    /**
     * Range: 0..65535 (0..100 -)
     * Scale: 0.0015259021896696422
     * Offset: 0
     */
    uint32_t bse_front;

    /**
     * Range: 0..65535 (0..100 -)
     * Scale: 0.0015259021896696422
     * Offset: 0
     */
    uint32_t bse_rear;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_pedals_output_t;

/**
 * Signals in message PEDALS_OUTPUT.
 *
 * Pedal output, already calibrated
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t apps;

    /**
     * Range: 0..65535 (0..100 -)
     * Scale: 0.0015259021896696422
     * Offset: 0
     */
    float bse_front;

    /**
     * Range: 0..65535 (0..100 -)
     * Scale: 0.0015259021896696422
     * Offset: 0
     */
    float bse_rear;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_pedals_output_converted_t;

/**
 * Signals in message STEERING_ANGLE.
 *
 * Steering angle in degrees
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..4294967295 (0..4294967295 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t angle;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_steering_angle_t;

/**
 * Signals in message STEERING_ANGLE.
 *
 * Steering angle in degrees
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..4294967295 (0..4294967295 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t angle;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_steering_angle_converted_t;

/**
 * Signals in message CONTROL_STATE.
 *
 * Send status of traction control
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (-0.5..1 -)
     * Scale: 1.5
     * Offset: -0.5
     */
    uint8_t map_pw;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1.0
     * Offset: 0
     */
    uint8_t map_sc;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1.0
     * Offset: 0
     */
    uint8_t map_tv;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_control_state_t;

/**
 * Signals in message CONTROL_STATE.
 *
 * Send status of traction control
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (-0.5..1 -)
     * Scale: 1.5
     * Offset: -0.5
     */
    float map_pw;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1.0
     * Offset: 0
     */
    uint8_t map_sc;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1.0
     * Offset: 0
     */
    uint8_t map_tv;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_control_state_converted_t;

/**
 * Signals in message TPMS.
 *
 * Tire Pressure Monitoring System, pressure and temperature of each tire
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..3 -)
     * Scale: 3.0
     * Offset: 0
     */
    uint8_t fl_pressure;

    /**
     * Range: 0..1 (0..3 -)
     * Scale: 3.0
     * Offset: 0
     */
    uint8_t fr_pressure;

    /**
     * Range: 0..1 (0..3 -)
     * Scale: 3.0
     * Offset: 0
     */
    uint8_t rl_pressure;

    /**
     * Range: 0..1 (0..3 -)
     * Scale: 3.0
     * Offset: 0
     */
    uint8_t rr_pressure;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t fl_temperature;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t fr_temperature;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t rl_temperature;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t rr_temperature;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_tpms_t;

/**
 * Signals in message TPMS.
 *
 * Tire Pressure Monitoring System, pressure and temperature of each tire
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..3 -)
     * Scale: 3.0
     * Offset: 0
     */
    uint8_t fl_pressure;

    /**
     * Range: 0..1 (0..3 -)
     * Scale: 3.0
     * Offset: 0
     */
    uint8_t fr_pressure;

    /**
     * Range: 0..1 (0..3 -)
     * Scale: 3.0
     * Offset: 0
     */
    uint8_t rl_pressure;

    /**
     * Range: 0..1 (0..3 -)
     * Scale: 3.0
     * Offset: 0
     */
    uint8_t rr_pressure;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t fl_temperature;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t fr_temperature;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t rl_temperature;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t rr_temperature;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_tpms_converted_t;

/**
 * Signals in message LC_STATUS.
 *
 * Session laps status, lap_number is -1 in case of OUT lap
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..4294967295 (0..4294967295 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t last_time;

    /**
     * Range: 0..65535 (-32768..32767 -)
     * Scale: 1
     * Offset: -32768
     */
    int16_t lap_number;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_lc_status_t;

/**
 * Signals in message LC_STATUS.
 *
 * Session laps status, lap_number is -1 in case of OUT lap
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..4294967295 (0..4294967295 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t last_time;

    /**
     * Range: 0..65535 (-32768..32767 -)
     * Scale: 1
     * Offset: -32768
     */
    int16_t lap_number;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_lc_status_converted_t;


void secondary_imu_angular_rate_raw_to_conversion(
    secondary_imu_angular_rate_converted_t *conversion,
    float ang_rate_x,
    float ang_rate_y,
    float ang_rate_z
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_imu_angular_rate_conversion_to_raw(
    secondary_imu_angular_rate_t *raw,
    float ang_rate_x,
    float ang_rate_y,
    float ang_rate_z
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_imu_angular_rate_raw_to_conversion_struct(
    secondary_imu_angular_rate_converted_t *conversion, 
    const secondary_imu_angular_rate_t *raw);


void secondary_imu_angular_rate_conversion_to_raw_struct(
    secondary_imu_angular_rate_t *raw,
    const secondary_imu_angular_rate_converted_t *conversion);


int secondary_imu_angular_rate_converted_to_string(secondary_imu_angular_rate_converted_t *message, char *buffer);

int secondary_imu_angular_rate_converted_to_string_file(secondary_imu_angular_rate_converted_t *message, FILE *buffer);

int secondary_imu_angular_rate_fields(char *buffer);

int secondary_imu_angular_rate_fields_file(FILE *buffer);

/**
 * Pack message IMU_ANGULAR_RATE.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_imu_angular_rate_pack(
    uint8_t *dst_p,
    const secondary_imu_angular_rate_t *src_p,
    size_t size);

/**
 * Unpack message IMU_ANGULAR_RATE.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_imu_angular_rate_unpack(
    secondary_imu_angular_rate_t *dst_p,
    const uint8_t *src_p,
    size_t size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t secondary_imu_angular_rate_ang_rate_x_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double secondary_imu_angular_rate_ang_rate_x_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_imu_angular_rate_ang_rate_x_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t secondary_imu_angular_rate_ang_rate_y_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double secondary_imu_angular_rate_ang_rate_y_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_imu_angular_rate_ang_rate_y_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t secondary_imu_angular_rate_ang_rate_z_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double secondary_imu_angular_rate_ang_rate_z_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_imu_angular_rate_ang_rate_z_is_in_range(uint8_t value);


void secondary_imu_acceleration_raw_to_conversion(
    secondary_imu_acceleration_converted_t *conversion,
    float accel_x,
    float accel_y,
    float accel_z,
    int16_t temperature
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_imu_acceleration_conversion_to_raw(
    secondary_imu_acceleration_t *raw,
    float accel_x,
    float accel_y,
    float accel_z,
    int16_t temperature
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_imu_acceleration_raw_to_conversion_struct(
    secondary_imu_acceleration_converted_t *conversion, 
    const secondary_imu_acceleration_t *raw);


void secondary_imu_acceleration_conversion_to_raw_struct(
    secondary_imu_acceleration_t *raw,
    const secondary_imu_acceleration_converted_t *conversion);


int secondary_imu_acceleration_converted_to_string(secondary_imu_acceleration_converted_t *message, char *buffer);

int secondary_imu_acceleration_converted_to_string_file(secondary_imu_acceleration_converted_t *message, FILE *buffer);

int secondary_imu_acceleration_fields(char *buffer);

int secondary_imu_acceleration_fields_file(FILE *buffer);

/**
 * Pack message IMU_ACCELERATION.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_imu_acceleration_pack(
    uint8_t *dst_p,
    const secondary_imu_acceleration_t *src_p,
    size_t size);

/**
 * Unpack message IMU_ACCELERATION.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_imu_acceleration_unpack(
    secondary_imu_acceleration_t *dst_p,
    const uint8_t *src_p,
    size_t size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t secondary_imu_acceleration_accel_x_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double secondary_imu_acceleration_accel_x_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_imu_acceleration_accel_x_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t secondary_imu_acceleration_accel_y_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double secondary_imu_acceleration_accel_y_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_imu_acceleration_accel_y_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t secondary_imu_acceleration_accel_z_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double secondary_imu_acceleration_accel_z_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_imu_acceleration_accel_z_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_imu_acceleration_temperature_is_in_range(int16_t value);


void secondary_irts_fl_0_raw_to_conversion(
    secondary_irts_fl_0_converted_t *conversion,
    float channel1,
    float channel2,
    float channel3,
    float channel4
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_irts_fl_0_conversion_to_raw(
    secondary_irts_fl_0_t *raw,
    float channel1,
    float channel2,
    float channel3,
    float channel4
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_irts_fl_0_raw_to_conversion_struct(
    secondary_irts_fl_0_converted_t *conversion, 
    const secondary_irts_fl_0_t *raw);


void secondary_irts_fl_0_conversion_to_raw_struct(
    secondary_irts_fl_0_t *raw,
    const secondary_irts_fl_0_converted_t *conversion);


int secondary_irts_fl_0_converted_to_string(secondary_irts_fl_0_converted_t *message, char *buffer);

int secondary_irts_fl_0_converted_to_string_file(secondary_irts_fl_0_converted_t *message, FILE *buffer);

int secondary_irts_fl_0_fields(char *buffer);

int secondary_irts_fl_0_fields_file(FILE *buffer);

/**
 * Pack message IRTS_FL_0.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_irts_fl_0_pack(
    uint8_t *dst_p,
    const secondary_irts_fl_0_t *src_p,
    size_t size);

/**
 * Unpack message IRTS_FL_0.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_irts_fl_0_unpack(
    secondary_irts_fl_0_t *dst_p,
    const uint8_t *src_p,
    size_t size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t secondary_irts_fl_0_channel1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double secondary_irts_fl_0_channel1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_fl_0_channel1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t secondary_irts_fl_0_channel2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double secondary_irts_fl_0_channel2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_fl_0_channel2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t secondary_irts_fl_0_channel3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double secondary_irts_fl_0_channel3_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_fl_0_channel3_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t secondary_irts_fl_0_channel4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double secondary_irts_fl_0_channel4_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_fl_0_channel4_is_in_range(uint8_t value);


void secondary_irts_fl_1_raw_to_conversion(
    secondary_irts_fl_1_converted_t *conversion,
    float channel5,
    float channel6,
    float channel7,
    float channel8
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_irts_fl_1_conversion_to_raw(
    secondary_irts_fl_1_t *raw,
    float channel5,
    float channel6,
    float channel7,
    float channel8
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_irts_fl_1_raw_to_conversion_struct(
    secondary_irts_fl_1_converted_t *conversion, 
    const secondary_irts_fl_1_t *raw);


void secondary_irts_fl_1_conversion_to_raw_struct(
    secondary_irts_fl_1_t *raw,
    const secondary_irts_fl_1_converted_t *conversion);


int secondary_irts_fl_1_converted_to_string(secondary_irts_fl_1_converted_t *message, char *buffer);

int secondary_irts_fl_1_converted_to_string_file(secondary_irts_fl_1_converted_t *message, FILE *buffer);

int secondary_irts_fl_1_fields(char *buffer);

int secondary_irts_fl_1_fields_file(FILE *buffer);

/**
 * Pack message IRTS_FL_1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_irts_fl_1_pack(
    uint8_t *dst_p,
    const secondary_irts_fl_1_t *src_p,
    size_t size);

/**
 * Unpack message IRTS_FL_1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_irts_fl_1_unpack(
    secondary_irts_fl_1_t *dst_p,
    const uint8_t *src_p,
    size_t size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t secondary_irts_fl_1_channel5_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double secondary_irts_fl_1_channel5_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_fl_1_channel5_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t secondary_irts_fl_1_channel6_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double secondary_irts_fl_1_channel6_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_fl_1_channel6_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t secondary_irts_fl_1_channel7_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double secondary_irts_fl_1_channel7_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_fl_1_channel7_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t secondary_irts_fl_1_channel8_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double secondary_irts_fl_1_channel8_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_fl_1_channel8_is_in_range(uint8_t value);


void secondary_irts_fl_2_raw_to_conversion(
    secondary_irts_fl_2_converted_t *conversion,
    float channel9,
    float channel10,
    float channel11,
    float channel12
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_irts_fl_2_conversion_to_raw(
    secondary_irts_fl_2_t *raw,
    float channel9,
    float channel10,
    float channel11,
    float channel12
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_irts_fl_2_raw_to_conversion_struct(
    secondary_irts_fl_2_converted_t *conversion, 
    const secondary_irts_fl_2_t *raw);


void secondary_irts_fl_2_conversion_to_raw_struct(
    secondary_irts_fl_2_t *raw,
    const secondary_irts_fl_2_converted_t *conversion);


int secondary_irts_fl_2_converted_to_string(secondary_irts_fl_2_converted_t *message, char *buffer);

int secondary_irts_fl_2_converted_to_string_file(secondary_irts_fl_2_converted_t *message, FILE *buffer);

int secondary_irts_fl_2_fields(char *buffer);

int secondary_irts_fl_2_fields_file(FILE *buffer);

/**
 * Pack message IRTS_FL_2.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_irts_fl_2_pack(
    uint8_t *dst_p,
    const secondary_irts_fl_2_t *src_p,
    size_t size);

/**
 * Unpack message IRTS_FL_2.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_irts_fl_2_unpack(
    secondary_irts_fl_2_t *dst_p,
    const uint8_t *src_p,
    size_t size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t secondary_irts_fl_2_channel9_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double secondary_irts_fl_2_channel9_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_fl_2_channel9_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t secondary_irts_fl_2_channel10_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double secondary_irts_fl_2_channel10_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_fl_2_channel10_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t secondary_irts_fl_2_channel11_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double secondary_irts_fl_2_channel11_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_fl_2_channel11_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t secondary_irts_fl_2_channel12_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double secondary_irts_fl_2_channel12_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_fl_2_channel12_is_in_range(uint8_t value);


void secondary_irts_fl_3_raw_to_conversion(
    secondary_irts_fl_3_converted_t *conversion,
    float channel13,
    float channel14,
    float channel15,
    float channel16
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_irts_fl_3_conversion_to_raw(
    secondary_irts_fl_3_t *raw,
    float channel13,
    float channel14,
    float channel15,
    float channel16
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_irts_fl_3_raw_to_conversion_struct(
    secondary_irts_fl_3_converted_t *conversion, 
    const secondary_irts_fl_3_t *raw);


void secondary_irts_fl_3_conversion_to_raw_struct(
    secondary_irts_fl_3_t *raw,
    const secondary_irts_fl_3_converted_t *conversion);


int secondary_irts_fl_3_converted_to_string(secondary_irts_fl_3_converted_t *message, char *buffer);

int secondary_irts_fl_3_converted_to_string_file(secondary_irts_fl_3_converted_t *message, FILE *buffer);

int secondary_irts_fl_3_fields(char *buffer);

int secondary_irts_fl_3_fields_file(FILE *buffer);

/**
 * Pack message IRTS_FL_3.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_irts_fl_3_pack(
    uint8_t *dst_p,
    const secondary_irts_fl_3_t *src_p,
    size_t size);

/**
 * Unpack message IRTS_FL_3.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_irts_fl_3_unpack(
    secondary_irts_fl_3_t *dst_p,
    const uint8_t *src_p,
    size_t size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t secondary_irts_fl_3_channel13_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double secondary_irts_fl_3_channel13_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_fl_3_channel13_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t secondary_irts_fl_3_channel14_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double secondary_irts_fl_3_channel14_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_fl_3_channel14_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t secondary_irts_fl_3_channel15_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double secondary_irts_fl_3_channel15_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_fl_3_channel15_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t secondary_irts_fl_3_channel16_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double secondary_irts_fl_3_channel16_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_fl_3_channel16_is_in_range(uint8_t value);


void secondary_irts_fr_0_raw_to_conversion(
    secondary_irts_fr_0_converted_t *conversion,
    float channel1,
    float channel2,
    float channel3,
    float channel4
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_irts_fr_0_conversion_to_raw(
    secondary_irts_fr_0_t *raw,
    float channel1,
    float channel2,
    float channel3,
    float channel4
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_irts_fr_0_raw_to_conversion_struct(
    secondary_irts_fr_0_converted_t *conversion, 
    const secondary_irts_fr_0_t *raw);


void secondary_irts_fr_0_conversion_to_raw_struct(
    secondary_irts_fr_0_t *raw,
    const secondary_irts_fr_0_converted_t *conversion);


int secondary_irts_fr_0_converted_to_string(secondary_irts_fr_0_converted_t *message, char *buffer);

int secondary_irts_fr_0_converted_to_string_file(secondary_irts_fr_0_converted_t *message, FILE *buffer);

int secondary_irts_fr_0_fields(char *buffer);

int secondary_irts_fr_0_fields_file(FILE *buffer);

/**
 * Pack message IRTS_FR_0.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_irts_fr_0_pack(
    uint8_t *dst_p,
    const secondary_irts_fr_0_t *src_p,
    size_t size);

/**
 * Unpack message IRTS_FR_0.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_irts_fr_0_unpack(
    secondary_irts_fr_0_t *dst_p,
    const uint8_t *src_p,
    size_t size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t secondary_irts_fr_0_channel1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double secondary_irts_fr_0_channel1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_fr_0_channel1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t secondary_irts_fr_0_channel2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double secondary_irts_fr_0_channel2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_fr_0_channel2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t secondary_irts_fr_0_channel3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double secondary_irts_fr_0_channel3_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_fr_0_channel3_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t secondary_irts_fr_0_channel4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double secondary_irts_fr_0_channel4_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_fr_0_channel4_is_in_range(uint8_t value);


void secondary_irts_fr_1_raw_to_conversion(
    secondary_irts_fr_1_converted_t *conversion,
    float channel5,
    float channel6,
    float channel7,
    float channel8
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_irts_fr_1_conversion_to_raw(
    secondary_irts_fr_1_t *raw,
    float channel5,
    float channel6,
    float channel7,
    float channel8
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_irts_fr_1_raw_to_conversion_struct(
    secondary_irts_fr_1_converted_t *conversion, 
    const secondary_irts_fr_1_t *raw);


void secondary_irts_fr_1_conversion_to_raw_struct(
    secondary_irts_fr_1_t *raw,
    const secondary_irts_fr_1_converted_t *conversion);


int secondary_irts_fr_1_converted_to_string(secondary_irts_fr_1_converted_t *message, char *buffer);

int secondary_irts_fr_1_converted_to_string_file(secondary_irts_fr_1_converted_t *message, FILE *buffer);

int secondary_irts_fr_1_fields(char *buffer);

int secondary_irts_fr_1_fields_file(FILE *buffer);

/**
 * Pack message IRTS_FR_1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_irts_fr_1_pack(
    uint8_t *dst_p,
    const secondary_irts_fr_1_t *src_p,
    size_t size);

/**
 * Unpack message IRTS_FR_1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_irts_fr_1_unpack(
    secondary_irts_fr_1_t *dst_p,
    const uint8_t *src_p,
    size_t size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t secondary_irts_fr_1_channel5_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double secondary_irts_fr_1_channel5_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_fr_1_channel5_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t secondary_irts_fr_1_channel6_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double secondary_irts_fr_1_channel6_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_fr_1_channel6_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t secondary_irts_fr_1_channel7_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double secondary_irts_fr_1_channel7_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_fr_1_channel7_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t secondary_irts_fr_1_channel8_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double secondary_irts_fr_1_channel8_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_fr_1_channel8_is_in_range(uint8_t value);


void secondary_irts_fr_2_raw_to_conversion(
    secondary_irts_fr_2_converted_t *conversion,
    float channel9,
    float channel10,
    float channel11,
    float channel12
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_irts_fr_2_conversion_to_raw(
    secondary_irts_fr_2_t *raw,
    float channel9,
    float channel10,
    float channel11,
    float channel12
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_irts_fr_2_raw_to_conversion_struct(
    secondary_irts_fr_2_converted_t *conversion, 
    const secondary_irts_fr_2_t *raw);


void secondary_irts_fr_2_conversion_to_raw_struct(
    secondary_irts_fr_2_t *raw,
    const secondary_irts_fr_2_converted_t *conversion);


int secondary_irts_fr_2_converted_to_string(secondary_irts_fr_2_converted_t *message, char *buffer);

int secondary_irts_fr_2_converted_to_string_file(secondary_irts_fr_2_converted_t *message, FILE *buffer);

int secondary_irts_fr_2_fields(char *buffer);

int secondary_irts_fr_2_fields_file(FILE *buffer);

/**
 * Pack message IRTS_FR_2.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_irts_fr_2_pack(
    uint8_t *dst_p,
    const secondary_irts_fr_2_t *src_p,
    size_t size);

/**
 * Unpack message IRTS_FR_2.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_irts_fr_2_unpack(
    secondary_irts_fr_2_t *dst_p,
    const uint8_t *src_p,
    size_t size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t secondary_irts_fr_2_channel9_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double secondary_irts_fr_2_channel9_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_fr_2_channel9_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t secondary_irts_fr_2_channel10_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double secondary_irts_fr_2_channel10_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_fr_2_channel10_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t secondary_irts_fr_2_channel11_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double secondary_irts_fr_2_channel11_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_fr_2_channel11_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t secondary_irts_fr_2_channel12_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double secondary_irts_fr_2_channel12_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_fr_2_channel12_is_in_range(uint8_t value);


void secondary_irts_fr_3_raw_to_conversion(
    secondary_irts_fr_3_converted_t *conversion,
    float channel13,
    float channel14,
    float channel15,
    float channel16
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_irts_fr_3_conversion_to_raw(
    secondary_irts_fr_3_t *raw,
    float channel13,
    float channel14,
    float channel15,
    float channel16
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_irts_fr_3_raw_to_conversion_struct(
    secondary_irts_fr_3_converted_t *conversion, 
    const secondary_irts_fr_3_t *raw);


void secondary_irts_fr_3_conversion_to_raw_struct(
    secondary_irts_fr_3_t *raw,
    const secondary_irts_fr_3_converted_t *conversion);


int secondary_irts_fr_3_converted_to_string(secondary_irts_fr_3_converted_t *message, char *buffer);

int secondary_irts_fr_3_converted_to_string_file(secondary_irts_fr_3_converted_t *message, FILE *buffer);

int secondary_irts_fr_3_fields(char *buffer);

int secondary_irts_fr_3_fields_file(FILE *buffer);

/**
 * Pack message IRTS_FR_3.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_irts_fr_3_pack(
    uint8_t *dst_p,
    const secondary_irts_fr_3_t *src_p,
    size_t size);

/**
 * Unpack message IRTS_FR_3.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_irts_fr_3_unpack(
    secondary_irts_fr_3_t *dst_p,
    const uint8_t *src_p,
    size_t size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t secondary_irts_fr_3_channel13_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double secondary_irts_fr_3_channel13_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_fr_3_channel13_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t secondary_irts_fr_3_channel14_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double secondary_irts_fr_3_channel14_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_fr_3_channel14_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t secondary_irts_fr_3_channel15_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double secondary_irts_fr_3_channel15_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_fr_3_channel15_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t secondary_irts_fr_3_channel16_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double secondary_irts_fr_3_channel16_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_fr_3_channel16_is_in_range(uint8_t value);


void secondary_irts_rl_0_raw_to_conversion(
    secondary_irts_rl_0_converted_t *conversion,
    float channel1,
    float channel2,
    float channel3,
    float channel4
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_irts_rl_0_conversion_to_raw(
    secondary_irts_rl_0_t *raw,
    float channel1,
    float channel2,
    float channel3,
    float channel4
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_irts_rl_0_raw_to_conversion_struct(
    secondary_irts_rl_0_converted_t *conversion, 
    const secondary_irts_rl_0_t *raw);


void secondary_irts_rl_0_conversion_to_raw_struct(
    secondary_irts_rl_0_t *raw,
    const secondary_irts_rl_0_converted_t *conversion);


int secondary_irts_rl_0_converted_to_string(secondary_irts_rl_0_converted_t *message, char *buffer);

int secondary_irts_rl_0_converted_to_string_file(secondary_irts_rl_0_converted_t *message, FILE *buffer);

int secondary_irts_rl_0_fields(char *buffer);

int secondary_irts_rl_0_fields_file(FILE *buffer);

/**
 * Pack message IRTS_RL_0.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_irts_rl_0_pack(
    uint8_t *dst_p,
    const secondary_irts_rl_0_t *src_p,
    size_t size);

/**
 * Unpack message IRTS_RL_0.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_irts_rl_0_unpack(
    secondary_irts_rl_0_t *dst_p,
    const uint8_t *src_p,
    size_t size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t secondary_irts_rl_0_channel1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double secondary_irts_rl_0_channel1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_rl_0_channel1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t secondary_irts_rl_0_channel2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double secondary_irts_rl_0_channel2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_rl_0_channel2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t secondary_irts_rl_0_channel3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double secondary_irts_rl_0_channel3_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_rl_0_channel3_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t secondary_irts_rl_0_channel4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double secondary_irts_rl_0_channel4_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_rl_0_channel4_is_in_range(uint8_t value);


void secondary_irts_rl_1_raw_to_conversion(
    secondary_irts_rl_1_converted_t *conversion,
    float channel5,
    float channel6,
    float channel7,
    float channel8
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_irts_rl_1_conversion_to_raw(
    secondary_irts_rl_1_t *raw,
    float channel5,
    float channel6,
    float channel7,
    float channel8
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_irts_rl_1_raw_to_conversion_struct(
    secondary_irts_rl_1_converted_t *conversion, 
    const secondary_irts_rl_1_t *raw);


void secondary_irts_rl_1_conversion_to_raw_struct(
    secondary_irts_rl_1_t *raw,
    const secondary_irts_rl_1_converted_t *conversion);


int secondary_irts_rl_1_converted_to_string(secondary_irts_rl_1_converted_t *message, char *buffer);

int secondary_irts_rl_1_converted_to_string_file(secondary_irts_rl_1_converted_t *message, FILE *buffer);

int secondary_irts_rl_1_fields(char *buffer);

int secondary_irts_rl_1_fields_file(FILE *buffer);

/**
 * Pack message IRTS_RL_1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_irts_rl_1_pack(
    uint8_t *dst_p,
    const secondary_irts_rl_1_t *src_p,
    size_t size);

/**
 * Unpack message IRTS_RL_1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_irts_rl_1_unpack(
    secondary_irts_rl_1_t *dst_p,
    const uint8_t *src_p,
    size_t size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t secondary_irts_rl_1_channel5_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double secondary_irts_rl_1_channel5_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_rl_1_channel5_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t secondary_irts_rl_1_channel6_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double secondary_irts_rl_1_channel6_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_rl_1_channel6_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t secondary_irts_rl_1_channel7_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double secondary_irts_rl_1_channel7_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_rl_1_channel7_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t secondary_irts_rl_1_channel8_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double secondary_irts_rl_1_channel8_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_rl_1_channel8_is_in_range(uint8_t value);


void secondary_irts_rl_2_raw_to_conversion(
    secondary_irts_rl_2_converted_t *conversion,
    float channel9,
    float channel10,
    float channel11,
    float channel12
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_irts_rl_2_conversion_to_raw(
    secondary_irts_rl_2_t *raw,
    float channel9,
    float channel10,
    float channel11,
    float channel12
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_irts_rl_2_raw_to_conversion_struct(
    secondary_irts_rl_2_converted_t *conversion, 
    const secondary_irts_rl_2_t *raw);


void secondary_irts_rl_2_conversion_to_raw_struct(
    secondary_irts_rl_2_t *raw,
    const secondary_irts_rl_2_converted_t *conversion);


int secondary_irts_rl_2_converted_to_string(secondary_irts_rl_2_converted_t *message, char *buffer);

int secondary_irts_rl_2_converted_to_string_file(secondary_irts_rl_2_converted_t *message, FILE *buffer);

int secondary_irts_rl_2_fields(char *buffer);

int secondary_irts_rl_2_fields_file(FILE *buffer);

/**
 * Pack message IRTS_RL_2.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_irts_rl_2_pack(
    uint8_t *dst_p,
    const secondary_irts_rl_2_t *src_p,
    size_t size);

/**
 * Unpack message IRTS_RL_2.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_irts_rl_2_unpack(
    secondary_irts_rl_2_t *dst_p,
    const uint8_t *src_p,
    size_t size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t secondary_irts_rl_2_channel9_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double secondary_irts_rl_2_channel9_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_rl_2_channel9_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t secondary_irts_rl_2_channel10_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double secondary_irts_rl_2_channel10_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_rl_2_channel10_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t secondary_irts_rl_2_channel11_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double secondary_irts_rl_2_channel11_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_rl_2_channel11_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t secondary_irts_rl_2_channel12_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double secondary_irts_rl_2_channel12_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_rl_2_channel12_is_in_range(uint8_t value);


void secondary_irts_rl_3_raw_to_conversion(
    secondary_irts_rl_3_converted_t *conversion,
    float channel13,
    float channel14,
    float channel15,
    float channel16
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_irts_rl_3_conversion_to_raw(
    secondary_irts_rl_3_t *raw,
    float channel13,
    float channel14,
    float channel15,
    float channel16
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_irts_rl_3_raw_to_conversion_struct(
    secondary_irts_rl_3_converted_t *conversion, 
    const secondary_irts_rl_3_t *raw);


void secondary_irts_rl_3_conversion_to_raw_struct(
    secondary_irts_rl_3_t *raw,
    const secondary_irts_rl_3_converted_t *conversion);


int secondary_irts_rl_3_converted_to_string(secondary_irts_rl_3_converted_t *message, char *buffer);

int secondary_irts_rl_3_converted_to_string_file(secondary_irts_rl_3_converted_t *message, FILE *buffer);

int secondary_irts_rl_3_fields(char *buffer);

int secondary_irts_rl_3_fields_file(FILE *buffer);

/**
 * Pack message IRTS_RL_3.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_irts_rl_3_pack(
    uint8_t *dst_p,
    const secondary_irts_rl_3_t *src_p,
    size_t size);

/**
 * Unpack message IRTS_RL_3.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_irts_rl_3_unpack(
    secondary_irts_rl_3_t *dst_p,
    const uint8_t *src_p,
    size_t size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t secondary_irts_rl_3_channel13_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double secondary_irts_rl_3_channel13_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_rl_3_channel13_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t secondary_irts_rl_3_channel14_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double secondary_irts_rl_3_channel14_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_rl_3_channel14_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t secondary_irts_rl_3_channel15_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double secondary_irts_rl_3_channel15_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_rl_3_channel15_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t secondary_irts_rl_3_channel16_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double secondary_irts_rl_3_channel16_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_rl_3_channel16_is_in_range(uint8_t value);


void secondary_irts_rr_0_raw_to_conversion(
    secondary_irts_rr_0_converted_t *conversion,
    float channel1,
    float channel2,
    float channel3,
    float channel4
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_irts_rr_0_conversion_to_raw(
    secondary_irts_rr_0_t *raw,
    float channel1,
    float channel2,
    float channel3,
    float channel4
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_irts_rr_0_raw_to_conversion_struct(
    secondary_irts_rr_0_converted_t *conversion, 
    const secondary_irts_rr_0_t *raw);


void secondary_irts_rr_0_conversion_to_raw_struct(
    secondary_irts_rr_0_t *raw,
    const secondary_irts_rr_0_converted_t *conversion);


int secondary_irts_rr_0_converted_to_string(secondary_irts_rr_0_converted_t *message, char *buffer);

int secondary_irts_rr_0_converted_to_string_file(secondary_irts_rr_0_converted_t *message, FILE *buffer);

int secondary_irts_rr_0_fields(char *buffer);

int secondary_irts_rr_0_fields_file(FILE *buffer);

/**
 * Pack message IRTS_RR_0.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_irts_rr_0_pack(
    uint8_t *dst_p,
    const secondary_irts_rr_0_t *src_p,
    size_t size);

/**
 * Unpack message IRTS_RR_0.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_irts_rr_0_unpack(
    secondary_irts_rr_0_t *dst_p,
    const uint8_t *src_p,
    size_t size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t secondary_irts_rr_0_channel1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double secondary_irts_rr_0_channel1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_rr_0_channel1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t secondary_irts_rr_0_channel2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double secondary_irts_rr_0_channel2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_rr_0_channel2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t secondary_irts_rr_0_channel3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double secondary_irts_rr_0_channel3_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_rr_0_channel3_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t secondary_irts_rr_0_channel4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double secondary_irts_rr_0_channel4_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_rr_0_channel4_is_in_range(uint8_t value);


void secondary_irts_rr_1_raw_to_conversion(
    secondary_irts_rr_1_converted_t *conversion,
    float channel5,
    float channel6,
    float channel7,
    float channel8
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_irts_rr_1_conversion_to_raw(
    secondary_irts_rr_1_t *raw,
    float channel5,
    float channel6,
    float channel7,
    float channel8
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_irts_rr_1_raw_to_conversion_struct(
    secondary_irts_rr_1_converted_t *conversion, 
    const secondary_irts_rr_1_t *raw);


void secondary_irts_rr_1_conversion_to_raw_struct(
    secondary_irts_rr_1_t *raw,
    const secondary_irts_rr_1_converted_t *conversion);


int secondary_irts_rr_1_converted_to_string(secondary_irts_rr_1_converted_t *message, char *buffer);

int secondary_irts_rr_1_converted_to_string_file(secondary_irts_rr_1_converted_t *message, FILE *buffer);

int secondary_irts_rr_1_fields(char *buffer);

int secondary_irts_rr_1_fields_file(FILE *buffer);

/**
 * Pack message IRTS_RR_1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_irts_rr_1_pack(
    uint8_t *dst_p,
    const secondary_irts_rr_1_t *src_p,
    size_t size);

/**
 * Unpack message IRTS_RR_1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_irts_rr_1_unpack(
    secondary_irts_rr_1_t *dst_p,
    const uint8_t *src_p,
    size_t size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t secondary_irts_rr_1_channel5_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double secondary_irts_rr_1_channel5_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_rr_1_channel5_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t secondary_irts_rr_1_channel6_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double secondary_irts_rr_1_channel6_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_rr_1_channel6_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t secondary_irts_rr_1_channel7_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double secondary_irts_rr_1_channel7_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_rr_1_channel7_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t secondary_irts_rr_1_channel8_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double secondary_irts_rr_1_channel8_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_rr_1_channel8_is_in_range(uint8_t value);


void secondary_irts_rr_2_raw_to_conversion(
    secondary_irts_rr_2_converted_t *conversion,
    float channel9,
    float channel10,
    float channel11,
    float channel12
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_irts_rr_2_conversion_to_raw(
    secondary_irts_rr_2_t *raw,
    float channel9,
    float channel10,
    float channel11,
    float channel12
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_irts_rr_2_raw_to_conversion_struct(
    secondary_irts_rr_2_converted_t *conversion, 
    const secondary_irts_rr_2_t *raw);


void secondary_irts_rr_2_conversion_to_raw_struct(
    secondary_irts_rr_2_t *raw,
    const secondary_irts_rr_2_converted_t *conversion);


int secondary_irts_rr_2_converted_to_string(secondary_irts_rr_2_converted_t *message, char *buffer);

int secondary_irts_rr_2_converted_to_string_file(secondary_irts_rr_2_converted_t *message, FILE *buffer);

int secondary_irts_rr_2_fields(char *buffer);

int secondary_irts_rr_2_fields_file(FILE *buffer);

/**
 * Pack message IRTS_RR_2.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_irts_rr_2_pack(
    uint8_t *dst_p,
    const secondary_irts_rr_2_t *src_p,
    size_t size);

/**
 * Unpack message IRTS_RR_2.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_irts_rr_2_unpack(
    secondary_irts_rr_2_t *dst_p,
    const uint8_t *src_p,
    size_t size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t secondary_irts_rr_2_channel9_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double secondary_irts_rr_2_channel9_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_rr_2_channel9_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t secondary_irts_rr_2_channel10_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double secondary_irts_rr_2_channel10_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_rr_2_channel10_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t secondary_irts_rr_2_channel11_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double secondary_irts_rr_2_channel11_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_rr_2_channel11_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t secondary_irts_rr_2_channel12_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double secondary_irts_rr_2_channel12_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_rr_2_channel12_is_in_range(uint8_t value);


void secondary_irts_rr_3_raw_to_conversion(
    secondary_irts_rr_3_converted_t *conversion,
    float channel13,
    float channel14,
    float channel15,
    float channel16
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_irts_rr_3_conversion_to_raw(
    secondary_irts_rr_3_t *raw,
    float channel13,
    float channel14,
    float channel15,
    float channel16
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_irts_rr_3_raw_to_conversion_struct(
    secondary_irts_rr_3_converted_t *conversion, 
    const secondary_irts_rr_3_t *raw);


void secondary_irts_rr_3_conversion_to_raw_struct(
    secondary_irts_rr_3_t *raw,
    const secondary_irts_rr_3_converted_t *conversion);


int secondary_irts_rr_3_converted_to_string(secondary_irts_rr_3_converted_t *message, char *buffer);

int secondary_irts_rr_3_converted_to_string_file(secondary_irts_rr_3_converted_t *message, FILE *buffer);

int secondary_irts_rr_3_fields(char *buffer);

int secondary_irts_rr_3_fields_file(FILE *buffer);

/**
 * Pack message IRTS_RR_3.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_irts_rr_3_pack(
    uint8_t *dst_p,
    const secondary_irts_rr_3_t *src_p,
    size_t size);

/**
 * Unpack message IRTS_RR_3.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_irts_rr_3_unpack(
    secondary_irts_rr_3_t *dst_p,
    const uint8_t *src_p,
    size_t size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t secondary_irts_rr_3_channel13_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double secondary_irts_rr_3_channel13_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_rr_3_channel13_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t secondary_irts_rr_3_channel14_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double secondary_irts_rr_3_channel14_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_rr_3_channel14_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t secondary_irts_rr_3_channel15_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double secondary_irts_rr_3_channel15_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_rr_3_channel15_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t secondary_irts_rr_3_channel16_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double secondary_irts_rr_3_channel16_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_rr_3_channel16_is_in_range(uint8_t value);


void secondary_gps_coords_raw_to_conversion(
    secondary_gps_coords_converted_t *conversion,
    uint32_t latitude,
    uint32_t longitude
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_gps_coords_conversion_to_raw(
    secondary_gps_coords_t *raw,
    uint32_t latitude,
    uint32_t longitude
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_gps_coords_raw_to_conversion_struct(
    secondary_gps_coords_converted_t *conversion, 
    const secondary_gps_coords_t *raw);


void secondary_gps_coords_conversion_to_raw_struct(
    secondary_gps_coords_t *raw,
    const secondary_gps_coords_converted_t *conversion);


int secondary_gps_coords_to_string(secondary_gps_coords_t *message, char *buffer);

int secondary_gps_coords_to_string_file(secondary_gps_coords_t *message, FILE *buffer);

int secondary_gps_coords_fields(char *buffer);

int secondary_gps_coords_fields_file(FILE *buffer);

/**
 * Pack message GPS_COORDS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_gps_coords_pack(
    uint8_t *dst_p,
    const secondary_gps_coords_t *src_p,
    size_t size);

/**
 * Unpack message GPS_COORDS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_gps_coords_unpack(
    secondary_gps_coords_t *dst_p,
    const uint8_t *src_p,
    size_t size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_gps_coords_latitude_is_in_range(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_gps_coords_longitude_is_in_range(uint32_t value);


void secondary_gps_speed_raw_to_conversion(
    secondary_gps_speed_converted_t *conversion,
    uint16_t speed
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_gps_speed_conversion_to_raw(
    secondary_gps_speed_t *raw,
    uint16_t speed
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_gps_speed_raw_to_conversion_struct(
    secondary_gps_speed_converted_t *conversion, 
    const secondary_gps_speed_t *raw);


void secondary_gps_speed_conversion_to_raw_struct(
    secondary_gps_speed_t *raw,
    const secondary_gps_speed_converted_t *conversion);


int secondary_gps_speed_to_string(secondary_gps_speed_t *message, char *buffer);

int secondary_gps_speed_to_string_file(secondary_gps_speed_t *message, FILE *buffer);

int secondary_gps_speed_fields(char *buffer);

int secondary_gps_speed_fields_file(FILE *buffer);

/**
 * Pack message GPS_SPEED.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_gps_speed_pack(
    uint8_t *dst_p,
    const secondary_gps_speed_t *src_p,
    size_t size);

/**
 * Unpack message GPS_SPEED.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_gps_speed_unpack(
    secondary_gps_speed_t *dst_p,
    const uint8_t *src_p,
    size_t size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_gps_speed_speed_is_in_range(uint16_t value);


void secondary_lap_count_raw_to_conversion(
    secondary_lap_count_converted_t *conversion,
    uint8_t lap_count,
    uint32_t lap_time
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_lap_count_conversion_to_raw(
    secondary_lap_count_t *raw,
    uint8_t lap_count,
    uint32_t lap_time
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_lap_count_raw_to_conversion_struct(
    secondary_lap_count_converted_t *conversion, 
    const secondary_lap_count_t *raw);


void secondary_lap_count_conversion_to_raw_struct(
    secondary_lap_count_t *raw,
    const secondary_lap_count_converted_t *conversion);


int secondary_lap_count_to_string(secondary_lap_count_t *message, char *buffer);

int secondary_lap_count_to_string_file(secondary_lap_count_t *message, FILE *buffer);

int secondary_lap_count_fields(char *buffer);

int secondary_lap_count_fields_file(FILE *buffer);

/**
 * Pack message LAP_COUNT.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_lap_count_pack(
    uint8_t *dst_p,
    const secondary_lap_count_t *src_p,
    size_t size);

/**
 * Unpack message LAP_COUNT.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_lap_count_unpack(
    secondary_lap_count_t *dst_p,
    const uint8_t *src_p,
    size_t size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_lap_count_lap_count_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_lap_count_lap_time_is_in_range(uint32_t value);


void secondary_pedals_output_raw_to_conversion(
    secondary_pedals_output_converted_t *conversion,
    uint8_t apps,
    float bse_front,
    float bse_rear
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_pedals_output_conversion_to_raw(
    secondary_pedals_output_t *raw,
    uint8_t apps,
    float bse_front,
    float bse_rear
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_pedals_output_raw_to_conversion_struct(
    secondary_pedals_output_converted_t *conversion, 
    const secondary_pedals_output_t *raw);


void secondary_pedals_output_conversion_to_raw_struct(
    secondary_pedals_output_t *raw,
    const secondary_pedals_output_converted_t *conversion);


int secondary_pedals_output_converted_to_string(secondary_pedals_output_converted_t *message, char *buffer);

int secondary_pedals_output_converted_to_string_file(secondary_pedals_output_converted_t *message, FILE *buffer);

int secondary_pedals_output_fields(char *buffer);

int secondary_pedals_output_fields_file(FILE *buffer);

/**
 * Pack message PEDALS_OUTPUT.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_pedals_output_pack(
    uint8_t *dst_p,
    const secondary_pedals_output_t *src_p,
    size_t size);

/**
 * Unpack message PEDALS_OUTPUT.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_pedals_output_unpack(
    secondary_pedals_output_t *dst_p,
    const uint8_t *src_p,
    size_t size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_pedals_output_apps_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t secondary_pedals_output_bse_front_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double secondary_pedals_output_bse_front_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_pedals_output_bse_front_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t secondary_pedals_output_bse_rear_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double secondary_pedals_output_bse_rear_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_pedals_output_bse_rear_is_in_range(uint32_t value);


void secondary_steering_angle_raw_to_conversion(
    secondary_steering_angle_converted_t *conversion,
    uint32_t angle
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_steering_angle_conversion_to_raw(
    secondary_steering_angle_t *raw,
    uint32_t angle
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_steering_angle_raw_to_conversion_struct(
    secondary_steering_angle_converted_t *conversion, 
    const secondary_steering_angle_t *raw);


void secondary_steering_angle_conversion_to_raw_struct(
    secondary_steering_angle_t *raw,
    const secondary_steering_angle_converted_t *conversion);


int secondary_steering_angle_to_string(secondary_steering_angle_t *message, char *buffer);

int secondary_steering_angle_to_string_file(secondary_steering_angle_t *message, FILE *buffer);

int secondary_steering_angle_fields(char *buffer);

int secondary_steering_angle_fields_file(FILE *buffer);

/**
 * Pack message STEERING_ANGLE.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_steering_angle_pack(
    uint8_t *dst_p,
    const secondary_steering_angle_t *src_p,
    size_t size);

/**
 * Unpack message STEERING_ANGLE.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_steering_angle_unpack(
    secondary_steering_angle_t *dst_p,
    const uint8_t *src_p,
    size_t size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_steering_angle_angle_is_in_range(uint32_t value);


void secondary_control_state_raw_to_conversion(
    secondary_control_state_converted_t *conversion,
    float map_pw,
    uint8_t map_sc,
    uint8_t map_tv
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_control_state_conversion_to_raw(
    secondary_control_state_t *raw,
    float map_pw,
    uint8_t map_sc,
    uint8_t map_tv
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_control_state_raw_to_conversion_struct(
    secondary_control_state_converted_t *conversion, 
    const secondary_control_state_t *raw);


void secondary_control_state_conversion_to_raw_struct(
    secondary_control_state_t *raw,
    const secondary_control_state_converted_t *conversion);


int secondary_control_state_converted_to_string(secondary_control_state_converted_t *message, char *buffer);

int secondary_control_state_converted_to_string_file(secondary_control_state_converted_t *message, FILE *buffer);

int secondary_control_state_fields(char *buffer);

int secondary_control_state_fields_file(FILE *buffer);

/**
 * Pack message CONTROL_STATE.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_control_state_pack(
    uint8_t *dst_p,
    const secondary_control_state_t *src_p,
    size_t size);

/**
 * Unpack message CONTROL_STATE.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_control_state_unpack(
    secondary_control_state_t *dst_p,
    const uint8_t *src_p,
    size_t size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t secondary_control_state_map_pw_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double secondary_control_state_map_pw_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_control_state_map_pw_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_control_state_map_sc_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_control_state_map_tv_is_in_range(uint8_t value);


void secondary_tpms_raw_to_conversion(
    secondary_tpms_converted_t *conversion,
    uint8_t fl_pressure,
    uint8_t fr_pressure,
    uint8_t rl_pressure,
    uint8_t rr_pressure,
    uint8_t fl_temperature,
    uint8_t fr_temperature,
    uint8_t rl_temperature,
    uint8_t rr_temperature
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_tpms_conversion_to_raw(
    secondary_tpms_t *raw,
    uint8_t fl_pressure,
    uint8_t fr_pressure,
    uint8_t rl_pressure,
    uint8_t rr_pressure,
    uint8_t fl_temperature,
    uint8_t fr_temperature,
    uint8_t rl_temperature,
    uint8_t rr_temperature
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_tpms_raw_to_conversion_struct(
    secondary_tpms_converted_t *conversion, 
    const secondary_tpms_t *raw);


void secondary_tpms_conversion_to_raw_struct(
    secondary_tpms_t *raw,
    const secondary_tpms_converted_t *conversion);


int secondary_tpms_to_string(secondary_tpms_t *message, char *buffer);

int secondary_tpms_to_string_file(secondary_tpms_t *message, FILE *buffer);

int secondary_tpms_fields(char *buffer);

int secondary_tpms_fields_file(FILE *buffer);

/**
 * Pack message TPMS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_tpms_pack(
    uint8_t *dst_p,
    const secondary_tpms_t *src_p,
    size_t size);

/**
 * Unpack message TPMS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_tpms_unpack(
    secondary_tpms_t *dst_p,
    const uint8_t *src_p,
    size_t size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_tpms_fl_pressure_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_tpms_fr_pressure_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_tpms_rl_pressure_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_tpms_rr_pressure_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_tpms_fl_temperature_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_tpms_fr_temperature_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_tpms_rl_temperature_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_tpms_rr_temperature_is_in_range(uint8_t value);


void secondary_lc_status_raw_to_conversion(
    secondary_lc_status_converted_t *conversion,
    uint32_t last_time,
    int16_t lap_number
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_lc_status_conversion_to_raw(
    secondary_lc_status_t *raw,
    uint32_t last_time,
    int16_t lap_number
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_lc_status_raw_to_conversion_struct(
    secondary_lc_status_converted_t *conversion, 
    const secondary_lc_status_t *raw);


void secondary_lc_status_conversion_to_raw_struct(
    secondary_lc_status_t *raw,
    const secondary_lc_status_converted_t *conversion);


int secondary_lc_status_to_string(secondary_lc_status_t *message, char *buffer);

int secondary_lc_status_to_string_file(secondary_lc_status_t *message, FILE *buffer);

int secondary_lc_status_fields(char *buffer);

int secondary_lc_status_fields_file(FILE *buffer);

/**
 * Pack message LC_STATUS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_lc_status_pack(
    uint8_t *dst_p,
    const secondary_lc_status_t *src_p,
    size_t size);

/**
 * Unpack message LC_STATUS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_lc_status_unpack(
    secondary_lc_status_t *dst_p,
    const uint8_t *src_p,
    size_t size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_lc_status_last_time_is_in_range(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_lc_status_lap_number_is_in_range(int16_t value);

bool secondary_id_is_message(uint16_t id);

int secondary_to_string_from_id(uint16_t message_id, void* message, char* buffer);
int secondary_fields_from_id(uint16_t message_id, char* buffer);
int secondary_to_string_file_from_id(uint16_t message_id, void* message, FILE* buffer);
int secondary_fields_file_from_id(uint16_t message_id, FILE* buffer);

#ifdef __cplusplus
}
#endif

#endif
