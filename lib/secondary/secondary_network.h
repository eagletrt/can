/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2018-2019 Erik Moqvist
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/**
 * This file was generated by cantools version 38.0.2 Thu Mar  6 18:52:37 2025.
 */

#ifndef SECONDARY_H
#define SECONDARY_H

#include <stdio.h>
#include <stdlib.h>
#include <inttypes.h>

#ifdef __cplusplus
extern "C" {
#endif

#include <stdint.h>
#include <stdbool.h>
#include <stddef.h>
#include "../canlib_device.h"

#ifndef CANLIB_BUILD
#define CANLIB_BUILD
#define CANLIB_BUILD_TIME 1741287157
#endif // CANLIB_BUILD

#define canlib_min(a,b) (((a) < (b)) ? (a) : (b))
#define canlib_max(a,b) (((a) > (b)) ? (a) : (b))

#ifndef CANLIB_PARKING
/* We know it's PACKING but PARKING sounds a bit better ;) */
#if defined(__MINGW32__)
#define CANLIB_PARKING                                                           __attribute__((__gcc_struct__, __packed__)) // , __aligned__(1)))
#else
#define CANLIB_PARKING __attribute__((__packed__)) // , __aligned__(1)))
#endif                                             // defined(__MINGW32__)
#endif                                             // CANLIB_PARKING

#ifndef EINVAL
#    define EINVAL 22
#endif

/* General defines */
#define SECONDARY_ONESHOT (-1)

/* Frame ids. */
#define SECONDARY_ACQUISINATOR_JMP_TO_BLT_FRAME_ID (0x00u)
#define SECONDARY_ACQUISINATOR_FLASH_0_TX_FRAME_ID (0x01u)
#define SECONDARY_ACQUISINATOR_FLASH_0_RX_FRAME_ID (0x02u)
#define SECONDARY_ACQUISINATOR_FLASH_1_TX_FRAME_ID (0x03u)
#define SECONDARY_ACQUISINATOR_FLASH_1_RX_FRAME_ID (0x04u)
#define SECONDARY_ACQUISINATOR_FLASH_2_TX_FRAME_ID (0x05u)
#define SECONDARY_ACQUISINATOR_FLASH_2_RX_FRAME_ID (0x06u)
#define SECONDARY_ACQUISINATOR_FLASH_3_TX_FRAME_ID (0x07u)
#define SECONDARY_ACQUISINATOR_FLASH_3_RX_FRAME_ID (0x08u)
#define SECONDARY_ACQUISINATOR_FLASH_4_TX_FRAME_ID (0x09u)
#define SECONDARY_ACQUISINATOR_FLASH_4_RX_FRAME_ID (0x0au)
#define SECONDARY_ACQUISINATOR_FLASH_5_TX_FRAME_ID (0x0bu)
#define SECONDARY_ACQUISINATOR_FLASH_5_RX_FRAME_ID (0x0cu)
#define SECONDARY_ACQUISINATOR_FLASH_6_TX_FRAME_ID (0x0du)
#define SECONDARY_ACQUISINATOR_FLASH_6_RX_FRAME_ID (0x0eu)
#define SECONDARY_ACQUISINATOR_FLASH_7_TX_FRAME_ID (0x0fu)
#define SECONDARY_ACQUISINATOR_FLASH_7_RX_FRAME_ID (0x10u)
#define SECONDARY_ACQUISINATOR_FLASH_8_TX_FRAME_ID (0x11u)
#define SECONDARY_ACQUISINATOR_FLASH_8_RX_FRAME_ID (0x12u)
#define SECONDARY_ACQUISINATOR_FLASH_9_TX_FRAME_ID (0x13u)
#define SECONDARY_ACQUISINATOR_FLASH_9_RX_FRAME_ID (0x14u)
#define SECONDARY_ACQUISINATOR_FLASH_10_TX_FRAME_ID (0x15u)
#define SECONDARY_ACQUISINATOR_FLASH_10_RX_FRAME_ID (0x16u)
#define SECONDARY_ACQUISINATOR_FLASH_11_TX_FRAME_ID (0x17u)
#define SECONDARY_ACQUISINATOR_FLASH_11_RX_FRAME_ID (0x18u)
#define SECONDARY_ACQUISINATOR_FLASH_12_TX_FRAME_ID (0x19u)
#define SECONDARY_ACQUISINATOR_FLASH_12_RX_FRAME_ID (0x1au)
#define SECONDARY_ACQUISINATOR_FLASH_13_TX_FRAME_ID (0x1bu)
#define SECONDARY_ACQUISINATOR_FLASH_13_RX_FRAME_ID (0x1cu)
#define SECONDARY_ACQUISINATOR_FLASH_14_TX_FRAME_ID (0x1du)
#define SECONDARY_ACQUISINATOR_FLASH_14_RX_FRAME_ID (0x1eu)
#define SECONDARY_ACQUISINATOR_FLASH_15_TX_FRAME_ID (0x1fu)
#define SECONDARY_ACQUISINATOR_FLASH_15_RX_FRAME_ID (0x20u)
#define SECONDARY_ACQUISINATOR_FLASH_16_TX_FRAME_ID (0x21u)
#define SECONDARY_ACQUISINATOR_FLASH_16_RX_FRAME_ID (0x22u)
#define SECONDARY_ACQUISINATOR_FLASH_17_TX_FRAME_ID (0x23u)
#define SECONDARY_ACQUISINATOR_FLASH_17_RX_FRAME_ID (0x24u)
#define SECONDARY_ACQUISINATOR_FLASH_18_TX_FRAME_ID (0x25u)
#define SECONDARY_ACQUISINATOR_FLASH_18_RX_FRAME_ID (0x26u)
#define SECONDARY_ACQUISINATOR_FLASH_19_TX_FRAME_ID (0x27u)
#define SECONDARY_ACQUISINATOR_FLASH_19_RX_FRAME_ID (0x28u)
#define SECONDARY_ACQUISINATOR_FLASH_20_TX_FRAME_ID (0x29u)
#define SECONDARY_ACQUISINATOR_FLASH_20_RX_FRAME_ID (0x2au)
#define SECONDARY_ACQUISINATOR_FLASH_21_TX_FRAME_ID (0x2bu)
#define SECONDARY_ACQUISINATOR_FLASH_21_RX_FRAME_ID (0x2cu)
#define SECONDARY_ACQUISINATOR_FLASH_22_TX_FRAME_ID (0x2du)
#define SECONDARY_ACQUISINATOR_FLASH_22_RX_FRAME_ID (0x2eu)
#define SECONDARY_ACQUISINATOR_FLASH_23_TX_FRAME_ID (0x2fu)
#define SECONDARY_ACQUISINATOR_FLASH_23_RX_FRAME_ID (0x30u)
#define SECONDARY_ACQUISINATOR_FLASH_24_TX_FRAME_ID (0x31u)
#define SECONDARY_ACQUISINATOR_FLASH_24_RX_FRAME_ID (0x32u)
#define SECONDARY_ACQUISINATOR_FLASH_25_TX_FRAME_ID (0x33u)
#define SECONDARY_ACQUISINATOR_FLASH_25_RX_FRAME_ID (0x34u)
#define SECONDARY_ACQUISINATOR_FLASH_26_TX_FRAME_ID (0x35u)
#define SECONDARY_ACQUISINATOR_FLASH_26_RX_FRAME_ID (0x36u)
#define SECONDARY_ACQUISINATOR_FLASH_27_TX_FRAME_ID (0x37u)
#define SECONDARY_ACQUISINATOR_FLASH_27_RX_FRAME_ID (0x38u)
#define SECONDARY_ACQUISINATOR_FLASH_28_TX_FRAME_ID (0x39u)
#define SECONDARY_ACQUISINATOR_FLASH_28_RX_FRAME_ID (0x3au)
#define SECONDARY_ACQUISINATOR_FLASH_29_TX_FRAME_ID (0x3bu)
#define SECONDARY_ACQUISINATOR_FLASH_29_RX_FRAME_ID (0x3cu)
#define SECONDARY_ACQUISINATOR_FLASH_30_TX_FRAME_ID (0x3du)
#define SECONDARY_ACQUISINATOR_FLASH_30_RX_FRAME_ID (0x3eu)
#define SECONDARY_ACQUISINATOR_FLASH_31_TX_FRAME_ID (0x3fu)
#define SECONDARY_ACQUISINATOR_FLASH_31_RX_FRAME_ID (0x40u)
#define SECONDARY_ACQUISINATOR_VERSION_FRAME_ID (0x2bcu)
#define SECONDARY_IMU_ANGULAR_RATE_FRAME_ID (0x4ecu)
#define SECONDARY_IMU_ACCELERATION_FRAME_ID (0x4edu)
#define SECONDARY_IRTS_FL_0_FRAME_ID (0x5b0u)
#define SECONDARY_IRTS_FL_1_FRAME_ID (0x5b1u)
#define SECONDARY_IRTS_FL_2_FRAME_ID (0x5b2u)
#define SECONDARY_IRTS_FL_3_FRAME_ID (0x5b3u)
#define SECONDARY_IRTS_FR_0_FRAME_ID (0x5b8u)
#define SECONDARY_IRTS_FR_1_FRAME_ID (0x5b9u)
#define SECONDARY_IRTS_FR_2_FRAME_ID (0x5bau)
#define SECONDARY_IRTS_FR_3_FRAME_ID (0x5bbu)
#define SECONDARY_IRTS_RL_0_FRAME_ID (0x5bcu)
#define SECONDARY_IRTS_RL_1_FRAME_ID (0x5bdu)
#define SECONDARY_IRTS_RL_2_FRAME_ID (0x5beu)
#define SECONDARY_IRTS_RL_3_FRAME_ID (0x5bfu)
#define SECONDARY_IRTS_RR_0_FRAME_ID (0x4b0u)
#define SECONDARY_IRTS_RR_1_FRAME_ID (0x4b1u)
#define SECONDARY_IRTS_RR_2_FRAME_ID (0x4b2u)
#define SECONDARY_IRTS_RR_3_FRAME_ID (0x4b3u)
#define SECONDARY_VEHICLE_POSITION_FRAME_ID (0x600u)
#define SECONDARY_VEHICLE_SPEED_FRAME_ID (0x608u)
#define SECONDARY_VEHICLE_CURVILINEAR_COORDINATES_FRAME_ID (0x610u)
#define SECONDARY_FRONT_ANGULAR_VELOCITY_FRAME_ID (0x618u)
#define SECONDARY_REAR_ANGULAR_VELOCITY_FRAME_ID (0x620u)
#define SECONDARY_HV_SOC_ESTIMATION_STATE_FRAME_ID (0x628u)
#define SECONDARY_HV_SOC_ESTIMATION_COVARIANCE_FRAME_ID (0x630u)
#define SECONDARY_LV_SOC_ESTIMATION_STATE_FRAME_ID (0x638u)
#define SECONDARY_LV_SOC_ESTIMATION_COVARIANCE_FRAME_ID (0x640u)
#define SECONDARY_PEDAL_THROTTLE_FRAME_ID (0x648u)
#define SECONDARY_PEDAL_BRAKES_PRESSURE_FRAME_ID (0x650u)
#define SECONDARY_STEER_ANGLE_FRAME_ID (0x658u)
#define SECONDARY_ODOMETER_FRAME_ID (0x660u)
#define SECONDARY_TPMS_PRESSURE_FRAME_ID (0x668u)
#define SECONDARY_TPMS_TEMPERATURE_FRAME_ID (0x670u)
#define SECONDARY_TLM_UNIX_TIMESTAMP_FRAME_ID (0x678u)
#define SECONDARY_TLM_LAP_TIME_FRAME_ID (0x680u)
#define SECONDARY_TLM_LAPS_STATS_FRAME_ID (0x688u)
#define SECONDARY_TLM_NETWORK_INTERFACE_FRAME_ID (0x690u)
#define SECONDARY_FRONT_AMMO_COMPRESSION_FRAME_ID (0x698u)
#define SECONDARY_REAR_AMMO_COMPRESSION_FRAME_ID (0x6a0u)
#define SECONDARY_ACQUISINATOR_CALIBRATIONS_OFFSETS_FRAME_ID (0x6a8u)
#define SECONDARY_ACQUISINATOR_ERRORS_FRAME_ID (0x6b0u)
#define SECONDARY_LINK_DEFORMATION_DEBUG_VOLTAGES_FRAME_ID (0x6b8u)
#define SECONDARY_LINK_DEFORMATION_FL_WHEEL_FRAME_ID (0x6c0u)
#define SECONDARY_LINK_DEFORMATION_FR_WHEEL_FRAME_ID (0x6c8u)
#define SECONDARY_LINK_DEFORMATION_RL_WHEEL_FRAME_ID (0x6d0u)
#define SECONDARY_LINK_DEFORMATION_RR_WHEEL_FRAME_ID (0x6d8u)
#define SECONDARY_LINK_DEFORMATION_SET_CALIBRATION_FRAME_ID (0x48u)
#define SECONDARY_AMMO_COMPRESSION_SET_CALIBRATION_FRAME_ID (0x50u)
#define SECONDARY_DEBUG_SIGNAL_5_FRAME_ID (0x6e0u)
#define SECONDARY_DEBUG_SIGNAL_6_FRAME_ID (0x6e8u)
#define SECONDARY_DEBUG_SIGNAL_7_FRAME_ID (0x6f0u)
#define SECONDARY_DEBUG_SIGNAL_8_FRAME_ID (0x6f8u)
#define SECONDARY_COOLING_TEMP_PUMPS_FRAME_ID (0x700u)
#define SECONDARY_COOLING_TEMP_RADIATORS_FRAME_ID (0x708u)
#define SECONDARY_LATERAL_CONTROLLER_PREVIEW_POINT_ERRORS_FRAME_ID (0x710u)
#define SECONDARY_LATERAL_CONTROLLER_ERRORS_FRAME_ID (0x718u)

/* Frame lengths in bytes. */
#define SECONDARY_ACQUISINATOR_JMP_TO_BLT_BYTE_SIZE (1u)
#define SECONDARY_ACQUISINATOR_FLASH_0_TX_BYTE_SIZE (0u)
#define SECONDARY_ACQUISINATOR_FLASH_0_RX_BYTE_SIZE (0u)
#define SECONDARY_ACQUISINATOR_FLASH_1_TX_BYTE_SIZE (0u)
#define SECONDARY_ACQUISINATOR_FLASH_1_RX_BYTE_SIZE (0u)
#define SECONDARY_ACQUISINATOR_FLASH_2_TX_BYTE_SIZE (0u)
#define SECONDARY_ACQUISINATOR_FLASH_2_RX_BYTE_SIZE (0u)
#define SECONDARY_ACQUISINATOR_FLASH_3_TX_BYTE_SIZE (0u)
#define SECONDARY_ACQUISINATOR_FLASH_3_RX_BYTE_SIZE (0u)
#define SECONDARY_ACQUISINATOR_FLASH_4_TX_BYTE_SIZE (0u)
#define SECONDARY_ACQUISINATOR_FLASH_4_RX_BYTE_SIZE (0u)
#define SECONDARY_ACQUISINATOR_FLASH_5_TX_BYTE_SIZE (0u)
#define SECONDARY_ACQUISINATOR_FLASH_5_RX_BYTE_SIZE (0u)
#define SECONDARY_ACQUISINATOR_FLASH_6_TX_BYTE_SIZE (0u)
#define SECONDARY_ACQUISINATOR_FLASH_6_RX_BYTE_SIZE (0u)
#define SECONDARY_ACQUISINATOR_FLASH_7_TX_BYTE_SIZE (0u)
#define SECONDARY_ACQUISINATOR_FLASH_7_RX_BYTE_SIZE (0u)
#define SECONDARY_ACQUISINATOR_FLASH_8_TX_BYTE_SIZE (0u)
#define SECONDARY_ACQUISINATOR_FLASH_8_RX_BYTE_SIZE (0u)
#define SECONDARY_ACQUISINATOR_FLASH_9_TX_BYTE_SIZE (0u)
#define SECONDARY_ACQUISINATOR_FLASH_9_RX_BYTE_SIZE (0u)
#define SECONDARY_ACQUISINATOR_FLASH_10_TX_BYTE_SIZE (0u)
#define SECONDARY_ACQUISINATOR_FLASH_10_RX_BYTE_SIZE (0u)
#define SECONDARY_ACQUISINATOR_FLASH_11_TX_BYTE_SIZE (0u)
#define SECONDARY_ACQUISINATOR_FLASH_11_RX_BYTE_SIZE (0u)
#define SECONDARY_ACQUISINATOR_FLASH_12_TX_BYTE_SIZE (0u)
#define SECONDARY_ACQUISINATOR_FLASH_12_RX_BYTE_SIZE (0u)
#define SECONDARY_ACQUISINATOR_FLASH_13_TX_BYTE_SIZE (0u)
#define SECONDARY_ACQUISINATOR_FLASH_13_RX_BYTE_SIZE (0u)
#define SECONDARY_ACQUISINATOR_FLASH_14_TX_BYTE_SIZE (0u)
#define SECONDARY_ACQUISINATOR_FLASH_14_RX_BYTE_SIZE (0u)
#define SECONDARY_ACQUISINATOR_FLASH_15_TX_BYTE_SIZE (0u)
#define SECONDARY_ACQUISINATOR_FLASH_15_RX_BYTE_SIZE (0u)
#define SECONDARY_ACQUISINATOR_FLASH_16_TX_BYTE_SIZE (0u)
#define SECONDARY_ACQUISINATOR_FLASH_16_RX_BYTE_SIZE (0u)
#define SECONDARY_ACQUISINATOR_FLASH_17_TX_BYTE_SIZE (0u)
#define SECONDARY_ACQUISINATOR_FLASH_17_RX_BYTE_SIZE (0u)
#define SECONDARY_ACQUISINATOR_FLASH_18_TX_BYTE_SIZE (0u)
#define SECONDARY_ACQUISINATOR_FLASH_18_RX_BYTE_SIZE (0u)
#define SECONDARY_ACQUISINATOR_FLASH_19_TX_BYTE_SIZE (0u)
#define SECONDARY_ACQUISINATOR_FLASH_19_RX_BYTE_SIZE (0u)
#define SECONDARY_ACQUISINATOR_FLASH_20_TX_BYTE_SIZE (0u)
#define SECONDARY_ACQUISINATOR_FLASH_20_RX_BYTE_SIZE (0u)
#define SECONDARY_ACQUISINATOR_FLASH_21_TX_BYTE_SIZE (0u)
#define SECONDARY_ACQUISINATOR_FLASH_21_RX_BYTE_SIZE (0u)
#define SECONDARY_ACQUISINATOR_FLASH_22_TX_BYTE_SIZE (0u)
#define SECONDARY_ACQUISINATOR_FLASH_22_RX_BYTE_SIZE (0u)
#define SECONDARY_ACQUISINATOR_FLASH_23_TX_BYTE_SIZE (0u)
#define SECONDARY_ACQUISINATOR_FLASH_23_RX_BYTE_SIZE (0u)
#define SECONDARY_ACQUISINATOR_FLASH_24_TX_BYTE_SIZE (0u)
#define SECONDARY_ACQUISINATOR_FLASH_24_RX_BYTE_SIZE (0u)
#define SECONDARY_ACQUISINATOR_FLASH_25_TX_BYTE_SIZE (0u)
#define SECONDARY_ACQUISINATOR_FLASH_25_RX_BYTE_SIZE (0u)
#define SECONDARY_ACQUISINATOR_FLASH_26_TX_BYTE_SIZE (0u)
#define SECONDARY_ACQUISINATOR_FLASH_26_RX_BYTE_SIZE (0u)
#define SECONDARY_ACQUISINATOR_FLASH_27_TX_BYTE_SIZE (0u)
#define SECONDARY_ACQUISINATOR_FLASH_27_RX_BYTE_SIZE (0u)
#define SECONDARY_ACQUISINATOR_FLASH_28_TX_BYTE_SIZE (0u)
#define SECONDARY_ACQUISINATOR_FLASH_28_RX_BYTE_SIZE (0u)
#define SECONDARY_ACQUISINATOR_FLASH_29_TX_BYTE_SIZE (0u)
#define SECONDARY_ACQUISINATOR_FLASH_29_RX_BYTE_SIZE (0u)
#define SECONDARY_ACQUISINATOR_FLASH_30_TX_BYTE_SIZE (0u)
#define SECONDARY_ACQUISINATOR_FLASH_30_RX_BYTE_SIZE (0u)
#define SECONDARY_ACQUISINATOR_FLASH_31_TX_BYTE_SIZE (0u)
#define SECONDARY_ACQUISINATOR_FLASH_31_RX_BYTE_SIZE (0u)
#define SECONDARY_ACQUISINATOR_VERSION_BYTE_SIZE (5u)
#define SECONDARY_IMU_ANGULAR_RATE_BYTE_SIZE (6u)
#define SECONDARY_IMU_ACCELERATION_BYTE_SIZE (8u)
#define SECONDARY_IRTS_FL_0_BYTE_SIZE (8u)
#define SECONDARY_IRTS_FL_1_BYTE_SIZE (8u)
#define SECONDARY_IRTS_FL_2_BYTE_SIZE (8u)
#define SECONDARY_IRTS_FL_3_BYTE_SIZE (8u)
#define SECONDARY_IRTS_FR_0_BYTE_SIZE (8u)
#define SECONDARY_IRTS_FR_1_BYTE_SIZE (8u)
#define SECONDARY_IRTS_FR_2_BYTE_SIZE (8u)
#define SECONDARY_IRTS_FR_3_BYTE_SIZE (8u)
#define SECONDARY_IRTS_RL_0_BYTE_SIZE (8u)
#define SECONDARY_IRTS_RL_1_BYTE_SIZE (8u)
#define SECONDARY_IRTS_RL_2_BYTE_SIZE (8u)
#define SECONDARY_IRTS_RL_3_BYTE_SIZE (8u)
#define SECONDARY_IRTS_RR_0_BYTE_SIZE (8u)
#define SECONDARY_IRTS_RR_1_BYTE_SIZE (8u)
#define SECONDARY_IRTS_RR_2_BYTE_SIZE (8u)
#define SECONDARY_IRTS_RR_3_BYTE_SIZE (8u)
#define SECONDARY_VEHICLE_POSITION_BYTE_SIZE (6u)
#define SECONDARY_VEHICLE_SPEED_BYTE_SIZE (4u)
#define SECONDARY_VEHICLE_CURVILINEAR_COORDINATES_BYTE_SIZE (6u)
#define SECONDARY_FRONT_ANGULAR_VELOCITY_BYTE_SIZE (4u)
#define SECONDARY_REAR_ANGULAR_VELOCITY_BYTE_SIZE (4u)
#define SECONDARY_HV_SOC_ESTIMATION_STATE_BYTE_SIZE (6u)
#define SECONDARY_HV_SOC_ESTIMATION_COVARIANCE_BYTE_SIZE (6u)
#define SECONDARY_LV_SOC_ESTIMATION_STATE_BYTE_SIZE (6u)
#define SECONDARY_LV_SOC_ESTIMATION_COVARIANCE_BYTE_SIZE (6u)
#define SECONDARY_PEDAL_THROTTLE_BYTE_SIZE (2u)
#define SECONDARY_PEDAL_BRAKES_PRESSURE_BYTE_SIZE (4u)
#define SECONDARY_STEER_ANGLE_BYTE_SIZE (4u)
#define SECONDARY_ODOMETER_BYTE_SIZE (4u)
#define SECONDARY_TPMS_PRESSURE_BYTE_SIZE (4u)
#define SECONDARY_TPMS_TEMPERATURE_BYTE_SIZE (4u)
#define SECONDARY_TLM_UNIX_TIMESTAMP_BYTE_SIZE (8u)
#define SECONDARY_TLM_LAP_TIME_BYTE_SIZE (4u)
#define SECONDARY_TLM_LAPS_STATS_BYTE_SIZE (6u)
#define SECONDARY_TLM_NETWORK_INTERFACE_BYTE_SIZE (8u)
#define SECONDARY_FRONT_AMMO_COMPRESSION_BYTE_SIZE (4u)
#define SECONDARY_REAR_AMMO_COMPRESSION_BYTE_SIZE (4u)
#define SECONDARY_ACQUISINATOR_CALIBRATIONS_OFFSETS_BYTE_SIZE (7u)
#define SECONDARY_ACQUISINATOR_ERRORS_BYTE_SIZE (2u)
#define SECONDARY_LINK_DEFORMATION_DEBUG_VOLTAGES_BYTE_SIZE (5u)
#define SECONDARY_LINK_DEFORMATION_FL_WHEEL_BYTE_SIZE (5u)
#define SECONDARY_LINK_DEFORMATION_FR_WHEEL_BYTE_SIZE (5u)
#define SECONDARY_LINK_DEFORMATION_RL_WHEEL_BYTE_SIZE (5u)
#define SECONDARY_LINK_DEFORMATION_RR_WHEEL_BYTE_SIZE (5u)
#define SECONDARY_LINK_DEFORMATION_SET_CALIBRATION_BYTE_SIZE (0u)
#define SECONDARY_AMMO_COMPRESSION_SET_CALIBRATION_BYTE_SIZE (0u)
#define SECONDARY_DEBUG_SIGNAL_5_BYTE_SIZE (7u)
#define SECONDARY_DEBUG_SIGNAL_6_BYTE_SIZE (7u)
#define SECONDARY_DEBUG_SIGNAL_7_BYTE_SIZE (7u)
#define SECONDARY_DEBUG_SIGNAL_8_BYTE_SIZE (7u)
#define SECONDARY_COOLING_TEMP_PUMPS_BYTE_SIZE (4u)
#define SECONDARY_COOLING_TEMP_RADIATORS_BYTE_SIZE (2u)
#define SECONDARY_LATERAL_CONTROLLER_PREVIEW_POINT_ERRORS_BYTE_SIZE (4u)
#define SECONDARY_LATERAL_CONTROLLER_ERRORS_BYTE_SIZE (2u)

/* Extended or standard frame types. */
#define SECONDARY_ACQUISINATOR_JMP_TO_BLT_IS_EXTENDED (0)
#define SECONDARY_ACQUISINATOR_FLASH_0_TX_IS_EXTENDED (0)
#define SECONDARY_ACQUISINATOR_FLASH_0_RX_IS_EXTENDED (0)
#define SECONDARY_ACQUISINATOR_FLASH_1_TX_IS_EXTENDED (0)
#define SECONDARY_ACQUISINATOR_FLASH_1_RX_IS_EXTENDED (0)
#define SECONDARY_ACQUISINATOR_FLASH_2_TX_IS_EXTENDED (0)
#define SECONDARY_ACQUISINATOR_FLASH_2_RX_IS_EXTENDED (0)
#define SECONDARY_ACQUISINATOR_FLASH_3_TX_IS_EXTENDED (0)
#define SECONDARY_ACQUISINATOR_FLASH_3_RX_IS_EXTENDED (0)
#define SECONDARY_ACQUISINATOR_FLASH_4_TX_IS_EXTENDED (0)
#define SECONDARY_ACQUISINATOR_FLASH_4_RX_IS_EXTENDED (0)
#define SECONDARY_ACQUISINATOR_FLASH_5_TX_IS_EXTENDED (0)
#define SECONDARY_ACQUISINATOR_FLASH_5_RX_IS_EXTENDED (0)
#define SECONDARY_ACQUISINATOR_FLASH_6_TX_IS_EXTENDED (0)
#define SECONDARY_ACQUISINATOR_FLASH_6_RX_IS_EXTENDED (0)
#define SECONDARY_ACQUISINATOR_FLASH_7_TX_IS_EXTENDED (0)
#define SECONDARY_ACQUISINATOR_FLASH_7_RX_IS_EXTENDED (0)
#define SECONDARY_ACQUISINATOR_FLASH_8_TX_IS_EXTENDED (0)
#define SECONDARY_ACQUISINATOR_FLASH_8_RX_IS_EXTENDED (0)
#define SECONDARY_ACQUISINATOR_FLASH_9_TX_IS_EXTENDED (0)
#define SECONDARY_ACQUISINATOR_FLASH_9_RX_IS_EXTENDED (0)
#define SECONDARY_ACQUISINATOR_FLASH_10_TX_IS_EXTENDED (0)
#define SECONDARY_ACQUISINATOR_FLASH_10_RX_IS_EXTENDED (0)
#define SECONDARY_ACQUISINATOR_FLASH_11_TX_IS_EXTENDED (0)
#define SECONDARY_ACQUISINATOR_FLASH_11_RX_IS_EXTENDED (0)
#define SECONDARY_ACQUISINATOR_FLASH_12_TX_IS_EXTENDED (0)
#define SECONDARY_ACQUISINATOR_FLASH_12_RX_IS_EXTENDED (0)
#define SECONDARY_ACQUISINATOR_FLASH_13_TX_IS_EXTENDED (0)
#define SECONDARY_ACQUISINATOR_FLASH_13_RX_IS_EXTENDED (0)
#define SECONDARY_ACQUISINATOR_FLASH_14_TX_IS_EXTENDED (0)
#define SECONDARY_ACQUISINATOR_FLASH_14_RX_IS_EXTENDED (0)
#define SECONDARY_ACQUISINATOR_FLASH_15_TX_IS_EXTENDED (0)
#define SECONDARY_ACQUISINATOR_FLASH_15_RX_IS_EXTENDED (0)
#define SECONDARY_ACQUISINATOR_FLASH_16_TX_IS_EXTENDED (0)
#define SECONDARY_ACQUISINATOR_FLASH_16_RX_IS_EXTENDED (0)
#define SECONDARY_ACQUISINATOR_FLASH_17_TX_IS_EXTENDED (0)
#define SECONDARY_ACQUISINATOR_FLASH_17_RX_IS_EXTENDED (0)
#define SECONDARY_ACQUISINATOR_FLASH_18_TX_IS_EXTENDED (0)
#define SECONDARY_ACQUISINATOR_FLASH_18_RX_IS_EXTENDED (0)
#define SECONDARY_ACQUISINATOR_FLASH_19_TX_IS_EXTENDED (0)
#define SECONDARY_ACQUISINATOR_FLASH_19_RX_IS_EXTENDED (0)
#define SECONDARY_ACQUISINATOR_FLASH_20_TX_IS_EXTENDED (0)
#define SECONDARY_ACQUISINATOR_FLASH_20_RX_IS_EXTENDED (0)
#define SECONDARY_ACQUISINATOR_FLASH_21_TX_IS_EXTENDED (0)
#define SECONDARY_ACQUISINATOR_FLASH_21_RX_IS_EXTENDED (0)
#define SECONDARY_ACQUISINATOR_FLASH_22_TX_IS_EXTENDED (0)
#define SECONDARY_ACQUISINATOR_FLASH_22_RX_IS_EXTENDED (0)
#define SECONDARY_ACQUISINATOR_FLASH_23_TX_IS_EXTENDED (0)
#define SECONDARY_ACQUISINATOR_FLASH_23_RX_IS_EXTENDED (0)
#define SECONDARY_ACQUISINATOR_FLASH_24_TX_IS_EXTENDED (0)
#define SECONDARY_ACQUISINATOR_FLASH_24_RX_IS_EXTENDED (0)
#define SECONDARY_ACQUISINATOR_FLASH_25_TX_IS_EXTENDED (0)
#define SECONDARY_ACQUISINATOR_FLASH_25_RX_IS_EXTENDED (0)
#define SECONDARY_ACQUISINATOR_FLASH_26_TX_IS_EXTENDED (0)
#define SECONDARY_ACQUISINATOR_FLASH_26_RX_IS_EXTENDED (0)
#define SECONDARY_ACQUISINATOR_FLASH_27_TX_IS_EXTENDED (0)
#define SECONDARY_ACQUISINATOR_FLASH_27_RX_IS_EXTENDED (0)
#define SECONDARY_ACQUISINATOR_FLASH_28_TX_IS_EXTENDED (0)
#define SECONDARY_ACQUISINATOR_FLASH_28_RX_IS_EXTENDED (0)
#define SECONDARY_ACQUISINATOR_FLASH_29_TX_IS_EXTENDED (0)
#define SECONDARY_ACQUISINATOR_FLASH_29_RX_IS_EXTENDED (0)
#define SECONDARY_ACQUISINATOR_FLASH_30_TX_IS_EXTENDED (0)
#define SECONDARY_ACQUISINATOR_FLASH_30_RX_IS_EXTENDED (0)
#define SECONDARY_ACQUISINATOR_FLASH_31_TX_IS_EXTENDED (0)
#define SECONDARY_ACQUISINATOR_FLASH_31_RX_IS_EXTENDED (0)
#define SECONDARY_ACQUISINATOR_VERSION_IS_EXTENDED (0)
#define SECONDARY_IMU_ANGULAR_RATE_IS_EXTENDED (0)
#define SECONDARY_IMU_ACCELERATION_IS_EXTENDED (0)
#define SECONDARY_IRTS_FL_0_IS_EXTENDED (0)
#define SECONDARY_IRTS_FL_1_IS_EXTENDED (0)
#define SECONDARY_IRTS_FL_2_IS_EXTENDED (0)
#define SECONDARY_IRTS_FL_3_IS_EXTENDED (0)
#define SECONDARY_IRTS_FR_0_IS_EXTENDED (0)
#define SECONDARY_IRTS_FR_1_IS_EXTENDED (0)
#define SECONDARY_IRTS_FR_2_IS_EXTENDED (0)
#define SECONDARY_IRTS_FR_3_IS_EXTENDED (0)
#define SECONDARY_IRTS_RL_0_IS_EXTENDED (0)
#define SECONDARY_IRTS_RL_1_IS_EXTENDED (0)
#define SECONDARY_IRTS_RL_2_IS_EXTENDED (0)
#define SECONDARY_IRTS_RL_3_IS_EXTENDED (0)
#define SECONDARY_IRTS_RR_0_IS_EXTENDED (0)
#define SECONDARY_IRTS_RR_1_IS_EXTENDED (0)
#define SECONDARY_IRTS_RR_2_IS_EXTENDED (0)
#define SECONDARY_IRTS_RR_3_IS_EXTENDED (0)
#define SECONDARY_VEHICLE_POSITION_IS_EXTENDED (0)
#define SECONDARY_VEHICLE_SPEED_IS_EXTENDED (0)
#define SECONDARY_VEHICLE_CURVILINEAR_COORDINATES_IS_EXTENDED (0)
#define SECONDARY_FRONT_ANGULAR_VELOCITY_IS_EXTENDED (0)
#define SECONDARY_REAR_ANGULAR_VELOCITY_IS_EXTENDED (0)
#define SECONDARY_HV_SOC_ESTIMATION_STATE_IS_EXTENDED (0)
#define SECONDARY_HV_SOC_ESTIMATION_COVARIANCE_IS_EXTENDED (0)
#define SECONDARY_LV_SOC_ESTIMATION_STATE_IS_EXTENDED (0)
#define SECONDARY_LV_SOC_ESTIMATION_COVARIANCE_IS_EXTENDED (0)
#define SECONDARY_PEDAL_THROTTLE_IS_EXTENDED (0)
#define SECONDARY_PEDAL_BRAKES_PRESSURE_IS_EXTENDED (0)
#define SECONDARY_STEER_ANGLE_IS_EXTENDED (0)
#define SECONDARY_ODOMETER_IS_EXTENDED (0)
#define SECONDARY_TPMS_PRESSURE_IS_EXTENDED (0)
#define SECONDARY_TPMS_TEMPERATURE_IS_EXTENDED (0)
#define SECONDARY_TLM_UNIX_TIMESTAMP_IS_EXTENDED (0)
#define SECONDARY_TLM_LAP_TIME_IS_EXTENDED (0)
#define SECONDARY_TLM_LAPS_STATS_IS_EXTENDED (0)
#define SECONDARY_TLM_NETWORK_INTERFACE_IS_EXTENDED (0)
#define SECONDARY_FRONT_AMMO_COMPRESSION_IS_EXTENDED (0)
#define SECONDARY_REAR_AMMO_COMPRESSION_IS_EXTENDED (0)
#define SECONDARY_ACQUISINATOR_CALIBRATIONS_OFFSETS_IS_EXTENDED (0)
#define SECONDARY_ACQUISINATOR_ERRORS_IS_EXTENDED (0)
#define SECONDARY_LINK_DEFORMATION_DEBUG_VOLTAGES_IS_EXTENDED (0)
#define SECONDARY_LINK_DEFORMATION_FL_WHEEL_IS_EXTENDED (0)
#define SECONDARY_LINK_DEFORMATION_FR_WHEEL_IS_EXTENDED (0)
#define SECONDARY_LINK_DEFORMATION_RL_WHEEL_IS_EXTENDED (0)
#define SECONDARY_LINK_DEFORMATION_RR_WHEEL_IS_EXTENDED (0)
#define SECONDARY_LINK_DEFORMATION_SET_CALIBRATION_IS_EXTENDED (0)
#define SECONDARY_AMMO_COMPRESSION_SET_CALIBRATION_IS_EXTENDED (0)
#define SECONDARY_DEBUG_SIGNAL_5_IS_EXTENDED (0)
#define SECONDARY_DEBUG_SIGNAL_6_IS_EXTENDED (0)
#define SECONDARY_DEBUG_SIGNAL_7_IS_EXTENDED (0)
#define SECONDARY_DEBUG_SIGNAL_8_IS_EXTENDED (0)
#define SECONDARY_COOLING_TEMP_PUMPS_IS_EXTENDED (0)
#define SECONDARY_COOLING_TEMP_RADIATORS_IS_EXTENDED (0)
#define SECONDARY_LATERAL_CONTROLLER_PREVIEW_POINT_ERRORS_IS_EXTENDED (0)
#define SECONDARY_LATERAL_CONTROLLER_ERRORS_IS_EXTENDED (0)

/* Frame cycle times in milliseconds. */
#define SECONDARY_ACQUISINATOR_VERSION_CYCLE_TIME_MS (1000u)
#define SECONDARY_VEHICLE_POSITION_CYCLE_TIME_MS (10u)
#define SECONDARY_VEHICLE_SPEED_CYCLE_TIME_MS (10u)
#define SECONDARY_VEHICLE_CURVILINEAR_COORDINATES_CYCLE_TIME_MS (10u)
#define SECONDARY_FRONT_ANGULAR_VELOCITY_CYCLE_TIME_MS (10u)
#define SECONDARY_REAR_ANGULAR_VELOCITY_CYCLE_TIME_MS (10u)
#define SECONDARY_HV_SOC_ESTIMATION_STATE_CYCLE_TIME_MS (50u)
#define SECONDARY_HV_SOC_ESTIMATION_COVARIANCE_CYCLE_TIME_MS (50u)
#define SECONDARY_LV_SOC_ESTIMATION_STATE_CYCLE_TIME_MS (50u)
#define SECONDARY_LV_SOC_ESTIMATION_COVARIANCE_CYCLE_TIME_MS (50u)
#define SECONDARY_PEDAL_THROTTLE_CYCLE_TIME_MS (10u)
#define SECONDARY_PEDAL_BRAKES_PRESSURE_CYCLE_TIME_MS (10u)
#define SECONDARY_STEER_ANGLE_CYCLE_TIME_MS (10u)
#define SECONDARY_ODOMETER_CYCLE_TIME_MS (1000u)
#define SECONDARY_TLM_UNIX_TIMESTAMP_CYCLE_TIME_MS (1000u)
#define SECONDARY_TLM_LAPS_STATS_CYCLE_TIME_MS (1000u)
#define SECONDARY_TLM_NETWORK_INTERFACE_CYCLE_TIME_MS (1000u)
#define SECONDARY_FRONT_AMMO_COMPRESSION_CYCLE_TIME_MS (10u)
#define SECONDARY_REAR_AMMO_COMPRESSION_CYCLE_TIME_MS (10u)
#define SECONDARY_ACQUISINATOR_CALIBRATIONS_OFFSETS_CYCLE_TIME_MS (1000u)
#define SECONDARY_ACQUISINATOR_ERRORS_CYCLE_TIME_MS (1000u)
#define SECONDARY_LINK_DEFORMATION_DEBUG_VOLTAGES_CYCLE_TIME_MS (10u)
#define SECONDARY_LINK_DEFORMATION_FL_WHEEL_CYCLE_TIME_MS (10u)
#define SECONDARY_LINK_DEFORMATION_FR_WHEEL_CYCLE_TIME_MS (10u)
#define SECONDARY_LINK_DEFORMATION_RL_WHEEL_CYCLE_TIME_MS (10u)
#define SECONDARY_LINK_DEFORMATION_RR_WHEEL_CYCLE_TIME_MS (10u)
#define SECONDARY_DEBUG_SIGNAL_5_CYCLE_TIME_MS (10u)
#define SECONDARY_DEBUG_SIGNAL_6_CYCLE_TIME_MS (10u)
#define SECONDARY_DEBUG_SIGNAL_7_CYCLE_TIME_MS (10u)
#define SECONDARY_DEBUG_SIGNAL_8_CYCLE_TIME_MS (10u)
#define SECONDARY_COOLING_TEMP_PUMPS_CYCLE_TIME_MS (500u)
#define SECONDARY_COOLING_TEMP_RADIATORS_CYCLE_TIME_MS (500u)
#define SECONDARY_LATERAL_CONTROLLER_PREVIEW_POINT_ERRORS_CYCLE_TIME_MS (50u)
#define SECONDARY_LATERAL_CONTROLLER_ERRORS_CYCLE_TIME_MS (50u)
#define SECONDARY_ACQUISINATOR_JMP_TO_BLT_CYCLE_TIME_MS (SECONDARY_ONESHOT)
#define SECONDARY_ACQUISINATOR_FLASH_0_TX_CYCLE_TIME_MS (SECONDARY_ONESHOT)
#define SECONDARY_ACQUISINATOR_FLASH_0_RX_CYCLE_TIME_MS (SECONDARY_ONESHOT)
#define SECONDARY_ACQUISINATOR_FLASH_1_TX_CYCLE_TIME_MS (SECONDARY_ONESHOT)
#define SECONDARY_ACQUISINATOR_FLASH_1_RX_CYCLE_TIME_MS (SECONDARY_ONESHOT)
#define SECONDARY_ACQUISINATOR_FLASH_2_TX_CYCLE_TIME_MS (SECONDARY_ONESHOT)
#define SECONDARY_ACQUISINATOR_FLASH_2_RX_CYCLE_TIME_MS (SECONDARY_ONESHOT)
#define SECONDARY_ACQUISINATOR_FLASH_3_TX_CYCLE_TIME_MS (SECONDARY_ONESHOT)
#define SECONDARY_ACQUISINATOR_FLASH_3_RX_CYCLE_TIME_MS (SECONDARY_ONESHOT)
#define SECONDARY_ACQUISINATOR_FLASH_4_TX_CYCLE_TIME_MS (SECONDARY_ONESHOT)
#define SECONDARY_ACQUISINATOR_FLASH_4_RX_CYCLE_TIME_MS (SECONDARY_ONESHOT)
#define SECONDARY_ACQUISINATOR_FLASH_5_TX_CYCLE_TIME_MS (SECONDARY_ONESHOT)
#define SECONDARY_ACQUISINATOR_FLASH_5_RX_CYCLE_TIME_MS (SECONDARY_ONESHOT)
#define SECONDARY_ACQUISINATOR_FLASH_6_TX_CYCLE_TIME_MS (SECONDARY_ONESHOT)
#define SECONDARY_ACQUISINATOR_FLASH_6_RX_CYCLE_TIME_MS (SECONDARY_ONESHOT)
#define SECONDARY_ACQUISINATOR_FLASH_7_TX_CYCLE_TIME_MS (SECONDARY_ONESHOT)
#define SECONDARY_ACQUISINATOR_FLASH_7_RX_CYCLE_TIME_MS (SECONDARY_ONESHOT)
#define SECONDARY_ACQUISINATOR_FLASH_8_TX_CYCLE_TIME_MS (SECONDARY_ONESHOT)
#define SECONDARY_ACQUISINATOR_FLASH_8_RX_CYCLE_TIME_MS (SECONDARY_ONESHOT)
#define SECONDARY_ACQUISINATOR_FLASH_9_TX_CYCLE_TIME_MS (SECONDARY_ONESHOT)
#define SECONDARY_ACQUISINATOR_FLASH_9_RX_CYCLE_TIME_MS (SECONDARY_ONESHOT)
#define SECONDARY_ACQUISINATOR_FLASH_10_TX_CYCLE_TIME_MS (SECONDARY_ONESHOT)
#define SECONDARY_ACQUISINATOR_FLASH_10_RX_CYCLE_TIME_MS (SECONDARY_ONESHOT)
#define SECONDARY_ACQUISINATOR_FLASH_11_TX_CYCLE_TIME_MS (SECONDARY_ONESHOT)
#define SECONDARY_ACQUISINATOR_FLASH_11_RX_CYCLE_TIME_MS (SECONDARY_ONESHOT)
#define SECONDARY_ACQUISINATOR_FLASH_12_TX_CYCLE_TIME_MS (SECONDARY_ONESHOT)
#define SECONDARY_ACQUISINATOR_FLASH_12_RX_CYCLE_TIME_MS (SECONDARY_ONESHOT)
#define SECONDARY_ACQUISINATOR_FLASH_13_TX_CYCLE_TIME_MS (SECONDARY_ONESHOT)
#define SECONDARY_ACQUISINATOR_FLASH_13_RX_CYCLE_TIME_MS (SECONDARY_ONESHOT)
#define SECONDARY_ACQUISINATOR_FLASH_14_TX_CYCLE_TIME_MS (SECONDARY_ONESHOT)
#define SECONDARY_ACQUISINATOR_FLASH_14_RX_CYCLE_TIME_MS (SECONDARY_ONESHOT)
#define SECONDARY_ACQUISINATOR_FLASH_15_TX_CYCLE_TIME_MS (SECONDARY_ONESHOT)
#define SECONDARY_ACQUISINATOR_FLASH_15_RX_CYCLE_TIME_MS (SECONDARY_ONESHOT)
#define SECONDARY_ACQUISINATOR_FLASH_16_TX_CYCLE_TIME_MS (SECONDARY_ONESHOT)
#define SECONDARY_ACQUISINATOR_FLASH_16_RX_CYCLE_TIME_MS (SECONDARY_ONESHOT)
#define SECONDARY_ACQUISINATOR_FLASH_17_TX_CYCLE_TIME_MS (SECONDARY_ONESHOT)
#define SECONDARY_ACQUISINATOR_FLASH_17_RX_CYCLE_TIME_MS (SECONDARY_ONESHOT)
#define SECONDARY_ACQUISINATOR_FLASH_18_TX_CYCLE_TIME_MS (SECONDARY_ONESHOT)
#define SECONDARY_ACQUISINATOR_FLASH_18_RX_CYCLE_TIME_MS (SECONDARY_ONESHOT)
#define SECONDARY_ACQUISINATOR_FLASH_19_TX_CYCLE_TIME_MS (SECONDARY_ONESHOT)
#define SECONDARY_ACQUISINATOR_FLASH_19_RX_CYCLE_TIME_MS (SECONDARY_ONESHOT)
#define SECONDARY_ACQUISINATOR_FLASH_20_TX_CYCLE_TIME_MS (SECONDARY_ONESHOT)
#define SECONDARY_ACQUISINATOR_FLASH_20_RX_CYCLE_TIME_MS (SECONDARY_ONESHOT)
#define SECONDARY_ACQUISINATOR_FLASH_21_TX_CYCLE_TIME_MS (SECONDARY_ONESHOT)
#define SECONDARY_ACQUISINATOR_FLASH_21_RX_CYCLE_TIME_MS (SECONDARY_ONESHOT)
#define SECONDARY_ACQUISINATOR_FLASH_22_TX_CYCLE_TIME_MS (SECONDARY_ONESHOT)
#define SECONDARY_ACQUISINATOR_FLASH_22_RX_CYCLE_TIME_MS (SECONDARY_ONESHOT)
#define SECONDARY_ACQUISINATOR_FLASH_23_TX_CYCLE_TIME_MS (SECONDARY_ONESHOT)
#define SECONDARY_ACQUISINATOR_FLASH_23_RX_CYCLE_TIME_MS (SECONDARY_ONESHOT)
#define SECONDARY_ACQUISINATOR_FLASH_24_TX_CYCLE_TIME_MS (SECONDARY_ONESHOT)
#define SECONDARY_ACQUISINATOR_FLASH_24_RX_CYCLE_TIME_MS (SECONDARY_ONESHOT)
#define SECONDARY_ACQUISINATOR_FLASH_25_TX_CYCLE_TIME_MS (SECONDARY_ONESHOT)
#define SECONDARY_ACQUISINATOR_FLASH_25_RX_CYCLE_TIME_MS (SECONDARY_ONESHOT)
#define SECONDARY_ACQUISINATOR_FLASH_26_TX_CYCLE_TIME_MS (SECONDARY_ONESHOT)
#define SECONDARY_ACQUISINATOR_FLASH_26_RX_CYCLE_TIME_MS (SECONDARY_ONESHOT)
#define SECONDARY_ACQUISINATOR_FLASH_27_TX_CYCLE_TIME_MS (SECONDARY_ONESHOT)
#define SECONDARY_ACQUISINATOR_FLASH_27_RX_CYCLE_TIME_MS (SECONDARY_ONESHOT)
#define SECONDARY_ACQUISINATOR_FLASH_28_TX_CYCLE_TIME_MS (SECONDARY_ONESHOT)
#define SECONDARY_ACQUISINATOR_FLASH_28_RX_CYCLE_TIME_MS (SECONDARY_ONESHOT)
#define SECONDARY_ACQUISINATOR_FLASH_29_TX_CYCLE_TIME_MS (SECONDARY_ONESHOT)
#define SECONDARY_ACQUISINATOR_FLASH_29_RX_CYCLE_TIME_MS (SECONDARY_ONESHOT)
#define SECONDARY_ACQUISINATOR_FLASH_30_TX_CYCLE_TIME_MS (SECONDARY_ONESHOT)
#define SECONDARY_ACQUISINATOR_FLASH_30_RX_CYCLE_TIME_MS (SECONDARY_ONESHOT)
#define SECONDARY_ACQUISINATOR_FLASH_31_TX_CYCLE_TIME_MS (SECONDARY_ONESHOT)
#define SECONDARY_ACQUISINATOR_FLASH_31_RX_CYCLE_TIME_MS (SECONDARY_ONESHOT)
#define SECONDARY_IMU_ANGULAR_RATE_CYCLE_TIME_MS (SECONDARY_ONESHOT)
#define SECONDARY_IMU_ACCELERATION_CYCLE_TIME_MS (SECONDARY_ONESHOT)
#define SECONDARY_IRTS_FL_0_CYCLE_TIME_MS (SECONDARY_ONESHOT)
#define SECONDARY_IRTS_FL_1_CYCLE_TIME_MS (SECONDARY_ONESHOT)
#define SECONDARY_IRTS_FL_2_CYCLE_TIME_MS (SECONDARY_ONESHOT)
#define SECONDARY_IRTS_FL_3_CYCLE_TIME_MS (SECONDARY_ONESHOT)
#define SECONDARY_IRTS_FR_0_CYCLE_TIME_MS (SECONDARY_ONESHOT)
#define SECONDARY_IRTS_FR_1_CYCLE_TIME_MS (SECONDARY_ONESHOT)
#define SECONDARY_IRTS_FR_2_CYCLE_TIME_MS (SECONDARY_ONESHOT)
#define SECONDARY_IRTS_FR_3_CYCLE_TIME_MS (SECONDARY_ONESHOT)
#define SECONDARY_IRTS_RL_0_CYCLE_TIME_MS (SECONDARY_ONESHOT)
#define SECONDARY_IRTS_RL_1_CYCLE_TIME_MS (SECONDARY_ONESHOT)
#define SECONDARY_IRTS_RL_2_CYCLE_TIME_MS (SECONDARY_ONESHOT)
#define SECONDARY_IRTS_RL_3_CYCLE_TIME_MS (SECONDARY_ONESHOT)
#define SECONDARY_IRTS_RR_0_CYCLE_TIME_MS (SECONDARY_ONESHOT)
#define SECONDARY_IRTS_RR_1_CYCLE_TIME_MS (SECONDARY_ONESHOT)
#define SECONDARY_IRTS_RR_2_CYCLE_TIME_MS (SECONDARY_ONESHOT)
#define SECONDARY_IRTS_RR_3_CYCLE_TIME_MS (SECONDARY_ONESHOT)
#define SECONDARY_TPMS_PRESSURE_CYCLE_TIME_MS (SECONDARY_ONESHOT)
#define SECONDARY_TPMS_TEMPERATURE_CYCLE_TIME_MS (SECONDARY_ONESHOT)
#define SECONDARY_TLM_LAP_TIME_CYCLE_TIME_MS (SECONDARY_ONESHOT)
#define SECONDARY_LINK_DEFORMATION_SET_CALIBRATION_CYCLE_TIME_MS (SECONDARY_ONESHOT)
#define SECONDARY_AMMO_COMPRESSION_SET_CALIBRATION_CYCLE_TIME_MS (SECONDARY_ONESHOT)

/* Topics masks */
/* TOPIC FIXED_IDS */
#define SECONDARY_TOPIC_MASK_FIXED_IDS 0b00000011111

#define SECONDARY_ID_ACQUISINATOR_JMP_TO_BLT 0x0 // dec: 0 bin: 0b00000000000
#define SECONDARY_ID_ACQUISINATOR_FLASH_0_TX 0x1 // dec: 1 bin: 0b00000000001
#define SECONDARY_ID_ACQUISINATOR_FLASH_0_RX 0x2 // dec: 2 bin: 0b00000000010
#define SECONDARY_ID_ACQUISINATOR_FLASH_1_TX 0x3 // dec: 3 bin: 0b00000000011
#define SECONDARY_ID_ACQUISINATOR_FLASH_1_RX 0x4 // dec: 4 bin: 0b00000000100
#define SECONDARY_ID_ACQUISINATOR_FLASH_2_TX 0x5 // dec: 5 bin: 0b00000000101
#define SECONDARY_ID_ACQUISINATOR_FLASH_2_RX 0x6 // dec: 6 bin: 0b00000000110
#define SECONDARY_ID_ACQUISINATOR_FLASH_3_TX 0x7 // dec: 7 bin: 0b00000000111
#define SECONDARY_ID_ACQUISINATOR_FLASH_3_RX 0x8 // dec: 8 bin: 0b00000001000
#define SECONDARY_ID_ACQUISINATOR_FLASH_4_TX 0x9 // dec: 9 bin: 0b00000001001
#define SECONDARY_ID_ACQUISINATOR_FLASH_4_RX 0xA // dec: 10 bin: 0b00000001010
#define SECONDARY_ID_ACQUISINATOR_FLASH_5_TX 0xB // dec: 11 bin: 0b00000001011
#define SECONDARY_ID_ACQUISINATOR_FLASH_5_RX 0xC // dec: 12 bin: 0b00000001100
#define SECONDARY_ID_ACQUISINATOR_FLASH_6_TX 0xD // dec: 13 bin: 0b00000001101
#define SECONDARY_ID_ACQUISINATOR_FLASH_6_RX 0xE // dec: 14 bin: 0b00000001110
#define SECONDARY_ID_ACQUISINATOR_FLASH_7_TX 0xF // dec: 15 bin: 0b00000001111
#define SECONDARY_ID_ACQUISINATOR_FLASH_7_RX 0x10 // dec: 16 bin: 0b00000010000
#define SECONDARY_ID_ACQUISINATOR_FLASH_8_TX 0x11 // dec: 17 bin: 0b00000010001
#define SECONDARY_ID_ACQUISINATOR_FLASH_8_RX 0x12 // dec: 18 bin: 0b00000010010
#define SECONDARY_ID_ACQUISINATOR_FLASH_9_TX 0x13 // dec: 19 bin: 0b00000010011
#define SECONDARY_ID_ACQUISINATOR_FLASH_9_RX 0x14 // dec: 20 bin: 0b00000010100
#define SECONDARY_ID_ACQUISINATOR_FLASH_10_TX 0x15 // dec: 21 bin: 0b00000010101
#define SECONDARY_ID_ACQUISINATOR_FLASH_10_RX 0x16 // dec: 22 bin: 0b00000010110
#define SECONDARY_ID_ACQUISINATOR_FLASH_11_TX 0x17 // dec: 23 bin: 0b00000010111
#define SECONDARY_ID_ACQUISINATOR_FLASH_11_RX 0x18 // dec: 24 bin: 0b00000011000
#define SECONDARY_ID_ACQUISINATOR_FLASH_12_TX 0x19 // dec: 25 bin: 0b00000011001
#define SECONDARY_ID_ACQUISINATOR_FLASH_12_RX 0x1A // dec: 26 bin: 0b00000011010
#define SECONDARY_ID_ACQUISINATOR_FLASH_13_TX 0x1B // dec: 27 bin: 0b00000011011
#define SECONDARY_ID_ACQUISINATOR_FLASH_13_RX 0x1C // dec: 28 bin: 0b00000011100
#define SECONDARY_ID_ACQUISINATOR_FLASH_14_TX 0x1D // dec: 29 bin: 0b00000011101
#define SECONDARY_ID_ACQUISINATOR_FLASH_14_RX 0x1E // dec: 30 bin: 0b00000011110
#define SECONDARY_ID_ACQUISINATOR_FLASH_15_TX 0x1F // dec: 31 bin: 0b00000011111
#define SECONDARY_ID_ACQUISINATOR_FLASH_15_RX 0x20 // dec: 32 bin: 0b00000100000
#define SECONDARY_ID_ACQUISINATOR_FLASH_16_TX 0x21 // dec: 33 bin: 0b00000100001
#define SECONDARY_ID_ACQUISINATOR_FLASH_16_RX 0x22 // dec: 34 bin: 0b00000100010
#define SECONDARY_ID_ACQUISINATOR_FLASH_17_TX 0x23 // dec: 35 bin: 0b00000100011
#define SECONDARY_ID_ACQUISINATOR_FLASH_17_RX 0x24 // dec: 36 bin: 0b00000100100
#define SECONDARY_ID_ACQUISINATOR_FLASH_18_TX 0x25 // dec: 37 bin: 0b00000100101
#define SECONDARY_ID_ACQUISINATOR_FLASH_18_RX 0x26 // dec: 38 bin: 0b00000100110
#define SECONDARY_ID_ACQUISINATOR_FLASH_19_TX 0x27 // dec: 39 bin: 0b00000100111
#define SECONDARY_ID_ACQUISINATOR_FLASH_19_RX 0x28 // dec: 40 bin: 0b00000101000
#define SECONDARY_ID_ACQUISINATOR_FLASH_20_TX 0x29 // dec: 41 bin: 0b00000101001
#define SECONDARY_ID_ACQUISINATOR_FLASH_20_RX 0x2A // dec: 42 bin: 0b00000101010
#define SECONDARY_ID_ACQUISINATOR_FLASH_21_TX 0x2B // dec: 43 bin: 0b00000101011
#define SECONDARY_ID_ACQUISINATOR_FLASH_21_RX 0x2C // dec: 44 bin: 0b00000101100
#define SECONDARY_ID_ACQUISINATOR_FLASH_22_TX 0x2D // dec: 45 bin: 0b00000101101
#define SECONDARY_ID_ACQUISINATOR_FLASH_22_RX 0x2E // dec: 46 bin: 0b00000101110
#define SECONDARY_ID_ACQUISINATOR_FLASH_23_TX 0x2F // dec: 47 bin: 0b00000101111
#define SECONDARY_ID_ACQUISINATOR_FLASH_23_RX 0x30 // dec: 48 bin: 0b00000110000
#define SECONDARY_ID_ACQUISINATOR_FLASH_24_TX 0x31 // dec: 49 bin: 0b00000110001
#define SECONDARY_ID_ACQUISINATOR_FLASH_24_RX 0x32 // dec: 50 bin: 0b00000110010
#define SECONDARY_ID_ACQUISINATOR_FLASH_25_TX 0x33 // dec: 51 bin: 0b00000110011
#define SECONDARY_ID_ACQUISINATOR_FLASH_25_RX 0x34 // dec: 52 bin: 0b00000110100
#define SECONDARY_ID_ACQUISINATOR_FLASH_26_TX 0x35 // dec: 53 bin: 0b00000110101
#define SECONDARY_ID_ACQUISINATOR_FLASH_26_RX 0x36 // dec: 54 bin: 0b00000110110
#define SECONDARY_ID_ACQUISINATOR_FLASH_27_TX 0x37 // dec: 55 bin: 0b00000110111
#define SECONDARY_ID_ACQUISINATOR_FLASH_27_RX 0x38 // dec: 56 bin: 0b00000111000
#define SECONDARY_ID_ACQUISINATOR_FLASH_28_TX 0x39 // dec: 57 bin: 0b00000111001
#define SECONDARY_ID_ACQUISINATOR_FLASH_28_RX 0x3A // dec: 58 bin: 0b00000111010
#define SECONDARY_ID_ACQUISINATOR_FLASH_29_TX 0x3B // dec: 59 bin: 0b00000111011
#define SECONDARY_ID_ACQUISINATOR_FLASH_29_RX 0x3C // dec: 60 bin: 0b00000111100
#define SECONDARY_ID_ACQUISINATOR_FLASH_30_TX 0x3D // dec: 61 bin: 0b00000111101
#define SECONDARY_ID_ACQUISINATOR_FLASH_30_RX 0x3E // dec: 62 bin: 0b00000111110
#define SECONDARY_ID_ACQUISINATOR_FLASH_31_TX 0x3F // dec: 63 bin: 0b00000111111
#define SECONDARY_ID_ACQUISINATOR_FLASH_31_RX 0x40 // dec: 64 bin: 0b00001000000
#define SECONDARY_ID_ACQUISINATOR_VERSION 0x2BC // dec: 700 bin: 0b01010111100
#define SECONDARY_ID_IMU_ANGULAR_RATE 0x4EC // dec: 1260 bin: 0b10011101100
#define SECONDARY_ID_IMU_ACCELERATION 0x4ED // dec: 1261 bin: 0b10011101101
#define SECONDARY_ID_IRTS_FL_0 0x5B0 // dec: 1456 bin: 0b10110110000
#define SECONDARY_ID_IRTS_FL_1 0x5B1 // dec: 1457 bin: 0b10110110001
#define SECONDARY_ID_IRTS_FL_2 0x5B2 // dec: 1458 bin: 0b10110110010
#define SECONDARY_ID_IRTS_FL_3 0x5B3 // dec: 1459 bin: 0b10110110011
#define SECONDARY_ID_IRTS_FR_0 0x5B8 // dec: 1464 bin: 0b10110111000
#define SECONDARY_ID_IRTS_FR_1 0x5B9 // dec: 1465 bin: 0b10110111001
#define SECONDARY_ID_IRTS_FR_2 0x5BA // dec: 1466 bin: 0b10110111010
#define SECONDARY_ID_IRTS_FR_3 0x5BB // dec: 1467 bin: 0b10110111011
#define SECONDARY_ID_IRTS_RL_0 0x5BC // dec: 1468 bin: 0b10110111100
#define SECONDARY_ID_IRTS_RL_1 0x5BD // dec: 1469 bin: 0b10110111101
#define SECONDARY_ID_IRTS_RL_2 0x5BE // dec: 1470 bin: 0b10110111110
#define SECONDARY_ID_IRTS_RL_3 0x5BF // dec: 1471 bin: 0b10110111111
#define SECONDARY_ID_IRTS_RR_0 0x4B0 // dec: 1200 bin: 0b10010110000
#define SECONDARY_ID_IRTS_RR_1 0x4B1 // dec: 1201 bin: 0b10010110001
#define SECONDARY_ID_IRTS_RR_2 0x4B2 // dec: 1202 bin: 0b10010110010
#define SECONDARY_ID_IRTS_RR_3 0x4B3 // dec: 1203 bin: 0b10010110011

/* TOPIC HYDRA */
#define SECONDARY_TOPIC_MASK_HYDRA 0b00000011111

#define SECONDARY_TOPIC_FILTER_HYDRA 0x0 // dec: 0 bin: 0b00000000000

#define SECONDARY_ID_VEHICLE_POSITION 0x600 // dec: 1536 bin: 0b11000000000
#define SECONDARY_ID_VEHICLE_SPEED 0x608 // dec: 1544 bin: 0b11000001000
#define SECONDARY_ID_VEHICLE_CURVILINEAR_COORDINATES 0x610 // dec: 1552 bin: 0b11000010000
#define SECONDARY_ID_FRONT_ANGULAR_VELOCITY 0x618 // dec: 1560 bin: 0b11000011000
#define SECONDARY_ID_REAR_ANGULAR_VELOCITY 0x620 // dec: 1568 bin: 0b11000100000
#define SECONDARY_ID_HV_SOC_ESTIMATION_STATE 0x628 // dec: 1576 bin: 0b11000101000
#define SECONDARY_ID_HV_SOC_ESTIMATION_COVARIANCE 0x630 // dec: 1584 bin: 0b11000110000
#define SECONDARY_ID_LV_SOC_ESTIMATION_STATE 0x638 // dec: 1592 bin: 0b11000111000
#define SECONDARY_ID_LV_SOC_ESTIMATION_COVARIANCE 0x640 // dec: 1600 bin: 0b11001000000
#define SECONDARY_ID_PEDAL_THROTTLE 0x648 // dec: 1608 bin: 0b11001001000
#define SECONDARY_ID_PEDAL_BRAKES_PRESSURE 0x650 // dec: 1616 bin: 0b11001010000
#define SECONDARY_ID_STEER_ANGLE 0x658 // dec: 1624 bin: 0b11001011000
#define SECONDARY_ID_ODOMETER 0x660 // dec: 1632 bin: 0b11001100000
#define SECONDARY_ID_TPMS_PRESSURE 0x668 // dec: 1640 bin: 0b11001101000
#define SECONDARY_ID_TPMS_TEMPERATURE 0x670 // dec: 1648 bin: 0b11001110000
#define SECONDARY_ID_TLM_UNIX_TIMESTAMP 0x678 // dec: 1656 bin: 0b11001111000
#define SECONDARY_ID_TLM_LAP_TIME 0x680 // dec: 1664 bin: 0b11010000000
#define SECONDARY_ID_TLM_LAPS_STATS 0x688 // dec: 1672 bin: 0b11010001000
#define SECONDARY_ID_TLM_NETWORK_INTERFACE 0x690 // dec: 1680 bin: 0b11010010000
#define SECONDARY_ID_FRONT_AMMO_COMPRESSION 0x698 // dec: 1688 bin: 0b11010011000
#define SECONDARY_ID_REAR_AMMO_COMPRESSION 0x6A0 // dec: 1696 bin: 0b11010100000
#define SECONDARY_ID_ACQUISINATOR_CALIBRATIONS_OFFSETS 0x6A8 // dec: 1704 bin: 0b11010101000
#define SECONDARY_ID_ACQUISINATOR_ERRORS 0x6B0 // dec: 1712 bin: 0b11010110000
#define SECONDARY_ID_LINK_DEFORMATION_DEBUG_VOLTAGES 0x6B8 // dec: 1720 bin: 0b11010111000
#define SECONDARY_ID_LINK_DEFORMATION_FL_WHEEL 0x6C0 // dec: 1728 bin: 0b11011000000
#define SECONDARY_ID_LINK_DEFORMATION_FR_WHEEL 0x6C8 // dec: 1736 bin: 0b11011001000
#define SECONDARY_ID_LINK_DEFORMATION_RL_WHEEL 0x6D0 // dec: 1744 bin: 0b11011010000
#define SECONDARY_ID_LINK_DEFORMATION_RR_WHEEL 0x6D8 // dec: 1752 bin: 0b11011011000
#define SECONDARY_ID_LINK_DEFORMATION_SET_CALIBRATION 0x48 // dec: 72 bin: 0b00001001000
#define SECONDARY_ID_AMMO_COMPRESSION_SET_CALIBRATION 0x50 // dec: 80 bin: 0b00001010000
#define SECONDARY_ID_DEBUG_SIGNAL_5 0x6E0 // dec: 1760 bin: 0b11011100000
#define SECONDARY_ID_DEBUG_SIGNAL_6 0x6E8 // dec: 1768 bin: 0b11011101000
#define SECONDARY_ID_DEBUG_SIGNAL_7 0x6F0 // dec: 1776 bin: 0b11011110000
#define SECONDARY_ID_DEBUG_SIGNAL_8 0x6F8 // dec: 1784 bin: 0b11011111000
#define SECONDARY_ID_COOLING_TEMP_PUMPS 0x700 // dec: 1792 bin: 0b11100000000
#define SECONDARY_ID_COOLING_TEMP_RADIATORS 0x708 // dec: 1800 bin: 0b11100001000
#define SECONDARY_ID_LATERAL_CONTROLLER_PREVIEW_POINT_ERRORS 0x710 // dec: 1808 bin: 0b11100010000
#define SECONDARY_ID_LATERAL_CONTROLLER_ERRORS 0x718 // dec: 1816 bin: 0b11100011000



/* Signal choices. */
#define SECONDARY_LINK_DEFORMATION_DEBUG_VOLTAGES_WHEEL_ID_FL_CHOICE (0u)
#define SECONDARY_LINK_DEFORMATION_DEBUG_VOLTAGES_WHEEL_ID_FR_CHOICE (1u)
#define SECONDARY_LINK_DEFORMATION_DEBUG_VOLTAGES_WHEEL_ID_RL_CHOICE (2u)
#define SECONDARY_LINK_DEFORMATION_DEBUG_VOLTAGES_WHEEL_ID_RR_CHOICE (3u)

#define SECONDARY_LINK_DEFORMATION_DEBUG_VOLTAGES_ROD_ID_F1011_CHOICE (0u)
#define SECONDARY_LINK_DEFORMATION_DEBUG_VOLTAGES_ROD_ID_F36_CHOICE (1u)
#define SECONDARY_LINK_DEFORMATION_DEBUG_VOLTAGES_ROD_ID_F46_CHOICE (2u)
#define SECONDARY_LINK_DEFORMATION_DEBUG_VOLTAGES_ROD_ID_F27_CHOICE (3u)
#define SECONDARY_LINK_DEFORMATION_DEBUG_VOLTAGES_ROD_ID_F17_CHOICE (4u)
#define SECONDARY_LINK_DEFORMATION_DEBUG_VOLTAGES_ROD_ID_F58_CHOICE (5u)

#define SECONDARY_LINK_DEFORMATION_FL_WHEEL_ROD_ID_F1011_CHOICE (0u)
#define SECONDARY_LINK_DEFORMATION_FL_WHEEL_ROD_ID_F36_CHOICE (1u)
#define SECONDARY_LINK_DEFORMATION_FL_WHEEL_ROD_ID_F46_CHOICE (2u)
#define SECONDARY_LINK_DEFORMATION_FL_WHEEL_ROD_ID_F27_CHOICE (3u)
#define SECONDARY_LINK_DEFORMATION_FL_WHEEL_ROD_ID_F17_CHOICE (4u)
#define SECONDARY_LINK_DEFORMATION_FL_WHEEL_ROD_ID_F58_CHOICE (5u)

#define SECONDARY_LINK_DEFORMATION_FR_WHEEL_ROD_ID_F1011_CHOICE (0u)
#define SECONDARY_LINK_DEFORMATION_FR_WHEEL_ROD_ID_F36_CHOICE (1u)
#define SECONDARY_LINK_DEFORMATION_FR_WHEEL_ROD_ID_F46_CHOICE (2u)
#define SECONDARY_LINK_DEFORMATION_FR_WHEEL_ROD_ID_F27_CHOICE (3u)
#define SECONDARY_LINK_DEFORMATION_FR_WHEEL_ROD_ID_F17_CHOICE (4u)
#define SECONDARY_LINK_DEFORMATION_FR_WHEEL_ROD_ID_F58_CHOICE (5u)

#define SECONDARY_LINK_DEFORMATION_RL_WHEEL_ROD_ID_F1011_CHOICE (0u)
#define SECONDARY_LINK_DEFORMATION_RL_WHEEL_ROD_ID_F36_CHOICE (1u)
#define SECONDARY_LINK_DEFORMATION_RL_WHEEL_ROD_ID_F46_CHOICE (2u)
#define SECONDARY_LINK_DEFORMATION_RL_WHEEL_ROD_ID_F27_CHOICE (3u)
#define SECONDARY_LINK_DEFORMATION_RL_WHEEL_ROD_ID_F17_CHOICE (4u)
#define SECONDARY_LINK_DEFORMATION_RL_WHEEL_ROD_ID_F58_CHOICE (5u)

#define SECONDARY_LINK_DEFORMATION_RR_WHEEL_ROD_ID_F1011_CHOICE (0u)
#define SECONDARY_LINK_DEFORMATION_RR_WHEEL_ROD_ID_F36_CHOICE (1u)
#define SECONDARY_LINK_DEFORMATION_RR_WHEEL_ROD_ID_F46_CHOICE (2u)
#define SECONDARY_LINK_DEFORMATION_RR_WHEEL_ROD_ID_F27_CHOICE (3u)
#define SECONDARY_LINK_DEFORMATION_RR_WHEEL_ROD_ID_F17_CHOICE (4u)
#define SECONDARY_LINK_DEFORMATION_RR_WHEEL_ROD_ID_F58_CHOICE (5u)

#define SECONDARY_DEBUG_SIGNAL_5_DEVICE_ID_HV_MAINBOARD_CHOICE (0u)
#define SECONDARY_DEBUG_SIGNAL_5_DEVICE_ID_HV_CELLBOARD_CHOICE (1u)
#define SECONDARY_DEBUG_SIGNAL_5_DEVICE_ID_LV_CHOICE (2u)
#define SECONDARY_DEBUG_SIGNAL_5_DEVICE_ID_ECU_CHOICE (3u)
#define SECONDARY_DEBUG_SIGNAL_5_DEVICE_ID_TLM_CHOICE (4u)
#define SECONDARY_DEBUG_SIGNAL_5_DEVICE_ID_TRACTION_CONTROL_CHOICE (5u)
#define SECONDARY_DEBUG_SIGNAL_5_DEVICE_ID_STEEERING_WHEEL_CHOICE (6u)
#define SECONDARY_DEBUG_SIGNAL_5_DEVICE_ID_HANDCART_CHOICE (7u)
#define SECONDARY_DEBUG_SIGNAL_5_DEVICE_ID_ACQUISINATOR_CHOICE (8u)

#define SECONDARY_DEBUG_SIGNAL_6_DEVICE_ID_HV_MAINBOARD_CHOICE (0u)
#define SECONDARY_DEBUG_SIGNAL_6_DEVICE_ID_HV_CELLBOARD_CHOICE (1u)
#define SECONDARY_DEBUG_SIGNAL_6_DEVICE_ID_LV_CHOICE (2u)
#define SECONDARY_DEBUG_SIGNAL_6_DEVICE_ID_ECU_CHOICE (3u)
#define SECONDARY_DEBUG_SIGNAL_6_DEVICE_ID_TLM_CHOICE (4u)
#define SECONDARY_DEBUG_SIGNAL_6_DEVICE_ID_TRACTION_CONTROL_CHOICE (5u)
#define SECONDARY_DEBUG_SIGNAL_6_DEVICE_ID_STEEERING_WHEEL_CHOICE (6u)
#define SECONDARY_DEBUG_SIGNAL_6_DEVICE_ID_HANDCART_CHOICE (7u)
#define SECONDARY_DEBUG_SIGNAL_6_DEVICE_ID_ACQUISINATOR_CHOICE (8u)

#define SECONDARY_DEBUG_SIGNAL_7_DEVICE_ID_HV_MAINBOARD_CHOICE (0u)
#define SECONDARY_DEBUG_SIGNAL_7_DEVICE_ID_HV_CELLBOARD_CHOICE (1u)
#define SECONDARY_DEBUG_SIGNAL_7_DEVICE_ID_LV_CHOICE (2u)
#define SECONDARY_DEBUG_SIGNAL_7_DEVICE_ID_ECU_CHOICE (3u)
#define SECONDARY_DEBUG_SIGNAL_7_DEVICE_ID_TLM_CHOICE (4u)
#define SECONDARY_DEBUG_SIGNAL_7_DEVICE_ID_TRACTION_CONTROL_CHOICE (5u)
#define SECONDARY_DEBUG_SIGNAL_7_DEVICE_ID_STEEERING_WHEEL_CHOICE (6u)
#define SECONDARY_DEBUG_SIGNAL_7_DEVICE_ID_HANDCART_CHOICE (7u)
#define SECONDARY_DEBUG_SIGNAL_7_DEVICE_ID_ACQUISINATOR_CHOICE (8u)

#define SECONDARY_DEBUG_SIGNAL_8_DEVICE_ID_HV_MAINBOARD_CHOICE (0u)
#define SECONDARY_DEBUG_SIGNAL_8_DEVICE_ID_HV_CELLBOARD_CHOICE (1u)
#define SECONDARY_DEBUG_SIGNAL_8_DEVICE_ID_LV_CHOICE (2u)
#define SECONDARY_DEBUG_SIGNAL_8_DEVICE_ID_ECU_CHOICE (3u)
#define SECONDARY_DEBUG_SIGNAL_8_DEVICE_ID_TLM_CHOICE (4u)
#define SECONDARY_DEBUG_SIGNAL_8_DEVICE_ID_TRACTION_CONTROL_CHOICE (5u)
#define SECONDARY_DEBUG_SIGNAL_8_DEVICE_ID_STEEERING_WHEEL_CHOICE (6u)
#define SECONDARY_DEBUG_SIGNAL_8_DEVICE_ID_HANDCART_CHOICE (7u)
#define SECONDARY_DEBUG_SIGNAL_8_DEVICE_ID_ACQUISINATOR_CHOICE (8u)

/* Indexes */
#define SECONDARY_ACQUISINATOR_JMP_TO_BLT_INDEX 0
#define SECONDARY_ACQUISINATOR_FLASH_0_TX_INDEX 1
#define SECONDARY_ACQUISINATOR_FLASH_0_RX_INDEX 2
#define SECONDARY_ACQUISINATOR_FLASH_1_TX_INDEX 3
#define SECONDARY_ACQUISINATOR_FLASH_1_RX_INDEX 4
#define SECONDARY_ACQUISINATOR_FLASH_2_TX_INDEX 5
#define SECONDARY_ACQUISINATOR_FLASH_2_RX_INDEX 6
#define SECONDARY_ACQUISINATOR_FLASH_3_TX_INDEX 7
#define SECONDARY_ACQUISINATOR_FLASH_3_RX_INDEX 8
#define SECONDARY_ACQUISINATOR_FLASH_4_TX_INDEX 9
#define SECONDARY_ACQUISINATOR_FLASH_4_RX_INDEX 10
#define SECONDARY_ACQUISINATOR_FLASH_5_TX_INDEX 11
#define SECONDARY_ACQUISINATOR_FLASH_5_RX_INDEX 12
#define SECONDARY_ACQUISINATOR_FLASH_6_TX_INDEX 13
#define SECONDARY_ACQUISINATOR_FLASH_6_RX_INDEX 14
#define SECONDARY_ACQUISINATOR_FLASH_7_TX_INDEX 15
#define SECONDARY_ACQUISINATOR_FLASH_7_RX_INDEX 16
#define SECONDARY_ACQUISINATOR_FLASH_8_TX_INDEX 17
#define SECONDARY_ACQUISINATOR_FLASH_8_RX_INDEX 18
#define SECONDARY_ACQUISINATOR_FLASH_9_TX_INDEX 19
#define SECONDARY_ACQUISINATOR_FLASH_9_RX_INDEX 20
#define SECONDARY_ACQUISINATOR_FLASH_10_TX_INDEX 21
#define SECONDARY_ACQUISINATOR_FLASH_10_RX_INDEX 22
#define SECONDARY_ACQUISINATOR_FLASH_11_TX_INDEX 23
#define SECONDARY_ACQUISINATOR_FLASH_11_RX_INDEX 24
#define SECONDARY_ACQUISINATOR_FLASH_12_TX_INDEX 25
#define SECONDARY_ACQUISINATOR_FLASH_12_RX_INDEX 26
#define SECONDARY_ACQUISINATOR_FLASH_13_TX_INDEX 27
#define SECONDARY_ACQUISINATOR_FLASH_13_RX_INDEX 28
#define SECONDARY_ACQUISINATOR_FLASH_14_TX_INDEX 29
#define SECONDARY_ACQUISINATOR_FLASH_14_RX_INDEX 30
#define SECONDARY_ACQUISINATOR_FLASH_15_TX_INDEX 31
#define SECONDARY_ACQUISINATOR_FLASH_15_RX_INDEX 32
#define SECONDARY_ACQUISINATOR_FLASH_16_TX_INDEX 33
#define SECONDARY_ACQUISINATOR_FLASH_16_RX_INDEX 34
#define SECONDARY_ACQUISINATOR_FLASH_17_TX_INDEX 35
#define SECONDARY_ACQUISINATOR_FLASH_17_RX_INDEX 36
#define SECONDARY_ACQUISINATOR_FLASH_18_TX_INDEX 37
#define SECONDARY_ACQUISINATOR_FLASH_18_RX_INDEX 38
#define SECONDARY_ACQUISINATOR_FLASH_19_TX_INDEX 39
#define SECONDARY_ACQUISINATOR_FLASH_19_RX_INDEX 40
#define SECONDARY_ACQUISINATOR_FLASH_20_TX_INDEX 41
#define SECONDARY_ACQUISINATOR_FLASH_20_RX_INDEX 42
#define SECONDARY_ACQUISINATOR_FLASH_21_TX_INDEX 43
#define SECONDARY_ACQUISINATOR_FLASH_21_RX_INDEX 44
#define SECONDARY_ACQUISINATOR_FLASH_22_TX_INDEX 45
#define SECONDARY_ACQUISINATOR_FLASH_22_RX_INDEX 46
#define SECONDARY_ACQUISINATOR_FLASH_23_TX_INDEX 47
#define SECONDARY_ACQUISINATOR_FLASH_23_RX_INDEX 48
#define SECONDARY_ACQUISINATOR_FLASH_24_TX_INDEX 49
#define SECONDARY_ACQUISINATOR_FLASH_24_RX_INDEX 50
#define SECONDARY_ACQUISINATOR_FLASH_25_TX_INDEX 51
#define SECONDARY_ACQUISINATOR_FLASH_25_RX_INDEX 52
#define SECONDARY_ACQUISINATOR_FLASH_26_TX_INDEX 53
#define SECONDARY_ACQUISINATOR_FLASH_26_RX_INDEX 54
#define SECONDARY_ACQUISINATOR_FLASH_27_TX_INDEX 55
#define SECONDARY_ACQUISINATOR_FLASH_27_RX_INDEX 56
#define SECONDARY_ACQUISINATOR_FLASH_28_TX_INDEX 57
#define SECONDARY_ACQUISINATOR_FLASH_28_RX_INDEX 58
#define SECONDARY_ACQUISINATOR_FLASH_29_TX_INDEX 59
#define SECONDARY_ACQUISINATOR_FLASH_29_RX_INDEX 60
#define SECONDARY_ACQUISINATOR_FLASH_30_TX_INDEX 61
#define SECONDARY_ACQUISINATOR_FLASH_30_RX_INDEX 62
#define SECONDARY_ACQUISINATOR_FLASH_31_TX_INDEX 63
#define SECONDARY_ACQUISINATOR_FLASH_31_RX_INDEX 64
#define SECONDARY_ACQUISINATOR_VERSION_INDEX 65
#define SECONDARY_IMU_ANGULAR_RATE_INDEX 66
#define SECONDARY_IMU_ACCELERATION_INDEX 67
#define SECONDARY_IRTS_FL_0_INDEX 68
#define SECONDARY_IRTS_FL_1_INDEX 69
#define SECONDARY_IRTS_FL_2_INDEX 70
#define SECONDARY_IRTS_FL_3_INDEX 71
#define SECONDARY_IRTS_FR_0_INDEX 72
#define SECONDARY_IRTS_FR_1_INDEX 73
#define SECONDARY_IRTS_FR_2_INDEX 74
#define SECONDARY_IRTS_FR_3_INDEX 75
#define SECONDARY_IRTS_RL_0_INDEX 76
#define SECONDARY_IRTS_RL_1_INDEX 77
#define SECONDARY_IRTS_RL_2_INDEX 78
#define SECONDARY_IRTS_RL_3_INDEX 79
#define SECONDARY_IRTS_RR_0_INDEX 80
#define SECONDARY_IRTS_RR_1_INDEX 81
#define SECONDARY_IRTS_RR_2_INDEX 82
#define SECONDARY_IRTS_RR_3_INDEX 83
#define SECONDARY_VEHICLE_POSITION_INDEX 84
#define SECONDARY_VEHICLE_SPEED_INDEX 85
#define SECONDARY_VEHICLE_CURVILINEAR_COORDINATES_INDEX 86
#define SECONDARY_FRONT_ANGULAR_VELOCITY_INDEX 87
#define SECONDARY_REAR_ANGULAR_VELOCITY_INDEX 88
#define SECONDARY_HV_SOC_ESTIMATION_STATE_INDEX 89
#define SECONDARY_HV_SOC_ESTIMATION_COVARIANCE_INDEX 90
#define SECONDARY_LV_SOC_ESTIMATION_STATE_INDEX 91
#define SECONDARY_LV_SOC_ESTIMATION_COVARIANCE_INDEX 92
#define SECONDARY_PEDAL_THROTTLE_INDEX 93
#define SECONDARY_PEDAL_BRAKES_PRESSURE_INDEX 94
#define SECONDARY_STEER_ANGLE_INDEX 95
#define SECONDARY_ODOMETER_INDEX 96
#define SECONDARY_TPMS_PRESSURE_INDEX 97
#define SECONDARY_TPMS_TEMPERATURE_INDEX 98
#define SECONDARY_TLM_UNIX_TIMESTAMP_INDEX 99
#define SECONDARY_TLM_LAP_TIME_INDEX 100
#define SECONDARY_TLM_LAPS_STATS_INDEX 101
#define SECONDARY_TLM_NETWORK_INTERFACE_INDEX 102
#define SECONDARY_FRONT_AMMO_COMPRESSION_INDEX 103
#define SECONDARY_REAR_AMMO_COMPRESSION_INDEX 104
#define SECONDARY_ACQUISINATOR_CALIBRATIONS_OFFSETS_INDEX 105
#define SECONDARY_ACQUISINATOR_ERRORS_INDEX 106
#define SECONDARY_LINK_DEFORMATION_DEBUG_VOLTAGES_INDEX 107
#define SECONDARY_LINK_DEFORMATION_FL_WHEEL_INDEX 108
#define SECONDARY_LINK_DEFORMATION_FR_WHEEL_INDEX 109
#define SECONDARY_LINK_DEFORMATION_RL_WHEEL_INDEX 110
#define SECONDARY_LINK_DEFORMATION_RR_WHEEL_INDEX 111
#define SECONDARY_LINK_DEFORMATION_SET_CALIBRATION_INDEX 112
#define SECONDARY_AMMO_COMPRESSION_SET_CALIBRATION_INDEX 113
#define SECONDARY_DEBUG_SIGNAL_5_INDEX 114
#define SECONDARY_DEBUG_SIGNAL_6_INDEX 115
#define SECONDARY_DEBUG_SIGNAL_7_INDEX 116
#define SECONDARY_DEBUG_SIGNAL_8_INDEX 117
#define SECONDARY_COOLING_TEMP_PUMPS_INDEX 118
#define SECONDARY_COOLING_TEMP_RADIATORS_INDEX 119
#define SECONDARY_LATERAL_CONTROLLER_PREVIEW_POINT_ERRORS_INDEX 120
#define SECONDARY_LATERAL_CONTROLLER_ERRORS_INDEX 121


#define secondary_MESSAGE_COUNT 122

void secondary_devices_deserialize_from_id(
    device_t* device,
    uint16_t message_id,
    uint8_t* data
#ifdef CANLIB_TIMESTAMP
    , uint64_t timestamp
#endif // CANLIB_TIMESTAMP
);

int secondary_serialize_from_id(
    void* converted_struct_pointer,
    uint16_t message_id,
    uint8_t* data
);

int secondary_message_name_from_id(uint16_t id, char* buffer);
int secondary_index_from_id(uint16_t id);
int secondary_id_from_index(int index);

typedef enum {
	secondary_link_deformation_debug_voltages_wheel_id_fl = 0,
	secondary_link_deformation_debug_voltages_wheel_id_fr = 1,
	secondary_link_deformation_debug_voltages_wheel_id_rl = 2,
	secondary_link_deformation_debug_voltages_wheel_id_rr = 3,
} secondary_link_deformation_debug_voltages_wheel_id;

typedef enum {
	secondary_link_deformation_debug_voltages_rod_id_F1011 = 0,
	secondary_link_deformation_debug_voltages_rod_id_F36 = 1,
	secondary_link_deformation_debug_voltages_rod_id_F46 = 2,
	secondary_link_deformation_debug_voltages_rod_id_F27 = 3,
	secondary_link_deformation_debug_voltages_rod_id_F17 = 4,
	secondary_link_deformation_debug_voltages_rod_id_F58 = 5,
} secondary_link_deformation_debug_voltages_rod_id;

typedef enum {
	secondary_link_deformation_fl_wheel_rod_id_F1011 = 0,
	secondary_link_deformation_fl_wheel_rod_id_F36 = 1,
	secondary_link_deformation_fl_wheel_rod_id_F46 = 2,
	secondary_link_deformation_fl_wheel_rod_id_F27 = 3,
	secondary_link_deformation_fl_wheel_rod_id_F17 = 4,
	secondary_link_deformation_fl_wheel_rod_id_F58 = 5,
} secondary_link_deformation_fl_wheel_rod_id;

typedef enum {
	secondary_link_deformation_fr_wheel_rod_id_F1011 = 0,
	secondary_link_deformation_fr_wheel_rod_id_F36 = 1,
	secondary_link_deformation_fr_wheel_rod_id_F46 = 2,
	secondary_link_deformation_fr_wheel_rod_id_F27 = 3,
	secondary_link_deformation_fr_wheel_rod_id_F17 = 4,
	secondary_link_deformation_fr_wheel_rod_id_F58 = 5,
} secondary_link_deformation_fr_wheel_rod_id;

typedef enum {
	secondary_link_deformation_rl_wheel_rod_id_F1011 = 0,
	secondary_link_deformation_rl_wheel_rod_id_F36 = 1,
	secondary_link_deformation_rl_wheel_rod_id_F46 = 2,
	secondary_link_deformation_rl_wheel_rod_id_F27 = 3,
	secondary_link_deformation_rl_wheel_rod_id_F17 = 4,
	secondary_link_deformation_rl_wheel_rod_id_F58 = 5,
} secondary_link_deformation_rl_wheel_rod_id;

typedef enum {
	secondary_link_deformation_rr_wheel_rod_id_F1011 = 0,
	secondary_link_deformation_rr_wheel_rod_id_F36 = 1,
	secondary_link_deformation_rr_wheel_rod_id_F46 = 2,
	secondary_link_deformation_rr_wheel_rod_id_F27 = 3,
	secondary_link_deformation_rr_wheel_rod_id_F17 = 4,
	secondary_link_deformation_rr_wheel_rod_id_F58 = 5,
} secondary_link_deformation_rr_wheel_rod_id;

typedef enum {
	secondary_debug_signal_5_device_id_hv_mainboard = 0,
	secondary_debug_signal_5_device_id_hv_cellboard = 1,
	secondary_debug_signal_5_device_id_lv = 2,
	secondary_debug_signal_5_device_id_ecu = 3,
	secondary_debug_signal_5_device_id_tlm = 4,
	secondary_debug_signal_5_device_id_traction_control = 5,
	secondary_debug_signal_5_device_id_steeering_wheel = 6,
	secondary_debug_signal_5_device_id_handcart = 7,
	secondary_debug_signal_5_device_id_acquisinator = 8,
} secondary_debug_signal_5_device_id;

typedef enum {
	secondary_debug_signal_6_device_id_hv_mainboard = 0,
	secondary_debug_signal_6_device_id_hv_cellboard = 1,
	secondary_debug_signal_6_device_id_lv = 2,
	secondary_debug_signal_6_device_id_ecu = 3,
	secondary_debug_signal_6_device_id_tlm = 4,
	secondary_debug_signal_6_device_id_traction_control = 5,
	secondary_debug_signal_6_device_id_steeering_wheel = 6,
	secondary_debug_signal_6_device_id_handcart = 7,
	secondary_debug_signal_6_device_id_acquisinator = 8,
} secondary_debug_signal_6_device_id;

typedef enum {
	secondary_debug_signal_7_device_id_hv_mainboard = 0,
	secondary_debug_signal_7_device_id_hv_cellboard = 1,
	secondary_debug_signal_7_device_id_lv = 2,
	secondary_debug_signal_7_device_id_ecu = 3,
	secondary_debug_signal_7_device_id_tlm = 4,
	secondary_debug_signal_7_device_id_traction_control = 5,
	secondary_debug_signal_7_device_id_steeering_wheel = 6,
	secondary_debug_signal_7_device_id_handcart = 7,
	secondary_debug_signal_7_device_id_acquisinator = 8,
} secondary_debug_signal_7_device_id;

typedef enum {
	secondary_debug_signal_8_device_id_hv_mainboard = 0,
	secondary_debug_signal_8_device_id_hv_cellboard = 1,
	secondary_debug_signal_8_device_id_lv = 2,
	secondary_debug_signal_8_device_id_ecu = 3,
	secondary_debug_signal_8_device_id_tlm = 4,
	secondary_debug_signal_8_device_id_traction_control = 5,
	secondary_debug_signal_8_device_id_steeering_wheel = 6,
	secondary_debug_signal_8_device_id_handcart = 7,
	secondary_debug_signal_8_device_id_acquisinator = 8,
} secondary_debug_signal_8_device_id;

/**
 * Signals in message ACQUISINATOR_JMP_TO_BLT.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t acquisinatore_id;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_acquisinator_jmp_to_blt_t;

/**
 * Signals in message ACQUISINATOR_JMP_TO_BLT.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t acquisinatore_id;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_acquisinator_jmp_to_blt_converted_t;

/**
 * Signals in message ACQUISINATOR_FLASH_0_TX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_acquisinator_flash_0_tx_t;

/**
 * Signals in message ACQUISINATOR_FLASH_0_TX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_acquisinator_flash_0_tx_converted_t;

/**
 * Signals in message ACQUISINATOR_FLASH_0_RX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_acquisinator_flash_0_rx_t;

/**
 * Signals in message ACQUISINATOR_FLASH_0_RX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_acquisinator_flash_0_rx_converted_t;

/**
 * Signals in message ACQUISINATOR_FLASH_1_TX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_acquisinator_flash_1_tx_t;

/**
 * Signals in message ACQUISINATOR_FLASH_1_TX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_acquisinator_flash_1_tx_converted_t;

/**
 * Signals in message ACQUISINATOR_FLASH_1_RX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_acquisinator_flash_1_rx_t;

/**
 * Signals in message ACQUISINATOR_FLASH_1_RX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_acquisinator_flash_1_rx_converted_t;

/**
 * Signals in message ACQUISINATOR_FLASH_2_TX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_acquisinator_flash_2_tx_t;

/**
 * Signals in message ACQUISINATOR_FLASH_2_TX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_acquisinator_flash_2_tx_converted_t;

/**
 * Signals in message ACQUISINATOR_FLASH_2_RX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_acquisinator_flash_2_rx_t;

/**
 * Signals in message ACQUISINATOR_FLASH_2_RX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_acquisinator_flash_2_rx_converted_t;

/**
 * Signals in message ACQUISINATOR_FLASH_3_TX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_acquisinator_flash_3_tx_t;

/**
 * Signals in message ACQUISINATOR_FLASH_3_TX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_acquisinator_flash_3_tx_converted_t;

/**
 * Signals in message ACQUISINATOR_FLASH_3_RX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_acquisinator_flash_3_rx_t;

/**
 * Signals in message ACQUISINATOR_FLASH_3_RX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_acquisinator_flash_3_rx_converted_t;

/**
 * Signals in message ACQUISINATOR_FLASH_4_TX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_acquisinator_flash_4_tx_t;

/**
 * Signals in message ACQUISINATOR_FLASH_4_TX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_acquisinator_flash_4_tx_converted_t;

/**
 * Signals in message ACQUISINATOR_FLASH_4_RX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_acquisinator_flash_4_rx_t;

/**
 * Signals in message ACQUISINATOR_FLASH_4_RX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_acquisinator_flash_4_rx_converted_t;

/**
 * Signals in message ACQUISINATOR_FLASH_5_TX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_acquisinator_flash_5_tx_t;

/**
 * Signals in message ACQUISINATOR_FLASH_5_TX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_acquisinator_flash_5_tx_converted_t;

/**
 * Signals in message ACQUISINATOR_FLASH_5_RX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_acquisinator_flash_5_rx_t;

/**
 * Signals in message ACQUISINATOR_FLASH_5_RX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_acquisinator_flash_5_rx_converted_t;

/**
 * Signals in message ACQUISINATOR_FLASH_6_TX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_acquisinator_flash_6_tx_t;

/**
 * Signals in message ACQUISINATOR_FLASH_6_TX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_acquisinator_flash_6_tx_converted_t;

/**
 * Signals in message ACQUISINATOR_FLASH_6_RX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_acquisinator_flash_6_rx_t;

/**
 * Signals in message ACQUISINATOR_FLASH_6_RX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_acquisinator_flash_6_rx_converted_t;

/**
 * Signals in message ACQUISINATOR_FLASH_7_TX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_acquisinator_flash_7_tx_t;

/**
 * Signals in message ACQUISINATOR_FLASH_7_TX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_acquisinator_flash_7_tx_converted_t;

/**
 * Signals in message ACQUISINATOR_FLASH_7_RX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_acquisinator_flash_7_rx_t;

/**
 * Signals in message ACQUISINATOR_FLASH_7_RX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_acquisinator_flash_7_rx_converted_t;

/**
 * Signals in message ACQUISINATOR_FLASH_8_TX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_acquisinator_flash_8_tx_t;

/**
 * Signals in message ACQUISINATOR_FLASH_8_TX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_acquisinator_flash_8_tx_converted_t;

/**
 * Signals in message ACQUISINATOR_FLASH_8_RX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_acquisinator_flash_8_rx_t;

/**
 * Signals in message ACQUISINATOR_FLASH_8_RX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_acquisinator_flash_8_rx_converted_t;

/**
 * Signals in message ACQUISINATOR_FLASH_9_TX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_acquisinator_flash_9_tx_t;

/**
 * Signals in message ACQUISINATOR_FLASH_9_TX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_acquisinator_flash_9_tx_converted_t;

/**
 * Signals in message ACQUISINATOR_FLASH_9_RX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_acquisinator_flash_9_rx_t;

/**
 * Signals in message ACQUISINATOR_FLASH_9_RX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_acquisinator_flash_9_rx_converted_t;

/**
 * Signals in message ACQUISINATOR_FLASH_10_TX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_acquisinator_flash_10_tx_t;

/**
 * Signals in message ACQUISINATOR_FLASH_10_TX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_acquisinator_flash_10_tx_converted_t;

/**
 * Signals in message ACQUISINATOR_FLASH_10_RX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_acquisinator_flash_10_rx_t;

/**
 * Signals in message ACQUISINATOR_FLASH_10_RX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_acquisinator_flash_10_rx_converted_t;

/**
 * Signals in message ACQUISINATOR_FLASH_11_TX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_acquisinator_flash_11_tx_t;

/**
 * Signals in message ACQUISINATOR_FLASH_11_TX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_acquisinator_flash_11_tx_converted_t;

/**
 * Signals in message ACQUISINATOR_FLASH_11_RX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_acquisinator_flash_11_rx_t;

/**
 * Signals in message ACQUISINATOR_FLASH_11_RX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_acquisinator_flash_11_rx_converted_t;

/**
 * Signals in message ACQUISINATOR_FLASH_12_TX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_acquisinator_flash_12_tx_t;

/**
 * Signals in message ACQUISINATOR_FLASH_12_TX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_acquisinator_flash_12_tx_converted_t;

/**
 * Signals in message ACQUISINATOR_FLASH_12_RX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_acquisinator_flash_12_rx_t;

/**
 * Signals in message ACQUISINATOR_FLASH_12_RX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_acquisinator_flash_12_rx_converted_t;

/**
 * Signals in message ACQUISINATOR_FLASH_13_TX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_acquisinator_flash_13_tx_t;

/**
 * Signals in message ACQUISINATOR_FLASH_13_TX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_acquisinator_flash_13_tx_converted_t;

/**
 * Signals in message ACQUISINATOR_FLASH_13_RX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_acquisinator_flash_13_rx_t;

/**
 * Signals in message ACQUISINATOR_FLASH_13_RX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_acquisinator_flash_13_rx_converted_t;

/**
 * Signals in message ACQUISINATOR_FLASH_14_TX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_acquisinator_flash_14_tx_t;

/**
 * Signals in message ACQUISINATOR_FLASH_14_TX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_acquisinator_flash_14_tx_converted_t;

/**
 * Signals in message ACQUISINATOR_FLASH_14_RX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_acquisinator_flash_14_rx_t;

/**
 * Signals in message ACQUISINATOR_FLASH_14_RX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_acquisinator_flash_14_rx_converted_t;

/**
 * Signals in message ACQUISINATOR_FLASH_15_TX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_acquisinator_flash_15_tx_t;

/**
 * Signals in message ACQUISINATOR_FLASH_15_TX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_acquisinator_flash_15_tx_converted_t;

/**
 * Signals in message ACQUISINATOR_FLASH_15_RX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_acquisinator_flash_15_rx_t;

/**
 * Signals in message ACQUISINATOR_FLASH_15_RX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_acquisinator_flash_15_rx_converted_t;

/**
 * Signals in message ACQUISINATOR_FLASH_16_TX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_acquisinator_flash_16_tx_t;

/**
 * Signals in message ACQUISINATOR_FLASH_16_TX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_acquisinator_flash_16_tx_converted_t;

/**
 * Signals in message ACQUISINATOR_FLASH_16_RX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_acquisinator_flash_16_rx_t;

/**
 * Signals in message ACQUISINATOR_FLASH_16_RX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_acquisinator_flash_16_rx_converted_t;

/**
 * Signals in message ACQUISINATOR_FLASH_17_TX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_acquisinator_flash_17_tx_t;

/**
 * Signals in message ACQUISINATOR_FLASH_17_TX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_acquisinator_flash_17_tx_converted_t;

/**
 * Signals in message ACQUISINATOR_FLASH_17_RX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_acquisinator_flash_17_rx_t;

/**
 * Signals in message ACQUISINATOR_FLASH_17_RX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_acquisinator_flash_17_rx_converted_t;

/**
 * Signals in message ACQUISINATOR_FLASH_18_TX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_acquisinator_flash_18_tx_t;

/**
 * Signals in message ACQUISINATOR_FLASH_18_TX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_acquisinator_flash_18_tx_converted_t;

/**
 * Signals in message ACQUISINATOR_FLASH_18_RX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_acquisinator_flash_18_rx_t;

/**
 * Signals in message ACQUISINATOR_FLASH_18_RX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_acquisinator_flash_18_rx_converted_t;

/**
 * Signals in message ACQUISINATOR_FLASH_19_TX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_acquisinator_flash_19_tx_t;

/**
 * Signals in message ACQUISINATOR_FLASH_19_TX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_acquisinator_flash_19_tx_converted_t;

/**
 * Signals in message ACQUISINATOR_FLASH_19_RX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_acquisinator_flash_19_rx_t;

/**
 * Signals in message ACQUISINATOR_FLASH_19_RX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_acquisinator_flash_19_rx_converted_t;

/**
 * Signals in message ACQUISINATOR_FLASH_20_TX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_acquisinator_flash_20_tx_t;

/**
 * Signals in message ACQUISINATOR_FLASH_20_TX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_acquisinator_flash_20_tx_converted_t;

/**
 * Signals in message ACQUISINATOR_FLASH_20_RX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_acquisinator_flash_20_rx_t;

/**
 * Signals in message ACQUISINATOR_FLASH_20_RX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_acquisinator_flash_20_rx_converted_t;

/**
 * Signals in message ACQUISINATOR_FLASH_21_TX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_acquisinator_flash_21_tx_t;

/**
 * Signals in message ACQUISINATOR_FLASH_21_TX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_acquisinator_flash_21_tx_converted_t;

/**
 * Signals in message ACQUISINATOR_FLASH_21_RX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_acquisinator_flash_21_rx_t;

/**
 * Signals in message ACQUISINATOR_FLASH_21_RX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_acquisinator_flash_21_rx_converted_t;

/**
 * Signals in message ACQUISINATOR_FLASH_22_TX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_acquisinator_flash_22_tx_t;

/**
 * Signals in message ACQUISINATOR_FLASH_22_TX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_acquisinator_flash_22_tx_converted_t;

/**
 * Signals in message ACQUISINATOR_FLASH_22_RX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_acquisinator_flash_22_rx_t;

/**
 * Signals in message ACQUISINATOR_FLASH_22_RX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_acquisinator_flash_22_rx_converted_t;

/**
 * Signals in message ACQUISINATOR_FLASH_23_TX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_acquisinator_flash_23_tx_t;

/**
 * Signals in message ACQUISINATOR_FLASH_23_TX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_acquisinator_flash_23_tx_converted_t;

/**
 * Signals in message ACQUISINATOR_FLASH_23_RX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_acquisinator_flash_23_rx_t;

/**
 * Signals in message ACQUISINATOR_FLASH_23_RX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_acquisinator_flash_23_rx_converted_t;

/**
 * Signals in message ACQUISINATOR_FLASH_24_TX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_acquisinator_flash_24_tx_t;

/**
 * Signals in message ACQUISINATOR_FLASH_24_TX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_acquisinator_flash_24_tx_converted_t;

/**
 * Signals in message ACQUISINATOR_FLASH_24_RX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_acquisinator_flash_24_rx_t;

/**
 * Signals in message ACQUISINATOR_FLASH_24_RX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_acquisinator_flash_24_rx_converted_t;

/**
 * Signals in message ACQUISINATOR_FLASH_25_TX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_acquisinator_flash_25_tx_t;

/**
 * Signals in message ACQUISINATOR_FLASH_25_TX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_acquisinator_flash_25_tx_converted_t;

/**
 * Signals in message ACQUISINATOR_FLASH_25_RX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_acquisinator_flash_25_rx_t;

/**
 * Signals in message ACQUISINATOR_FLASH_25_RX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_acquisinator_flash_25_rx_converted_t;

/**
 * Signals in message ACQUISINATOR_FLASH_26_TX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_acquisinator_flash_26_tx_t;

/**
 * Signals in message ACQUISINATOR_FLASH_26_TX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_acquisinator_flash_26_tx_converted_t;

/**
 * Signals in message ACQUISINATOR_FLASH_26_RX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_acquisinator_flash_26_rx_t;

/**
 * Signals in message ACQUISINATOR_FLASH_26_RX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_acquisinator_flash_26_rx_converted_t;

/**
 * Signals in message ACQUISINATOR_FLASH_27_TX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_acquisinator_flash_27_tx_t;

/**
 * Signals in message ACQUISINATOR_FLASH_27_TX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_acquisinator_flash_27_tx_converted_t;

/**
 * Signals in message ACQUISINATOR_FLASH_27_RX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_acquisinator_flash_27_rx_t;

/**
 * Signals in message ACQUISINATOR_FLASH_27_RX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_acquisinator_flash_27_rx_converted_t;

/**
 * Signals in message ACQUISINATOR_FLASH_28_TX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_acquisinator_flash_28_tx_t;

/**
 * Signals in message ACQUISINATOR_FLASH_28_TX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_acquisinator_flash_28_tx_converted_t;

/**
 * Signals in message ACQUISINATOR_FLASH_28_RX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_acquisinator_flash_28_rx_t;

/**
 * Signals in message ACQUISINATOR_FLASH_28_RX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_acquisinator_flash_28_rx_converted_t;

/**
 * Signals in message ACQUISINATOR_FLASH_29_TX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_acquisinator_flash_29_tx_t;

/**
 * Signals in message ACQUISINATOR_FLASH_29_TX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_acquisinator_flash_29_tx_converted_t;

/**
 * Signals in message ACQUISINATOR_FLASH_29_RX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_acquisinator_flash_29_rx_t;

/**
 * Signals in message ACQUISINATOR_FLASH_29_RX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_acquisinator_flash_29_rx_converted_t;

/**
 * Signals in message ACQUISINATOR_FLASH_30_TX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_acquisinator_flash_30_tx_t;

/**
 * Signals in message ACQUISINATOR_FLASH_30_TX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_acquisinator_flash_30_tx_converted_t;

/**
 * Signals in message ACQUISINATOR_FLASH_30_RX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_acquisinator_flash_30_rx_t;

/**
 * Signals in message ACQUISINATOR_FLASH_30_RX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_acquisinator_flash_30_rx_converted_t;

/**
 * Signals in message ACQUISINATOR_FLASH_31_TX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_acquisinator_flash_31_tx_t;

/**
 * Signals in message ACQUISINATOR_FLASH_31_TX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_acquisinator_flash_31_tx_converted_t;

/**
 * Signals in message ACQUISINATOR_FLASH_31_RX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_acquisinator_flash_31_rx_t;

/**
 * Signals in message ACQUISINATOR_FLASH_31_RX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_acquisinator_flash_31_rx_converted_t;

/**
 * Signals in message ACQUISINATOR_VERSION.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t acquisinator_id;

    /**
     * Range: 0..4294967295 (0..4294967295 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t canlib_build_time;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_acquisinator_version_t;

/**
 * Signals in message ACQUISINATOR_VERSION.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t acquisinator_id;

    /**
     * Range: 0..4294967295 (0..4294967295 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t canlib_build_time;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_acquisinator_version_converted_t;

/**
 * Signals in message IMU_ANGULAR_RATE.
 *
 * Inertial Measurement Unit [x,y,z]-axis angular rate value. 0.01dps per bit, Big-Endian, 16bit Total, signed
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..24500 (0..245 -)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t x;

    /**
     * Range: 0..24500 (0..245 -)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t y;

    /**
     * Range: 0..24500 (0..245 -)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t z;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_imu_angular_rate_t;

/**
 * Signals in message IMU_ANGULAR_RATE.
 *
 * Inertial Measurement Unit [x,y,z]-axis angular rate value. 0.01dps per bit, Big-Endian, 16bit Total, signed
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..24500 (0..245 -)
     * Scale: 0.01
     * Offset: 0
     */
    float x;

    /**
     * Range: 0..24500 (0..245 -)
     * Scale: 0.01
     * Offset: 0
     */
    float y;

    /**
     * Range: 0..24500 (0..245 -)
     * Scale: 0.01
     * Offset: 0
     */
    float z;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_imu_angular_rate_converted_t;

/**
 * Signals in message IMU_ACCELERATION.
 *
 * Inertial Measurement Unit [x,y,z]-axis acceleration value. 0.01g per bit, Big-Endian, 16bit Total, signed
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..800 (0..8 -)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t x;

    /**
     * Range: 0..800 (0..8 -)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t y;

    /**
     * Range: 0..800 (0..8 -)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t z;

    /**
     * Range: 0..65535 (-32768..32767 -)
     * Scale: 1
     * Offset: -32768
     */
    int16_t imu_temperature;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_imu_acceleration_t;

/**
 * Signals in message IMU_ACCELERATION.
 *
 * Inertial Measurement Unit [x,y,z]-axis acceleration value. 0.01g per bit, Big-Endian, 16bit Total, signed
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..800 (0..8 -)
     * Scale: 0.01
     * Offset: 0
     */
    float x;

    /**
     * Range: 0..800 (0..8 -)
     * Scale: 0.01
     * Offset: 0
     */
    float y;

    /**
     * Range: 0..800 (0..8 -)
     * Scale: 0.01
     * Offset: 0
     */
    float z;

    /**
     * Range: 0..65535 (-32768..32767 -)
     * Scale: 1
     * Offset: -32768
     */
    int16_t imu_temperature;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_imu_acceleration_converted_t;

/**
 * Signals in message IRTS_FL_0.
 *
 * Front Left wheel InfraRed Temperature Sensor data, channels 1 through 4. 0.1˚C per bit, -100˚C offset, Big-Endian, 16bit Total, unsigned.
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    uint16_t channel1;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    uint16_t channel2;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    uint16_t channel3;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    uint16_t channel4;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_irts_fl_0_t;

/**
 * Signals in message IRTS_FL_0.
 *
 * Front Left wheel InfraRed Temperature Sensor data, channels 1 through 4. 0.1˚C per bit, -100˚C offset, Big-Endian, 16bit Total, unsigned.
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    float channel1;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    float channel2;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    float channel3;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    float channel4;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_irts_fl_0_converted_t;

/**
 * Signals in message IRTS_FL_1.
 *
 * Front Left wheel InfraRed Temperature Sensor data, channels 5 through 8. 0.1˚C per bit, -100˚C offset, Big-Endian, 16bit Total, unsigned.
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    uint16_t channel5;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    uint16_t channel6;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    uint16_t channel7;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    uint16_t channel8;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_irts_fl_1_t;

/**
 * Signals in message IRTS_FL_1.
 *
 * Front Left wheel InfraRed Temperature Sensor data, channels 5 through 8. 0.1˚C per bit, -100˚C offset, Big-Endian, 16bit Total, unsigned.
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    float channel5;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    float channel6;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    float channel7;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    float channel8;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_irts_fl_1_converted_t;

/**
 * Signals in message IRTS_FL_2.
 *
 * Front Left wheel InfraRed Temperature Sensor data, channels 9 through 12. 0.1˚C per bit, -100˚C offset, Big-Endian, 16bit Total, unsigned.
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    uint16_t channel9;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    uint16_t channel10;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    uint16_t channel11;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    uint16_t channel12;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_irts_fl_2_t;

/**
 * Signals in message IRTS_FL_2.
 *
 * Front Left wheel InfraRed Temperature Sensor data, channels 9 through 12. 0.1˚C per bit, -100˚C offset, Big-Endian, 16bit Total, unsigned.
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    float channel9;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    float channel10;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    float channel11;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    float channel12;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_irts_fl_2_converted_t;

/**
 * Signals in message IRTS_FL_3.
 *
 * Front Left wheel InfraRed Temperature Sensor data, channels 13 through 16. 0.1˚C per bit, -100˚C offset, Big-Endian, 16bit Total, unsigned.
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    uint16_t channel13;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    uint16_t channel14;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    uint16_t channel15;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    uint16_t channel16;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_irts_fl_3_t;

/**
 * Signals in message IRTS_FL_3.
 *
 * Front Left wheel InfraRed Temperature Sensor data, channels 13 through 16. 0.1˚C per bit, -100˚C offset, Big-Endian, 16bit Total, unsigned.
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    float channel13;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    float channel14;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    float channel15;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    float channel16;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_irts_fl_3_converted_t;

/**
 * Signals in message IRTS_FR_0.
 *
 * Front Right wheel InfraRed Temperature Sensor data, channels 1 through 4. 0.1˚C per bit, -100˚C offset, Big-Endian, 16bit Total, unsigned.
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    uint16_t channel1;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    uint16_t channel2;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    uint16_t channel3;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    uint16_t channel4;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_irts_fr_0_t;

/**
 * Signals in message IRTS_FR_0.
 *
 * Front Right wheel InfraRed Temperature Sensor data, channels 1 through 4. 0.1˚C per bit, -100˚C offset, Big-Endian, 16bit Total, unsigned.
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    float channel1;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    float channel2;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    float channel3;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    float channel4;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_irts_fr_0_converted_t;

/**
 * Signals in message IRTS_FR_1.
 *
 * Front Right wheel InfraRed Temperature Sensor data, channels 5 through 8. 0.1˚C per bit, -100˚C offset, Big-Endian, 16bit Total, unsigned.
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    uint16_t channel5;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    uint16_t channel6;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    uint16_t channel7;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    uint16_t channel8;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_irts_fr_1_t;

/**
 * Signals in message IRTS_FR_1.
 *
 * Front Right wheel InfraRed Temperature Sensor data, channels 5 through 8. 0.1˚C per bit, -100˚C offset, Big-Endian, 16bit Total, unsigned.
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    float channel5;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    float channel6;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    float channel7;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    float channel8;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_irts_fr_1_converted_t;

/**
 * Signals in message IRTS_FR_2.
 *
 * Front Right wheel InfraRed Temperature Sensor data, channels 9 through 12. 0.1˚C per bit, -100˚C offset, Big-Endian, 16bit Total, unsigned.
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    uint16_t channel9;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    uint16_t channel10;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    uint16_t channel11;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    uint16_t channel12;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_irts_fr_2_t;

/**
 * Signals in message IRTS_FR_2.
 *
 * Front Right wheel InfraRed Temperature Sensor data, channels 9 through 12. 0.1˚C per bit, -100˚C offset, Big-Endian, 16bit Total, unsigned.
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    float channel9;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    float channel10;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    float channel11;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    float channel12;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_irts_fr_2_converted_t;

/**
 * Signals in message IRTS_FR_3.
 *
 * Front Right wheel InfraRed Temperature Sensor data, channels 13 through 16. 0.1˚C per bit, -100˚C offset, Big-Endian, 16bit Total, unsigned.
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    uint16_t channel13;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    uint16_t channel14;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    uint16_t channel15;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    uint16_t channel16;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_irts_fr_3_t;

/**
 * Signals in message IRTS_FR_3.
 *
 * Front Right wheel InfraRed Temperature Sensor data, channels 13 through 16. 0.1˚C per bit, -100˚C offset, Big-Endian, 16bit Total, unsigned.
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    float channel13;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    float channel14;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    float channel15;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    float channel16;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_irts_fr_3_converted_t;

/**
 * Signals in message IRTS_RL_0.
 *
 * Rear Left wheel InfraRed Temperature Sensor data, channels 1 through 4. 0.1˚C per bit, -100˚C offset, Big-Endian, 16bit Total, unsigned.
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    uint16_t channel1;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    uint16_t channel2;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    uint16_t channel3;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    uint16_t channel4;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_irts_rl_0_t;

/**
 * Signals in message IRTS_RL_0.
 *
 * Rear Left wheel InfraRed Temperature Sensor data, channels 1 through 4. 0.1˚C per bit, -100˚C offset, Big-Endian, 16bit Total, unsigned.
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    float channel1;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    float channel2;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    float channel3;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    float channel4;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_irts_rl_0_converted_t;

/**
 * Signals in message IRTS_RL_1.
 *
 * Rear Left wheel InfraRed Temperature Sensor data, channels 5 through 8. 0.1˚C per bit, -100˚C offset, Big-Endian, 16bit Total, unsigned.
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    uint16_t channel5;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    uint16_t channel6;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    uint16_t channel7;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    uint16_t channel8;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_irts_rl_1_t;

/**
 * Signals in message IRTS_RL_1.
 *
 * Rear Left wheel InfraRed Temperature Sensor data, channels 5 through 8. 0.1˚C per bit, -100˚C offset, Big-Endian, 16bit Total, unsigned.
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    float channel5;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    float channel6;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    float channel7;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    float channel8;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_irts_rl_1_converted_t;

/**
 * Signals in message IRTS_RL_2.
 *
 * Rear Left wheel InfraRed Temperature Sensor data, channels 9 through 12. 0.1˚C per bit, -100˚C offset, Big-Endian, 16bit Total, unsigned.
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    uint16_t channel9;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    uint16_t channel10;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    uint16_t channel11;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    uint16_t channel12;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_irts_rl_2_t;

/**
 * Signals in message IRTS_RL_2.
 *
 * Rear Left wheel InfraRed Temperature Sensor data, channels 9 through 12. 0.1˚C per bit, -100˚C offset, Big-Endian, 16bit Total, unsigned.
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    float channel9;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    float channel10;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    float channel11;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    float channel12;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_irts_rl_2_converted_t;

/**
 * Signals in message IRTS_RL_3.
 *
 * Rear Left wheel InfraRed Temperature Sensor data, channels 13 through 16. 0.1˚C per bit, -100˚C offset, Big-Endian, 16bit Total, unsigned.
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    uint16_t channel13;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    uint16_t channel14;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    uint16_t channel15;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    uint16_t channel16;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_irts_rl_3_t;

/**
 * Signals in message IRTS_RL_3.
 *
 * Rear Left wheel InfraRed Temperature Sensor data, channels 13 through 16. 0.1˚C per bit, -100˚C offset, Big-Endian, 16bit Total, unsigned.
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    float channel13;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    float channel14;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    float channel15;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    float channel16;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_irts_rl_3_converted_t;

/**
 * Signals in message IRTS_RR_0.
 *
 * Rear Right wheel InfraRed Temperature Sensor data, channels 1 through 4. 0.1˚C per bit, -100˚C offset, Big-Endian, 16bit Total, unsigned.
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    uint16_t channel1;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    uint16_t channel2;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    uint16_t channel3;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    uint16_t channel4;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_irts_rr_0_t;

/**
 * Signals in message IRTS_RR_0.
 *
 * Rear Right wheel InfraRed Temperature Sensor data, channels 1 through 4. 0.1˚C per bit, -100˚C offset, Big-Endian, 16bit Total, unsigned.
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    float channel1;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    float channel2;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    float channel3;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    float channel4;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_irts_rr_0_converted_t;

/**
 * Signals in message IRTS_RR_1.
 *
 * Rear Right wheel InfraRed Temperature Sensor data, channels 5 through 8. 0.1˚C per bit, -100˚C offset, Big-Endian, 16bit Total, unsigned.
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    uint16_t channel5;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    uint16_t channel6;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    uint16_t channel7;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    uint16_t channel8;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_irts_rr_1_t;

/**
 * Signals in message IRTS_RR_1.
 *
 * Rear Right wheel InfraRed Temperature Sensor data, channels 5 through 8. 0.1˚C per bit, -100˚C offset, Big-Endian, 16bit Total, unsigned.
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    float channel5;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    float channel6;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    float channel7;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    float channel8;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_irts_rr_1_converted_t;

/**
 * Signals in message IRTS_RR_2.
 *
 * Rear Right wheel InfraRed Temperature Sensor data, channels 9 through 12. 0.1˚C per bit, -100˚C offset, Big-Endian, 16bit Total, unsigned.
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    uint16_t channel9;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    uint16_t channel10;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    uint16_t channel11;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    uint16_t channel12;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_irts_rr_2_t;

/**
 * Signals in message IRTS_RR_2.
 *
 * Rear Right wheel InfraRed Temperature Sensor data, channels 9 through 12. 0.1˚C per bit, -100˚C offset, Big-Endian, 16bit Total, unsigned.
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    float channel9;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    float channel10;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    float channel11;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    float channel12;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_irts_rr_2_converted_t;

/**
 * Signals in message IRTS_RR_3.
 *
 * Rear Right wheel InfraRed Temperature Sensor data, channels 13 through 16. 0.1˚C per bit, -100˚C offset, Big-Endian, 16bit Total, unsigned.
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    uint16_t channel13;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    uint16_t channel14;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    uint16_t channel15;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    uint16_t channel16;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_irts_rr_3_t;

/**
 * Signals in message IRTS_RR_3.
 *
 * Rear Right wheel InfraRed Temperature Sensor data, channels 13 through 16. 0.1˚C per bit, -100˚C offset, Big-Endian, 16bit Total, unsigned.
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    float channel13;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    float channel14;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    float channel15;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    float channel16;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_irts_rr_3_converted_t;

/**
 * Signals in message VEHICLE_POSITION.
 *
 * Vehicle position in meters and heading in radians
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (-1000..1000 -)
     * Scale: 0.030518043793392843
     * Offset: -1000
     */
    uint16_t x;

    /**
     * Range: 0..65535 (-1000..1000 -)
     * Scale: 0.030518043793392843
     * Offset: -1000
     */
    uint16_t y;

    /**
     * Range: 0..65534.99999999999 (-3.14159..3.14159 -)
     * Scale: 9.587518120088503e-05
     * Offset: -3.14159
     */
    uint16_t heading;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_vehicle_position_t;

/**
 * Signals in message VEHICLE_POSITION.
 *
 * Vehicle position in meters and heading in radians
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (-1000..1000 -)
     * Scale: 0.030518043793392843
     * Offset: -1000
     */
    float x;

    /**
     * Range: 0..65535 (-1000..1000 -)
     * Scale: 0.030518043793392843
     * Offset: -1000
     */
    float y;

    /**
     * Range: 0..65534.99999999999 (-3.14159..3.14159 -)
     * Scale: 9.587518120088503e-05
     * Offset: -3.14159
     */
    float heading;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_vehicle_position_converted_t;

/**
 * Signals in message VEHICLE_SPEED.
 *
 * Vehicle speed in m/s
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (0..40 -)
     * Scale: 0.0006103608758678569
     * Offset: 0
     */
    uint16_t u;

    /**
     * Range: 0..65535 (-20..20 -)
     * Scale: 0.0006103608758678569
     * Offset: -20
     */
    uint16_t v;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_vehicle_speed_t;

/**
 * Signals in message VEHICLE_SPEED.
 *
 * Vehicle speed in m/s
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (0..40 -)
     * Scale: 0.0006103608758678569
     * Offset: 0
     */
    float u;

    /**
     * Range: 0..65535 (-20..20 -)
     * Scale: 0.0006103608758678569
     * Offset: -20
     */
    float v;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_vehicle_speed_converted_t;

/**
 * Signals in message VEHICLE_CURVILINEAR_COORDINATES.
 *
 * Vehicle curvilinear coordinates wrt baseline
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..4294967295 (0..5000 -)
     * Scale: 1.1641532185403987e-06
     * Offset: 0
     */
    uint32_t s;

    /**
     * Range: 0..65535 (-10..10 -)
     * Scale: 0.00030518043793392844
     * Offset: -10
     */
    uint16_t n;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_vehicle_curvilinear_coordinates_t;

/**
 * Signals in message VEHICLE_CURVILINEAR_COORDINATES.
 *
 * Vehicle curvilinear coordinates wrt baseline
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..4294967295 (0..5000 -)
     * Scale: 1.1641532185403987e-06
     * Offset: 0
     */
    float s;

    /**
     * Range: 0..65535 (-10..10 -)
     * Scale: 0.00030518043793392844
     * Offset: -10
     */
    float n;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_vehicle_curvilinear_coordinates_converted_t;

/**
 * Signals in message FRONT_ANGULAR_VELOCITY.
 *
 * Front encoder speed in rad/sec
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (-200..200 -)
     * Scale: 0.006103608758678569
     * Offset: -200
     */
    uint16_t fl;

    /**
     * Range: 0..65535 (-200..200 -)
     * Scale: 0.006103608758678569
     * Offset: -200
     */
    uint16_t fr;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_front_angular_velocity_t;

/**
 * Signals in message FRONT_ANGULAR_VELOCITY.
 *
 * Front encoder speed in rad/sec
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (-200..200 -)
     * Scale: 0.006103608758678569
     * Offset: -200
     */
    float fl;

    /**
     * Range: 0..65535 (-200..200 -)
     * Scale: 0.006103608758678569
     * Offset: -200
     */
    float fr;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_front_angular_velocity_converted_t;

/**
 * Signals in message REAR_ANGULAR_VELOCITY.
 *
 * Rear encoders speed in rad/sec
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (-200..200 -)
     * Scale: 0.006103608758678569
     * Offset: -200
     */
    uint16_t rl;

    /**
     * Range: 0..65535 (-200..200 -)
     * Scale: 0.006103608758678569
     * Offset: -200
     */
    uint16_t rr;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_rear_angular_velocity_t;

/**
 * Signals in message REAR_ANGULAR_VELOCITY.
 *
 * Rear encoders speed in rad/sec
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (-200..200 -)
     * Scale: 0.006103608758678569
     * Offset: -200
     */
    float rl;

    /**
     * Range: 0..65535 (-200..200 -)
     * Scale: 0.006103608758678569
     * Offset: -200
     */
    float rr;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_rear_angular_velocity_converted_t;

/**
 * Signals in message HV_SOC_ESTIMATION_STATE.
 *
 * State of Charge estimation state
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (0..1 -)
     * Scale: 1.5259021896696422e-05
     * Offset: 0
     */
    uint16_t soc;

    /**
     * Range: 0..65535 (0..4.5 -)
     * Scale: 6.86655985351339e-05
     * Offset: 0
     */
    uint16_t rc1;

    /**
     * Range: 0..65535 (0..4.5 -)
     * Scale: 6.86655985351339e-05
     * Offset: 0
     */
    uint16_t rc2;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_hv_soc_estimation_state_t;

/**
 * Signals in message HV_SOC_ESTIMATION_STATE.
 *
 * State of Charge estimation state
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (0..1 -)
     * Scale: 1.5259021896696422e-05
     * Offset: 0
     */
    float soc;

    /**
     * Range: 0..65535 (0..4.5 -)
     * Scale: 6.86655985351339e-05
     * Offset: 0
     */
    float rc1;

    /**
     * Range: 0..65535 (0..4.5 -)
     * Scale: 6.86655985351339e-05
     * Offset: 0
     */
    float rc2;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_hv_soc_estimation_state_converted_t;

/**
 * Signals in message HV_SOC_ESTIMATION_COVARIANCE.
 *
 * State of Charge estimation covariance of the state
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (0..10 -)
     * Scale: 0.00015259021896696422
     * Offset: 0
     */
    uint16_t soc;

    /**
     * Range: 0..65535 (0..100 -)
     * Scale: 0.0015259021896696422
     * Offset: 0
     */
    uint16_t rc1;

    /**
     * Range: 0..65535 (0..100 -)
     * Scale: 0.0015259021896696422
     * Offset: 0
     */
    uint16_t rc2;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_hv_soc_estimation_covariance_t;

/**
 * Signals in message HV_SOC_ESTIMATION_COVARIANCE.
 *
 * State of Charge estimation covariance of the state
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (0..10 -)
     * Scale: 0.00015259021896696422
     * Offset: 0
     */
    float soc;

    /**
     * Range: 0..65535 (0..100 -)
     * Scale: 0.0015259021896696422
     * Offset: 0
     */
    float rc1;

    /**
     * Range: 0..65535 (0..100 -)
     * Scale: 0.0015259021896696422
     * Offset: 0
     */
    float rc2;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_hv_soc_estimation_covariance_converted_t;

/**
 * Signals in message LV_SOC_ESTIMATION_STATE.
 *
 * State of Charge estimation state
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (0..1 -)
     * Scale: 1.5259021896696422e-05
     * Offset: 0
     */
    uint16_t soc;

    /**
     * Range: 0..65535 (0..4.5 -)
     * Scale: 6.86655985351339e-05
     * Offset: 0
     */
    uint16_t rc1;

    /**
     * Range: 0..65535 (0..4.5 -)
     * Scale: 6.86655985351339e-05
     * Offset: 0
     */
    uint16_t rc2;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_lv_soc_estimation_state_t;

/**
 * Signals in message LV_SOC_ESTIMATION_STATE.
 *
 * State of Charge estimation state
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (0..1 -)
     * Scale: 1.5259021896696422e-05
     * Offset: 0
     */
    float soc;

    /**
     * Range: 0..65535 (0..4.5 -)
     * Scale: 6.86655985351339e-05
     * Offset: 0
     */
    float rc1;

    /**
     * Range: 0..65535 (0..4.5 -)
     * Scale: 6.86655985351339e-05
     * Offset: 0
     */
    float rc2;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_lv_soc_estimation_state_converted_t;

/**
 * Signals in message LV_SOC_ESTIMATION_COVARIANCE.
 *
 * State of Charge estimation covariance of the state
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (0..10 -)
     * Scale: 0.00015259021896696422
     * Offset: 0
     */
    uint16_t soc;

    /**
     * Range: 0..65535 (0..100 -)
     * Scale: 0.0015259021896696422
     * Offset: 0
     */
    uint16_t rc1;

    /**
     * Range: 0..65535 (0..100 -)
     * Scale: 0.0015259021896696422
     * Offset: 0
     */
    uint16_t rc2;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_lv_soc_estimation_covariance_t;

/**
 * Signals in message LV_SOC_ESTIMATION_COVARIANCE.
 *
 * State of Charge estimation covariance of the state
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (0..10 -)
     * Scale: 0.00015259021896696422
     * Offset: 0
     */
    float soc;

    /**
     * Range: 0..65535 (0..100 -)
     * Scale: 0.0015259021896696422
     * Offset: 0
     */
    float rc1;

    /**
     * Range: 0..65535 (0..100 -)
     * Scale: 0.0015259021896696422
     * Offset: 0
     */
    float rc2;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_lv_soc_estimation_covariance_converted_t;

/**
 * Signals in message PEDAL_THROTTLE.
 *
 * Pedal Throttle , already calibrated
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (0..1 -)
     * Scale: 1.5259021896696422e-05
     * Offset: 0
     */
    uint16_t throttle;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_pedal_throttle_t;

/**
 * Signals in message PEDAL_THROTTLE.
 *
 * Pedal Throttle , already calibrated
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (0..1 -)
     * Scale: 1.5259021896696422e-05
     * Offset: 0
     */
    float throttle;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_pedal_throttle_converted_t;

/**
 * Signals in message PEDAL_BRAKES_PRESSURE.
 *
 * Pedal brakes pressures in bar, already calibrated
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (0..100 -)
     * Scale: 0.0015259021896696422
     * Offset: 0
     */
    uint16_t front;

    /**
     * Range: 0..65535 (0..100 -)
     * Scale: 0.0015259021896696422
     * Offset: 0
     */
    uint16_t rear;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_pedal_brakes_pressure_t;

/**
 * Signals in message PEDAL_BRAKES_PRESSURE.
 *
 * Pedal brakes pressures in bar, already calibrated
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (0..100 -)
     * Scale: 0.0015259021896696422
     * Offset: 0
     */
    float front;

    /**
     * Range: 0..65535 (0..100 -)
     * Scale: 0.0015259021896696422
     * Offset: 0
     */
    float rear;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_pedal_brakes_pressure_converted_t;

/**
 * Signals in message STEER_ANGLE.
 *
 * Steering angle in degrees
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..4294967295 (-180..180 -)
     * Scale: 8.38190317349087e-08
     * Offset: -180
     */
    uint32_t angle;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_steer_angle_t;

/**
 * Signals in message STEER_ANGLE.
 *
 * Steering angle in degrees
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..4294967295 (-180..180 -)
     * Scale: 8.38190317349087e-08
     * Offset: -180
     */
    float angle;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_steer_angle_converted_t;

/**
 * Signals in message ODOMETER.
 *
 * Cumulative kilometers count
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..4294967295 (0..1000000 -)
     * Scale: 0.00023283064370807974
     * Offset: 0
     */
    uint32_t kilometers;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_odometer_t;

/**
 * Signals in message ODOMETER.
 *
 * Cumulative kilometers count
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..4294967295 (0..1000000 -)
     * Scale: 0.00023283064370807974
     * Offset: 0
     */
    float kilometers;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_odometer_converted_t;

/**
 * Signals in message TPMS_PRESSURE.
 *
 * Tire Pressure Monitoring System, pressure of each tire
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1.0
     * Offset: 0
     */
    uint8_t fl;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1.0
     * Offset: 0
     */
    uint8_t fr;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1.0
     * Offset: 0
     */
    uint8_t rl;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1.0
     * Offset: 0
     */
    uint8_t rr;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_tpms_pressure_t;

/**
 * Signals in message TPMS_PRESSURE.
 *
 * Tire Pressure Monitoring System, pressure of each tire
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1.0
     * Offset: 0
     */
    uint8_t fl;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1.0
     * Offset: 0
     */
    uint8_t fr;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1.0
     * Offset: 0
     */
    uint8_t rl;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1.0
     * Offset: 0
     */
    uint8_t rr;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_tpms_pressure_converted_t;

/**
 * Signals in message TPMS_TEMPERATURE.
 *
 * Tire Pressure Monitoring System, temperature of each tire
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1.0
     * Offset: 0
     */
    uint8_t fl;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1.0
     * Offset: 0
     */
    uint8_t fr;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1.0
     * Offset: 0
     */
    uint8_t rl;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1.0
     * Offset: 0
     */
    uint8_t rr;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_tpms_temperature_t;

/**
 * Signals in message TPMS_TEMPERATURE.
 *
 * Tire Pressure Monitoring System, temperature of each tire
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1.0
     * Offset: 0
     */
    uint8_t fl;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1.0
     * Offset: 0
     */
    uint8_t fr;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1.0
     * Offset: 0
     */
    uint8_t rl;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1.0
     * Offset: 0
     */
    uint8_t rr;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_tpms_temperature_converted_t;

/**
 * Signals in message TLM_UNIX_TIMESTAMP.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..18446744073709551616 (0..18446744073709551615 -)
     * Scale: 1
     * Offset: 0
     */
    uint64_t timestamp;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_tlm_unix_timestamp_t;

/**
 * Signals in message TLM_UNIX_TIMESTAMP.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..18446744073709551616 (0..18446744073709551615 -)
     * Scale: 1
     * Offset: 0
     */
    uint64_t timestamp;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_tlm_unix_timestamp_converted_t;

/**
 * Signals in message TLM_LAP_TIME.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t lap_count;

    /**
     * Range: 0..65535 (0..1000 -)
     * Scale: 0.015259021896696421
     * Offset: 0
     */
    uint16_t lap_time;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_tlm_lap_time_t;

/**
 * Signals in message TLM_LAP_TIME.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t lap_count;

    /**
     * Range: 0..65535 (0..1000 -)
     * Scale: 0.015259021896696421
     * Offset: 0
     */
    float lap_time;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_tlm_lap_time_converted_t;

/**
 * Signals in message TLM_LAPS_STATS.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t lap_number;

    /**
     * Range: 0..65535 (0..1000 -)
     * Scale: 0.015259021896696421
     * Offset: 0
     */
    uint16_t best_time;

    /**
     * Range: 0..65535 (0..1000 -)
     * Scale: 0.015259021896696421
     * Offset: 0
     */
    uint16_t last_time;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_tlm_laps_stats_t;

/**
 * Signals in message TLM_LAPS_STATS.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t lap_number;

    /**
     * Range: 0..65535 (0..1000 -)
     * Scale: 0.015259021896696421
     * Offset: 0
     */
    float best_time;

    /**
     * Range: 0..65535 (0..1000 -)
     * Scale: 0.015259021896696421
     * Offset: 0
     */
    float last_time;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_tlm_laps_stats_converted_t;

/**
 * Signals in message TLM_NETWORK_INTERFACE.
 *
 * Network interface from telemetry device, only IPV4
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t iname_0;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t iname_1;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t iname_2;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t iname_3;

    /**
     * Range: 0..4294967295 (0..4294967295 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t ip_address;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_tlm_network_interface_t;

/**
 * Signals in message TLM_NETWORK_INTERFACE.
 *
 * Network interface from telemetry device, only IPV4
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t iname_0;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t iname_1;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t iname_2;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t iname_3;

    /**
     * Range: 0..4294967295 (0..4294967295 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t ip_address;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_tlm_network_interface_converted_t;

/**
 * Signals in message FRONT_AMMO_COMPRESSION.
 *
 * Front ammo compressions
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (-100..100 -)
     * Scale: 0.0030518043793392844
     * Offset: -100
     */
    uint16_t fl;

    /**
     * Range: 0..65535 (-100..100 -)
     * Scale: 0.0030518043793392844
     * Offset: -100
     */
    uint16_t fr;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_front_ammo_compression_t;

/**
 * Signals in message FRONT_AMMO_COMPRESSION.
 *
 * Front ammo compressions
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (-100..100 -)
     * Scale: 0.0030518043793392844
     * Offset: -100
     */
    float fl;

    /**
     * Range: 0..65535 (-100..100 -)
     * Scale: 0.0030518043793392844
     * Offset: -100
     */
    float fr;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_front_ammo_compression_converted_t;

/**
 * Signals in message REAR_AMMO_COMPRESSION.
 *
 * Rear ammo compressions
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (-100..100 -)
     * Scale: 0.0030518043793392844
     * Offset: -100
     */
    uint16_t rl;

    /**
     * Range: 0..65535 (-100..100 -)
     * Scale: 0.0030518043793392844
     * Offset: -100
     */
    uint16_t rr;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_rear_ammo_compression_t;

/**
 * Signals in message REAR_AMMO_COMPRESSION.
 *
 * Rear ammo compressions
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (-100..100 -)
     * Scale: 0.0030518043793392844
     * Offset: -100
     */
    float rl;

    /**
     * Range: 0..65535 (-100..100 -)
     * Scale: 0.0030518043793392844
     * Offset: -100
     */
    float rr;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_rear_ammo_compression_converted_t;

/**
 * Signals in message ACQUISINATOR_CALIBRATIONS_OFFSETS.
 *
 * Calibration offsets for acquisinators
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t acquisinator_id;

    /**
     * Range: 0..65535 (-100.0..100.0 -)
     * Scale: 0.0030518043793392844
     * Offset: -100.0
     */
    uint16_t offset1;

    /**
     * Range: 0..4294967295 (-100.0..100.0 -)
     * Scale: 4.656612874161595e-08
     * Offset: -100.0
     */
    uint32_t offset2;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_acquisinator_calibrations_offsets_t;

/**
 * Signals in message ACQUISINATOR_CALIBRATIONS_OFFSETS.
 *
 * Calibration offsets for acquisinators
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t acquisinator_id;

    /**
     * Range: 0..65535 (-100.0..100.0 -)
     * Scale: 0.0030518043793392844
     * Offset: -100.0
     */
    float offset1;

    /**
     * Range: 0..4294967295 (-100.0..100.0 -)
     * Scale: 4.656612874161595e-08
     * Offset: -100.0
     */
    float offset2;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_acquisinator_calibrations_offsets_converted_t;

/**
 * Signals in message ACQUISINATOR_ERRORS.
 *
 * Acquisinator errors
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t acquisinator_id;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t acquisinator_errors_acquisinatore_led_code_can_not_working;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t acquisinator_errors_acquisinatore_led_code_spi_error;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t acquisinator_errors_acquisinatore_led_code_read_write_flash;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t acquisinator_errors_acquisinatore_led_code_flashed_firmware_with_wrong_id;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_acquisinator_errors_t;

/**
 * Signals in message ACQUISINATOR_ERRORS.
 *
 * Acquisinator errors
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t acquisinator_id;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int acquisinator_errors_acquisinatore_led_code_can_not_working : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int acquisinator_errors_acquisinatore_led_code_spi_error : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int acquisinator_errors_acquisinatore_led_code_read_write_flash : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int acquisinator_errors_acquisinatore_led_code_flashed_firmware_with_wrong_id : 1;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_acquisinator_errors_converted_t;

/**
 * Signals in message LINK_DEFORMATION_DEBUG_VOLTAGES.
 *
 * Debug message with raw voltages from strain gauges
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    secondary_link_deformation_debug_voltages_wheel_id wheel_id;

    /**
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    secondary_link_deformation_debug_voltages_rod_id rod_id;

    /**
     * Range: 0..4294967295 (0.0..3.5 -)
     * Scale: 8.149072529782791e-10
     * Offset: 0.0
     */
    uint32_t raw_voltage;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_link_deformation_debug_voltages_t;

/**
 * Signals in message LINK_DEFORMATION_DEBUG_VOLTAGES.
 *
 * Debug message with raw voltages from strain gauges
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    secondary_link_deformation_debug_voltages_wheel_id wheel_id;

    /**
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    secondary_link_deformation_debug_voltages_rod_id rod_id;

    /**
     * Range: 0..4294967295 (0.0..3.5 -)
     * Scale: 8.149072529782791e-10
     * Offset: 0.0
     */
    float raw_voltage;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_link_deformation_debug_voltages_converted_t;

/**
 * Signals in message LINK_DEFORMATION_FL_WHEEL.
 *
 * Message for the arm deformation for the front left wheel
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    secondary_link_deformation_fl_wheel_rod_id rod_id;

    /**
     * Range: 0..4294967295 (-0.01..0.01 -)
     * Scale: 4.656612874161595e-12
     * Offset: -0.01
     */
    uint32_t deformation;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_link_deformation_fl_wheel_t;

/**
 * Signals in message LINK_DEFORMATION_FL_WHEEL.
 *
 * Message for the arm deformation for the front left wheel
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    secondary_link_deformation_fl_wheel_rod_id rod_id;

    /**
     * Range: 0..4294967295 (-0.01..0.01 -)
     * Scale: 4.656612874161595e-12
     * Offset: -0.01
     */
    float deformation;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_link_deformation_fl_wheel_converted_t;

/**
 * Signals in message LINK_DEFORMATION_FR_WHEEL.
 *
 * Message for the arm deformation for the front right wheel
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    secondary_link_deformation_fr_wheel_rod_id rod_id;

    /**
     * Range: 0..4294967295 (-0.01..0.01 -)
     * Scale: 4.656612874161595e-12
     * Offset: -0.01
     */
    uint32_t deformation;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_link_deformation_fr_wheel_t;

/**
 * Signals in message LINK_DEFORMATION_FR_WHEEL.
 *
 * Message for the arm deformation for the front right wheel
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    secondary_link_deformation_fr_wheel_rod_id rod_id;

    /**
     * Range: 0..4294967295 (-0.01..0.01 -)
     * Scale: 4.656612874161595e-12
     * Offset: -0.01
     */
    float deformation;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_link_deformation_fr_wheel_converted_t;

/**
 * Signals in message LINK_DEFORMATION_RL_WHEEL.
 *
 * Message for the arm deformation for the rear left wheel
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    secondary_link_deformation_rl_wheel_rod_id rod_id;

    /**
     * Range: 0..4294967295 (-0.01..0.01 -)
     * Scale: 4.656612874161595e-12
     * Offset: -0.01
     */
    uint32_t deformation;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_link_deformation_rl_wheel_t;

/**
 * Signals in message LINK_DEFORMATION_RL_WHEEL.
 *
 * Message for the arm deformation for the rear left wheel
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    secondary_link_deformation_rl_wheel_rod_id rod_id;

    /**
     * Range: 0..4294967295 (-0.01..0.01 -)
     * Scale: 4.656612874161595e-12
     * Offset: -0.01
     */
    float deformation;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_link_deformation_rl_wheel_converted_t;

/**
 * Signals in message LINK_DEFORMATION_RR_WHEEL.
 *
 * Message for the arm deformation for the rear right wheel
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    secondary_link_deformation_rr_wheel_rod_id rod_id;

    /**
     * Range: 0..4294967295 (-0.01..0.01 -)
     * Scale: 4.656612874161595e-12
     * Offset: -0.01
     */
    uint32_t deformation;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_link_deformation_rr_wheel_t;

/**
 * Signals in message LINK_DEFORMATION_RR_WHEEL.
 *
 * Message for the arm deformation for the rear right wheel
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    secondary_link_deformation_rr_wheel_rod_id rod_id;

    /**
     * Range: 0..4294967295 (-0.01..0.01 -)
     * Scale: 4.656612874161595e-12
     * Offset: -0.01
     */
    float deformation;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_link_deformation_rr_wheel_converted_t;

/**
 * Signals in message LINK_DEFORMATION_SET_CALIBRATION.
 *
 * Calibration command for link deformation
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_link_deformation_set_calibration_t;

/**
 * Signals in message LINK_DEFORMATION_SET_CALIBRATION.
 *
 * Calibration command for link deformation
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_link_deformation_set_calibration_converted_t;

/**
 * Signals in message AMMO_COMPRESSION_SET_CALIBRATION.
 *
 * Calibration command for ammo compression
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_ammo_compression_set_calibration_t;

/**
 * Signals in message AMMO_COMPRESSION_SET_CALIBRATION.
 *
 * Calibration command for ammo compression
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_ammo_compression_set_calibration_converted_t;

/**
 * Signals in message DEBUG_SIGNAL_5.
 *
 * Debug signals
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    secondary_debug_signal_5_device_id device_id;

    /**
     * Range: 0..65535 (-1..1 -)
     * Scale: 3.0518043793392844e-05
     * Offset: -1
     */
    uint16_t field_1;

    /**
     * Range: 0..65535 (-1..1 -)
     * Scale: 3.0518043793392844e-05
     * Offset: -1
     */
    uint16_t field_2;

    /**
     * Range: 0..65535 (-1..1 -)
     * Scale: 3.0518043793392844e-05
     * Offset: -1
     */
    uint16_t field_3;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_debug_signal_5_t;

/**
 * Signals in message DEBUG_SIGNAL_5.
 *
 * Debug signals
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    secondary_debug_signal_5_device_id device_id;

    /**
     * Range: 0..65535 (-1..1 -)
     * Scale: 3.0518043793392844e-05
     * Offset: -1
     */
    float field_1;

    /**
     * Range: 0..65535 (-1..1 -)
     * Scale: 3.0518043793392844e-05
     * Offset: -1
     */
    float field_2;

    /**
     * Range: 0..65535 (-1..1 -)
     * Scale: 3.0518043793392844e-05
     * Offset: -1
     */
    float field_3;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_debug_signal_5_converted_t;

/**
 * Signals in message DEBUG_SIGNAL_6.
 *
 * Debug signals
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    secondary_debug_signal_6_device_id device_id;

    /**
     * Range: 0..65535 (-1..1 -)
     * Scale: 3.0518043793392844e-05
     * Offset: -1
     */
    uint16_t field_1;

    /**
     * Range: 0..65535 (-1..1 -)
     * Scale: 3.0518043793392844e-05
     * Offset: -1
     */
    uint16_t field_2;

    /**
     * Range: 0..65535 (-1..1 -)
     * Scale: 3.0518043793392844e-05
     * Offset: -1
     */
    uint16_t field_3;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_debug_signal_6_t;

/**
 * Signals in message DEBUG_SIGNAL_6.
 *
 * Debug signals
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    secondary_debug_signal_6_device_id device_id;

    /**
     * Range: 0..65535 (-1..1 -)
     * Scale: 3.0518043793392844e-05
     * Offset: -1
     */
    float field_1;

    /**
     * Range: 0..65535 (-1..1 -)
     * Scale: 3.0518043793392844e-05
     * Offset: -1
     */
    float field_2;

    /**
     * Range: 0..65535 (-1..1 -)
     * Scale: 3.0518043793392844e-05
     * Offset: -1
     */
    float field_3;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_debug_signal_6_converted_t;

/**
 * Signals in message DEBUG_SIGNAL_7.
 *
 * Debug signals
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    secondary_debug_signal_7_device_id device_id;

    /**
     * Range: 0..65535 (-1..1 -)
     * Scale: 3.0518043793392844e-05
     * Offset: -1
     */
    uint16_t field_1;

    /**
     * Range: 0..65535 (-1..1 -)
     * Scale: 3.0518043793392844e-05
     * Offset: -1
     */
    uint16_t field_2;

    /**
     * Range: 0..65535 (-1..1 -)
     * Scale: 3.0518043793392844e-05
     * Offset: -1
     */
    uint16_t field_3;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_debug_signal_7_t;

/**
 * Signals in message DEBUG_SIGNAL_7.
 *
 * Debug signals
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    secondary_debug_signal_7_device_id device_id;

    /**
     * Range: 0..65535 (-1..1 -)
     * Scale: 3.0518043793392844e-05
     * Offset: -1
     */
    float field_1;

    /**
     * Range: 0..65535 (-1..1 -)
     * Scale: 3.0518043793392844e-05
     * Offset: -1
     */
    float field_2;

    /**
     * Range: 0..65535 (-1..1 -)
     * Scale: 3.0518043793392844e-05
     * Offset: -1
     */
    float field_3;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_debug_signal_7_converted_t;

/**
 * Signals in message DEBUG_SIGNAL_8.
 *
 * Debug signals
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    secondary_debug_signal_8_device_id device_id;

    /**
     * Range: 0..65535 (-1..1 -)
     * Scale: 3.0518043793392844e-05
     * Offset: -1
     */
    uint16_t field_1;

    /**
     * Range: 0..65535 (-1..1 -)
     * Scale: 3.0518043793392844e-05
     * Offset: -1
     */
    uint16_t field_2;

    /**
     * Range: 0..65535 (-1..1 -)
     * Scale: 3.0518043793392844e-05
     * Offset: -1
     */
    uint16_t field_3;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_debug_signal_8_t;

/**
 * Signals in message DEBUG_SIGNAL_8.
 *
 * Debug signals
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    secondary_debug_signal_8_device_id device_id;

    /**
     * Range: 0..65535 (-1..1 -)
     * Scale: 3.0518043793392844e-05
     * Offset: -1
     */
    float field_1;

    /**
     * Range: 0..65535 (-1..1 -)
     * Scale: 3.0518043793392844e-05
     * Offset: -1
     */
    float field_2;

    /**
     * Range: 0..65535 (-1..1 -)
     * Scale: 3.0518043793392844e-05
     * Offset: -1
     */
    float field_3;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_debug_signal_8_converted_t;

/**
 * Signals in message COOLING_TEMP_PUMPS.
 *
 * Temperature of pumps input to the radiator and output
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (-10..110 -)
     * Scale: 0.0018310826276035706
     * Offset: -10
     */
    uint16_t input;

    /**
     * Range: 0..65535 (-10..110 -)
     * Scale: 0.0018310826276035706
     * Offset: -10
     */
    uint16_t output;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_cooling_temp_pumps_t;

/**
 * Signals in message COOLING_TEMP_PUMPS.
 *
 * Temperature of pumps input to the radiator and output
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (-10..110 -)
     * Scale: 0.0018310826276035706
     * Offset: -10
     */
    float input;

    /**
     * Range: 0..65535 (-10..110 -)
     * Scale: 0.0018310826276035706
     * Offset: -10
     */
    float output;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_cooling_temp_pumps_converted_t;

/**
 * Signals in message COOLING_TEMP_RADIATORS.
 *
 * Air temperature outside the radiator
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (-10..110 -)
     * Scale: 0.0018310826276035706
     * Offset: -10
     */
    uint16_t air_temp;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_cooling_temp_radiators_t;

/**
 * Signals in message COOLING_TEMP_RADIATORS.
 *
 * Air temperature outside the radiator
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (-10..110 -)
     * Scale: 0.0018310826276035706
     * Offset: -10
     */
    float air_temp;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_cooling_temp_radiators_converted_t;

/**
 * Signals in message LATERAL_CONTROLLER_PREVIEW_POINT_ERRORS.
 *
 * Lateral controller (preview point) controller errors
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65534.99999999999 (-3.14159..3.14159 -)
     * Scale: 9.587518120088503e-05
     * Offset: -3.14159
     */
    uint16_t heading;

    /**
     * Range: 0..65535 (-10..10 -)
     * Scale: 0.00030518043793392844
     * Offset: -10
     */
    uint16_t distance;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_lateral_controller_preview_point_errors_t;

/**
 * Signals in message LATERAL_CONTROLLER_PREVIEW_POINT_ERRORS.
 *
 * Lateral controller (preview point) controller errors
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65534.99999999999 (-3.14159..3.14159 -)
     * Scale: 9.587518120088503e-05
     * Offset: -3.14159
     */
    float heading;

    /**
     * Range: 0..65535 (-10..10 -)
     * Scale: 0.00030518043793392844
     * Offset: -10
     */
    float distance;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_lateral_controller_preview_point_errors_converted_t;

/**
 * Signals in message LATERAL_CONTROLLER_ERRORS.
 *
 * Lateral controller errors
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (-10..10 -)
     * Scale: 0.00030518043793392844
     * Offset: -10
     */
    uint16_t com_distance;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_lateral_controller_errors_t;

/**
 * Signals in message LATERAL_CONTROLLER_ERRORS.
 *
 * Lateral controller errors
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (-10..10 -)
     * Scale: 0.00030518043793392844
     * Offset: -10
     */
    float com_distance;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_lateral_controller_errors_converted_t;


void secondary_acquisinator_jmp_to_blt_raw_to_conversion(
    secondary_acquisinator_jmp_to_blt_converted_t *conversion,
    uint8_t acquisinatore_id
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_acquisinator_jmp_to_blt_conversion_to_raw(
    secondary_acquisinator_jmp_to_blt_t *raw,
    uint8_t acquisinatore_id
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_acquisinator_jmp_to_blt_raw_to_conversion_struct(
    secondary_acquisinator_jmp_to_blt_converted_t *conversion, 
    const secondary_acquisinator_jmp_to_blt_t *raw);


void secondary_acquisinator_jmp_to_blt_conversion_to_raw_struct(
    secondary_acquisinator_jmp_to_blt_t *raw,
    const secondary_acquisinator_jmp_to_blt_converted_t *conversion);


int secondary_acquisinator_jmp_to_blt_to_string(secondary_acquisinator_jmp_to_blt_t *message, char *buffer);

int secondary_acquisinator_jmp_to_blt_to_string_file(secondary_acquisinator_jmp_to_blt_t *message, FILE *buffer);

int secondary_acquisinator_jmp_to_blt_fields(char *buffer);

int secondary_acquisinator_jmp_to_blt_fields_file(FILE *buffer);

/**
 * Pack message ACQUISINATOR_JMP_TO_BLT.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_acquisinator_jmp_to_blt_pack(
    uint8_t *dst_p,
    const secondary_acquisinator_jmp_to_blt_t *src_p,
    size_t byte_size);

/**
 * Unpack message ACQUISINATOR_JMP_TO_BLT.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_acquisinator_jmp_to_blt_unpack(
    secondary_acquisinator_jmp_to_blt_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_acquisinator_jmp_to_blt_acquisinatore_id_is_in_range(uint8_t value);


;


;


void secondary_acquisinator_flash_0_tx_raw_to_conversion_struct(
    secondary_acquisinator_flash_0_tx_converted_t *conversion, 
    const secondary_acquisinator_flash_0_tx_t *raw);


void secondary_acquisinator_flash_0_tx_conversion_to_raw_struct(
    secondary_acquisinator_flash_0_tx_t *raw,
    const secondary_acquisinator_flash_0_tx_converted_t *conversion);


int secondary_acquisinator_flash_0_tx_to_string(secondary_acquisinator_flash_0_tx_t *message, char *buffer);

int secondary_acquisinator_flash_0_tx_to_string_file(secondary_acquisinator_flash_0_tx_t *message, FILE *buffer);

int secondary_acquisinator_flash_0_tx_fields(char *buffer);

int secondary_acquisinator_flash_0_tx_fields_file(FILE *buffer);

/**
 * Pack message ACQUISINATOR_FLASH_0_TX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_acquisinator_flash_0_tx_pack(
    uint8_t *dst_p,
    const secondary_acquisinator_flash_0_tx_t *src_p,
    size_t byte_size);

/**
 * Unpack message ACQUISINATOR_FLASH_0_TX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_acquisinator_flash_0_tx_unpack(
    secondary_acquisinator_flash_0_tx_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void secondary_acquisinator_flash_0_rx_raw_to_conversion_struct(
    secondary_acquisinator_flash_0_rx_converted_t *conversion, 
    const secondary_acquisinator_flash_0_rx_t *raw);


void secondary_acquisinator_flash_0_rx_conversion_to_raw_struct(
    secondary_acquisinator_flash_0_rx_t *raw,
    const secondary_acquisinator_flash_0_rx_converted_t *conversion);


int secondary_acquisinator_flash_0_rx_to_string(secondary_acquisinator_flash_0_rx_t *message, char *buffer);

int secondary_acquisinator_flash_0_rx_to_string_file(secondary_acquisinator_flash_0_rx_t *message, FILE *buffer);

int secondary_acquisinator_flash_0_rx_fields(char *buffer);

int secondary_acquisinator_flash_0_rx_fields_file(FILE *buffer);

/**
 * Pack message ACQUISINATOR_FLASH_0_RX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_acquisinator_flash_0_rx_pack(
    uint8_t *dst_p,
    const secondary_acquisinator_flash_0_rx_t *src_p,
    size_t byte_size);

/**
 * Unpack message ACQUISINATOR_FLASH_0_RX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_acquisinator_flash_0_rx_unpack(
    secondary_acquisinator_flash_0_rx_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void secondary_acquisinator_flash_1_tx_raw_to_conversion_struct(
    secondary_acquisinator_flash_1_tx_converted_t *conversion, 
    const secondary_acquisinator_flash_1_tx_t *raw);


void secondary_acquisinator_flash_1_tx_conversion_to_raw_struct(
    secondary_acquisinator_flash_1_tx_t *raw,
    const secondary_acquisinator_flash_1_tx_converted_t *conversion);


int secondary_acquisinator_flash_1_tx_to_string(secondary_acquisinator_flash_1_tx_t *message, char *buffer);

int secondary_acquisinator_flash_1_tx_to_string_file(secondary_acquisinator_flash_1_tx_t *message, FILE *buffer);

int secondary_acquisinator_flash_1_tx_fields(char *buffer);

int secondary_acquisinator_flash_1_tx_fields_file(FILE *buffer);

/**
 * Pack message ACQUISINATOR_FLASH_1_TX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_acquisinator_flash_1_tx_pack(
    uint8_t *dst_p,
    const secondary_acquisinator_flash_1_tx_t *src_p,
    size_t byte_size);

/**
 * Unpack message ACQUISINATOR_FLASH_1_TX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_acquisinator_flash_1_tx_unpack(
    secondary_acquisinator_flash_1_tx_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void secondary_acquisinator_flash_1_rx_raw_to_conversion_struct(
    secondary_acquisinator_flash_1_rx_converted_t *conversion, 
    const secondary_acquisinator_flash_1_rx_t *raw);


void secondary_acquisinator_flash_1_rx_conversion_to_raw_struct(
    secondary_acquisinator_flash_1_rx_t *raw,
    const secondary_acquisinator_flash_1_rx_converted_t *conversion);


int secondary_acquisinator_flash_1_rx_to_string(secondary_acquisinator_flash_1_rx_t *message, char *buffer);

int secondary_acquisinator_flash_1_rx_to_string_file(secondary_acquisinator_flash_1_rx_t *message, FILE *buffer);

int secondary_acquisinator_flash_1_rx_fields(char *buffer);

int secondary_acquisinator_flash_1_rx_fields_file(FILE *buffer);

/**
 * Pack message ACQUISINATOR_FLASH_1_RX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_acquisinator_flash_1_rx_pack(
    uint8_t *dst_p,
    const secondary_acquisinator_flash_1_rx_t *src_p,
    size_t byte_size);

/**
 * Unpack message ACQUISINATOR_FLASH_1_RX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_acquisinator_flash_1_rx_unpack(
    secondary_acquisinator_flash_1_rx_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void secondary_acquisinator_flash_2_tx_raw_to_conversion_struct(
    secondary_acquisinator_flash_2_tx_converted_t *conversion, 
    const secondary_acquisinator_flash_2_tx_t *raw);


void secondary_acquisinator_flash_2_tx_conversion_to_raw_struct(
    secondary_acquisinator_flash_2_tx_t *raw,
    const secondary_acquisinator_flash_2_tx_converted_t *conversion);


int secondary_acquisinator_flash_2_tx_to_string(secondary_acquisinator_flash_2_tx_t *message, char *buffer);

int secondary_acquisinator_flash_2_tx_to_string_file(secondary_acquisinator_flash_2_tx_t *message, FILE *buffer);

int secondary_acquisinator_flash_2_tx_fields(char *buffer);

int secondary_acquisinator_flash_2_tx_fields_file(FILE *buffer);

/**
 * Pack message ACQUISINATOR_FLASH_2_TX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_acquisinator_flash_2_tx_pack(
    uint8_t *dst_p,
    const secondary_acquisinator_flash_2_tx_t *src_p,
    size_t byte_size);

/**
 * Unpack message ACQUISINATOR_FLASH_2_TX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_acquisinator_flash_2_tx_unpack(
    secondary_acquisinator_flash_2_tx_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void secondary_acquisinator_flash_2_rx_raw_to_conversion_struct(
    secondary_acquisinator_flash_2_rx_converted_t *conversion, 
    const secondary_acquisinator_flash_2_rx_t *raw);


void secondary_acquisinator_flash_2_rx_conversion_to_raw_struct(
    secondary_acquisinator_flash_2_rx_t *raw,
    const secondary_acquisinator_flash_2_rx_converted_t *conversion);


int secondary_acquisinator_flash_2_rx_to_string(secondary_acquisinator_flash_2_rx_t *message, char *buffer);

int secondary_acquisinator_flash_2_rx_to_string_file(secondary_acquisinator_flash_2_rx_t *message, FILE *buffer);

int secondary_acquisinator_flash_2_rx_fields(char *buffer);

int secondary_acquisinator_flash_2_rx_fields_file(FILE *buffer);

/**
 * Pack message ACQUISINATOR_FLASH_2_RX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_acquisinator_flash_2_rx_pack(
    uint8_t *dst_p,
    const secondary_acquisinator_flash_2_rx_t *src_p,
    size_t byte_size);

/**
 * Unpack message ACQUISINATOR_FLASH_2_RX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_acquisinator_flash_2_rx_unpack(
    secondary_acquisinator_flash_2_rx_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void secondary_acquisinator_flash_3_tx_raw_to_conversion_struct(
    secondary_acquisinator_flash_3_tx_converted_t *conversion, 
    const secondary_acquisinator_flash_3_tx_t *raw);


void secondary_acquisinator_flash_3_tx_conversion_to_raw_struct(
    secondary_acquisinator_flash_3_tx_t *raw,
    const secondary_acquisinator_flash_3_tx_converted_t *conversion);


int secondary_acquisinator_flash_3_tx_to_string(secondary_acquisinator_flash_3_tx_t *message, char *buffer);

int secondary_acquisinator_flash_3_tx_to_string_file(secondary_acquisinator_flash_3_tx_t *message, FILE *buffer);

int secondary_acquisinator_flash_3_tx_fields(char *buffer);

int secondary_acquisinator_flash_3_tx_fields_file(FILE *buffer);

/**
 * Pack message ACQUISINATOR_FLASH_3_TX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_acquisinator_flash_3_tx_pack(
    uint8_t *dst_p,
    const secondary_acquisinator_flash_3_tx_t *src_p,
    size_t byte_size);

/**
 * Unpack message ACQUISINATOR_FLASH_3_TX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_acquisinator_flash_3_tx_unpack(
    secondary_acquisinator_flash_3_tx_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void secondary_acquisinator_flash_3_rx_raw_to_conversion_struct(
    secondary_acquisinator_flash_3_rx_converted_t *conversion, 
    const secondary_acquisinator_flash_3_rx_t *raw);


void secondary_acquisinator_flash_3_rx_conversion_to_raw_struct(
    secondary_acquisinator_flash_3_rx_t *raw,
    const secondary_acquisinator_flash_3_rx_converted_t *conversion);


int secondary_acquisinator_flash_3_rx_to_string(secondary_acquisinator_flash_3_rx_t *message, char *buffer);

int secondary_acquisinator_flash_3_rx_to_string_file(secondary_acquisinator_flash_3_rx_t *message, FILE *buffer);

int secondary_acquisinator_flash_3_rx_fields(char *buffer);

int secondary_acquisinator_flash_3_rx_fields_file(FILE *buffer);

/**
 * Pack message ACQUISINATOR_FLASH_3_RX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_acquisinator_flash_3_rx_pack(
    uint8_t *dst_p,
    const secondary_acquisinator_flash_3_rx_t *src_p,
    size_t byte_size);

/**
 * Unpack message ACQUISINATOR_FLASH_3_RX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_acquisinator_flash_3_rx_unpack(
    secondary_acquisinator_flash_3_rx_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void secondary_acquisinator_flash_4_tx_raw_to_conversion_struct(
    secondary_acquisinator_flash_4_tx_converted_t *conversion, 
    const secondary_acquisinator_flash_4_tx_t *raw);


void secondary_acquisinator_flash_4_tx_conversion_to_raw_struct(
    secondary_acquisinator_flash_4_tx_t *raw,
    const secondary_acquisinator_flash_4_tx_converted_t *conversion);


int secondary_acquisinator_flash_4_tx_to_string(secondary_acquisinator_flash_4_tx_t *message, char *buffer);

int secondary_acquisinator_flash_4_tx_to_string_file(secondary_acquisinator_flash_4_tx_t *message, FILE *buffer);

int secondary_acquisinator_flash_4_tx_fields(char *buffer);

int secondary_acquisinator_flash_4_tx_fields_file(FILE *buffer);

/**
 * Pack message ACQUISINATOR_FLASH_4_TX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_acquisinator_flash_4_tx_pack(
    uint8_t *dst_p,
    const secondary_acquisinator_flash_4_tx_t *src_p,
    size_t byte_size);

/**
 * Unpack message ACQUISINATOR_FLASH_4_TX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_acquisinator_flash_4_tx_unpack(
    secondary_acquisinator_flash_4_tx_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void secondary_acquisinator_flash_4_rx_raw_to_conversion_struct(
    secondary_acquisinator_flash_4_rx_converted_t *conversion, 
    const secondary_acquisinator_flash_4_rx_t *raw);


void secondary_acquisinator_flash_4_rx_conversion_to_raw_struct(
    secondary_acquisinator_flash_4_rx_t *raw,
    const secondary_acquisinator_flash_4_rx_converted_t *conversion);


int secondary_acquisinator_flash_4_rx_to_string(secondary_acquisinator_flash_4_rx_t *message, char *buffer);

int secondary_acquisinator_flash_4_rx_to_string_file(secondary_acquisinator_flash_4_rx_t *message, FILE *buffer);

int secondary_acquisinator_flash_4_rx_fields(char *buffer);

int secondary_acquisinator_flash_4_rx_fields_file(FILE *buffer);

/**
 * Pack message ACQUISINATOR_FLASH_4_RX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_acquisinator_flash_4_rx_pack(
    uint8_t *dst_p,
    const secondary_acquisinator_flash_4_rx_t *src_p,
    size_t byte_size);

/**
 * Unpack message ACQUISINATOR_FLASH_4_RX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_acquisinator_flash_4_rx_unpack(
    secondary_acquisinator_flash_4_rx_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void secondary_acquisinator_flash_5_tx_raw_to_conversion_struct(
    secondary_acquisinator_flash_5_tx_converted_t *conversion, 
    const secondary_acquisinator_flash_5_tx_t *raw);


void secondary_acquisinator_flash_5_tx_conversion_to_raw_struct(
    secondary_acquisinator_flash_5_tx_t *raw,
    const secondary_acquisinator_flash_5_tx_converted_t *conversion);


int secondary_acquisinator_flash_5_tx_to_string(secondary_acquisinator_flash_5_tx_t *message, char *buffer);

int secondary_acquisinator_flash_5_tx_to_string_file(secondary_acquisinator_flash_5_tx_t *message, FILE *buffer);

int secondary_acquisinator_flash_5_tx_fields(char *buffer);

int secondary_acquisinator_flash_5_tx_fields_file(FILE *buffer);

/**
 * Pack message ACQUISINATOR_FLASH_5_TX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_acquisinator_flash_5_tx_pack(
    uint8_t *dst_p,
    const secondary_acquisinator_flash_5_tx_t *src_p,
    size_t byte_size);

/**
 * Unpack message ACQUISINATOR_FLASH_5_TX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_acquisinator_flash_5_tx_unpack(
    secondary_acquisinator_flash_5_tx_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void secondary_acquisinator_flash_5_rx_raw_to_conversion_struct(
    secondary_acquisinator_flash_5_rx_converted_t *conversion, 
    const secondary_acquisinator_flash_5_rx_t *raw);


void secondary_acquisinator_flash_5_rx_conversion_to_raw_struct(
    secondary_acquisinator_flash_5_rx_t *raw,
    const secondary_acquisinator_flash_5_rx_converted_t *conversion);


int secondary_acquisinator_flash_5_rx_to_string(secondary_acquisinator_flash_5_rx_t *message, char *buffer);

int secondary_acquisinator_flash_5_rx_to_string_file(secondary_acquisinator_flash_5_rx_t *message, FILE *buffer);

int secondary_acquisinator_flash_5_rx_fields(char *buffer);

int secondary_acquisinator_flash_5_rx_fields_file(FILE *buffer);

/**
 * Pack message ACQUISINATOR_FLASH_5_RX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_acquisinator_flash_5_rx_pack(
    uint8_t *dst_p,
    const secondary_acquisinator_flash_5_rx_t *src_p,
    size_t byte_size);

/**
 * Unpack message ACQUISINATOR_FLASH_5_RX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_acquisinator_flash_5_rx_unpack(
    secondary_acquisinator_flash_5_rx_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void secondary_acquisinator_flash_6_tx_raw_to_conversion_struct(
    secondary_acquisinator_flash_6_tx_converted_t *conversion, 
    const secondary_acquisinator_flash_6_tx_t *raw);


void secondary_acquisinator_flash_6_tx_conversion_to_raw_struct(
    secondary_acquisinator_flash_6_tx_t *raw,
    const secondary_acquisinator_flash_6_tx_converted_t *conversion);


int secondary_acquisinator_flash_6_tx_to_string(secondary_acquisinator_flash_6_tx_t *message, char *buffer);

int secondary_acquisinator_flash_6_tx_to_string_file(secondary_acquisinator_flash_6_tx_t *message, FILE *buffer);

int secondary_acquisinator_flash_6_tx_fields(char *buffer);

int secondary_acquisinator_flash_6_tx_fields_file(FILE *buffer);

/**
 * Pack message ACQUISINATOR_FLASH_6_TX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_acquisinator_flash_6_tx_pack(
    uint8_t *dst_p,
    const secondary_acquisinator_flash_6_tx_t *src_p,
    size_t byte_size);

/**
 * Unpack message ACQUISINATOR_FLASH_6_TX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_acquisinator_flash_6_tx_unpack(
    secondary_acquisinator_flash_6_tx_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void secondary_acquisinator_flash_6_rx_raw_to_conversion_struct(
    secondary_acquisinator_flash_6_rx_converted_t *conversion, 
    const secondary_acquisinator_flash_6_rx_t *raw);


void secondary_acquisinator_flash_6_rx_conversion_to_raw_struct(
    secondary_acquisinator_flash_6_rx_t *raw,
    const secondary_acquisinator_flash_6_rx_converted_t *conversion);


int secondary_acquisinator_flash_6_rx_to_string(secondary_acquisinator_flash_6_rx_t *message, char *buffer);

int secondary_acquisinator_flash_6_rx_to_string_file(secondary_acquisinator_flash_6_rx_t *message, FILE *buffer);

int secondary_acquisinator_flash_6_rx_fields(char *buffer);

int secondary_acquisinator_flash_6_rx_fields_file(FILE *buffer);

/**
 * Pack message ACQUISINATOR_FLASH_6_RX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_acquisinator_flash_6_rx_pack(
    uint8_t *dst_p,
    const secondary_acquisinator_flash_6_rx_t *src_p,
    size_t byte_size);

/**
 * Unpack message ACQUISINATOR_FLASH_6_RX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_acquisinator_flash_6_rx_unpack(
    secondary_acquisinator_flash_6_rx_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void secondary_acquisinator_flash_7_tx_raw_to_conversion_struct(
    secondary_acquisinator_flash_7_tx_converted_t *conversion, 
    const secondary_acquisinator_flash_7_tx_t *raw);


void secondary_acquisinator_flash_7_tx_conversion_to_raw_struct(
    secondary_acquisinator_flash_7_tx_t *raw,
    const secondary_acquisinator_flash_7_tx_converted_t *conversion);


int secondary_acquisinator_flash_7_tx_to_string(secondary_acquisinator_flash_7_tx_t *message, char *buffer);

int secondary_acquisinator_flash_7_tx_to_string_file(secondary_acquisinator_flash_7_tx_t *message, FILE *buffer);

int secondary_acquisinator_flash_7_tx_fields(char *buffer);

int secondary_acquisinator_flash_7_tx_fields_file(FILE *buffer);

/**
 * Pack message ACQUISINATOR_FLASH_7_TX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_acquisinator_flash_7_tx_pack(
    uint8_t *dst_p,
    const secondary_acquisinator_flash_7_tx_t *src_p,
    size_t byte_size);

/**
 * Unpack message ACQUISINATOR_FLASH_7_TX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_acquisinator_flash_7_tx_unpack(
    secondary_acquisinator_flash_7_tx_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void secondary_acquisinator_flash_7_rx_raw_to_conversion_struct(
    secondary_acquisinator_flash_7_rx_converted_t *conversion, 
    const secondary_acquisinator_flash_7_rx_t *raw);


void secondary_acquisinator_flash_7_rx_conversion_to_raw_struct(
    secondary_acquisinator_flash_7_rx_t *raw,
    const secondary_acquisinator_flash_7_rx_converted_t *conversion);


int secondary_acquisinator_flash_7_rx_to_string(secondary_acquisinator_flash_7_rx_t *message, char *buffer);

int secondary_acquisinator_flash_7_rx_to_string_file(secondary_acquisinator_flash_7_rx_t *message, FILE *buffer);

int secondary_acquisinator_flash_7_rx_fields(char *buffer);

int secondary_acquisinator_flash_7_rx_fields_file(FILE *buffer);

/**
 * Pack message ACQUISINATOR_FLASH_7_RX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_acquisinator_flash_7_rx_pack(
    uint8_t *dst_p,
    const secondary_acquisinator_flash_7_rx_t *src_p,
    size_t byte_size);

/**
 * Unpack message ACQUISINATOR_FLASH_7_RX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_acquisinator_flash_7_rx_unpack(
    secondary_acquisinator_flash_7_rx_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void secondary_acquisinator_flash_8_tx_raw_to_conversion_struct(
    secondary_acquisinator_flash_8_tx_converted_t *conversion, 
    const secondary_acquisinator_flash_8_tx_t *raw);


void secondary_acquisinator_flash_8_tx_conversion_to_raw_struct(
    secondary_acquisinator_flash_8_tx_t *raw,
    const secondary_acquisinator_flash_8_tx_converted_t *conversion);


int secondary_acquisinator_flash_8_tx_to_string(secondary_acquisinator_flash_8_tx_t *message, char *buffer);

int secondary_acquisinator_flash_8_tx_to_string_file(secondary_acquisinator_flash_8_tx_t *message, FILE *buffer);

int secondary_acquisinator_flash_8_tx_fields(char *buffer);

int secondary_acquisinator_flash_8_tx_fields_file(FILE *buffer);

/**
 * Pack message ACQUISINATOR_FLASH_8_TX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_acquisinator_flash_8_tx_pack(
    uint8_t *dst_p,
    const secondary_acquisinator_flash_8_tx_t *src_p,
    size_t byte_size);

/**
 * Unpack message ACQUISINATOR_FLASH_8_TX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_acquisinator_flash_8_tx_unpack(
    secondary_acquisinator_flash_8_tx_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void secondary_acquisinator_flash_8_rx_raw_to_conversion_struct(
    secondary_acquisinator_flash_8_rx_converted_t *conversion, 
    const secondary_acquisinator_flash_8_rx_t *raw);


void secondary_acquisinator_flash_8_rx_conversion_to_raw_struct(
    secondary_acquisinator_flash_8_rx_t *raw,
    const secondary_acquisinator_flash_8_rx_converted_t *conversion);


int secondary_acquisinator_flash_8_rx_to_string(secondary_acquisinator_flash_8_rx_t *message, char *buffer);

int secondary_acquisinator_flash_8_rx_to_string_file(secondary_acquisinator_flash_8_rx_t *message, FILE *buffer);

int secondary_acquisinator_flash_8_rx_fields(char *buffer);

int secondary_acquisinator_flash_8_rx_fields_file(FILE *buffer);

/**
 * Pack message ACQUISINATOR_FLASH_8_RX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_acquisinator_flash_8_rx_pack(
    uint8_t *dst_p,
    const secondary_acquisinator_flash_8_rx_t *src_p,
    size_t byte_size);

/**
 * Unpack message ACQUISINATOR_FLASH_8_RX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_acquisinator_flash_8_rx_unpack(
    secondary_acquisinator_flash_8_rx_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void secondary_acquisinator_flash_9_tx_raw_to_conversion_struct(
    secondary_acquisinator_flash_9_tx_converted_t *conversion, 
    const secondary_acquisinator_flash_9_tx_t *raw);


void secondary_acquisinator_flash_9_tx_conversion_to_raw_struct(
    secondary_acquisinator_flash_9_tx_t *raw,
    const secondary_acquisinator_flash_9_tx_converted_t *conversion);


int secondary_acquisinator_flash_9_tx_to_string(secondary_acquisinator_flash_9_tx_t *message, char *buffer);

int secondary_acquisinator_flash_9_tx_to_string_file(secondary_acquisinator_flash_9_tx_t *message, FILE *buffer);

int secondary_acquisinator_flash_9_tx_fields(char *buffer);

int secondary_acquisinator_flash_9_tx_fields_file(FILE *buffer);

/**
 * Pack message ACQUISINATOR_FLASH_9_TX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_acquisinator_flash_9_tx_pack(
    uint8_t *dst_p,
    const secondary_acquisinator_flash_9_tx_t *src_p,
    size_t byte_size);

/**
 * Unpack message ACQUISINATOR_FLASH_9_TX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_acquisinator_flash_9_tx_unpack(
    secondary_acquisinator_flash_9_tx_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void secondary_acquisinator_flash_9_rx_raw_to_conversion_struct(
    secondary_acquisinator_flash_9_rx_converted_t *conversion, 
    const secondary_acquisinator_flash_9_rx_t *raw);


void secondary_acquisinator_flash_9_rx_conversion_to_raw_struct(
    secondary_acquisinator_flash_9_rx_t *raw,
    const secondary_acquisinator_flash_9_rx_converted_t *conversion);


int secondary_acquisinator_flash_9_rx_to_string(secondary_acquisinator_flash_9_rx_t *message, char *buffer);

int secondary_acquisinator_flash_9_rx_to_string_file(secondary_acquisinator_flash_9_rx_t *message, FILE *buffer);

int secondary_acquisinator_flash_9_rx_fields(char *buffer);

int secondary_acquisinator_flash_9_rx_fields_file(FILE *buffer);

/**
 * Pack message ACQUISINATOR_FLASH_9_RX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_acquisinator_flash_9_rx_pack(
    uint8_t *dst_p,
    const secondary_acquisinator_flash_9_rx_t *src_p,
    size_t byte_size);

/**
 * Unpack message ACQUISINATOR_FLASH_9_RX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_acquisinator_flash_9_rx_unpack(
    secondary_acquisinator_flash_9_rx_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void secondary_acquisinator_flash_10_tx_raw_to_conversion_struct(
    secondary_acquisinator_flash_10_tx_converted_t *conversion, 
    const secondary_acquisinator_flash_10_tx_t *raw);


void secondary_acquisinator_flash_10_tx_conversion_to_raw_struct(
    secondary_acquisinator_flash_10_tx_t *raw,
    const secondary_acquisinator_flash_10_tx_converted_t *conversion);


int secondary_acquisinator_flash_10_tx_to_string(secondary_acquisinator_flash_10_tx_t *message, char *buffer);

int secondary_acquisinator_flash_10_tx_to_string_file(secondary_acquisinator_flash_10_tx_t *message, FILE *buffer);

int secondary_acquisinator_flash_10_tx_fields(char *buffer);

int secondary_acquisinator_flash_10_tx_fields_file(FILE *buffer);

/**
 * Pack message ACQUISINATOR_FLASH_10_TX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_acquisinator_flash_10_tx_pack(
    uint8_t *dst_p,
    const secondary_acquisinator_flash_10_tx_t *src_p,
    size_t byte_size);

/**
 * Unpack message ACQUISINATOR_FLASH_10_TX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_acquisinator_flash_10_tx_unpack(
    secondary_acquisinator_flash_10_tx_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void secondary_acquisinator_flash_10_rx_raw_to_conversion_struct(
    secondary_acquisinator_flash_10_rx_converted_t *conversion, 
    const secondary_acquisinator_flash_10_rx_t *raw);


void secondary_acquisinator_flash_10_rx_conversion_to_raw_struct(
    secondary_acquisinator_flash_10_rx_t *raw,
    const secondary_acquisinator_flash_10_rx_converted_t *conversion);


int secondary_acquisinator_flash_10_rx_to_string(secondary_acquisinator_flash_10_rx_t *message, char *buffer);

int secondary_acquisinator_flash_10_rx_to_string_file(secondary_acquisinator_flash_10_rx_t *message, FILE *buffer);

int secondary_acquisinator_flash_10_rx_fields(char *buffer);

int secondary_acquisinator_flash_10_rx_fields_file(FILE *buffer);

/**
 * Pack message ACQUISINATOR_FLASH_10_RX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_acquisinator_flash_10_rx_pack(
    uint8_t *dst_p,
    const secondary_acquisinator_flash_10_rx_t *src_p,
    size_t byte_size);

/**
 * Unpack message ACQUISINATOR_FLASH_10_RX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_acquisinator_flash_10_rx_unpack(
    secondary_acquisinator_flash_10_rx_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void secondary_acquisinator_flash_11_tx_raw_to_conversion_struct(
    secondary_acquisinator_flash_11_tx_converted_t *conversion, 
    const secondary_acquisinator_flash_11_tx_t *raw);


void secondary_acquisinator_flash_11_tx_conversion_to_raw_struct(
    secondary_acquisinator_flash_11_tx_t *raw,
    const secondary_acquisinator_flash_11_tx_converted_t *conversion);


int secondary_acquisinator_flash_11_tx_to_string(secondary_acquisinator_flash_11_tx_t *message, char *buffer);

int secondary_acquisinator_flash_11_tx_to_string_file(secondary_acquisinator_flash_11_tx_t *message, FILE *buffer);

int secondary_acquisinator_flash_11_tx_fields(char *buffer);

int secondary_acquisinator_flash_11_tx_fields_file(FILE *buffer);

/**
 * Pack message ACQUISINATOR_FLASH_11_TX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_acquisinator_flash_11_tx_pack(
    uint8_t *dst_p,
    const secondary_acquisinator_flash_11_tx_t *src_p,
    size_t byte_size);

/**
 * Unpack message ACQUISINATOR_FLASH_11_TX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_acquisinator_flash_11_tx_unpack(
    secondary_acquisinator_flash_11_tx_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void secondary_acquisinator_flash_11_rx_raw_to_conversion_struct(
    secondary_acquisinator_flash_11_rx_converted_t *conversion, 
    const secondary_acquisinator_flash_11_rx_t *raw);


void secondary_acquisinator_flash_11_rx_conversion_to_raw_struct(
    secondary_acquisinator_flash_11_rx_t *raw,
    const secondary_acquisinator_flash_11_rx_converted_t *conversion);


int secondary_acquisinator_flash_11_rx_to_string(secondary_acquisinator_flash_11_rx_t *message, char *buffer);

int secondary_acquisinator_flash_11_rx_to_string_file(secondary_acquisinator_flash_11_rx_t *message, FILE *buffer);

int secondary_acquisinator_flash_11_rx_fields(char *buffer);

int secondary_acquisinator_flash_11_rx_fields_file(FILE *buffer);

/**
 * Pack message ACQUISINATOR_FLASH_11_RX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_acquisinator_flash_11_rx_pack(
    uint8_t *dst_p,
    const secondary_acquisinator_flash_11_rx_t *src_p,
    size_t byte_size);

/**
 * Unpack message ACQUISINATOR_FLASH_11_RX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_acquisinator_flash_11_rx_unpack(
    secondary_acquisinator_flash_11_rx_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void secondary_acquisinator_flash_12_tx_raw_to_conversion_struct(
    secondary_acquisinator_flash_12_tx_converted_t *conversion, 
    const secondary_acquisinator_flash_12_tx_t *raw);


void secondary_acquisinator_flash_12_tx_conversion_to_raw_struct(
    secondary_acquisinator_flash_12_tx_t *raw,
    const secondary_acquisinator_flash_12_tx_converted_t *conversion);


int secondary_acquisinator_flash_12_tx_to_string(secondary_acquisinator_flash_12_tx_t *message, char *buffer);

int secondary_acquisinator_flash_12_tx_to_string_file(secondary_acquisinator_flash_12_tx_t *message, FILE *buffer);

int secondary_acquisinator_flash_12_tx_fields(char *buffer);

int secondary_acquisinator_flash_12_tx_fields_file(FILE *buffer);

/**
 * Pack message ACQUISINATOR_FLASH_12_TX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_acquisinator_flash_12_tx_pack(
    uint8_t *dst_p,
    const secondary_acquisinator_flash_12_tx_t *src_p,
    size_t byte_size);

/**
 * Unpack message ACQUISINATOR_FLASH_12_TX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_acquisinator_flash_12_tx_unpack(
    secondary_acquisinator_flash_12_tx_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void secondary_acquisinator_flash_12_rx_raw_to_conversion_struct(
    secondary_acquisinator_flash_12_rx_converted_t *conversion, 
    const secondary_acquisinator_flash_12_rx_t *raw);


void secondary_acquisinator_flash_12_rx_conversion_to_raw_struct(
    secondary_acquisinator_flash_12_rx_t *raw,
    const secondary_acquisinator_flash_12_rx_converted_t *conversion);


int secondary_acquisinator_flash_12_rx_to_string(secondary_acquisinator_flash_12_rx_t *message, char *buffer);

int secondary_acquisinator_flash_12_rx_to_string_file(secondary_acquisinator_flash_12_rx_t *message, FILE *buffer);

int secondary_acquisinator_flash_12_rx_fields(char *buffer);

int secondary_acquisinator_flash_12_rx_fields_file(FILE *buffer);

/**
 * Pack message ACQUISINATOR_FLASH_12_RX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_acquisinator_flash_12_rx_pack(
    uint8_t *dst_p,
    const secondary_acquisinator_flash_12_rx_t *src_p,
    size_t byte_size);

/**
 * Unpack message ACQUISINATOR_FLASH_12_RX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_acquisinator_flash_12_rx_unpack(
    secondary_acquisinator_flash_12_rx_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void secondary_acquisinator_flash_13_tx_raw_to_conversion_struct(
    secondary_acquisinator_flash_13_tx_converted_t *conversion, 
    const secondary_acquisinator_flash_13_tx_t *raw);


void secondary_acquisinator_flash_13_tx_conversion_to_raw_struct(
    secondary_acquisinator_flash_13_tx_t *raw,
    const secondary_acquisinator_flash_13_tx_converted_t *conversion);


int secondary_acquisinator_flash_13_tx_to_string(secondary_acquisinator_flash_13_tx_t *message, char *buffer);

int secondary_acquisinator_flash_13_tx_to_string_file(secondary_acquisinator_flash_13_tx_t *message, FILE *buffer);

int secondary_acquisinator_flash_13_tx_fields(char *buffer);

int secondary_acquisinator_flash_13_tx_fields_file(FILE *buffer);

/**
 * Pack message ACQUISINATOR_FLASH_13_TX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_acquisinator_flash_13_tx_pack(
    uint8_t *dst_p,
    const secondary_acquisinator_flash_13_tx_t *src_p,
    size_t byte_size);

/**
 * Unpack message ACQUISINATOR_FLASH_13_TX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_acquisinator_flash_13_tx_unpack(
    secondary_acquisinator_flash_13_tx_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void secondary_acquisinator_flash_13_rx_raw_to_conversion_struct(
    secondary_acquisinator_flash_13_rx_converted_t *conversion, 
    const secondary_acquisinator_flash_13_rx_t *raw);


void secondary_acquisinator_flash_13_rx_conversion_to_raw_struct(
    secondary_acquisinator_flash_13_rx_t *raw,
    const secondary_acquisinator_flash_13_rx_converted_t *conversion);


int secondary_acquisinator_flash_13_rx_to_string(secondary_acquisinator_flash_13_rx_t *message, char *buffer);

int secondary_acquisinator_flash_13_rx_to_string_file(secondary_acquisinator_flash_13_rx_t *message, FILE *buffer);

int secondary_acquisinator_flash_13_rx_fields(char *buffer);

int secondary_acquisinator_flash_13_rx_fields_file(FILE *buffer);

/**
 * Pack message ACQUISINATOR_FLASH_13_RX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_acquisinator_flash_13_rx_pack(
    uint8_t *dst_p,
    const secondary_acquisinator_flash_13_rx_t *src_p,
    size_t byte_size);

/**
 * Unpack message ACQUISINATOR_FLASH_13_RX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_acquisinator_flash_13_rx_unpack(
    secondary_acquisinator_flash_13_rx_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void secondary_acquisinator_flash_14_tx_raw_to_conversion_struct(
    secondary_acquisinator_flash_14_tx_converted_t *conversion, 
    const secondary_acquisinator_flash_14_tx_t *raw);


void secondary_acquisinator_flash_14_tx_conversion_to_raw_struct(
    secondary_acquisinator_flash_14_tx_t *raw,
    const secondary_acquisinator_flash_14_tx_converted_t *conversion);


int secondary_acquisinator_flash_14_tx_to_string(secondary_acquisinator_flash_14_tx_t *message, char *buffer);

int secondary_acquisinator_flash_14_tx_to_string_file(secondary_acquisinator_flash_14_tx_t *message, FILE *buffer);

int secondary_acquisinator_flash_14_tx_fields(char *buffer);

int secondary_acquisinator_flash_14_tx_fields_file(FILE *buffer);

/**
 * Pack message ACQUISINATOR_FLASH_14_TX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_acquisinator_flash_14_tx_pack(
    uint8_t *dst_p,
    const secondary_acquisinator_flash_14_tx_t *src_p,
    size_t byte_size);

/**
 * Unpack message ACQUISINATOR_FLASH_14_TX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_acquisinator_flash_14_tx_unpack(
    secondary_acquisinator_flash_14_tx_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void secondary_acquisinator_flash_14_rx_raw_to_conversion_struct(
    secondary_acquisinator_flash_14_rx_converted_t *conversion, 
    const secondary_acquisinator_flash_14_rx_t *raw);


void secondary_acquisinator_flash_14_rx_conversion_to_raw_struct(
    secondary_acquisinator_flash_14_rx_t *raw,
    const secondary_acquisinator_flash_14_rx_converted_t *conversion);


int secondary_acquisinator_flash_14_rx_to_string(secondary_acquisinator_flash_14_rx_t *message, char *buffer);

int secondary_acquisinator_flash_14_rx_to_string_file(secondary_acquisinator_flash_14_rx_t *message, FILE *buffer);

int secondary_acquisinator_flash_14_rx_fields(char *buffer);

int secondary_acquisinator_flash_14_rx_fields_file(FILE *buffer);

/**
 * Pack message ACQUISINATOR_FLASH_14_RX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_acquisinator_flash_14_rx_pack(
    uint8_t *dst_p,
    const secondary_acquisinator_flash_14_rx_t *src_p,
    size_t byte_size);

/**
 * Unpack message ACQUISINATOR_FLASH_14_RX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_acquisinator_flash_14_rx_unpack(
    secondary_acquisinator_flash_14_rx_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void secondary_acquisinator_flash_15_tx_raw_to_conversion_struct(
    secondary_acquisinator_flash_15_tx_converted_t *conversion, 
    const secondary_acquisinator_flash_15_tx_t *raw);


void secondary_acquisinator_flash_15_tx_conversion_to_raw_struct(
    secondary_acquisinator_flash_15_tx_t *raw,
    const secondary_acquisinator_flash_15_tx_converted_t *conversion);


int secondary_acquisinator_flash_15_tx_to_string(secondary_acquisinator_flash_15_tx_t *message, char *buffer);

int secondary_acquisinator_flash_15_tx_to_string_file(secondary_acquisinator_flash_15_tx_t *message, FILE *buffer);

int secondary_acquisinator_flash_15_tx_fields(char *buffer);

int secondary_acquisinator_flash_15_tx_fields_file(FILE *buffer);

/**
 * Pack message ACQUISINATOR_FLASH_15_TX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_acquisinator_flash_15_tx_pack(
    uint8_t *dst_p,
    const secondary_acquisinator_flash_15_tx_t *src_p,
    size_t byte_size);

/**
 * Unpack message ACQUISINATOR_FLASH_15_TX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_acquisinator_flash_15_tx_unpack(
    secondary_acquisinator_flash_15_tx_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void secondary_acquisinator_flash_15_rx_raw_to_conversion_struct(
    secondary_acquisinator_flash_15_rx_converted_t *conversion, 
    const secondary_acquisinator_flash_15_rx_t *raw);


void secondary_acquisinator_flash_15_rx_conversion_to_raw_struct(
    secondary_acquisinator_flash_15_rx_t *raw,
    const secondary_acquisinator_flash_15_rx_converted_t *conversion);


int secondary_acquisinator_flash_15_rx_to_string(secondary_acquisinator_flash_15_rx_t *message, char *buffer);

int secondary_acquisinator_flash_15_rx_to_string_file(secondary_acquisinator_flash_15_rx_t *message, FILE *buffer);

int secondary_acquisinator_flash_15_rx_fields(char *buffer);

int secondary_acquisinator_flash_15_rx_fields_file(FILE *buffer);

/**
 * Pack message ACQUISINATOR_FLASH_15_RX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_acquisinator_flash_15_rx_pack(
    uint8_t *dst_p,
    const secondary_acquisinator_flash_15_rx_t *src_p,
    size_t byte_size);

/**
 * Unpack message ACQUISINATOR_FLASH_15_RX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_acquisinator_flash_15_rx_unpack(
    secondary_acquisinator_flash_15_rx_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void secondary_acquisinator_flash_16_tx_raw_to_conversion_struct(
    secondary_acquisinator_flash_16_tx_converted_t *conversion, 
    const secondary_acquisinator_flash_16_tx_t *raw);


void secondary_acquisinator_flash_16_tx_conversion_to_raw_struct(
    secondary_acquisinator_flash_16_tx_t *raw,
    const secondary_acquisinator_flash_16_tx_converted_t *conversion);


int secondary_acquisinator_flash_16_tx_to_string(secondary_acquisinator_flash_16_tx_t *message, char *buffer);

int secondary_acquisinator_flash_16_tx_to_string_file(secondary_acquisinator_flash_16_tx_t *message, FILE *buffer);

int secondary_acquisinator_flash_16_tx_fields(char *buffer);

int secondary_acquisinator_flash_16_tx_fields_file(FILE *buffer);

/**
 * Pack message ACQUISINATOR_FLASH_16_TX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_acquisinator_flash_16_tx_pack(
    uint8_t *dst_p,
    const secondary_acquisinator_flash_16_tx_t *src_p,
    size_t byte_size);

/**
 * Unpack message ACQUISINATOR_FLASH_16_TX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_acquisinator_flash_16_tx_unpack(
    secondary_acquisinator_flash_16_tx_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void secondary_acquisinator_flash_16_rx_raw_to_conversion_struct(
    secondary_acquisinator_flash_16_rx_converted_t *conversion, 
    const secondary_acquisinator_flash_16_rx_t *raw);


void secondary_acquisinator_flash_16_rx_conversion_to_raw_struct(
    secondary_acquisinator_flash_16_rx_t *raw,
    const secondary_acquisinator_flash_16_rx_converted_t *conversion);


int secondary_acquisinator_flash_16_rx_to_string(secondary_acquisinator_flash_16_rx_t *message, char *buffer);

int secondary_acquisinator_flash_16_rx_to_string_file(secondary_acquisinator_flash_16_rx_t *message, FILE *buffer);

int secondary_acquisinator_flash_16_rx_fields(char *buffer);

int secondary_acquisinator_flash_16_rx_fields_file(FILE *buffer);

/**
 * Pack message ACQUISINATOR_FLASH_16_RX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_acquisinator_flash_16_rx_pack(
    uint8_t *dst_p,
    const secondary_acquisinator_flash_16_rx_t *src_p,
    size_t byte_size);

/**
 * Unpack message ACQUISINATOR_FLASH_16_RX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_acquisinator_flash_16_rx_unpack(
    secondary_acquisinator_flash_16_rx_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void secondary_acquisinator_flash_17_tx_raw_to_conversion_struct(
    secondary_acquisinator_flash_17_tx_converted_t *conversion, 
    const secondary_acquisinator_flash_17_tx_t *raw);


void secondary_acquisinator_flash_17_tx_conversion_to_raw_struct(
    secondary_acquisinator_flash_17_tx_t *raw,
    const secondary_acquisinator_flash_17_tx_converted_t *conversion);


int secondary_acquisinator_flash_17_tx_to_string(secondary_acquisinator_flash_17_tx_t *message, char *buffer);

int secondary_acquisinator_flash_17_tx_to_string_file(secondary_acquisinator_flash_17_tx_t *message, FILE *buffer);

int secondary_acquisinator_flash_17_tx_fields(char *buffer);

int secondary_acquisinator_flash_17_tx_fields_file(FILE *buffer);

/**
 * Pack message ACQUISINATOR_FLASH_17_TX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_acquisinator_flash_17_tx_pack(
    uint8_t *dst_p,
    const secondary_acquisinator_flash_17_tx_t *src_p,
    size_t byte_size);

/**
 * Unpack message ACQUISINATOR_FLASH_17_TX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_acquisinator_flash_17_tx_unpack(
    secondary_acquisinator_flash_17_tx_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void secondary_acquisinator_flash_17_rx_raw_to_conversion_struct(
    secondary_acquisinator_flash_17_rx_converted_t *conversion, 
    const secondary_acquisinator_flash_17_rx_t *raw);


void secondary_acquisinator_flash_17_rx_conversion_to_raw_struct(
    secondary_acquisinator_flash_17_rx_t *raw,
    const secondary_acquisinator_flash_17_rx_converted_t *conversion);


int secondary_acquisinator_flash_17_rx_to_string(secondary_acquisinator_flash_17_rx_t *message, char *buffer);

int secondary_acquisinator_flash_17_rx_to_string_file(secondary_acquisinator_flash_17_rx_t *message, FILE *buffer);

int secondary_acquisinator_flash_17_rx_fields(char *buffer);

int secondary_acquisinator_flash_17_rx_fields_file(FILE *buffer);

/**
 * Pack message ACQUISINATOR_FLASH_17_RX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_acquisinator_flash_17_rx_pack(
    uint8_t *dst_p,
    const secondary_acquisinator_flash_17_rx_t *src_p,
    size_t byte_size);

/**
 * Unpack message ACQUISINATOR_FLASH_17_RX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_acquisinator_flash_17_rx_unpack(
    secondary_acquisinator_flash_17_rx_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void secondary_acquisinator_flash_18_tx_raw_to_conversion_struct(
    secondary_acquisinator_flash_18_tx_converted_t *conversion, 
    const secondary_acquisinator_flash_18_tx_t *raw);


void secondary_acquisinator_flash_18_tx_conversion_to_raw_struct(
    secondary_acquisinator_flash_18_tx_t *raw,
    const secondary_acquisinator_flash_18_tx_converted_t *conversion);


int secondary_acquisinator_flash_18_tx_to_string(secondary_acquisinator_flash_18_tx_t *message, char *buffer);

int secondary_acquisinator_flash_18_tx_to_string_file(secondary_acquisinator_flash_18_tx_t *message, FILE *buffer);

int secondary_acquisinator_flash_18_tx_fields(char *buffer);

int secondary_acquisinator_flash_18_tx_fields_file(FILE *buffer);

/**
 * Pack message ACQUISINATOR_FLASH_18_TX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_acquisinator_flash_18_tx_pack(
    uint8_t *dst_p,
    const secondary_acquisinator_flash_18_tx_t *src_p,
    size_t byte_size);

/**
 * Unpack message ACQUISINATOR_FLASH_18_TX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_acquisinator_flash_18_tx_unpack(
    secondary_acquisinator_flash_18_tx_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void secondary_acquisinator_flash_18_rx_raw_to_conversion_struct(
    secondary_acquisinator_flash_18_rx_converted_t *conversion, 
    const secondary_acquisinator_flash_18_rx_t *raw);


void secondary_acquisinator_flash_18_rx_conversion_to_raw_struct(
    secondary_acquisinator_flash_18_rx_t *raw,
    const secondary_acquisinator_flash_18_rx_converted_t *conversion);


int secondary_acquisinator_flash_18_rx_to_string(secondary_acquisinator_flash_18_rx_t *message, char *buffer);

int secondary_acquisinator_flash_18_rx_to_string_file(secondary_acquisinator_flash_18_rx_t *message, FILE *buffer);

int secondary_acquisinator_flash_18_rx_fields(char *buffer);

int secondary_acquisinator_flash_18_rx_fields_file(FILE *buffer);

/**
 * Pack message ACQUISINATOR_FLASH_18_RX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_acquisinator_flash_18_rx_pack(
    uint8_t *dst_p,
    const secondary_acquisinator_flash_18_rx_t *src_p,
    size_t byte_size);

/**
 * Unpack message ACQUISINATOR_FLASH_18_RX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_acquisinator_flash_18_rx_unpack(
    secondary_acquisinator_flash_18_rx_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void secondary_acquisinator_flash_19_tx_raw_to_conversion_struct(
    secondary_acquisinator_flash_19_tx_converted_t *conversion, 
    const secondary_acquisinator_flash_19_tx_t *raw);


void secondary_acquisinator_flash_19_tx_conversion_to_raw_struct(
    secondary_acquisinator_flash_19_tx_t *raw,
    const secondary_acquisinator_flash_19_tx_converted_t *conversion);


int secondary_acquisinator_flash_19_tx_to_string(secondary_acquisinator_flash_19_tx_t *message, char *buffer);

int secondary_acquisinator_flash_19_tx_to_string_file(secondary_acquisinator_flash_19_tx_t *message, FILE *buffer);

int secondary_acquisinator_flash_19_tx_fields(char *buffer);

int secondary_acquisinator_flash_19_tx_fields_file(FILE *buffer);

/**
 * Pack message ACQUISINATOR_FLASH_19_TX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_acquisinator_flash_19_tx_pack(
    uint8_t *dst_p,
    const secondary_acquisinator_flash_19_tx_t *src_p,
    size_t byte_size);

/**
 * Unpack message ACQUISINATOR_FLASH_19_TX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_acquisinator_flash_19_tx_unpack(
    secondary_acquisinator_flash_19_tx_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void secondary_acquisinator_flash_19_rx_raw_to_conversion_struct(
    secondary_acquisinator_flash_19_rx_converted_t *conversion, 
    const secondary_acquisinator_flash_19_rx_t *raw);


void secondary_acquisinator_flash_19_rx_conversion_to_raw_struct(
    secondary_acquisinator_flash_19_rx_t *raw,
    const secondary_acquisinator_flash_19_rx_converted_t *conversion);


int secondary_acquisinator_flash_19_rx_to_string(secondary_acquisinator_flash_19_rx_t *message, char *buffer);

int secondary_acquisinator_flash_19_rx_to_string_file(secondary_acquisinator_flash_19_rx_t *message, FILE *buffer);

int secondary_acquisinator_flash_19_rx_fields(char *buffer);

int secondary_acquisinator_flash_19_rx_fields_file(FILE *buffer);

/**
 * Pack message ACQUISINATOR_FLASH_19_RX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_acquisinator_flash_19_rx_pack(
    uint8_t *dst_p,
    const secondary_acquisinator_flash_19_rx_t *src_p,
    size_t byte_size);

/**
 * Unpack message ACQUISINATOR_FLASH_19_RX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_acquisinator_flash_19_rx_unpack(
    secondary_acquisinator_flash_19_rx_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void secondary_acquisinator_flash_20_tx_raw_to_conversion_struct(
    secondary_acquisinator_flash_20_tx_converted_t *conversion, 
    const secondary_acquisinator_flash_20_tx_t *raw);


void secondary_acquisinator_flash_20_tx_conversion_to_raw_struct(
    secondary_acquisinator_flash_20_tx_t *raw,
    const secondary_acquisinator_flash_20_tx_converted_t *conversion);


int secondary_acquisinator_flash_20_tx_to_string(secondary_acquisinator_flash_20_tx_t *message, char *buffer);

int secondary_acquisinator_flash_20_tx_to_string_file(secondary_acquisinator_flash_20_tx_t *message, FILE *buffer);

int secondary_acquisinator_flash_20_tx_fields(char *buffer);

int secondary_acquisinator_flash_20_tx_fields_file(FILE *buffer);

/**
 * Pack message ACQUISINATOR_FLASH_20_TX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_acquisinator_flash_20_tx_pack(
    uint8_t *dst_p,
    const secondary_acquisinator_flash_20_tx_t *src_p,
    size_t byte_size);

/**
 * Unpack message ACQUISINATOR_FLASH_20_TX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_acquisinator_flash_20_tx_unpack(
    secondary_acquisinator_flash_20_tx_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void secondary_acquisinator_flash_20_rx_raw_to_conversion_struct(
    secondary_acquisinator_flash_20_rx_converted_t *conversion, 
    const secondary_acquisinator_flash_20_rx_t *raw);


void secondary_acquisinator_flash_20_rx_conversion_to_raw_struct(
    secondary_acquisinator_flash_20_rx_t *raw,
    const secondary_acquisinator_flash_20_rx_converted_t *conversion);


int secondary_acquisinator_flash_20_rx_to_string(secondary_acquisinator_flash_20_rx_t *message, char *buffer);

int secondary_acquisinator_flash_20_rx_to_string_file(secondary_acquisinator_flash_20_rx_t *message, FILE *buffer);

int secondary_acquisinator_flash_20_rx_fields(char *buffer);

int secondary_acquisinator_flash_20_rx_fields_file(FILE *buffer);

/**
 * Pack message ACQUISINATOR_FLASH_20_RX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_acquisinator_flash_20_rx_pack(
    uint8_t *dst_p,
    const secondary_acquisinator_flash_20_rx_t *src_p,
    size_t byte_size);

/**
 * Unpack message ACQUISINATOR_FLASH_20_RX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_acquisinator_flash_20_rx_unpack(
    secondary_acquisinator_flash_20_rx_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void secondary_acquisinator_flash_21_tx_raw_to_conversion_struct(
    secondary_acquisinator_flash_21_tx_converted_t *conversion, 
    const secondary_acquisinator_flash_21_tx_t *raw);


void secondary_acquisinator_flash_21_tx_conversion_to_raw_struct(
    secondary_acquisinator_flash_21_tx_t *raw,
    const secondary_acquisinator_flash_21_tx_converted_t *conversion);


int secondary_acquisinator_flash_21_tx_to_string(secondary_acquisinator_flash_21_tx_t *message, char *buffer);

int secondary_acquisinator_flash_21_tx_to_string_file(secondary_acquisinator_flash_21_tx_t *message, FILE *buffer);

int secondary_acquisinator_flash_21_tx_fields(char *buffer);

int secondary_acquisinator_flash_21_tx_fields_file(FILE *buffer);

/**
 * Pack message ACQUISINATOR_FLASH_21_TX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_acquisinator_flash_21_tx_pack(
    uint8_t *dst_p,
    const secondary_acquisinator_flash_21_tx_t *src_p,
    size_t byte_size);

/**
 * Unpack message ACQUISINATOR_FLASH_21_TX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_acquisinator_flash_21_tx_unpack(
    secondary_acquisinator_flash_21_tx_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void secondary_acquisinator_flash_21_rx_raw_to_conversion_struct(
    secondary_acquisinator_flash_21_rx_converted_t *conversion, 
    const secondary_acquisinator_flash_21_rx_t *raw);


void secondary_acquisinator_flash_21_rx_conversion_to_raw_struct(
    secondary_acquisinator_flash_21_rx_t *raw,
    const secondary_acquisinator_flash_21_rx_converted_t *conversion);


int secondary_acquisinator_flash_21_rx_to_string(secondary_acquisinator_flash_21_rx_t *message, char *buffer);

int secondary_acquisinator_flash_21_rx_to_string_file(secondary_acquisinator_flash_21_rx_t *message, FILE *buffer);

int secondary_acquisinator_flash_21_rx_fields(char *buffer);

int secondary_acquisinator_flash_21_rx_fields_file(FILE *buffer);

/**
 * Pack message ACQUISINATOR_FLASH_21_RX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_acquisinator_flash_21_rx_pack(
    uint8_t *dst_p,
    const secondary_acquisinator_flash_21_rx_t *src_p,
    size_t byte_size);

/**
 * Unpack message ACQUISINATOR_FLASH_21_RX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_acquisinator_flash_21_rx_unpack(
    secondary_acquisinator_flash_21_rx_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void secondary_acquisinator_flash_22_tx_raw_to_conversion_struct(
    secondary_acquisinator_flash_22_tx_converted_t *conversion, 
    const secondary_acquisinator_flash_22_tx_t *raw);


void secondary_acquisinator_flash_22_tx_conversion_to_raw_struct(
    secondary_acquisinator_flash_22_tx_t *raw,
    const secondary_acquisinator_flash_22_tx_converted_t *conversion);


int secondary_acquisinator_flash_22_tx_to_string(secondary_acquisinator_flash_22_tx_t *message, char *buffer);

int secondary_acquisinator_flash_22_tx_to_string_file(secondary_acquisinator_flash_22_tx_t *message, FILE *buffer);

int secondary_acquisinator_flash_22_tx_fields(char *buffer);

int secondary_acquisinator_flash_22_tx_fields_file(FILE *buffer);

/**
 * Pack message ACQUISINATOR_FLASH_22_TX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_acquisinator_flash_22_tx_pack(
    uint8_t *dst_p,
    const secondary_acquisinator_flash_22_tx_t *src_p,
    size_t byte_size);

/**
 * Unpack message ACQUISINATOR_FLASH_22_TX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_acquisinator_flash_22_tx_unpack(
    secondary_acquisinator_flash_22_tx_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void secondary_acquisinator_flash_22_rx_raw_to_conversion_struct(
    secondary_acquisinator_flash_22_rx_converted_t *conversion, 
    const secondary_acquisinator_flash_22_rx_t *raw);


void secondary_acquisinator_flash_22_rx_conversion_to_raw_struct(
    secondary_acquisinator_flash_22_rx_t *raw,
    const secondary_acquisinator_flash_22_rx_converted_t *conversion);


int secondary_acquisinator_flash_22_rx_to_string(secondary_acquisinator_flash_22_rx_t *message, char *buffer);

int secondary_acquisinator_flash_22_rx_to_string_file(secondary_acquisinator_flash_22_rx_t *message, FILE *buffer);

int secondary_acquisinator_flash_22_rx_fields(char *buffer);

int secondary_acquisinator_flash_22_rx_fields_file(FILE *buffer);

/**
 * Pack message ACQUISINATOR_FLASH_22_RX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_acquisinator_flash_22_rx_pack(
    uint8_t *dst_p,
    const secondary_acquisinator_flash_22_rx_t *src_p,
    size_t byte_size);

/**
 * Unpack message ACQUISINATOR_FLASH_22_RX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_acquisinator_flash_22_rx_unpack(
    secondary_acquisinator_flash_22_rx_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void secondary_acquisinator_flash_23_tx_raw_to_conversion_struct(
    secondary_acquisinator_flash_23_tx_converted_t *conversion, 
    const secondary_acquisinator_flash_23_tx_t *raw);


void secondary_acquisinator_flash_23_tx_conversion_to_raw_struct(
    secondary_acquisinator_flash_23_tx_t *raw,
    const secondary_acquisinator_flash_23_tx_converted_t *conversion);


int secondary_acquisinator_flash_23_tx_to_string(secondary_acquisinator_flash_23_tx_t *message, char *buffer);

int secondary_acquisinator_flash_23_tx_to_string_file(secondary_acquisinator_flash_23_tx_t *message, FILE *buffer);

int secondary_acquisinator_flash_23_tx_fields(char *buffer);

int secondary_acquisinator_flash_23_tx_fields_file(FILE *buffer);

/**
 * Pack message ACQUISINATOR_FLASH_23_TX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_acquisinator_flash_23_tx_pack(
    uint8_t *dst_p,
    const secondary_acquisinator_flash_23_tx_t *src_p,
    size_t byte_size);

/**
 * Unpack message ACQUISINATOR_FLASH_23_TX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_acquisinator_flash_23_tx_unpack(
    secondary_acquisinator_flash_23_tx_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void secondary_acquisinator_flash_23_rx_raw_to_conversion_struct(
    secondary_acquisinator_flash_23_rx_converted_t *conversion, 
    const secondary_acquisinator_flash_23_rx_t *raw);


void secondary_acquisinator_flash_23_rx_conversion_to_raw_struct(
    secondary_acquisinator_flash_23_rx_t *raw,
    const secondary_acquisinator_flash_23_rx_converted_t *conversion);


int secondary_acquisinator_flash_23_rx_to_string(secondary_acquisinator_flash_23_rx_t *message, char *buffer);

int secondary_acquisinator_flash_23_rx_to_string_file(secondary_acquisinator_flash_23_rx_t *message, FILE *buffer);

int secondary_acquisinator_flash_23_rx_fields(char *buffer);

int secondary_acquisinator_flash_23_rx_fields_file(FILE *buffer);

/**
 * Pack message ACQUISINATOR_FLASH_23_RX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_acquisinator_flash_23_rx_pack(
    uint8_t *dst_p,
    const secondary_acquisinator_flash_23_rx_t *src_p,
    size_t byte_size);

/**
 * Unpack message ACQUISINATOR_FLASH_23_RX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_acquisinator_flash_23_rx_unpack(
    secondary_acquisinator_flash_23_rx_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void secondary_acquisinator_flash_24_tx_raw_to_conversion_struct(
    secondary_acquisinator_flash_24_tx_converted_t *conversion, 
    const secondary_acquisinator_flash_24_tx_t *raw);


void secondary_acquisinator_flash_24_tx_conversion_to_raw_struct(
    secondary_acquisinator_flash_24_tx_t *raw,
    const secondary_acquisinator_flash_24_tx_converted_t *conversion);


int secondary_acquisinator_flash_24_tx_to_string(secondary_acquisinator_flash_24_tx_t *message, char *buffer);

int secondary_acquisinator_flash_24_tx_to_string_file(secondary_acquisinator_flash_24_tx_t *message, FILE *buffer);

int secondary_acquisinator_flash_24_tx_fields(char *buffer);

int secondary_acquisinator_flash_24_tx_fields_file(FILE *buffer);

/**
 * Pack message ACQUISINATOR_FLASH_24_TX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_acquisinator_flash_24_tx_pack(
    uint8_t *dst_p,
    const secondary_acquisinator_flash_24_tx_t *src_p,
    size_t byte_size);

/**
 * Unpack message ACQUISINATOR_FLASH_24_TX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_acquisinator_flash_24_tx_unpack(
    secondary_acquisinator_flash_24_tx_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void secondary_acquisinator_flash_24_rx_raw_to_conversion_struct(
    secondary_acquisinator_flash_24_rx_converted_t *conversion, 
    const secondary_acquisinator_flash_24_rx_t *raw);


void secondary_acquisinator_flash_24_rx_conversion_to_raw_struct(
    secondary_acquisinator_flash_24_rx_t *raw,
    const secondary_acquisinator_flash_24_rx_converted_t *conversion);


int secondary_acquisinator_flash_24_rx_to_string(secondary_acquisinator_flash_24_rx_t *message, char *buffer);

int secondary_acquisinator_flash_24_rx_to_string_file(secondary_acquisinator_flash_24_rx_t *message, FILE *buffer);

int secondary_acquisinator_flash_24_rx_fields(char *buffer);

int secondary_acquisinator_flash_24_rx_fields_file(FILE *buffer);

/**
 * Pack message ACQUISINATOR_FLASH_24_RX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_acquisinator_flash_24_rx_pack(
    uint8_t *dst_p,
    const secondary_acquisinator_flash_24_rx_t *src_p,
    size_t byte_size);

/**
 * Unpack message ACQUISINATOR_FLASH_24_RX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_acquisinator_flash_24_rx_unpack(
    secondary_acquisinator_flash_24_rx_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void secondary_acquisinator_flash_25_tx_raw_to_conversion_struct(
    secondary_acquisinator_flash_25_tx_converted_t *conversion, 
    const secondary_acquisinator_flash_25_tx_t *raw);


void secondary_acquisinator_flash_25_tx_conversion_to_raw_struct(
    secondary_acquisinator_flash_25_tx_t *raw,
    const secondary_acquisinator_flash_25_tx_converted_t *conversion);


int secondary_acquisinator_flash_25_tx_to_string(secondary_acquisinator_flash_25_tx_t *message, char *buffer);

int secondary_acquisinator_flash_25_tx_to_string_file(secondary_acquisinator_flash_25_tx_t *message, FILE *buffer);

int secondary_acquisinator_flash_25_tx_fields(char *buffer);

int secondary_acquisinator_flash_25_tx_fields_file(FILE *buffer);

/**
 * Pack message ACQUISINATOR_FLASH_25_TX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_acquisinator_flash_25_tx_pack(
    uint8_t *dst_p,
    const secondary_acquisinator_flash_25_tx_t *src_p,
    size_t byte_size);

/**
 * Unpack message ACQUISINATOR_FLASH_25_TX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_acquisinator_flash_25_tx_unpack(
    secondary_acquisinator_flash_25_tx_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void secondary_acquisinator_flash_25_rx_raw_to_conversion_struct(
    secondary_acquisinator_flash_25_rx_converted_t *conversion, 
    const secondary_acquisinator_flash_25_rx_t *raw);


void secondary_acquisinator_flash_25_rx_conversion_to_raw_struct(
    secondary_acquisinator_flash_25_rx_t *raw,
    const secondary_acquisinator_flash_25_rx_converted_t *conversion);


int secondary_acquisinator_flash_25_rx_to_string(secondary_acquisinator_flash_25_rx_t *message, char *buffer);

int secondary_acquisinator_flash_25_rx_to_string_file(secondary_acquisinator_flash_25_rx_t *message, FILE *buffer);

int secondary_acquisinator_flash_25_rx_fields(char *buffer);

int secondary_acquisinator_flash_25_rx_fields_file(FILE *buffer);

/**
 * Pack message ACQUISINATOR_FLASH_25_RX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_acquisinator_flash_25_rx_pack(
    uint8_t *dst_p,
    const secondary_acquisinator_flash_25_rx_t *src_p,
    size_t byte_size);

/**
 * Unpack message ACQUISINATOR_FLASH_25_RX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_acquisinator_flash_25_rx_unpack(
    secondary_acquisinator_flash_25_rx_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void secondary_acquisinator_flash_26_tx_raw_to_conversion_struct(
    secondary_acquisinator_flash_26_tx_converted_t *conversion, 
    const secondary_acquisinator_flash_26_tx_t *raw);


void secondary_acquisinator_flash_26_tx_conversion_to_raw_struct(
    secondary_acquisinator_flash_26_tx_t *raw,
    const secondary_acquisinator_flash_26_tx_converted_t *conversion);


int secondary_acquisinator_flash_26_tx_to_string(secondary_acquisinator_flash_26_tx_t *message, char *buffer);

int secondary_acquisinator_flash_26_tx_to_string_file(secondary_acquisinator_flash_26_tx_t *message, FILE *buffer);

int secondary_acquisinator_flash_26_tx_fields(char *buffer);

int secondary_acquisinator_flash_26_tx_fields_file(FILE *buffer);

/**
 * Pack message ACQUISINATOR_FLASH_26_TX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_acquisinator_flash_26_tx_pack(
    uint8_t *dst_p,
    const secondary_acquisinator_flash_26_tx_t *src_p,
    size_t byte_size);

/**
 * Unpack message ACQUISINATOR_FLASH_26_TX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_acquisinator_flash_26_tx_unpack(
    secondary_acquisinator_flash_26_tx_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void secondary_acquisinator_flash_26_rx_raw_to_conversion_struct(
    secondary_acquisinator_flash_26_rx_converted_t *conversion, 
    const secondary_acquisinator_flash_26_rx_t *raw);


void secondary_acquisinator_flash_26_rx_conversion_to_raw_struct(
    secondary_acquisinator_flash_26_rx_t *raw,
    const secondary_acquisinator_flash_26_rx_converted_t *conversion);


int secondary_acquisinator_flash_26_rx_to_string(secondary_acquisinator_flash_26_rx_t *message, char *buffer);

int secondary_acquisinator_flash_26_rx_to_string_file(secondary_acquisinator_flash_26_rx_t *message, FILE *buffer);

int secondary_acquisinator_flash_26_rx_fields(char *buffer);

int secondary_acquisinator_flash_26_rx_fields_file(FILE *buffer);

/**
 * Pack message ACQUISINATOR_FLASH_26_RX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_acquisinator_flash_26_rx_pack(
    uint8_t *dst_p,
    const secondary_acquisinator_flash_26_rx_t *src_p,
    size_t byte_size);

/**
 * Unpack message ACQUISINATOR_FLASH_26_RX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_acquisinator_flash_26_rx_unpack(
    secondary_acquisinator_flash_26_rx_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void secondary_acquisinator_flash_27_tx_raw_to_conversion_struct(
    secondary_acquisinator_flash_27_tx_converted_t *conversion, 
    const secondary_acquisinator_flash_27_tx_t *raw);


void secondary_acquisinator_flash_27_tx_conversion_to_raw_struct(
    secondary_acquisinator_flash_27_tx_t *raw,
    const secondary_acquisinator_flash_27_tx_converted_t *conversion);


int secondary_acquisinator_flash_27_tx_to_string(secondary_acquisinator_flash_27_tx_t *message, char *buffer);

int secondary_acquisinator_flash_27_tx_to_string_file(secondary_acquisinator_flash_27_tx_t *message, FILE *buffer);

int secondary_acquisinator_flash_27_tx_fields(char *buffer);

int secondary_acquisinator_flash_27_tx_fields_file(FILE *buffer);

/**
 * Pack message ACQUISINATOR_FLASH_27_TX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_acquisinator_flash_27_tx_pack(
    uint8_t *dst_p,
    const secondary_acquisinator_flash_27_tx_t *src_p,
    size_t byte_size);

/**
 * Unpack message ACQUISINATOR_FLASH_27_TX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_acquisinator_flash_27_tx_unpack(
    secondary_acquisinator_flash_27_tx_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void secondary_acquisinator_flash_27_rx_raw_to_conversion_struct(
    secondary_acquisinator_flash_27_rx_converted_t *conversion, 
    const secondary_acquisinator_flash_27_rx_t *raw);


void secondary_acquisinator_flash_27_rx_conversion_to_raw_struct(
    secondary_acquisinator_flash_27_rx_t *raw,
    const secondary_acquisinator_flash_27_rx_converted_t *conversion);


int secondary_acquisinator_flash_27_rx_to_string(secondary_acquisinator_flash_27_rx_t *message, char *buffer);

int secondary_acquisinator_flash_27_rx_to_string_file(secondary_acquisinator_flash_27_rx_t *message, FILE *buffer);

int secondary_acquisinator_flash_27_rx_fields(char *buffer);

int secondary_acquisinator_flash_27_rx_fields_file(FILE *buffer);

/**
 * Pack message ACQUISINATOR_FLASH_27_RX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_acquisinator_flash_27_rx_pack(
    uint8_t *dst_p,
    const secondary_acquisinator_flash_27_rx_t *src_p,
    size_t byte_size);

/**
 * Unpack message ACQUISINATOR_FLASH_27_RX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_acquisinator_flash_27_rx_unpack(
    secondary_acquisinator_flash_27_rx_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void secondary_acquisinator_flash_28_tx_raw_to_conversion_struct(
    secondary_acquisinator_flash_28_tx_converted_t *conversion, 
    const secondary_acquisinator_flash_28_tx_t *raw);


void secondary_acquisinator_flash_28_tx_conversion_to_raw_struct(
    secondary_acquisinator_flash_28_tx_t *raw,
    const secondary_acquisinator_flash_28_tx_converted_t *conversion);


int secondary_acquisinator_flash_28_tx_to_string(secondary_acquisinator_flash_28_tx_t *message, char *buffer);

int secondary_acquisinator_flash_28_tx_to_string_file(secondary_acquisinator_flash_28_tx_t *message, FILE *buffer);

int secondary_acquisinator_flash_28_tx_fields(char *buffer);

int secondary_acquisinator_flash_28_tx_fields_file(FILE *buffer);

/**
 * Pack message ACQUISINATOR_FLASH_28_TX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_acquisinator_flash_28_tx_pack(
    uint8_t *dst_p,
    const secondary_acquisinator_flash_28_tx_t *src_p,
    size_t byte_size);

/**
 * Unpack message ACQUISINATOR_FLASH_28_TX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_acquisinator_flash_28_tx_unpack(
    secondary_acquisinator_flash_28_tx_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void secondary_acquisinator_flash_28_rx_raw_to_conversion_struct(
    secondary_acquisinator_flash_28_rx_converted_t *conversion, 
    const secondary_acquisinator_flash_28_rx_t *raw);


void secondary_acquisinator_flash_28_rx_conversion_to_raw_struct(
    secondary_acquisinator_flash_28_rx_t *raw,
    const secondary_acquisinator_flash_28_rx_converted_t *conversion);


int secondary_acquisinator_flash_28_rx_to_string(secondary_acquisinator_flash_28_rx_t *message, char *buffer);

int secondary_acquisinator_flash_28_rx_to_string_file(secondary_acquisinator_flash_28_rx_t *message, FILE *buffer);

int secondary_acquisinator_flash_28_rx_fields(char *buffer);

int secondary_acquisinator_flash_28_rx_fields_file(FILE *buffer);

/**
 * Pack message ACQUISINATOR_FLASH_28_RX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_acquisinator_flash_28_rx_pack(
    uint8_t *dst_p,
    const secondary_acquisinator_flash_28_rx_t *src_p,
    size_t byte_size);

/**
 * Unpack message ACQUISINATOR_FLASH_28_RX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_acquisinator_flash_28_rx_unpack(
    secondary_acquisinator_flash_28_rx_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void secondary_acquisinator_flash_29_tx_raw_to_conversion_struct(
    secondary_acquisinator_flash_29_tx_converted_t *conversion, 
    const secondary_acquisinator_flash_29_tx_t *raw);


void secondary_acquisinator_flash_29_tx_conversion_to_raw_struct(
    secondary_acquisinator_flash_29_tx_t *raw,
    const secondary_acquisinator_flash_29_tx_converted_t *conversion);


int secondary_acquisinator_flash_29_tx_to_string(secondary_acquisinator_flash_29_tx_t *message, char *buffer);

int secondary_acquisinator_flash_29_tx_to_string_file(secondary_acquisinator_flash_29_tx_t *message, FILE *buffer);

int secondary_acquisinator_flash_29_tx_fields(char *buffer);

int secondary_acquisinator_flash_29_tx_fields_file(FILE *buffer);

/**
 * Pack message ACQUISINATOR_FLASH_29_TX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_acquisinator_flash_29_tx_pack(
    uint8_t *dst_p,
    const secondary_acquisinator_flash_29_tx_t *src_p,
    size_t byte_size);

/**
 * Unpack message ACQUISINATOR_FLASH_29_TX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_acquisinator_flash_29_tx_unpack(
    secondary_acquisinator_flash_29_tx_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void secondary_acquisinator_flash_29_rx_raw_to_conversion_struct(
    secondary_acquisinator_flash_29_rx_converted_t *conversion, 
    const secondary_acquisinator_flash_29_rx_t *raw);


void secondary_acquisinator_flash_29_rx_conversion_to_raw_struct(
    secondary_acquisinator_flash_29_rx_t *raw,
    const secondary_acquisinator_flash_29_rx_converted_t *conversion);


int secondary_acquisinator_flash_29_rx_to_string(secondary_acquisinator_flash_29_rx_t *message, char *buffer);

int secondary_acquisinator_flash_29_rx_to_string_file(secondary_acquisinator_flash_29_rx_t *message, FILE *buffer);

int secondary_acquisinator_flash_29_rx_fields(char *buffer);

int secondary_acquisinator_flash_29_rx_fields_file(FILE *buffer);

/**
 * Pack message ACQUISINATOR_FLASH_29_RX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_acquisinator_flash_29_rx_pack(
    uint8_t *dst_p,
    const secondary_acquisinator_flash_29_rx_t *src_p,
    size_t byte_size);

/**
 * Unpack message ACQUISINATOR_FLASH_29_RX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_acquisinator_flash_29_rx_unpack(
    secondary_acquisinator_flash_29_rx_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void secondary_acquisinator_flash_30_tx_raw_to_conversion_struct(
    secondary_acquisinator_flash_30_tx_converted_t *conversion, 
    const secondary_acquisinator_flash_30_tx_t *raw);


void secondary_acquisinator_flash_30_tx_conversion_to_raw_struct(
    secondary_acquisinator_flash_30_tx_t *raw,
    const secondary_acquisinator_flash_30_tx_converted_t *conversion);


int secondary_acquisinator_flash_30_tx_to_string(secondary_acquisinator_flash_30_tx_t *message, char *buffer);

int secondary_acquisinator_flash_30_tx_to_string_file(secondary_acquisinator_flash_30_tx_t *message, FILE *buffer);

int secondary_acquisinator_flash_30_tx_fields(char *buffer);

int secondary_acquisinator_flash_30_tx_fields_file(FILE *buffer);

/**
 * Pack message ACQUISINATOR_FLASH_30_TX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_acquisinator_flash_30_tx_pack(
    uint8_t *dst_p,
    const secondary_acquisinator_flash_30_tx_t *src_p,
    size_t byte_size);

/**
 * Unpack message ACQUISINATOR_FLASH_30_TX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_acquisinator_flash_30_tx_unpack(
    secondary_acquisinator_flash_30_tx_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void secondary_acquisinator_flash_30_rx_raw_to_conversion_struct(
    secondary_acquisinator_flash_30_rx_converted_t *conversion, 
    const secondary_acquisinator_flash_30_rx_t *raw);


void secondary_acquisinator_flash_30_rx_conversion_to_raw_struct(
    secondary_acquisinator_flash_30_rx_t *raw,
    const secondary_acquisinator_flash_30_rx_converted_t *conversion);


int secondary_acquisinator_flash_30_rx_to_string(secondary_acquisinator_flash_30_rx_t *message, char *buffer);

int secondary_acquisinator_flash_30_rx_to_string_file(secondary_acquisinator_flash_30_rx_t *message, FILE *buffer);

int secondary_acquisinator_flash_30_rx_fields(char *buffer);

int secondary_acquisinator_flash_30_rx_fields_file(FILE *buffer);

/**
 * Pack message ACQUISINATOR_FLASH_30_RX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_acquisinator_flash_30_rx_pack(
    uint8_t *dst_p,
    const secondary_acquisinator_flash_30_rx_t *src_p,
    size_t byte_size);

/**
 * Unpack message ACQUISINATOR_FLASH_30_RX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_acquisinator_flash_30_rx_unpack(
    secondary_acquisinator_flash_30_rx_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void secondary_acquisinator_flash_31_tx_raw_to_conversion_struct(
    secondary_acquisinator_flash_31_tx_converted_t *conversion, 
    const secondary_acquisinator_flash_31_tx_t *raw);


void secondary_acquisinator_flash_31_tx_conversion_to_raw_struct(
    secondary_acquisinator_flash_31_tx_t *raw,
    const secondary_acquisinator_flash_31_tx_converted_t *conversion);


int secondary_acquisinator_flash_31_tx_to_string(secondary_acquisinator_flash_31_tx_t *message, char *buffer);

int secondary_acquisinator_flash_31_tx_to_string_file(secondary_acquisinator_flash_31_tx_t *message, FILE *buffer);

int secondary_acquisinator_flash_31_tx_fields(char *buffer);

int secondary_acquisinator_flash_31_tx_fields_file(FILE *buffer);

/**
 * Pack message ACQUISINATOR_FLASH_31_TX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_acquisinator_flash_31_tx_pack(
    uint8_t *dst_p,
    const secondary_acquisinator_flash_31_tx_t *src_p,
    size_t byte_size);

/**
 * Unpack message ACQUISINATOR_FLASH_31_TX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_acquisinator_flash_31_tx_unpack(
    secondary_acquisinator_flash_31_tx_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void secondary_acquisinator_flash_31_rx_raw_to_conversion_struct(
    secondary_acquisinator_flash_31_rx_converted_t *conversion, 
    const secondary_acquisinator_flash_31_rx_t *raw);


void secondary_acquisinator_flash_31_rx_conversion_to_raw_struct(
    secondary_acquisinator_flash_31_rx_t *raw,
    const secondary_acquisinator_flash_31_rx_converted_t *conversion);


int secondary_acquisinator_flash_31_rx_to_string(secondary_acquisinator_flash_31_rx_t *message, char *buffer);

int secondary_acquisinator_flash_31_rx_to_string_file(secondary_acquisinator_flash_31_rx_t *message, FILE *buffer);

int secondary_acquisinator_flash_31_rx_fields(char *buffer);

int secondary_acquisinator_flash_31_rx_fields_file(FILE *buffer);

/**
 * Pack message ACQUISINATOR_FLASH_31_RX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_acquisinator_flash_31_rx_pack(
    uint8_t *dst_p,
    const secondary_acquisinator_flash_31_rx_t *src_p,
    size_t byte_size);

/**
 * Unpack message ACQUISINATOR_FLASH_31_RX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_acquisinator_flash_31_rx_unpack(
    secondary_acquisinator_flash_31_rx_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


void secondary_acquisinator_version_raw_to_conversion(
    secondary_acquisinator_version_converted_t *conversion,
    uint8_t acquisinator_id,
    uint32_t canlib_build_time
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_acquisinator_version_conversion_to_raw(
    secondary_acquisinator_version_t *raw,
    uint8_t acquisinator_id,
    uint32_t canlib_build_time
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_acquisinator_version_raw_to_conversion_struct(
    secondary_acquisinator_version_converted_t *conversion, 
    const secondary_acquisinator_version_t *raw);


void secondary_acquisinator_version_conversion_to_raw_struct(
    secondary_acquisinator_version_t *raw,
    const secondary_acquisinator_version_converted_t *conversion);


int secondary_acquisinator_version_to_string(secondary_acquisinator_version_t *message, char *buffer);

int secondary_acquisinator_version_to_string_file(secondary_acquisinator_version_t *message, FILE *buffer);

int secondary_acquisinator_version_fields(char *buffer);

int secondary_acquisinator_version_fields_file(FILE *buffer);

/**
 * Pack message ACQUISINATOR_VERSION.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_acquisinator_version_pack(
    uint8_t *dst_p,
    const secondary_acquisinator_version_t *src_p,
    size_t byte_size);

/**
 * Unpack message ACQUISINATOR_VERSION.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_acquisinator_version_unpack(
    secondary_acquisinator_version_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_acquisinator_version_acquisinator_id_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_acquisinator_version_canlib_build_time_is_in_range(uint32_t value);


void secondary_imu_angular_rate_raw_to_conversion(
    secondary_imu_angular_rate_converted_t *conversion,
    float x,
    float y,
    float z
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_imu_angular_rate_conversion_to_raw(
    secondary_imu_angular_rate_t *raw,
    float x,
    float y,
    float z
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_imu_angular_rate_raw_to_conversion_struct(
    secondary_imu_angular_rate_converted_t *conversion, 
    const secondary_imu_angular_rate_t *raw);


void secondary_imu_angular_rate_conversion_to_raw_struct(
    secondary_imu_angular_rate_t *raw,
    const secondary_imu_angular_rate_converted_t *conversion);


int secondary_imu_angular_rate_converted_to_string(secondary_imu_angular_rate_converted_t *message, char *buffer);

int secondary_imu_angular_rate_converted_to_string_file(secondary_imu_angular_rate_converted_t *message, FILE *buffer);

int secondary_imu_angular_rate_fields(char *buffer);

int secondary_imu_angular_rate_fields_file(FILE *buffer);

/**
 * Pack message IMU_ANGULAR_RATE.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_imu_angular_rate_pack(
    uint8_t *dst_p,
    const secondary_imu_angular_rate_t *src_p,
    size_t byte_size);

/**
 * Unpack message IMU_ANGULAR_RATE.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_imu_angular_rate_unpack(
    secondary_imu_angular_rate_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t secondary_imu_angular_rate_x_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_imu_angular_rate_x_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_imu_angular_rate_x_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t secondary_imu_angular_rate_y_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_imu_angular_rate_y_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_imu_angular_rate_y_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t secondary_imu_angular_rate_z_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_imu_angular_rate_z_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_imu_angular_rate_z_is_in_range(int16_t value);


void secondary_imu_acceleration_raw_to_conversion(
    secondary_imu_acceleration_converted_t *conversion,
    float x,
    float y,
    float z,
    int16_t imu_temperature
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_imu_acceleration_conversion_to_raw(
    secondary_imu_acceleration_t *raw,
    float x,
    float y,
    float z,
    int16_t imu_temperature
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_imu_acceleration_raw_to_conversion_struct(
    secondary_imu_acceleration_converted_t *conversion, 
    const secondary_imu_acceleration_t *raw);


void secondary_imu_acceleration_conversion_to_raw_struct(
    secondary_imu_acceleration_t *raw,
    const secondary_imu_acceleration_converted_t *conversion);


int secondary_imu_acceleration_converted_to_string(secondary_imu_acceleration_converted_t *message, char *buffer);

int secondary_imu_acceleration_converted_to_string_file(secondary_imu_acceleration_converted_t *message, FILE *buffer);

int secondary_imu_acceleration_fields(char *buffer);

int secondary_imu_acceleration_fields_file(FILE *buffer);

/**
 * Pack message IMU_ACCELERATION.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_imu_acceleration_pack(
    uint8_t *dst_p,
    const secondary_imu_acceleration_t *src_p,
    size_t byte_size);

/**
 * Unpack message IMU_ACCELERATION.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_imu_acceleration_unpack(
    secondary_imu_acceleration_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t secondary_imu_acceleration_x_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_imu_acceleration_x_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_imu_acceleration_x_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t secondary_imu_acceleration_y_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_imu_acceleration_y_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_imu_acceleration_y_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t secondary_imu_acceleration_z_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_imu_acceleration_z_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_imu_acceleration_z_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_imu_acceleration_imu_temperature_is_in_range(int16_t value);


void secondary_irts_fl_0_raw_to_conversion(
    secondary_irts_fl_0_converted_t *conversion,
    float channel1,
    float channel2,
    float channel3,
    float channel4
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_irts_fl_0_conversion_to_raw(
    secondary_irts_fl_0_t *raw,
    float channel1,
    float channel2,
    float channel3,
    float channel4
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_irts_fl_0_raw_to_conversion_struct(
    secondary_irts_fl_0_converted_t *conversion, 
    const secondary_irts_fl_0_t *raw);


void secondary_irts_fl_0_conversion_to_raw_struct(
    secondary_irts_fl_0_t *raw,
    const secondary_irts_fl_0_converted_t *conversion);


int secondary_irts_fl_0_converted_to_string(secondary_irts_fl_0_converted_t *message, char *buffer);

int secondary_irts_fl_0_converted_to_string_file(secondary_irts_fl_0_converted_t *message, FILE *buffer);

int secondary_irts_fl_0_fields(char *buffer);

int secondary_irts_fl_0_fields_file(FILE *buffer);

/**
 * Pack message IRTS_FL_0.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_irts_fl_0_pack(
    uint8_t *dst_p,
    const secondary_irts_fl_0_t *src_p,
    size_t byte_size);

/**
 * Unpack message IRTS_FL_0.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_irts_fl_0_unpack(
    secondary_irts_fl_0_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_irts_fl_0_channel1_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_irts_fl_0_channel1_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_fl_0_channel1_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_irts_fl_0_channel2_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_irts_fl_0_channel2_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_fl_0_channel2_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_irts_fl_0_channel3_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_irts_fl_0_channel3_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_fl_0_channel3_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_irts_fl_0_channel4_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_irts_fl_0_channel4_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_fl_0_channel4_is_in_range(uint16_t value);


void secondary_irts_fl_1_raw_to_conversion(
    secondary_irts_fl_1_converted_t *conversion,
    float channel5,
    float channel6,
    float channel7,
    float channel8
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_irts_fl_1_conversion_to_raw(
    secondary_irts_fl_1_t *raw,
    float channel5,
    float channel6,
    float channel7,
    float channel8
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_irts_fl_1_raw_to_conversion_struct(
    secondary_irts_fl_1_converted_t *conversion, 
    const secondary_irts_fl_1_t *raw);


void secondary_irts_fl_1_conversion_to_raw_struct(
    secondary_irts_fl_1_t *raw,
    const secondary_irts_fl_1_converted_t *conversion);


int secondary_irts_fl_1_converted_to_string(secondary_irts_fl_1_converted_t *message, char *buffer);

int secondary_irts_fl_1_converted_to_string_file(secondary_irts_fl_1_converted_t *message, FILE *buffer);

int secondary_irts_fl_1_fields(char *buffer);

int secondary_irts_fl_1_fields_file(FILE *buffer);

/**
 * Pack message IRTS_FL_1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_irts_fl_1_pack(
    uint8_t *dst_p,
    const secondary_irts_fl_1_t *src_p,
    size_t byte_size);

/**
 * Unpack message IRTS_FL_1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_irts_fl_1_unpack(
    secondary_irts_fl_1_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_irts_fl_1_channel5_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_irts_fl_1_channel5_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_fl_1_channel5_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_irts_fl_1_channel6_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_irts_fl_1_channel6_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_fl_1_channel6_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_irts_fl_1_channel7_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_irts_fl_1_channel7_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_fl_1_channel7_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_irts_fl_1_channel8_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_irts_fl_1_channel8_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_fl_1_channel8_is_in_range(uint16_t value);


void secondary_irts_fl_2_raw_to_conversion(
    secondary_irts_fl_2_converted_t *conversion,
    float channel9,
    float channel10,
    float channel11,
    float channel12
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_irts_fl_2_conversion_to_raw(
    secondary_irts_fl_2_t *raw,
    float channel9,
    float channel10,
    float channel11,
    float channel12
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_irts_fl_2_raw_to_conversion_struct(
    secondary_irts_fl_2_converted_t *conversion, 
    const secondary_irts_fl_2_t *raw);


void secondary_irts_fl_2_conversion_to_raw_struct(
    secondary_irts_fl_2_t *raw,
    const secondary_irts_fl_2_converted_t *conversion);


int secondary_irts_fl_2_converted_to_string(secondary_irts_fl_2_converted_t *message, char *buffer);

int secondary_irts_fl_2_converted_to_string_file(secondary_irts_fl_2_converted_t *message, FILE *buffer);

int secondary_irts_fl_2_fields(char *buffer);

int secondary_irts_fl_2_fields_file(FILE *buffer);

/**
 * Pack message IRTS_FL_2.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_irts_fl_2_pack(
    uint8_t *dst_p,
    const secondary_irts_fl_2_t *src_p,
    size_t byte_size);

/**
 * Unpack message IRTS_FL_2.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_irts_fl_2_unpack(
    secondary_irts_fl_2_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_irts_fl_2_channel9_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_irts_fl_2_channel9_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_fl_2_channel9_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_irts_fl_2_channel10_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_irts_fl_2_channel10_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_fl_2_channel10_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_irts_fl_2_channel11_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_irts_fl_2_channel11_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_fl_2_channel11_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_irts_fl_2_channel12_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_irts_fl_2_channel12_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_fl_2_channel12_is_in_range(uint16_t value);


void secondary_irts_fl_3_raw_to_conversion(
    secondary_irts_fl_3_converted_t *conversion,
    float channel13,
    float channel14,
    float channel15,
    float channel16
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_irts_fl_3_conversion_to_raw(
    secondary_irts_fl_3_t *raw,
    float channel13,
    float channel14,
    float channel15,
    float channel16
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_irts_fl_3_raw_to_conversion_struct(
    secondary_irts_fl_3_converted_t *conversion, 
    const secondary_irts_fl_3_t *raw);


void secondary_irts_fl_3_conversion_to_raw_struct(
    secondary_irts_fl_3_t *raw,
    const secondary_irts_fl_3_converted_t *conversion);


int secondary_irts_fl_3_converted_to_string(secondary_irts_fl_3_converted_t *message, char *buffer);

int secondary_irts_fl_3_converted_to_string_file(secondary_irts_fl_3_converted_t *message, FILE *buffer);

int secondary_irts_fl_3_fields(char *buffer);

int secondary_irts_fl_3_fields_file(FILE *buffer);

/**
 * Pack message IRTS_FL_3.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_irts_fl_3_pack(
    uint8_t *dst_p,
    const secondary_irts_fl_3_t *src_p,
    size_t byte_size);

/**
 * Unpack message IRTS_FL_3.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_irts_fl_3_unpack(
    secondary_irts_fl_3_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_irts_fl_3_channel13_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_irts_fl_3_channel13_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_fl_3_channel13_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_irts_fl_3_channel14_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_irts_fl_3_channel14_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_fl_3_channel14_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_irts_fl_3_channel15_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_irts_fl_3_channel15_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_fl_3_channel15_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_irts_fl_3_channel16_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_irts_fl_3_channel16_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_fl_3_channel16_is_in_range(uint16_t value);


void secondary_irts_fr_0_raw_to_conversion(
    secondary_irts_fr_0_converted_t *conversion,
    float channel1,
    float channel2,
    float channel3,
    float channel4
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_irts_fr_0_conversion_to_raw(
    secondary_irts_fr_0_t *raw,
    float channel1,
    float channel2,
    float channel3,
    float channel4
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_irts_fr_0_raw_to_conversion_struct(
    secondary_irts_fr_0_converted_t *conversion, 
    const secondary_irts_fr_0_t *raw);


void secondary_irts_fr_0_conversion_to_raw_struct(
    secondary_irts_fr_0_t *raw,
    const secondary_irts_fr_0_converted_t *conversion);


int secondary_irts_fr_0_converted_to_string(secondary_irts_fr_0_converted_t *message, char *buffer);

int secondary_irts_fr_0_converted_to_string_file(secondary_irts_fr_0_converted_t *message, FILE *buffer);

int secondary_irts_fr_0_fields(char *buffer);

int secondary_irts_fr_0_fields_file(FILE *buffer);

/**
 * Pack message IRTS_FR_0.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_irts_fr_0_pack(
    uint8_t *dst_p,
    const secondary_irts_fr_0_t *src_p,
    size_t byte_size);

/**
 * Unpack message IRTS_FR_0.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_irts_fr_0_unpack(
    secondary_irts_fr_0_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_irts_fr_0_channel1_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_irts_fr_0_channel1_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_fr_0_channel1_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_irts_fr_0_channel2_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_irts_fr_0_channel2_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_fr_0_channel2_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_irts_fr_0_channel3_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_irts_fr_0_channel3_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_fr_0_channel3_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_irts_fr_0_channel4_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_irts_fr_0_channel4_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_fr_0_channel4_is_in_range(uint16_t value);


void secondary_irts_fr_1_raw_to_conversion(
    secondary_irts_fr_1_converted_t *conversion,
    float channel5,
    float channel6,
    float channel7,
    float channel8
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_irts_fr_1_conversion_to_raw(
    secondary_irts_fr_1_t *raw,
    float channel5,
    float channel6,
    float channel7,
    float channel8
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_irts_fr_1_raw_to_conversion_struct(
    secondary_irts_fr_1_converted_t *conversion, 
    const secondary_irts_fr_1_t *raw);


void secondary_irts_fr_1_conversion_to_raw_struct(
    secondary_irts_fr_1_t *raw,
    const secondary_irts_fr_1_converted_t *conversion);


int secondary_irts_fr_1_converted_to_string(secondary_irts_fr_1_converted_t *message, char *buffer);

int secondary_irts_fr_1_converted_to_string_file(secondary_irts_fr_1_converted_t *message, FILE *buffer);

int secondary_irts_fr_1_fields(char *buffer);

int secondary_irts_fr_1_fields_file(FILE *buffer);

/**
 * Pack message IRTS_FR_1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_irts_fr_1_pack(
    uint8_t *dst_p,
    const secondary_irts_fr_1_t *src_p,
    size_t byte_size);

/**
 * Unpack message IRTS_FR_1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_irts_fr_1_unpack(
    secondary_irts_fr_1_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_irts_fr_1_channel5_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_irts_fr_1_channel5_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_fr_1_channel5_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_irts_fr_1_channel6_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_irts_fr_1_channel6_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_fr_1_channel6_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_irts_fr_1_channel7_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_irts_fr_1_channel7_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_fr_1_channel7_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_irts_fr_1_channel8_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_irts_fr_1_channel8_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_fr_1_channel8_is_in_range(uint16_t value);


void secondary_irts_fr_2_raw_to_conversion(
    secondary_irts_fr_2_converted_t *conversion,
    float channel9,
    float channel10,
    float channel11,
    float channel12
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_irts_fr_2_conversion_to_raw(
    secondary_irts_fr_2_t *raw,
    float channel9,
    float channel10,
    float channel11,
    float channel12
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_irts_fr_2_raw_to_conversion_struct(
    secondary_irts_fr_2_converted_t *conversion, 
    const secondary_irts_fr_2_t *raw);


void secondary_irts_fr_2_conversion_to_raw_struct(
    secondary_irts_fr_2_t *raw,
    const secondary_irts_fr_2_converted_t *conversion);


int secondary_irts_fr_2_converted_to_string(secondary_irts_fr_2_converted_t *message, char *buffer);

int secondary_irts_fr_2_converted_to_string_file(secondary_irts_fr_2_converted_t *message, FILE *buffer);

int secondary_irts_fr_2_fields(char *buffer);

int secondary_irts_fr_2_fields_file(FILE *buffer);

/**
 * Pack message IRTS_FR_2.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_irts_fr_2_pack(
    uint8_t *dst_p,
    const secondary_irts_fr_2_t *src_p,
    size_t byte_size);

/**
 * Unpack message IRTS_FR_2.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_irts_fr_2_unpack(
    secondary_irts_fr_2_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_irts_fr_2_channel9_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_irts_fr_2_channel9_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_fr_2_channel9_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_irts_fr_2_channel10_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_irts_fr_2_channel10_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_fr_2_channel10_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_irts_fr_2_channel11_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_irts_fr_2_channel11_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_fr_2_channel11_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_irts_fr_2_channel12_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_irts_fr_2_channel12_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_fr_2_channel12_is_in_range(uint16_t value);


void secondary_irts_fr_3_raw_to_conversion(
    secondary_irts_fr_3_converted_t *conversion,
    float channel13,
    float channel14,
    float channel15,
    float channel16
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_irts_fr_3_conversion_to_raw(
    secondary_irts_fr_3_t *raw,
    float channel13,
    float channel14,
    float channel15,
    float channel16
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_irts_fr_3_raw_to_conversion_struct(
    secondary_irts_fr_3_converted_t *conversion, 
    const secondary_irts_fr_3_t *raw);


void secondary_irts_fr_3_conversion_to_raw_struct(
    secondary_irts_fr_3_t *raw,
    const secondary_irts_fr_3_converted_t *conversion);


int secondary_irts_fr_3_converted_to_string(secondary_irts_fr_3_converted_t *message, char *buffer);

int secondary_irts_fr_3_converted_to_string_file(secondary_irts_fr_3_converted_t *message, FILE *buffer);

int secondary_irts_fr_3_fields(char *buffer);

int secondary_irts_fr_3_fields_file(FILE *buffer);

/**
 * Pack message IRTS_FR_3.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_irts_fr_3_pack(
    uint8_t *dst_p,
    const secondary_irts_fr_3_t *src_p,
    size_t byte_size);

/**
 * Unpack message IRTS_FR_3.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_irts_fr_3_unpack(
    secondary_irts_fr_3_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_irts_fr_3_channel13_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_irts_fr_3_channel13_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_fr_3_channel13_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_irts_fr_3_channel14_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_irts_fr_3_channel14_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_fr_3_channel14_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_irts_fr_3_channel15_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_irts_fr_3_channel15_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_fr_3_channel15_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_irts_fr_3_channel16_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_irts_fr_3_channel16_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_fr_3_channel16_is_in_range(uint16_t value);


void secondary_irts_rl_0_raw_to_conversion(
    secondary_irts_rl_0_converted_t *conversion,
    float channel1,
    float channel2,
    float channel3,
    float channel4
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_irts_rl_0_conversion_to_raw(
    secondary_irts_rl_0_t *raw,
    float channel1,
    float channel2,
    float channel3,
    float channel4
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_irts_rl_0_raw_to_conversion_struct(
    secondary_irts_rl_0_converted_t *conversion, 
    const secondary_irts_rl_0_t *raw);


void secondary_irts_rl_0_conversion_to_raw_struct(
    secondary_irts_rl_0_t *raw,
    const secondary_irts_rl_0_converted_t *conversion);


int secondary_irts_rl_0_converted_to_string(secondary_irts_rl_0_converted_t *message, char *buffer);

int secondary_irts_rl_0_converted_to_string_file(secondary_irts_rl_0_converted_t *message, FILE *buffer);

int secondary_irts_rl_0_fields(char *buffer);

int secondary_irts_rl_0_fields_file(FILE *buffer);

/**
 * Pack message IRTS_RL_0.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_irts_rl_0_pack(
    uint8_t *dst_p,
    const secondary_irts_rl_0_t *src_p,
    size_t byte_size);

/**
 * Unpack message IRTS_RL_0.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_irts_rl_0_unpack(
    secondary_irts_rl_0_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_irts_rl_0_channel1_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_irts_rl_0_channel1_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_rl_0_channel1_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_irts_rl_0_channel2_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_irts_rl_0_channel2_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_rl_0_channel2_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_irts_rl_0_channel3_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_irts_rl_0_channel3_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_rl_0_channel3_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_irts_rl_0_channel4_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_irts_rl_0_channel4_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_rl_0_channel4_is_in_range(uint16_t value);


void secondary_irts_rl_1_raw_to_conversion(
    secondary_irts_rl_1_converted_t *conversion,
    float channel5,
    float channel6,
    float channel7,
    float channel8
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_irts_rl_1_conversion_to_raw(
    secondary_irts_rl_1_t *raw,
    float channel5,
    float channel6,
    float channel7,
    float channel8
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_irts_rl_1_raw_to_conversion_struct(
    secondary_irts_rl_1_converted_t *conversion, 
    const secondary_irts_rl_1_t *raw);


void secondary_irts_rl_1_conversion_to_raw_struct(
    secondary_irts_rl_1_t *raw,
    const secondary_irts_rl_1_converted_t *conversion);


int secondary_irts_rl_1_converted_to_string(secondary_irts_rl_1_converted_t *message, char *buffer);

int secondary_irts_rl_1_converted_to_string_file(secondary_irts_rl_1_converted_t *message, FILE *buffer);

int secondary_irts_rl_1_fields(char *buffer);

int secondary_irts_rl_1_fields_file(FILE *buffer);

/**
 * Pack message IRTS_RL_1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_irts_rl_1_pack(
    uint8_t *dst_p,
    const secondary_irts_rl_1_t *src_p,
    size_t byte_size);

/**
 * Unpack message IRTS_RL_1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_irts_rl_1_unpack(
    secondary_irts_rl_1_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_irts_rl_1_channel5_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_irts_rl_1_channel5_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_rl_1_channel5_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_irts_rl_1_channel6_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_irts_rl_1_channel6_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_rl_1_channel6_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_irts_rl_1_channel7_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_irts_rl_1_channel7_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_rl_1_channel7_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_irts_rl_1_channel8_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_irts_rl_1_channel8_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_rl_1_channel8_is_in_range(uint16_t value);


void secondary_irts_rl_2_raw_to_conversion(
    secondary_irts_rl_2_converted_t *conversion,
    float channel9,
    float channel10,
    float channel11,
    float channel12
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_irts_rl_2_conversion_to_raw(
    secondary_irts_rl_2_t *raw,
    float channel9,
    float channel10,
    float channel11,
    float channel12
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_irts_rl_2_raw_to_conversion_struct(
    secondary_irts_rl_2_converted_t *conversion, 
    const secondary_irts_rl_2_t *raw);


void secondary_irts_rl_2_conversion_to_raw_struct(
    secondary_irts_rl_2_t *raw,
    const secondary_irts_rl_2_converted_t *conversion);


int secondary_irts_rl_2_converted_to_string(secondary_irts_rl_2_converted_t *message, char *buffer);

int secondary_irts_rl_2_converted_to_string_file(secondary_irts_rl_2_converted_t *message, FILE *buffer);

int secondary_irts_rl_2_fields(char *buffer);

int secondary_irts_rl_2_fields_file(FILE *buffer);

/**
 * Pack message IRTS_RL_2.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_irts_rl_2_pack(
    uint8_t *dst_p,
    const secondary_irts_rl_2_t *src_p,
    size_t byte_size);

/**
 * Unpack message IRTS_RL_2.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_irts_rl_2_unpack(
    secondary_irts_rl_2_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_irts_rl_2_channel9_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_irts_rl_2_channel9_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_rl_2_channel9_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_irts_rl_2_channel10_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_irts_rl_2_channel10_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_rl_2_channel10_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_irts_rl_2_channel11_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_irts_rl_2_channel11_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_rl_2_channel11_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_irts_rl_2_channel12_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_irts_rl_2_channel12_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_rl_2_channel12_is_in_range(uint16_t value);


void secondary_irts_rl_3_raw_to_conversion(
    secondary_irts_rl_3_converted_t *conversion,
    float channel13,
    float channel14,
    float channel15,
    float channel16
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_irts_rl_3_conversion_to_raw(
    secondary_irts_rl_3_t *raw,
    float channel13,
    float channel14,
    float channel15,
    float channel16
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_irts_rl_3_raw_to_conversion_struct(
    secondary_irts_rl_3_converted_t *conversion, 
    const secondary_irts_rl_3_t *raw);


void secondary_irts_rl_3_conversion_to_raw_struct(
    secondary_irts_rl_3_t *raw,
    const secondary_irts_rl_3_converted_t *conversion);


int secondary_irts_rl_3_converted_to_string(secondary_irts_rl_3_converted_t *message, char *buffer);

int secondary_irts_rl_3_converted_to_string_file(secondary_irts_rl_3_converted_t *message, FILE *buffer);

int secondary_irts_rl_3_fields(char *buffer);

int secondary_irts_rl_3_fields_file(FILE *buffer);

/**
 * Pack message IRTS_RL_3.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_irts_rl_3_pack(
    uint8_t *dst_p,
    const secondary_irts_rl_3_t *src_p,
    size_t byte_size);

/**
 * Unpack message IRTS_RL_3.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_irts_rl_3_unpack(
    secondary_irts_rl_3_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_irts_rl_3_channel13_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_irts_rl_3_channel13_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_rl_3_channel13_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_irts_rl_3_channel14_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_irts_rl_3_channel14_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_rl_3_channel14_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_irts_rl_3_channel15_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_irts_rl_3_channel15_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_rl_3_channel15_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_irts_rl_3_channel16_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_irts_rl_3_channel16_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_rl_3_channel16_is_in_range(uint16_t value);


void secondary_irts_rr_0_raw_to_conversion(
    secondary_irts_rr_0_converted_t *conversion,
    float channel1,
    float channel2,
    float channel3,
    float channel4
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_irts_rr_0_conversion_to_raw(
    secondary_irts_rr_0_t *raw,
    float channel1,
    float channel2,
    float channel3,
    float channel4
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_irts_rr_0_raw_to_conversion_struct(
    secondary_irts_rr_0_converted_t *conversion, 
    const secondary_irts_rr_0_t *raw);


void secondary_irts_rr_0_conversion_to_raw_struct(
    secondary_irts_rr_0_t *raw,
    const secondary_irts_rr_0_converted_t *conversion);


int secondary_irts_rr_0_converted_to_string(secondary_irts_rr_0_converted_t *message, char *buffer);

int secondary_irts_rr_0_converted_to_string_file(secondary_irts_rr_0_converted_t *message, FILE *buffer);

int secondary_irts_rr_0_fields(char *buffer);

int secondary_irts_rr_0_fields_file(FILE *buffer);

/**
 * Pack message IRTS_RR_0.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_irts_rr_0_pack(
    uint8_t *dst_p,
    const secondary_irts_rr_0_t *src_p,
    size_t byte_size);

/**
 * Unpack message IRTS_RR_0.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_irts_rr_0_unpack(
    secondary_irts_rr_0_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_irts_rr_0_channel1_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_irts_rr_0_channel1_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_rr_0_channel1_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_irts_rr_0_channel2_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_irts_rr_0_channel2_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_rr_0_channel2_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_irts_rr_0_channel3_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_irts_rr_0_channel3_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_rr_0_channel3_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_irts_rr_0_channel4_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_irts_rr_0_channel4_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_rr_0_channel4_is_in_range(uint16_t value);


void secondary_irts_rr_1_raw_to_conversion(
    secondary_irts_rr_1_converted_t *conversion,
    float channel5,
    float channel6,
    float channel7,
    float channel8
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_irts_rr_1_conversion_to_raw(
    secondary_irts_rr_1_t *raw,
    float channel5,
    float channel6,
    float channel7,
    float channel8
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_irts_rr_1_raw_to_conversion_struct(
    secondary_irts_rr_1_converted_t *conversion, 
    const secondary_irts_rr_1_t *raw);


void secondary_irts_rr_1_conversion_to_raw_struct(
    secondary_irts_rr_1_t *raw,
    const secondary_irts_rr_1_converted_t *conversion);


int secondary_irts_rr_1_converted_to_string(secondary_irts_rr_1_converted_t *message, char *buffer);

int secondary_irts_rr_1_converted_to_string_file(secondary_irts_rr_1_converted_t *message, FILE *buffer);

int secondary_irts_rr_1_fields(char *buffer);

int secondary_irts_rr_1_fields_file(FILE *buffer);

/**
 * Pack message IRTS_RR_1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_irts_rr_1_pack(
    uint8_t *dst_p,
    const secondary_irts_rr_1_t *src_p,
    size_t byte_size);

/**
 * Unpack message IRTS_RR_1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_irts_rr_1_unpack(
    secondary_irts_rr_1_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_irts_rr_1_channel5_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_irts_rr_1_channel5_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_rr_1_channel5_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_irts_rr_1_channel6_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_irts_rr_1_channel6_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_rr_1_channel6_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_irts_rr_1_channel7_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_irts_rr_1_channel7_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_rr_1_channel7_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_irts_rr_1_channel8_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_irts_rr_1_channel8_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_rr_1_channel8_is_in_range(uint16_t value);


void secondary_irts_rr_2_raw_to_conversion(
    secondary_irts_rr_2_converted_t *conversion,
    float channel9,
    float channel10,
    float channel11,
    float channel12
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_irts_rr_2_conversion_to_raw(
    secondary_irts_rr_2_t *raw,
    float channel9,
    float channel10,
    float channel11,
    float channel12
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_irts_rr_2_raw_to_conversion_struct(
    secondary_irts_rr_2_converted_t *conversion, 
    const secondary_irts_rr_2_t *raw);


void secondary_irts_rr_2_conversion_to_raw_struct(
    secondary_irts_rr_2_t *raw,
    const secondary_irts_rr_2_converted_t *conversion);


int secondary_irts_rr_2_converted_to_string(secondary_irts_rr_2_converted_t *message, char *buffer);

int secondary_irts_rr_2_converted_to_string_file(secondary_irts_rr_2_converted_t *message, FILE *buffer);

int secondary_irts_rr_2_fields(char *buffer);

int secondary_irts_rr_2_fields_file(FILE *buffer);

/**
 * Pack message IRTS_RR_2.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_irts_rr_2_pack(
    uint8_t *dst_p,
    const secondary_irts_rr_2_t *src_p,
    size_t byte_size);

/**
 * Unpack message IRTS_RR_2.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_irts_rr_2_unpack(
    secondary_irts_rr_2_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_irts_rr_2_channel9_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_irts_rr_2_channel9_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_rr_2_channel9_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_irts_rr_2_channel10_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_irts_rr_2_channel10_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_rr_2_channel10_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_irts_rr_2_channel11_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_irts_rr_2_channel11_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_rr_2_channel11_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_irts_rr_2_channel12_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_irts_rr_2_channel12_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_rr_2_channel12_is_in_range(uint16_t value);


void secondary_irts_rr_3_raw_to_conversion(
    secondary_irts_rr_3_converted_t *conversion,
    float channel13,
    float channel14,
    float channel15,
    float channel16
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_irts_rr_3_conversion_to_raw(
    secondary_irts_rr_3_t *raw,
    float channel13,
    float channel14,
    float channel15,
    float channel16
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_irts_rr_3_raw_to_conversion_struct(
    secondary_irts_rr_3_converted_t *conversion, 
    const secondary_irts_rr_3_t *raw);


void secondary_irts_rr_3_conversion_to_raw_struct(
    secondary_irts_rr_3_t *raw,
    const secondary_irts_rr_3_converted_t *conversion);


int secondary_irts_rr_3_converted_to_string(secondary_irts_rr_3_converted_t *message, char *buffer);

int secondary_irts_rr_3_converted_to_string_file(secondary_irts_rr_3_converted_t *message, FILE *buffer);

int secondary_irts_rr_3_fields(char *buffer);

int secondary_irts_rr_3_fields_file(FILE *buffer);

/**
 * Pack message IRTS_RR_3.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_irts_rr_3_pack(
    uint8_t *dst_p,
    const secondary_irts_rr_3_t *src_p,
    size_t byte_size);

/**
 * Unpack message IRTS_RR_3.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_irts_rr_3_unpack(
    secondary_irts_rr_3_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_irts_rr_3_channel13_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_irts_rr_3_channel13_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_rr_3_channel13_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_irts_rr_3_channel14_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_irts_rr_3_channel14_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_rr_3_channel14_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_irts_rr_3_channel15_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_irts_rr_3_channel15_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_rr_3_channel15_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_irts_rr_3_channel16_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_irts_rr_3_channel16_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_rr_3_channel16_is_in_range(uint16_t value);


void secondary_vehicle_position_raw_to_conversion(
    secondary_vehicle_position_converted_t *conversion,
    float x,
    float y,
    float heading
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_vehicle_position_conversion_to_raw(
    secondary_vehicle_position_t *raw,
    float x,
    float y,
    float heading
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_vehicle_position_raw_to_conversion_struct(
    secondary_vehicle_position_converted_t *conversion, 
    const secondary_vehicle_position_t *raw);


void secondary_vehicle_position_conversion_to_raw_struct(
    secondary_vehicle_position_t *raw,
    const secondary_vehicle_position_converted_t *conversion);


int secondary_vehicle_position_converted_to_string(secondary_vehicle_position_converted_t *message, char *buffer);

int secondary_vehicle_position_converted_to_string_file(secondary_vehicle_position_converted_t *message, FILE *buffer);

int secondary_vehicle_position_fields(char *buffer);

int secondary_vehicle_position_fields_file(FILE *buffer);

/**
 * Pack message VEHICLE_POSITION.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_vehicle_position_pack(
    uint8_t *dst_p,
    const secondary_vehicle_position_t *src_p,
    size_t byte_size);

/**
 * Unpack message VEHICLE_POSITION.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_vehicle_position_unpack(
    secondary_vehicle_position_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_vehicle_position_x_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_vehicle_position_x_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_vehicle_position_x_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_vehicle_position_y_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_vehicle_position_y_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_vehicle_position_y_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_vehicle_position_heading_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_vehicle_position_heading_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_vehicle_position_heading_is_in_range(uint16_t value);


void secondary_vehicle_speed_raw_to_conversion(
    secondary_vehicle_speed_converted_t *conversion,
    float u,
    float v
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_vehicle_speed_conversion_to_raw(
    secondary_vehicle_speed_t *raw,
    float u,
    float v
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_vehicle_speed_raw_to_conversion_struct(
    secondary_vehicle_speed_converted_t *conversion, 
    const secondary_vehicle_speed_t *raw);


void secondary_vehicle_speed_conversion_to_raw_struct(
    secondary_vehicle_speed_t *raw,
    const secondary_vehicle_speed_converted_t *conversion);


int secondary_vehicle_speed_converted_to_string(secondary_vehicle_speed_converted_t *message, char *buffer);

int secondary_vehicle_speed_converted_to_string_file(secondary_vehicle_speed_converted_t *message, FILE *buffer);

int secondary_vehicle_speed_fields(char *buffer);

int secondary_vehicle_speed_fields_file(FILE *buffer);

/**
 * Pack message VEHICLE_SPEED.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_vehicle_speed_pack(
    uint8_t *dst_p,
    const secondary_vehicle_speed_t *src_p,
    size_t byte_size);

/**
 * Unpack message VEHICLE_SPEED.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_vehicle_speed_unpack(
    secondary_vehicle_speed_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_vehicle_speed_u_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_vehicle_speed_u_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_vehicle_speed_u_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_vehicle_speed_v_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_vehicle_speed_v_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_vehicle_speed_v_is_in_range(uint16_t value);


void secondary_vehicle_curvilinear_coordinates_raw_to_conversion(
    secondary_vehicle_curvilinear_coordinates_converted_t *conversion,
    float s,
    float n
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_vehicle_curvilinear_coordinates_conversion_to_raw(
    secondary_vehicle_curvilinear_coordinates_t *raw,
    float s,
    float n
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_vehicle_curvilinear_coordinates_raw_to_conversion_struct(
    secondary_vehicle_curvilinear_coordinates_converted_t *conversion, 
    const secondary_vehicle_curvilinear_coordinates_t *raw);


void secondary_vehicle_curvilinear_coordinates_conversion_to_raw_struct(
    secondary_vehicle_curvilinear_coordinates_t *raw,
    const secondary_vehicle_curvilinear_coordinates_converted_t *conversion);


int secondary_vehicle_curvilinear_coordinates_converted_to_string(secondary_vehicle_curvilinear_coordinates_converted_t *message, char *buffer);

int secondary_vehicle_curvilinear_coordinates_converted_to_string_file(secondary_vehicle_curvilinear_coordinates_converted_t *message, FILE *buffer);

int secondary_vehicle_curvilinear_coordinates_fields(char *buffer);

int secondary_vehicle_curvilinear_coordinates_fields_file(FILE *buffer);

/**
 * Pack message VEHICLE_CURVILINEAR_COORDINATES.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_vehicle_curvilinear_coordinates_pack(
    uint8_t *dst_p,
    const secondary_vehicle_curvilinear_coordinates_t *src_p,
    size_t byte_size);

/**
 * Unpack message VEHICLE_CURVILINEAR_COORDINATES.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_vehicle_curvilinear_coordinates_unpack(
    secondary_vehicle_curvilinear_coordinates_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t secondary_vehicle_curvilinear_coordinates_s_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_vehicle_curvilinear_coordinates_s_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_vehicle_curvilinear_coordinates_s_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_vehicle_curvilinear_coordinates_n_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_vehicle_curvilinear_coordinates_n_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_vehicle_curvilinear_coordinates_n_is_in_range(uint16_t value);


void secondary_front_angular_velocity_raw_to_conversion(
    secondary_front_angular_velocity_converted_t *conversion,
    float fl,
    float fr
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_front_angular_velocity_conversion_to_raw(
    secondary_front_angular_velocity_t *raw,
    float fl,
    float fr
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_front_angular_velocity_raw_to_conversion_struct(
    secondary_front_angular_velocity_converted_t *conversion, 
    const secondary_front_angular_velocity_t *raw);


void secondary_front_angular_velocity_conversion_to_raw_struct(
    secondary_front_angular_velocity_t *raw,
    const secondary_front_angular_velocity_converted_t *conversion);


int secondary_front_angular_velocity_converted_to_string(secondary_front_angular_velocity_converted_t *message, char *buffer);

int secondary_front_angular_velocity_converted_to_string_file(secondary_front_angular_velocity_converted_t *message, FILE *buffer);

int secondary_front_angular_velocity_fields(char *buffer);

int secondary_front_angular_velocity_fields_file(FILE *buffer);

/**
 * Pack message FRONT_ANGULAR_VELOCITY.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_front_angular_velocity_pack(
    uint8_t *dst_p,
    const secondary_front_angular_velocity_t *src_p,
    size_t byte_size);

/**
 * Unpack message FRONT_ANGULAR_VELOCITY.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_front_angular_velocity_unpack(
    secondary_front_angular_velocity_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_front_angular_velocity_fl_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_front_angular_velocity_fl_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_front_angular_velocity_fl_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_front_angular_velocity_fr_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_front_angular_velocity_fr_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_front_angular_velocity_fr_is_in_range(uint16_t value);


void secondary_rear_angular_velocity_raw_to_conversion(
    secondary_rear_angular_velocity_converted_t *conversion,
    float rl,
    float rr
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_rear_angular_velocity_conversion_to_raw(
    secondary_rear_angular_velocity_t *raw,
    float rl,
    float rr
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_rear_angular_velocity_raw_to_conversion_struct(
    secondary_rear_angular_velocity_converted_t *conversion, 
    const secondary_rear_angular_velocity_t *raw);


void secondary_rear_angular_velocity_conversion_to_raw_struct(
    secondary_rear_angular_velocity_t *raw,
    const secondary_rear_angular_velocity_converted_t *conversion);


int secondary_rear_angular_velocity_converted_to_string(secondary_rear_angular_velocity_converted_t *message, char *buffer);

int secondary_rear_angular_velocity_converted_to_string_file(secondary_rear_angular_velocity_converted_t *message, FILE *buffer);

int secondary_rear_angular_velocity_fields(char *buffer);

int secondary_rear_angular_velocity_fields_file(FILE *buffer);

/**
 * Pack message REAR_ANGULAR_VELOCITY.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_rear_angular_velocity_pack(
    uint8_t *dst_p,
    const secondary_rear_angular_velocity_t *src_p,
    size_t byte_size);

/**
 * Unpack message REAR_ANGULAR_VELOCITY.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_rear_angular_velocity_unpack(
    secondary_rear_angular_velocity_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_rear_angular_velocity_rl_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_rear_angular_velocity_rl_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_rear_angular_velocity_rl_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_rear_angular_velocity_rr_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_rear_angular_velocity_rr_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_rear_angular_velocity_rr_is_in_range(uint16_t value);


void secondary_hv_soc_estimation_state_raw_to_conversion(
    secondary_hv_soc_estimation_state_converted_t *conversion,
    float soc,
    float rc1,
    float rc2
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_hv_soc_estimation_state_conversion_to_raw(
    secondary_hv_soc_estimation_state_t *raw,
    float soc,
    float rc1,
    float rc2
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_hv_soc_estimation_state_raw_to_conversion_struct(
    secondary_hv_soc_estimation_state_converted_t *conversion, 
    const secondary_hv_soc_estimation_state_t *raw);


void secondary_hv_soc_estimation_state_conversion_to_raw_struct(
    secondary_hv_soc_estimation_state_t *raw,
    const secondary_hv_soc_estimation_state_converted_t *conversion);


int secondary_hv_soc_estimation_state_converted_to_string(secondary_hv_soc_estimation_state_converted_t *message, char *buffer);

int secondary_hv_soc_estimation_state_converted_to_string_file(secondary_hv_soc_estimation_state_converted_t *message, FILE *buffer);

int secondary_hv_soc_estimation_state_fields(char *buffer);

int secondary_hv_soc_estimation_state_fields_file(FILE *buffer);

/**
 * Pack message HV_SOC_ESTIMATION_STATE.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_hv_soc_estimation_state_pack(
    uint8_t *dst_p,
    const secondary_hv_soc_estimation_state_t *src_p,
    size_t byte_size);

/**
 * Unpack message HV_SOC_ESTIMATION_STATE.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_hv_soc_estimation_state_unpack(
    secondary_hv_soc_estimation_state_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_hv_soc_estimation_state_soc_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_hv_soc_estimation_state_soc_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_hv_soc_estimation_state_soc_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_hv_soc_estimation_state_rc1_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_hv_soc_estimation_state_rc1_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_hv_soc_estimation_state_rc1_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_hv_soc_estimation_state_rc2_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_hv_soc_estimation_state_rc2_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_hv_soc_estimation_state_rc2_is_in_range(uint16_t value);


void secondary_hv_soc_estimation_covariance_raw_to_conversion(
    secondary_hv_soc_estimation_covariance_converted_t *conversion,
    float soc,
    float rc1,
    float rc2
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_hv_soc_estimation_covariance_conversion_to_raw(
    secondary_hv_soc_estimation_covariance_t *raw,
    float soc,
    float rc1,
    float rc2
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_hv_soc_estimation_covariance_raw_to_conversion_struct(
    secondary_hv_soc_estimation_covariance_converted_t *conversion, 
    const secondary_hv_soc_estimation_covariance_t *raw);


void secondary_hv_soc_estimation_covariance_conversion_to_raw_struct(
    secondary_hv_soc_estimation_covariance_t *raw,
    const secondary_hv_soc_estimation_covariance_converted_t *conversion);


int secondary_hv_soc_estimation_covariance_converted_to_string(secondary_hv_soc_estimation_covariance_converted_t *message, char *buffer);

int secondary_hv_soc_estimation_covariance_converted_to_string_file(secondary_hv_soc_estimation_covariance_converted_t *message, FILE *buffer);

int secondary_hv_soc_estimation_covariance_fields(char *buffer);

int secondary_hv_soc_estimation_covariance_fields_file(FILE *buffer);

/**
 * Pack message HV_SOC_ESTIMATION_COVARIANCE.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_hv_soc_estimation_covariance_pack(
    uint8_t *dst_p,
    const secondary_hv_soc_estimation_covariance_t *src_p,
    size_t byte_size);

/**
 * Unpack message HV_SOC_ESTIMATION_COVARIANCE.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_hv_soc_estimation_covariance_unpack(
    secondary_hv_soc_estimation_covariance_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_hv_soc_estimation_covariance_soc_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_hv_soc_estimation_covariance_soc_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_hv_soc_estimation_covariance_soc_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_hv_soc_estimation_covariance_rc1_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_hv_soc_estimation_covariance_rc1_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_hv_soc_estimation_covariance_rc1_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_hv_soc_estimation_covariance_rc2_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_hv_soc_estimation_covariance_rc2_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_hv_soc_estimation_covariance_rc2_is_in_range(uint16_t value);


void secondary_lv_soc_estimation_state_raw_to_conversion(
    secondary_lv_soc_estimation_state_converted_t *conversion,
    float soc,
    float rc1,
    float rc2
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_lv_soc_estimation_state_conversion_to_raw(
    secondary_lv_soc_estimation_state_t *raw,
    float soc,
    float rc1,
    float rc2
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_lv_soc_estimation_state_raw_to_conversion_struct(
    secondary_lv_soc_estimation_state_converted_t *conversion, 
    const secondary_lv_soc_estimation_state_t *raw);


void secondary_lv_soc_estimation_state_conversion_to_raw_struct(
    secondary_lv_soc_estimation_state_t *raw,
    const secondary_lv_soc_estimation_state_converted_t *conversion);


int secondary_lv_soc_estimation_state_converted_to_string(secondary_lv_soc_estimation_state_converted_t *message, char *buffer);

int secondary_lv_soc_estimation_state_converted_to_string_file(secondary_lv_soc_estimation_state_converted_t *message, FILE *buffer);

int secondary_lv_soc_estimation_state_fields(char *buffer);

int secondary_lv_soc_estimation_state_fields_file(FILE *buffer);

/**
 * Pack message LV_SOC_ESTIMATION_STATE.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_lv_soc_estimation_state_pack(
    uint8_t *dst_p,
    const secondary_lv_soc_estimation_state_t *src_p,
    size_t byte_size);

/**
 * Unpack message LV_SOC_ESTIMATION_STATE.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_lv_soc_estimation_state_unpack(
    secondary_lv_soc_estimation_state_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_lv_soc_estimation_state_soc_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_lv_soc_estimation_state_soc_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_lv_soc_estimation_state_soc_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_lv_soc_estimation_state_rc1_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_lv_soc_estimation_state_rc1_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_lv_soc_estimation_state_rc1_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_lv_soc_estimation_state_rc2_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_lv_soc_estimation_state_rc2_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_lv_soc_estimation_state_rc2_is_in_range(uint16_t value);


void secondary_lv_soc_estimation_covariance_raw_to_conversion(
    secondary_lv_soc_estimation_covariance_converted_t *conversion,
    float soc,
    float rc1,
    float rc2
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_lv_soc_estimation_covariance_conversion_to_raw(
    secondary_lv_soc_estimation_covariance_t *raw,
    float soc,
    float rc1,
    float rc2
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_lv_soc_estimation_covariance_raw_to_conversion_struct(
    secondary_lv_soc_estimation_covariance_converted_t *conversion, 
    const secondary_lv_soc_estimation_covariance_t *raw);


void secondary_lv_soc_estimation_covariance_conversion_to_raw_struct(
    secondary_lv_soc_estimation_covariance_t *raw,
    const secondary_lv_soc_estimation_covariance_converted_t *conversion);


int secondary_lv_soc_estimation_covariance_converted_to_string(secondary_lv_soc_estimation_covariance_converted_t *message, char *buffer);

int secondary_lv_soc_estimation_covariance_converted_to_string_file(secondary_lv_soc_estimation_covariance_converted_t *message, FILE *buffer);

int secondary_lv_soc_estimation_covariance_fields(char *buffer);

int secondary_lv_soc_estimation_covariance_fields_file(FILE *buffer);

/**
 * Pack message LV_SOC_ESTIMATION_COVARIANCE.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_lv_soc_estimation_covariance_pack(
    uint8_t *dst_p,
    const secondary_lv_soc_estimation_covariance_t *src_p,
    size_t byte_size);

/**
 * Unpack message LV_SOC_ESTIMATION_COVARIANCE.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_lv_soc_estimation_covariance_unpack(
    secondary_lv_soc_estimation_covariance_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_lv_soc_estimation_covariance_soc_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_lv_soc_estimation_covariance_soc_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_lv_soc_estimation_covariance_soc_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_lv_soc_estimation_covariance_rc1_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_lv_soc_estimation_covariance_rc1_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_lv_soc_estimation_covariance_rc1_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_lv_soc_estimation_covariance_rc2_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_lv_soc_estimation_covariance_rc2_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_lv_soc_estimation_covariance_rc2_is_in_range(uint16_t value);


void secondary_pedal_throttle_raw_to_conversion(
    secondary_pedal_throttle_converted_t *conversion,
    float throttle
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_pedal_throttle_conversion_to_raw(
    secondary_pedal_throttle_t *raw,
    float throttle
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_pedal_throttle_raw_to_conversion_struct(
    secondary_pedal_throttle_converted_t *conversion, 
    const secondary_pedal_throttle_t *raw);


void secondary_pedal_throttle_conversion_to_raw_struct(
    secondary_pedal_throttle_t *raw,
    const secondary_pedal_throttle_converted_t *conversion);


int secondary_pedal_throttle_converted_to_string(secondary_pedal_throttle_converted_t *message, char *buffer);

int secondary_pedal_throttle_converted_to_string_file(secondary_pedal_throttle_converted_t *message, FILE *buffer);

int secondary_pedal_throttle_fields(char *buffer);

int secondary_pedal_throttle_fields_file(FILE *buffer);

/**
 * Pack message PEDAL_THROTTLE.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_pedal_throttle_pack(
    uint8_t *dst_p,
    const secondary_pedal_throttle_t *src_p,
    size_t byte_size);

/**
 * Unpack message PEDAL_THROTTLE.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_pedal_throttle_unpack(
    secondary_pedal_throttle_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_pedal_throttle_throttle_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_pedal_throttle_throttle_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_pedal_throttle_throttle_is_in_range(uint16_t value);


void secondary_pedal_brakes_pressure_raw_to_conversion(
    secondary_pedal_brakes_pressure_converted_t *conversion,
    float front,
    float rear
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_pedal_brakes_pressure_conversion_to_raw(
    secondary_pedal_brakes_pressure_t *raw,
    float front,
    float rear
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_pedal_brakes_pressure_raw_to_conversion_struct(
    secondary_pedal_brakes_pressure_converted_t *conversion, 
    const secondary_pedal_brakes_pressure_t *raw);


void secondary_pedal_brakes_pressure_conversion_to_raw_struct(
    secondary_pedal_brakes_pressure_t *raw,
    const secondary_pedal_brakes_pressure_converted_t *conversion);


int secondary_pedal_brakes_pressure_converted_to_string(secondary_pedal_brakes_pressure_converted_t *message, char *buffer);

int secondary_pedal_brakes_pressure_converted_to_string_file(secondary_pedal_brakes_pressure_converted_t *message, FILE *buffer);

int secondary_pedal_brakes_pressure_fields(char *buffer);

int secondary_pedal_brakes_pressure_fields_file(FILE *buffer);

/**
 * Pack message PEDAL_BRAKES_PRESSURE.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_pedal_brakes_pressure_pack(
    uint8_t *dst_p,
    const secondary_pedal_brakes_pressure_t *src_p,
    size_t byte_size);

/**
 * Unpack message PEDAL_BRAKES_PRESSURE.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_pedal_brakes_pressure_unpack(
    secondary_pedal_brakes_pressure_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_pedal_brakes_pressure_front_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_pedal_brakes_pressure_front_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_pedal_brakes_pressure_front_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_pedal_brakes_pressure_rear_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_pedal_brakes_pressure_rear_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_pedal_brakes_pressure_rear_is_in_range(uint16_t value);


void secondary_steer_angle_raw_to_conversion(
    secondary_steer_angle_converted_t *conversion,
    float angle
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_steer_angle_conversion_to_raw(
    secondary_steer_angle_t *raw,
    float angle
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_steer_angle_raw_to_conversion_struct(
    secondary_steer_angle_converted_t *conversion, 
    const secondary_steer_angle_t *raw);


void secondary_steer_angle_conversion_to_raw_struct(
    secondary_steer_angle_t *raw,
    const secondary_steer_angle_converted_t *conversion);


int secondary_steer_angle_converted_to_string(secondary_steer_angle_converted_t *message, char *buffer);

int secondary_steer_angle_converted_to_string_file(secondary_steer_angle_converted_t *message, FILE *buffer);

int secondary_steer_angle_fields(char *buffer);

int secondary_steer_angle_fields_file(FILE *buffer);

/**
 * Pack message STEER_ANGLE.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_steer_angle_pack(
    uint8_t *dst_p,
    const secondary_steer_angle_t *src_p,
    size_t byte_size);

/**
 * Unpack message STEER_ANGLE.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_steer_angle_unpack(
    secondary_steer_angle_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t secondary_steer_angle_angle_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_steer_angle_angle_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_steer_angle_angle_is_in_range(uint32_t value);


void secondary_odometer_raw_to_conversion(
    secondary_odometer_converted_t *conversion,
    float kilometers
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_odometer_conversion_to_raw(
    secondary_odometer_t *raw,
    float kilometers
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_odometer_raw_to_conversion_struct(
    secondary_odometer_converted_t *conversion, 
    const secondary_odometer_t *raw);


void secondary_odometer_conversion_to_raw_struct(
    secondary_odometer_t *raw,
    const secondary_odometer_converted_t *conversion);


int secondary_odometer_converted_to_string(secondary_odometer_converted_t *message, char *buffer);

int secondary_odometer_converted_to_string_file(secondary_odometer_converted_t *message, FILE *buffer);

int secondary_odometer_fields(char *buffer);

int secondary_odometer_fields_file(FILE *buffer);

/**
 * Pack message ODOMETER.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_odometer_pack(
    uint8_t *dst_p,
    const secondary_odometer_t *src_p,
    size_t byte_size);

/**
 * Unpack message ODOMETER.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_odometer_unpack(
    secondary_odometer_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t secondary_odometer_kilometers_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_odometer_kilometers_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_odometer_kilometers_is_in_range(uint32_t value);


void secondary_tpms_pressure_raw_to_conversion(
    secondary_tpms_pressure_converted_t *conversion,
    uint8_t fl,
    uint8_t fr,
    uint8_t rl,
    uint8_t rr
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_tpms_pressure_conversion_to_raw(
    secondary_tpms_pressure_t *raw,
    uint8_t fl,
    uint8_t fr,
    uint8_t rl,
    uint8_t rr
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_tpms_pressure_raw_to_conversion_struct(
    secondary_tpms_pressure_converted_t *conversion, 
    const secondary_tpms_pressure_t *raw);


void secondary_tpms_pressure_conversion_to_raw_struct(
    secondary_tpms_pressure_t *raw,
    const secondary_tpms_pressure_converted_t *conversion);


int secondary_tpms_pressure_to_string(secondary_tpms_pressure_t *message, char *buffer);

int secondary_tpms_pressure_to_string_file(secondary_tpms_pressure_t *message, FILE *buffer);

int secondary_tpms_pressure_fields(char *buffer);

int secondary_tpms_pressure_fields_file(FILE *buffer);

/**
 * Pack message TPMS_PRESSURE.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_tpms_pressure_pack(
    uint8_t *dst_p,
    const secondary_tpms_pressure_t *src_p,
    size_t byte_size);

/**
 * Unpack message TPMS_PRESSURE.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_tpms_pressure_unpack(
    secondary_tpms_pressure_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_tpms_pressure_fl_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_tpms_pressure_fr_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_tpms_pressure_rl_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_tpms_pressure_rr_is_in_range(uint8_t value);


void secondary_tpms_temperature_raw_to_conversion(
    secondary_tpms_temperature_converted_t *conversion,
    uint8_t fl,
    uint8_t fr,
    uint8_t rl,
    uint8_t rr
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_tpms_temperature_conversion_to_raw(
    secondary_tpms_temperature_t *raw,
    uint8_t fl,
    uint8_t fr,
    uint8_t rl,
    uint8_t rr
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_tpms_temperature_raw_to_conversion_struct(
    secondary_tpms_temperature_converted_t *conversion, 
    const secondary_tpms_temperature_t *raw);


void secondary_tpms_temperature_conversion_to_raw_struct(
    secondary_tpms_temperature_t *raw,
    const secondary_tpms_temperature_converted_t *conversion);


int secondary_tpms_temperature_to_string(secondary_tpms_temperature_t *message, char *buffer);

int secondary_tpms_temperature_to_string_file(secondary_tpms_temperature_t *message, FILE *buffer);

int secondary_tpms_temperature_fields(char *buffer);

int secondary_tpms_temperature_fields_file(FILE *buffer);

/**
 * Pack message TPMS_TEMPERATURE.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_tpms_temperature_pack(
    uint8_t *dst_p,
    const secondary_tpms_temperature_t *src_p,
    size_t byte_size);

/**
 * Unpack message TPMS_TEMPERATURE.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_tpms_temperature_unpack(
    secondary_tpms_temperature_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_tpms_temperature_fl_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_tpms_temperature_fr_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_tpms_temperature_rl_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_tpms_temperature_rr_is_in_range(uint8_t value);


void secondary_tlm_unix_timestamp_raw_to_conversion(
    secondary_tlm_unix_timestamp_converted_t *conversion,
    uint64_t timestamp
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_tlm_unix_timestamp_conversion_to_raw(
    secondary_tlm_unix_timestamp_t *raw,
    uint64_t timestamp
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_tlm_unix_timestamp_raw_to_conversion_struct(
    secondary_tlm_unix_timestamp_converted_t *conversion, 
    const secondary_tlm_unix_timestamp_t *raw);


void secondary_tlm_unix_timestamp_conversion_to_raw_struct(
    secondary_tlm_unix_timestamp_t *raw,
    const secondary_tlm_unix_timestamp_converted_t *conversion);


int secondary_tlm_unix_timestamp_to_string(secondary_tlm_unix_timestamp_t *message, char *buffer);

int secondary_tlm_unix_timestamp_to_string_file(secondary_tlm_unix_timestamp_t *message, FILE *buffer);

int secondary_tlm_unix_timestamp_fields(char *buffer);

int secondary_tlm_unix_timestamp_fields_file(FILE *buffer);

/**
 * Pack message TLM_UNIX_TIMESTAMP.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_tlm_unix_timestamp_pack(
    uint8_t *dst_p,
    const secondary_tlm_unix_timestamp_t *src_p,
    size_t byte_size);

/**
 * Unpack message TLM_UNIX_TIMESTAMP.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_tlm_unix_timestamp_unpack(
    secondary_tlm_unix_timestamp_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_tlm_unix_timestamp_timestamp_is_in_range(uint64_t value);


void secondary_tlm_lap_time_raw_to_conversion(
    secondary_tlm_lap_time_converted_t *conversion,
    uint16_t lap_count,
    float lap_time
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_tlm_lap_time_conversion_to_raw(
    secondary_tlm_lap_time_t *raw,
    uint16_t lap_count,
    float lap_time
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_tlm_lap_time_raw_to_conversion_struct(
    secondary_tlm_lap_time_converted_t *conversion, 
    const secondary_tlm_lap_time_t *raw);


void secondary_tlm_lap_time_conversion_to_raw_struct(
    secondary_tlm_lap_time_t *raw,
    const secondary_tlm_lap_time_converted_t *conversion);


int secondary_tlm_lap_time_converted_to_string(secondary_tlm_lap_time_converted_t *message, char *buffer);

int secondary_tlm_lap_time_converted_to_string_file(secondary_tlm_lap_time_converted_t *message, FILE *buffer);

int secondary_tlm_lap_time_fields(char *buffer);

int secondary_tlm_lap_time_fields_file(FILE *buffer);

/**
 * Pack message TLM_LAP_TIME.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_tlm_lap_time_pack(
    uint8_t *dst_p,
    const secondary_tlm_lap_time_t *src_p,
    size_t byte_size);

/**
 * Unpack message TLM_LAP_TIME.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_tlm_lap_time_unpack(
    secondary_tlm_lap_time_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_tlm_lap_time_lap_count_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_tlm_lap_time_lap_time_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_tlm_lap_time_lap_time_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_tlm_lap_time_lap_time_is_in_range(uint16_t value);


void secondary_tlm_laps_stats_raw_to_conversion(
    secondary_tlm_laps_stats_converted_t *conversion,
    uint16_t lap_number,
    float best_time,
    float last_time
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_tlm_laps_stats_conversion_to_raw(
    secondary_tlm_laps_stats_t *raw,
    uint16_t lap_number,
    float best_time,
    float last_time
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_tlm_laps_stats_raw_to_conversion_struct(
    secondary_tlm_laps_stats_converted_t *conversion, 
    const secondary_tlm_laps_stats_t *raw);


void secondary_tlm_laps_stats_conversion_to_raw_struct(
    secondary_tlm_laps_stats_t *raw,
    const secondary_tlm_laps_stats_converted_t *conversion);


int secondary_tlm_laps_stats_converted_to_string(secondary_tlm_laps_stats_converted_t *message, char *buffer);

int secondary_tlm_laps_stats_converted_to_string_file(secondary_tlm_laps_stats_converted_t *message, FILE *buffer);

int secondary_tlm_laps_stats_fields(char *buffer);

int secondary_tlm_laps_stats_fields_file(FILE *buffer);

/**
 * Pack message TLM_LAPS_STATS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_tlm_laps_stats_pack(
    uint8_t *dst_p,
    const secondary_tlm_laps_stats_t *src_p,
    size_t byte_size);

/**
 * Unpack message TLM_LAPS_STATS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_tlm_laps_stats_unpack(
    secondary_tlm_laps_stats_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_tlm_laps_stats_lap_number_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_tlm_laps_stats_best_time_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_tlm_laps_stats_best_time_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_tlm_laps_stats_best_time_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_tlm_laps_stats_last_time_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_tlm_laps_stats_last_time_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_tlm_laps_stats_last_time_is_in_range(uint16_t value);


void secondary_tlm_network_interface_raw_to_conversion(
    secondary_tlm_network_interface_converted_t *conversion,
    uint8_t iname_0,
    uint8_t iname_1,
    uint8_t iname_2,
    uint8_t iname_3,
    uint32_t ip_address
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_tlm_network_interface_conversion_to_raw(
    secondary_tlm_network_interface_t *raw,
    uint8_t iname_0,
    uint8_t iname_1,
    uint8_t iname_2,
    uint8_t iname_3,
    uint32_t ip_address
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_tlm_network_interface_raw_to_conversion_struct(
    secondary_tlm_network_interface_converted_t *conversion, 
    const secondary_tlm_network_interface_t *raw);


void secondary_tlm_network_interface_conversion_to_raw_struct(
    secondary_tlm_network_interface_t *raw,
    const secondary_tlm_network_interface_converted_t *conversion);


int secondary_tlm_network_interface_to_string(secondary_tlm_network_interface_t *message, char *buffer);

int secondary_tlm_network_interface_to_string_file(secondary_tlm_network_interface_t *message, FILE *buffer);

int secondary_tlm_network_interface_fields(char *buffer);

int secondary_tlm_network_interface_fields_file(FILE *buffer);

/**
 * Pack message TLM_NETWORK_INTERFACE.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_tlm_network_interface_pack(
    uint8_t *dst_p,
    const secondary_tlm_network_interface_t *src_p,
    size_t byte_size);

/**
 * Unpack message TLM_NETWORK_INTERFACE.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_tlm_network_interface_unpack(
    secondary_tlm_network_interface_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_tlm_network_interface_iname_0_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_tlm_network_interface_iname_1_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_tlm_network_interface_iname_2_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_tlm_network_interface_iname_3_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_tlm_network_interface_ip_address_is_in_range(uint32_t value);


void secondary_front_ammo_compression_raw_to_conversion(
    secondary_front_ammo_compression_converted_t *conversion,
    float fl,
    float fr
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_front_ammo_compression_conversion_to_raw(
    secondary_front_ammo_compression_t *raw,
    float fl,
    float fr
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_front_ammo_compression_raw_to_conversion_struct(
    secondary_front_ammo_compression_converted_t *conversion, 
    const secondary_front_ammo_compression_t *raw);


void secondary_front_ammo_compression_conversion_to_raw_struct(
    secondary_front_ammo_compression_t *raw,
    const secondary_front_ammo_compression_converted_t *conversion);


int secondary_front_ammo_compression_converted_to_string(secondary_front_ammo_compression_converted_t *message, char *buffer);

int secondary_front_ammo_compression_converted_to_string_file(secondary_front_ammo_compression_converted_t *message, FILE *buffer);

int secondary_front_ammo_compression_fields(char *buffer);

int secondary_front_ammo_compression_fields_file(FILE *buffer);

/**
 * Pack message FRONT_AMMO_COMPRESSION.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_front_ammo_compression_pack(
    uint8_t *dst_p,
    const secondary_front_ammo_compression_t *src_p,
    size_t byte_size);

/**
 * Unpack message FRONT_AMMO_COMPRESSION.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_front_ammo_compression_unpack(
    secondary_front_ammo_compression_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_front_ammo_compression_fl_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_front_ammo_compression_fl_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_front_ammo_compression_fl_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_front_ammo_compression_fr_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_front_ammo_compression_fr_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_front_ammo_compression_fr_is_in_range(uint16_t value);


void secondary_rear_ammo_compression_raw_to_conversion(
    secondary_rear_ammo_compression_converted_t *conversion,
    float rl,
    float rr
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_rear_ammo_compression_conversion_to_raw(
    secondary_rear_ammo_compression_t *raw,
    float rl,
    float rr
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_rear_ammo_compression_raw_to_conversion_struct(
    secondary_rear_ammo_compression_converted_t *conversion, 
    const secondary_rear_ammo_compression_t *raw);


void secondary_rear_ammo_compression_conversion_to_raw_struct(
    secondary_rear_ammo_compression_t *raw,
    const secondary_rear_ammo_compression_converted_t *conversion);


int secondary_rear_ammo_compression_converted_to_string(secondary_rear_ammo_compression_converted_t *message, char *buffer);

int secondary_rear_ammo_compression_converted_to_string_file(secondary_rear_ammo_compression_converted_t *message, FILE *buffer);

int secondary_rear_ammo_compression_fields(char *buffer);

int secondary_rear_ammo_compression_fields_file(FILE *buffer);

/**
 * Pack message REAR_AMMO_COMPRESSION.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_rear_ammo_compression_pack(
    uint8_t *dst_p,
    const secondary_rear_ammo_compression_t *src_p,
    size_t byte_size);

/**
 * Unpack message REAR_AMMO_COMPRESSION.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_rear_ammo_compression_unpack(
    secondary_rear_ammo_compression_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_rear_ammo_compression_rl_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_rear_ammo_compression_rl_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_rear_ammo_compression_rl_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_rear_ammo_compression_rr_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_rear_ammo_compression_rr_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_rear_ammo_compression_rr_is_in_range(uint16_t value);


void secondary_acquisinator_calibrations_offsets_raw_to_conversion(
    secondary_acquisinator_calibrations_offsets_converted_t *conversion,
    uint8_t acquisinator_id,
    float offset1,
    float offset2
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_acquisinator_calibrations_offsets_conversion_to_raw(
    secondary_acquisinator_calibrations_offsets_t *raw,
    uint8_t acquisinator_id,
    float offset1,
    float offset2
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_acquisinator_calibrations_offsets_raw_to_conversion_struct(
    secondary_acquisinator_calibrations_offsets_converted_t *conversion, 
    const secondary_acquisinator_calibrations_offsets_t *raw);


void secondary_acquisinator_calibrations_offsets_conversion_to_raw_struct(
    secondary_acquisinator_calibrations_offsets_t *raw,
    const secondary_acquisinator_calibrations_offsets_converted_t *conversion);


int secondary_acquisinator_calibrations_offsets_converted_to_string(secondary_acquisinator_calibrations_offsets_converted_t *message, char *buffer);

int secondary_acquisinator_calibrations_offsets_converted_to_string_file(secondary_acquisinator_calibrations_offsets_converted_t *message, FILE *buffer);

int secondary_acquisinator_calibrations_offsets_fields(char *buffer);

int secondary_acquisinator_calibrations_offsets_fields_file(FILE *buffer);

/**
 * Pack message ACQUISINATOR_CALIBRATIONS_OFFSETS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_acquisinator_calibrations_offsets_pack(
    uint8_t *dst_p,
    const secondary_acquisinator_calibrations_offsets_t *src_p,
    size_t byte_size);

/**
 * Unpack message ACQUISINATOR_CALIBRATIONS_OFFSETS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_acquisinator_calibrations_offsets_unpack(
    secondary_acquisinator_calibrations_offsets_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_acquisinator_calibrations_offsets_acquisinator_id_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_acquisinator_calibrations_offsets_offset1_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_acquisinator_calibrations_offsets_offset1_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_acquisinator_calibrations_offsets_offset1_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t secondary_acquisinator_calibrations_offsets_offset2_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_acquisinator_calibrations_offsets_offset2_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_acquisinator_calibrations_offsets_offset2_is_in_range(uint32_t value);


void secondary_acquisinator_errors_raw_to_conversion(
    secondary_acquisinator_errors_converted_t *conversion,
    uint8_t acquisinator_id,
    uint8_t acquisinator_errors_acquisinatore_led_code_can_not_working,
    uint8_t acquisinator_errors_acquisinatore_led_code_spi_error,
    uint8_t acquisinator_errors_acquisinatore_led_code_read_write_flash,
    uint8_t acquisinator_errors_acquisinatore_led_code_flashed_firmware_with_wrong_id
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_acquisinator_errors_conversion_to_raw(
    secondary_acquisinator_errors_t *raw,
    uint8_t acquisinator_id,
    uint8_t acquisinator_errors_acquisinatore_led_code_can_not_working,
    uint8_t acquisinator_errors_acquisinatore_led_code_spi_error,
    uint8_t acquisinator_errors_acquisinatore_led_code_read_write_flash,
    uint8_t acquisinator_errors_acquisinatore_led_code_flashed_firmware_with_wrong_id
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_acquisinator_errors_raw_to_conversion_struct(
    secondary_acquisinator_errors_converted_t *conversion, 
    const secondary_acquisinator_errors_t *raw);


void secondary_acquisinator_errors_conversion_to_raw_struct(
    secondary_acquisinator_errors_t *raw,
    const secondary_acquisinator_errors_converted_t *conversion);


int secondary_acquisinator_errors_to_string(secondary_acquisinator_errors_t *message, char *buffer);

int secondary_acquisinator_errors_to_string_file(secondary_acquisinator_errors_t *message, FILE *buffer);

int secondary_acquisinator_errors_fields(char *buffer);

int secondary_acquisinator_errors_fields_file(FILE *buffer);

/**
 * Pack message ACQUISINATOR_ERRORS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_acquisinator_errors_pack(
    uint8_t *dst_p,
    const secondary_acquisinator_errors_t *src_p,
    size_t byte_size);

/**
 * Unpack message ACQUISINATOR_ERRORS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_acquisinator_errors_unpack(
    secondary_acquisinator_errors_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_acquisinator_errors_acquisinator_id_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_acquisinator_errors_acquisinator_errors_acquisinatore_led_code_can_not_working_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_acquisinator_errors_acquisinator_errors_acquisinatore_led_code_spi_error_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_acquisinator_errors_acquisinator_errors_acquisinatore_led_code_read_write_flash_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_acquisinator_errors_acquisinator_errors_acquisinatore_led_code_flashed_firmware_with_wrong_id_is_in_range(uint8_t value);


void secondary_link_deformation_debug_voltages_raw_to_conversion(
    secondary_link_deformation_debug_voltages_converted_t *conversion,
    secondary_link_deformation_debug_voltages_wheel_id wheel_id,
    secondary_link_deformation_debug_voltages_rod_id rod_id,
    float raw_voltage
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_link_deformation_debug_voltages_conversion_to_raw(
    secondary_link_deformation_debug_voltages_t *raw,
    secondary_link_deformation_debug_voltages_wheel_id wheel_id,
    secondary_link_deformation_debug_voltages_rod_id rod_id,
    float raw_voltage
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_link_deformation_debug_voltages_raw_to_conversion_struct(
    secondary_link_deformation_debug_voltages_converted_t *conversion, 
    const secondary_link_deformation_debug_voltages_t *raw);


void secondary_link_deformation_debug_voltages_conversion_to_raw_struct(
    secondary_link_deformation_debug_voltages_t *raw,
    const secondary_link_deformation_debug_voltages_converted_t *conversion);

int secondary_link_deformation_debug_voltages_wheel_id_enum_to_string(secondary_link_deformation_debug_voltages_wheel_id value, char *buffer);
int secondary_link_deformation_debug_voltages_rod_id_enum_to_string(secondary_link_deformation_debug_voltages_rod_id value, char *buffer);

int secondary_link_deformation_debug_voltages_converted_to_string(secondary_link_deformation_debug_voltages_converted_t *message, char *buffer);

int secondary_link_deformation_debug_voltages_converted_to_string_file(secondary_link_deformation_debug_voltages_converted_t *message, FILE *buffer);

int secondary_link_deformation_debug_voltages_fields(char *buffer);

int secondary_link_deformation_debug_voltages_fields_file(FILE *buffer);

/**
 * Pack message LINK_DEFORMATION_DEBUG_VOLTAGES.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_link_deformation_debug_voltages_pack(
    uint8_t *dst_p,
    const secondary_link_deformation_debug_voltages_t *src_p,
    size_t byte_size);

/**
 * Unpack message LINK_DEFORMATION_DEBUG_VOLTAGES.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_link_deformation_debug_voltages_unpack(
    secondary_link_deformation_debug_voltages_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_link_deformation_debug_voltages_wheel_id_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_link_deformation_debug_voltages_rod_id_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t secondary_link_deformation_debug_voltages_raw_voltage_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_link_deformation_debug_voltages_raw_voltage_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_link_deformation_debug_voltages_raw_voltage_is_in_range(uint32_t value);


void secondary_link_deformation_fl_wheel_raw_to_conversion(
    secondary_link_deformation_fl_wheel_converted_t *conversion,
    secondary_link_deformation_fl_wheel_rod_id rod_id,
    float deformation
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_link_deformation_fl_wheel_conversion_to_raw(
    secondary_link_deformation_fl_wheel_t *raw,
    secondary_link_deformation_fl_wheel_rod_id rod_id,
    float deformation
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_link_deformation_fl_wheel_raw_to_conversion_struct(
    secondary_link_deformation_fl_wheel_converted_t *conversion, 
    const secondary_link_deformation_fl_wheel_t *raw);


void secondary_link_deformation_fl_wheel_conversion_to_raw_struct(
    secondary_link_deformation_fl_wheel_t *raw,
    const secondary_link_deformation_fl_wheel_converted_t *conversion);

int secondary_link_deformation_fl_wheel_rod_id_enum_to_string(secondary_link_deformation_fl_wheel_rod_id value, char *buffer);

int secondary_link_deformation_fl_wheel_converted_to_string(secondary_link_deformation_fl_wheel_converted_t *message, char *buffer);

int secondary_link_deformation_fl_wheel_converted_to_string_file(secondary_link_deformation_fl_wheel_converted_t *message, FILE *buffer);

int secondary_link_deformation_fl_wheel_fields(char *buffer);

int secondary_link_deformation_fl_wheel_fields_file(FILE *buffer);

/**
 * Pack message LINK_DEFORMATION_FL_WHEEL.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_link_deformation_fl_wheel_pack(
    uint8_t *dst_p,
    const secondary_link_deformation_fl_wheel_t *src_p,
    size_t byte_size);

/**
 * Unpack message LINK_DEFORMATION_FL_WHEEL.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_link_deformation_fl_wheel_unpack(
    secondary_link_deformation_fl_wheel_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_link_deformation_fl_wheel_rod_id_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t secondary_link_deformation_fl_wheel_deformation_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_link_deformation_fl_wheel_deformation_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_link_deformation_fl_wheel_deformation_is_in_range(uint32_t value);


void secondary_link_deformation_fr_wheel_raw_to_conversion(
    secondary_link_deformation_fr_wheel_converted_t *conversion,
    secondary_link_deformation_fr_wheel_rod_id rod_id,
    float deformation
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_link_deformation_fr_wheel_conversion_to_raw(
    secondary_link_deformation_fr_wheel_t *raw,
    secondary_link_deformation_fr_wheel_rod_id rod_id,
    float deformation
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_link_deformation_fr_wheel_raw_to_conversion_struct(
    secondary_link_deformation_fr_wheel_converted_t *conversion, 
    const secondary_link_deformation_fr_wheel_t *raw);


void secondary_link_deformation_fr_wheel_conversion_to_raw_struct(
    secondary_link_deformation_fr_wheel_t *raw,
    const secondary_link_deformation_fr_wheel_converted_t *conversion);

int secondary_link_deformation_fr_wheel_rod_id_enum_to_string(secondary_link_deformation_fr_wheel_rod_id value, char *buffer);

int secondary_link_deformation_fr_wheel_converted_to_string(secondary_link_deformation_fr_wheel_converted_t *message, char *buffer);

int secondary_link_deformation_fr_wheel_converted_to_string_file(secondary_link_deformation_fr_wheel_converted_t *message, FILE *buffer);

int secondary_link_deformation_fr_wheel_fields(char *buffer);

int secondary_link_deformation_fr_wheel_fields_file(FILE *buffer);

/**
 * Pack message LINK_DEFORMATION_FR_WHEEL.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_link_deformation_fr_wheel_pack(
    uint8_t *dst_p,
    const secondary_link_deformation_fr_wheel_t *src_p,
    size_t byte_size);

/**
 * Unpack message LINK_DEFORMATION_FR_WHEEL.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_link_deformation_fr_wheel_unpack(
    secondary_link_deformation_fr_wheel_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_link_deformation_fr_wheel_rod_id_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t secondary_link_deformation_fr_wheel_deformation_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_link_deformation_fr_wheel_deformation_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_link_deformation_fr_wheel_deformation_is_in_range(uint32_t value);


void secondary_link_deformation_rl_wheel_raw_to_conversion(
    secondary_link_deformation_rl_wheel_converted_t *conversion,
    secondary_link_deformation_rl_wheel_rod_id rod_id,
    float deformation
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_link_deformation_rl_wheel_conversion_to_raw(
    secondary_link_deformation_rl_wheel_t *raw,
    secondary_link_deformation_rl_wheel_rod_id rod_id,
    float deformation
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_link_deformation_rl_wheel_raw_to_conversion_struct(
    secondary_link_deformation_rl_wheel_converted_t *conversion, 
    const secondary_link_deformation_rl_wheel_t *raw);


void secondary_link_deformation_rl_wheel_conversion_to_raw_struct(
    secondary_link_deformation_rl_wheel_t *raw,
    const secondary_link_deformation_rl_wheel_converted_t *conversion);

int secondary_link_deformation_rl_wheel_rod_id_enum_to_string(secondary_link_deformation_rl_wheel_rod_id value, char *buffer);

int secondary_link_deformation_rl_wheel_converted_to_string(secondary_link_deformation_rl_wheel_converted_t *message, char *buffer);

int secondary_link_deformation_rl_wheel_converted_to_string_file(secondary_link_deformation_rl_wheel_converted_t *message, FILE *buffer);

int secondary_link_deformation_rl_wheel_fields(char *buffer);

int secondary_link_deformation_rl_wheel_fields_file(FILE *buffer);

/**
 * Pack message LINK_DEFORMATION_RL_WHEEL.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_link_deformation_rl_wheel_pack(
    uint8_t *dst_p,
    const secondary_link_deformation_rl_wheel_t *src_p,
    size_t byte_size);

/**
 * Unpack message LINK_DEFORMATION_RL_WHEEL.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_link_deformation_rl_wheel_unpack(
    secondary_link_deformation_rl_wheel_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_link_deformation_rl_wheel_rod_id_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t secondary_link_deformation_rl_wheel_deformation_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_link_deformation_rl_wheel_deformation_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_link_deformation_rl_wheel_deformation_is_in_range(uint32_t value);


void secondary_link_deformation_rr_wheel_raw_to_conversion(
    secondary_link_deformation_rr_wheel_converted_t *conversion,
    secondary_link_deformation_rr_wheel_rod_id rod_id,
    float deformation
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_link_deformation_rr_wheel_conversion_to_raw(
    secondary_link_deformation_rr_wheel_t *raw,
    secondary_link_deformation_rr_wheel_rod_id rod_id,
    float deformation
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_link_deformation_rr_wheel_raw_to_conversion_struct(
    secondary_link_deformation_rr_wheel_converted_t *conversion, 
    const secondary_link_deformation_rr_wheel_t *raw);


void secondary_link_deformation_rr_wheel_conversion_to_raw_struct(
    secondary_link_deformation_rr_wheel_t *raw,
    const secondary_link_deformation_rr_wheel_converted_t *conversion);

int secondary_link_deformation_rr_wheel_rod_id_enum_to_string(secondary_link_deformation_rr_wheel_rod_id value, char *buffer);

int secondary_link_deformation_rr_wheel_converted_to_string(secondary_link_deformation_rr_wheel_converted_t *message, char *buffer);

int secondary_link_deformation_rr_wheel_converted_to_string_file(secondary_link_deformation_rr_wheel_converted_t *message, FILE *buffer);

int secondary_link_deformation_rr_wheel_fields(char *buffer);

int secondary_link_deformation_rr_wheel_fields_file(FILE *buffer);

/**
 * Pack message LINK_DEFORMATION_RR_WHEEL.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_link_deformation_rr_wheel_pack(
    uint8_t *dst_p,
    const secondary_link_deformation_rr_wheel_t *src_p,
    size_t byte_size);

/**
 * Unpack message LINK_DEFORMATION_RR_WHEEL.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_link_deformation_rr_wheel_unpack(
    secondary_link_deformation_rr_wheel_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_link_deformation_rr_wheel_rod_id_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t secondary_link_deformation_rr_wheel_deformation_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_link_deformation_rr_wheel_deformation_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_link_deformation_rr_wheel_deformation_is_in_range(uint32_t value);


;


;


void secondary_link_deformation_set_calibration_raw_to_conversion_struct(
    secondary_link_deformation_set_calibration_converted_t *conversion, 
    const secondary_link_deformation_set_calibration_t *raw);


void secondary_link_deformation_set_calibration_conversion_to_raw_struct(
    secondary_link_deformation_set_calibration_t *raw,
    const secondary_link_deformation_set_calibration_converted_t *conversion);


int secondary_link_deformation_set_calibration_to_string(secondary_link_deformation_set_calibration_t *message, char *buffer);

int secondary_link_deformation_set_calibration_to_string_file(secondary_link_deformation_set_calibration_t *message, FILE *buffer);

int secondary_link_deformation_set_calibration_fields(char *buffer);

int secondary_link_deformation_set_calibration_fields_file(FILE *buffer);

/**
 * Pack message LINK_DEFORMATION_SET_CALIBRATION.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_link_deformation_set_calibration_pack(
    uint8_t *dst_p,
    const secondary_link_deformation_set_calibration_t *src_p,
    size_t byte_size);

/**
 * Unpack message LINK_DEFORMATION_SET_CALIBRATION.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_link_deformation_set_calibration_unpack(
    secondary_link_deformation_set_calibration_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void secondary_ammo_compression_set_calibration_raw_to_conversion_struct(
    secondary_ammo_compression_set_calibration_converted_t *conversion, 
    const secondary_ammo_compression_set_calibration_t *raw);


void secondary_ammo_compression_set_calibration_conversion_to_raw_struct(
    secondary_ammo_compression_set_calibration_t *raw,
    const secondary_ammo_compression_set_calibration_converted_t *conversion);


int secondary_ammo_compression_set_calibration_to_string(secondary_ammo_compression_set_calibration_t *message, char *buffer);

int secondary_ammo_compression_set_calibration_to_string_file(secondary_ammo_compression_set_calibration_t *message, FILE *buffer);

int secondary_ammo_compression_set_calibration_fields(char *buffer);

int secondary_ammo_compression_set_calibration_fields_file(FILE *buffer);

/**
 * Pack message AMMO_COMPRESSION_SET_CALIBRATION.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_ammo_compression_set_calibration_pack(
    uint8_t *dst_p,
    const secondary_ammo_compression_set_calibration_t *src_p,
    size_t byte_size);

/**
 * Unpack message AMMO_COMPRESSION_SET_CALIBRATION.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_ammo_compression_set_calibration_unpack(
    secondary_ammo_compression_set_calibration_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


void secondary_debug_signal_5_raw_to_conversion(
    secondary_debug_signal_5_converted_t *conversion,
    secondary_debug_signal_5_device_id device_id,
    float field_1,
    float field_2,
    float field_3
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_debug_signal_5_conversion_to_raw(
    secondary_debug_signal_5_t *raw,
    secondary_debug_signal_5_device_id device_id,
    float field_1,
    float field_2,
    float field_3
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_debug_signal_5_raw_to_conversion_struct(
    secondary_debug_signal_5_converted_t *conversion, 
    const secondary_debug_signal_5_t *raw);


void secondary_debug_signal_5_conversion_to_raw_struct(
    secondary_debug_signal_5_t *raw,
    const secondary_debug_signal_5_converted_t *conversion);

int secondary_debug_signal_5_device_id_enum_to_string(secondary_debug_signal_5_device_id value, char *buffer);

int secondary_debug_signal_5_converted_to_string(secondary_debug_signal_5_converted_t *message, char *buffer);

int secondary_debug_signal_5_converted_to_string_file(secondary_debug_signal_5_converted_t *message, FILE *buffer);

int secondary_debug_signal_5_fields(char *buffer);

int secondary_debug_signal_5_fields_file(FILE *buffer);

/**
 * Pack message DEBUG_SIGNAL_5.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_debug_signal_5_pack(
    uint8_t *dst_p,
    const secondary_debug_signal_5_t *src_p,
    size_t byte_size);

/**
 * Unpack message DEBUG_SIGNAL_5.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_debug_signal_5_unpack(
    secondary_debug_signal_5_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_debug_signal_5_device_id_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_debug_signal_5_field_1_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_debug_signal_5_field_1_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_debug_signal_5_field_1_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_debug_signal_5_field_2_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_debug_signal_5_field_2_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_debug_signal_5_field_2_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_debug_signal_5_field_3_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_debug_signal_5_field_3_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_debug_signal_5_field_3_is_in_range(uint16_t value);


void secondary_debug_signal_6_raw_to_conversion(
    secondary_debug_signal_6_converted_t *conversion,
    secondary_debug_signal_6_device_id device_id,
    float field_1,
    float field_2,
    float field_3
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_debug_signal_6_conversion_to_raw(
    secondary_debug_signal_6_t *raw,
    secondary_debug_signal_6_device_id device_id,
    float field_1,
    float field_2,
    float field_3
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_debug_signal_6_raw_to_conversion_struct(
    secondary_debug_signal_6_converted_t *conversion, 
    const secondary_debug_signal_6_t *raw);


void secondary_debug_signal_6_conversion_to_raw_struct(
    secondary_debug_signal_6_t *raw,
    const secondary_debug_signal_6_converted_t *conversion);

int secondary_debug_signal_6_device_id_enum_to_string(secondary_debug_signal_6_device_id value, char *buffer);

int secondary_debug_signal_6_converted_to_string(secondary_debug_signal_6_converted_t *message, char *buffer);

int secondary_debug_signal_6_converted_to_string_file(secondary_debug_signal_6_converted_t *message, FILE *buffer);

int secondary_debug_signal_6_fields(char *buffer);

int secondary_debug_signal_6_fields_file(FILE *buffer);

/**
 * Pack message DEBUG_SIGNAL_6.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_debug_signal_6_pack(
    uint8_t *dst_p,
    const secondary_debug_signal_6_t *src_p,
    size_t byte_size);

/**
 * Unpack message DEBUG_SIGNAL_6.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_debug_signal_6_unpack(
    secondary_debug_signal_6_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_debug_signal_6_device_id_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_debug_signal_6_field_1_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_debug_signal_6_field_1_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_debug_signal_6_field_1_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_debug_signal_6_field_2_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_debug_signal_6_field_2_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_debug_signal_6_field_2_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_debug_signal_6_field_3_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_debug_signal_6_field_3_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_debug_signal_6_field_3_is_in_range(uint16_t value);


void secondary_debug_signal_7_raw_to_conversion(
    secondary_debug_signal_7_converted_t *conversion,
    secondary_debug_signal_7_device_id device_id,
    float field_1,
    float field_2,
    float field_3
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_debug_signal_7_conversion_to_raw(
    secondary_debug_signal_7_t *raw,
    secondary_debug_signal_7_device_id device_id,
    float field_1,
    float field_2,
    float field_3
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_debug_signal_7_raw_to_conversion_struct(
    secondary_debug_signal_7_converted_t *conversion, 
    const secondary_debug_signal_7_t *raw);


void secondary_debug_signal_7_conversion_to_raw_struct(
    secondary_debug_signal_7_t *raw,
    const secondary_debug_signal_7_converted_t *conversion);

int secondary_debug_signal_7_device_id_enum_to_string(secondary_debug_signal_7_device_id value, char *buffer);

int secondary_debug_signal_7_converted_to_string(secondary_debug_signal_7_converted_t *message, char *buffer);

int secondary_debug_signal_7_converted_to_string_file(secondary_debug_signal_7_converted_t *message, FILE *buffer);

int secondary_debug_signal_7_fields(char *buffer);

int secondary_debug_signal_7_fields_file(FILE *buffer);

/**
 * Pack message DEBUG_SIGNAL_7.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_debug_signal_7_pack(
    uint8_t *dst_p,
    const secondary_debug_signal_7_t *src_p,
    size_t byte_size);

/**
 * Unpack message DEBUG_SIGNAL_7.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_debug_signal_7_unpack(
    secondary_debug_signal_7_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_debug_signal_7_device_id_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_debug_signal_7_field_1_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_debug_signal_7_field_1_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_debug_signal_7_field_1_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_debug_signal_7_field_2_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_debug_signal_7_field_2_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_debug_signal_7_field_2_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_debug_signal_7_field_3_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_debug_signal_7_field_3_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_debug_signal_7_field_3_is_in_range(uint16_t value);


void secondary_debug_signal_8_raw_to_conversion(
    secondary_debug_signal_8_converted_t *conversion,
    secondary_debug_signal_8_device_id device_id,
    float field_1,
    float field_2,
    float field_3
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_debug_signal_8_conversion_to_raw(
    secondary_debug_signal_8_t *raw,
    secondary_debug_signal_8_device_id device_id,
    float field_1,
    float field_2,
    float field_3
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_debug_signal_8_raw_to_conversion_struct(
    secondary_debug_signal_8_converted_t *conversion, 
    const secondary_debug_signal_8_t *raw);


void secondary_debug_signal_8_conversion_to_raw_struct(
    secondary_debug_signal_8_t *raw,
    const secondary_debug_signal_8_converted_t *conversion);

int secondary_debug_signal_8_device_id_enum_to_string(secondary_debug_signal_8_device_id value, char *buffer);

int secondary_debug_signal_8_converted_to_string(secondary_debug_signal_8_converted_t *message, char *buffer);

int secondary_debug_signal_8_converted_to_string_file(secondary_debug_signal_8_converted_t *message, FILE *buffer);

int secondary_debug_signal_8_fields(char *buffer);

int secondary_debug_signal_8_fields_file(FILE *buffer);

/**
 * Pack message DEBUG_SIGNAL_8.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_debug_signal_8_pack(
    uint8_t *dst_p,
    const secondary_debug_signal_8_t *src_p,
    size_t byte_size);

/**
 * Unpack message DEBUG_SIGNAL_8.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_debug_signal_8_unpack(
    secondary_debug_signal_8_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_debug_signal_8_device_id_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_debug_signal_8_field_1_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_debug_signal_8_field_1_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_debug_signal_8_field_1_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_debug_signal_8_field_2_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_debug_signal_8_field_2_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_debug_signal_8_field_2_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_debug_signal_8_field_3_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_debug_signal_8_field_3_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_debug_signal_8_field_3_is_in_range(uint16_t value);


void secondary_cooling_temp_pumps_raw_to_conversion(
    secondary_cooling_temp_pumps_converted_t *conversion,
    float input,
    float output
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_cooling_temp_pumps_conversion_to_raw(
    secondary_cooling_temp_pumps_t *raw,
    float input,
    float output
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_cooling_temp_pumps_raw_to_conversion_struct(
    secondary_cooling_temp_pumps_converted_t *conversion, 
    const secondary_cooling_temp_pumps_t *raw);


void secondary_cooling_temp_pumps_conversion_to_raw_struct(
    secondary_cooling_temp_pumps_t *raw,
    const secondary_cooling_temp_pumps_converted_t *conversion);


int secondary_cooling_temp_pumps_converted_to_string(secondary_cooling_temp_pumps_converted_t *message, char *buffer);

int secondary_cooling_temp_pumps_converted_to_string_file(secondary_cooling_temp_pumps_converted_t *message, FILE *buffer);

int secondary_cooling_temp_pumps_fields(char *buffer);

int secondary_cooling_temp_pumps_fields_file(FILE *buffer);

/**
 * Pack message COOLING_TEMP_PUMPS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_cooling_temp_pumps_pack(
    uint8_t *dst_p,
    const secondary_cooling_temp_pumps_t *src_p,
    size_t byte_size);

/**
 * Unpack message COOLING_TEMP_PUMPS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_cooling_temp_pumps_unpack(
    secondary_cooling_temp_pumps_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_cooling_temp_pumps_input_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_cooling_temp_pumps_input_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_cooling_temp_pumps_input_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_cooling_temp_pumps_output_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_cooling_temp_pumps_output_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_cooling_temp_pumps_output_is_in_range(uint16_t value);


void secondary_cooling_temp_radiators_raw_to_conversion(
    secondary_cooling_temp_radiators_converted_t *conversion,
    float air_temp
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_cooling_temp_radiators_conversion_to_raw(
    secondary_cooling_temp_radiators_t *raw,
    float air_temp
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_cooling_temp_radiators_raw_to_conversion_struct(
    secondary_cooling_temp_radiators_converted_t *conversion, 
    const secondary_cooling_temp_radiators_t *raw);


void secondary_cooling_temp_radiators_conversion_to_raw_struct(
    secondary_cooling_temp_radiators_t *raw,
    const secondary_cooling_temp_radiators_converted_t *conversion);


int secondary_cooling_temp_radiators_converted_to_string(secondary_cooling_temp_radiators_converted_t *message, char *buffer);

int secondary_cooling_temp_radiators_converted_to_string_file(secondary_cooling_temp_radiators_converted_t *message, FILE *buffer);

int secondary_cooling_temp_radiators_fields(char *buffer);

int secondary_cooling_temp_radiators_fields_file(FILE *buffer);

/**
 * Pack message COOLING_TEMP_RADIATORS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_cooling_temp_radiators_pack(
    uint8_t *dst_p,
    const secondary_cooling_temp_radiators_t *src_p,
    size_t byte_size);

/**
 * Unpack message COOLING_TEMP_RADIATORS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_cooling_temp_radiators_unpack(
    secondary_cooling_temp_radiators_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_cooling_temp_radiators_air_temp_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_cooling_temp_radiators_air_temp_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_cooling_temp_radiators_air_temp_is_in_range(uint16_t value);


void secondary_lateral_controller_preview_point_errors_raw_to_conversion(
    secondary_lateral_controller_preview_point_errors_converted_t *conversion,
    float heading,
    float distance
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_lateral_controller_preview_point_errors_conversion_to_raw(
    secondary_lateral_controller_preview_point_errors_t *raw,
    float heading,
    float distance
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_lateral_controller_preview_point_errors_raw_to_conversion_struct(
    secondary_lateral_controller_preview_point_errors_converted_t *conversion, 
    const secondary_lateral_controller_preview_point_errors_t *raw);


void secondary_lateral_controller_preview_point_errors_conversion_to_raw_struct(
    secondary_lateral_controller_preview_point_errors_t *raw,
    const secondary_lateral_controller_preview_point_errors_converted_t *conversion);


int secondary_lateral_controller_preview_point_errors_converted_to_string(secondary_lateral_controller_preview_point_errors_converted_t *message, char *buffer);

int secondary_lateral_controller_preview_point_errors_converted_to_string_file(secondary_lateral_controller_preview_point_errors_converted_t *message, FILE *buffer);

int secondary_lateral_controller_preview_point_errors_fields(char *buffer);

int secondary_lateral_controller_preview_point_errors_fields_file(FILE *buffer);

/**
 * Pack message LATERAL_CONTROLLER_PREVIEW_POINT_ERRORS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_lateral_controller_preview_point_errors_pack(
    uint8_t *dst_p,
    const secondary_lateral_controller_preview_point_errors_t *src_p,
    size_t byte_size);

/**
 * Unpack message LATERAL_CONTROLLER_PREVIEW_POINT_ERRORS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_lateral_controller_preview_point_errors_unpack(
    secondary_lateral_controller_preview_point_errors_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_lateral_controller_preview_point_errors_heading_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_lateral_controller_preview_point_errors_heading_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_lateral_controller_preview_point_errors_heading_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_lateral_controller_preview_point_errors_distance_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_lateral_controller_preview_point_errors_distance_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_lateral_controller_preview_point_errors_distance_is_in_range(uint16_t value);


void secondary_lateral_controller_errors_raw_to_conversion(
    secondary_lateral_controller_errors_converted_t *conversion,
    float com_distance
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_lateral_controller_errors_conversion_to_raw(
    secondary_lateral_controller_errors_t *raw,
    float com_distance
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_lateral_controller_errors_raw_to_conversion_struct(
    secondary_lateral_controller_errors_converted_t *conversion, 
    const secondary_lateral_controller_errors_t *raw);


void secondary_lateral_controller_errors_conversion_to_raw_struct(
    secondary_lateral_controller_errors_t *raw,
    const secondary_lateral_controller_errors_converted_t *conversion);


int secondary_lateral_controller_errors_converted_to_string(secondary_lateral_controller_errors_converted_t *message, char *buffer);

int secondary_lateral_controller_errors_converted_to_string_file(secondary_lateral_controller_errors_converted_t *message, FILE *buffer);

int secondary_lateral_controller_errors_fields(char *buffer);

int secondary_lateral_controller_errors_fields_file(FILE *buffer);

/**
 * Pack message LATERAL_CONTROLLER_ERRORS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_lateral_controller_errors_pack(
    uint8_t *dst_p,
    const secondary_lateral_controller_errors_t *src_p,
    size_t byte_size);

/**
 * Unpack message LATERAL_CONTROLLER_ERRORS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_lateral_controller_errors_unpack(
    secondary_lateral_controller_errors_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_lateral_controller_errors_com_distance_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_lateral_controller_errors_com_distance_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_lateral_controller_errors_com_distance_is_in_range(uint16_t value);

bool secondary_id_is_message(uint16_t id);

int secondary_to_string_from_id(uint16_t message_id, void* message, char* buffer);
int secondary_fields_from_id(uint16_t message_id, char* buffer);
int secondary_to_string_file_from_id(uint16_t message_id, void* message, FILE* buffer);
int secondary_fields_file_from_id(uint16_t message_id, FILE* buffer);


typedef union CANLIB_PARKING {
    secondary_acquisinator_jmp_to_blt_t _acquisinator_jmp_to_blt;
    secondary_acquisinator_flash_0_tx_t _acquisinator_flash_0_tx;
    secondary_acquisinator_flash_0_rx_t _acquisinator_flash_0_rx;
    secondary_acquisinator_flash_1_tx_t _acquisinator_flash_1_tx;
    secondary_acquisinator_flash_1_rx_t _acquisinator_flash_1_rx;
    secondary_acquisinator_flash_2_tx_t _acquisinator_flash_2_tx;
    secondary_acquisinator_flash_2_rx_t _acquisinator_flash_2_rx;
    secondary_acquisinator_flash_3_tx_t _acquisinator_flash_3_tx;
    secondary_acquisinator_flash_3_rx_t _acquisinator_flash_3_rx;
    secondary_acquisinator_flash_4_tx_t _acquisinator_flash_4_tx;
    secondary_acquisinator_flash_4_rx_t _acquisinator_flash_4_rx;
    secondary_acquisinator_flash_5_tx_t _acquisinator_flash_5_tx;
    secondary_acquisinator_flash_5_rx_t _acquisinator_flash_5_rx;
    secondary_acquisinator_flash_6_tx_t _acquisinator_flash_6_tx;
    secondary_acquisinator_flash_6_rx_t _acquisinator_flash_6_rx;
    secondary_acquisinator_flash_7_tx_t _acquisinator_flash_7_tx;
    secondary_acquisinator_flash_7_rx_t _acquisinator_flash_7_rx;
    secondary_acquisinator_flash_8_tx_t _acquisinator_flash_8_tx;
    secondary_acquisinator_flash_8_rx_t _acquisinator_flash_8_rx;
    secondary_acquisinator_flash_9_tx_t _acquisinator_flash_9_tx;
    secondary_acquisinator_flash_9_rx_t _acquisinator_flash_9_rx;
    secondary_acquisinator_flash_10_tx_t _acquisinator_flash_10_tx;
    secondary_acquisinator_flash_10_rx_t _acquisinator_flash_10_rx;
    secondary_acquisinator_flash_11_tx_t _acquisinator_flash_11_tx;
    secondary_acquisinator_flash_11_rx_t _acquisinator_flash_11_rx;
    secondary_acquisinator_flash_12_tx_t _acquisinator_flash_12_tx;
    secondary_acquisinator_flash_12_rx_t _acquisinator_flash_12_rx;
    secondary_acquisinator_flash_13_tx_t _acquisinator_flash_13_tx;
    secondary_acquisinator_flash_13_rx_t _acquisinator_flash_13_rx;
    secondary_acquisinator_flash_14_tx_t _acquisinator_flash_14_tx;
    secondary_acquisinator_flash_14_rx_t _acquisinator_flash_14_rx;
    secondary_acquisinator_flash_15_tx_t _acquisinator_flash_15_tx;
    secondary_acquisinator_flash_15_rx_t _acquisinator_flash_15_rx;
    secondary_acquisinator_flash_16_tx_t _acquisinator_flash_16_tx;
    secondary_acquisinator_flash_16_rx_t _acquisinator_flash_16_rx;
    secondary_acquisinator_flash_17_tx_t _acquisinator_flash_17_tx;
    secondary_acquisinator_flash_17_rx_t _acquisinator_flash_17_rx;
    secondary_acquisinator_flash_18_tx_t _acquisinator_flash_18_tx;
    secondary_acquisinator_flash_18_rx_t _acquisinator_flash_18_rx;
    secondary_acquisinator_flash_19_tx_t _acquisinator_flash_19_tx;
    secondary_acquisinator_flash_19_rx_t _acquisinator_flash_19_rx;
    secondary_acquisinator_flash_20_tx_t _acquisinator_flash_20_tx;
    secondary_acquisinator_flash_20_rx_t _acquisinator_flash_20_rx;
    secondary_acquisinator_flash_21_tx_t _acquisinator_flash_21_tx;
    secondary_acquisinator_flash_21_rx_t _acquisinator_flash_21_rx;
    secondary_acquisinator_flash_22_tx_t _acquisinator_flash_22_tx;
    secondary_acquisinator_flash_22_rx_t _acquisinator_flash_22_rx;
    secondary_acquisinator_flash_23_tx_t _acquisinator_flash_23_tx;
    secondary_acquisinator_flash_23_rx_t _acquisinator_flash_23_rx;
    secondary_acquisinator_flash_24_tx_t _acquisinator_flash_24_tx;
    secondary_acquisinator_flash_24_rx_t _acquisinator_flash_24_rx;
    secondary_acquisinator_flash_25_tx_t _acquisinator_flash_25_tx;
    secondary_acquisinator_flash_25_rx_t _acquisinator_flash_25_rx;
    secondary_acquisinator_flash_26_tx_t _acquisinator_flash_26_tx;
    secondary_acquisinator_flash_26_rx_t _acquisinator_flash_26_rx;
    secondary_acquisinator_flash_27_tx_t _acquisinator_flash_27_tx;
    secondary_acquisinator_flash_27_rx_t _acquisinator_flash_27_rx;
    secondary_acquisinator_flash_28_tx_t _acquisinator_flash_28_tx;
    secondary_acquisinator_flash_28_rx_t _acquisinator_flash_28_rx;
    secondary_acquisinator_flash_29_tx_t _acquisinator_flash_29_tx;
    secondary_acquisinator_flash_29_rx_t _acquisinator_flash_29_rx;
    secondary_acquisinator_flash_30_tx_t _acquisinator_flash_30_tx;
    secondary_acquisinator_flash_30_rx_t _acquisinator_flash_30_rx;
    secondary_acquisinator_flash_31_tx_t _acquisinator_flash_31_tx;
    secondary_acquisinator_flash_31_rx_t _acquisinator_flash_31_rx;
    secondary_acquisinator_version_t _acquisinator_version;
    secondary_imu_angular_rate_t _imu_angular_rate;
    secondary_imu_acceleration_t _imu_acceleration;
    secondary_irts_fl_0_t _irts_fl_0;
    secondary_irts_fl_1_t _irts_fl_1;
    secondary_irts_fl_2_t _irts_fl_2;
    secondary_irts_fl_3_t _irts_fl_3;
    secondary_irts_fr_0_t _irts_fr_0;
    secondary_irts_fr_1_t _irts_fr_1;
    secondary_irts_fr_2_t _irts_fr_2;
    secondary_irts_fr_3_t _irts_fr_3;
    secondary_irts_rl_0_t _irts_rl_0;
    secondary_irts_rl_1_t _irts_rl_1;
    secondary_irts_rl_2_t _irts_rl_2;
    secondary_irts_rl_3_t _irts_rl_3;
    secondary_irts_rr_0_t _irts_rr_0;
    secondary_irts_rr_1_t _irts_rr_1;
    secondary_irts_rr_2_t _irts_rr_2;
    secondary_irts_rr_3_t _irts_rr_3;
    secondary_vehicle_position_t _vehicle_position;
    secondary_vehicle_speed_t _vehicle_speed;
    secondary_vehicle_curvilinear_coordinates_t _vehicle_curvilinear_coordinates;
    secondary_front_angular_velocity_t _front_angular_velocity;
    secondary_rear_angular_velocity_t _rear_angular_velocity;
    secondary_hv_soc_estimation_state_t _hv_soc_estimation_state;
    secondary_hv_soc_estimation_covariance_t _hv_soc_estimation_covariance;
    secondary_lv_soc_estimation_state_t _lv_soc_estimation_state;
    secondary_lv_soc_estimation_covariance_t _lv_soc_estimation_covariance;
    secondary_pedal_throttle_t _pedal_throttle;
    secondary_pedal_brakes_pressure_t _pedal_brakes_pressure;
    secondary_steer_angle_t _steer_angle;
    secondary_odometer_t _odometer;
    secondary_tpms_pressure_t _tpms_pressure;
    secondary_tpms_temperature_t _tpms_temperature;
    secondary_tlm_unix_timestamp_t _tlm_unix_timestamp;
    secondary_tlm_lap_time_t _tlm_lap_time;
    secondary_tlm_laps_stats_t _tlm_laps_stats;
    secondary_tlm_network_interface_t _tlm_network_interface;
    secondary_front_ammo_compression_t _front_ammo_compression;
    secondary_rear_ammo_compression_t _rear_ammo_compression;
    secondary_acquisinator_calibrations_offsets_t _acquisinator_calibrations_offsets;
    secondary_acquisinator_errors_t _acquisinator_errors;
    secondary_link_deformation_debug_voltages_t _link_deformation_debug_voltages;
    secondary_link_deformation_fl_wheel_t _link_deformation_fl_wheel;
    secondary_link_deformation_fr_wheel_t _link_deformation_fr_wheel;
    secondary_link_deformation_rl_wheel_t _link_deformation_rl_wheel;
    secondary_link_deformation_rr_wheel_t _link_deformation_rr_wheel;
    secondary_link_deformation_set_calibration_t _link_deformation_set_calibration;
    secondary_ammo_compression_set_calibration_t _ammo_compression_set_calibration;
    secondary_debug_signal_5_t _debug_signal_5;
    secondary_debug_signal_6_t _debug_signal_6;
    secondary_debug_signal_7_t _debug_signal_7;
    secondary_debug_signal_8_t _debug_signal_8;
    secondary_cooling_temp_pumps_t _cooling_temp_pumps;
    secondary_cooling_temp_radiators_t _cooling_temp_radiators;
    secondary_lateral_controller_preview_point_errors_t _lateral_controller_preview_point_errors;
    secondary_lateral_controller_errors_t _lateral_controller_errors;

} _secondary_all_struct_raw;

typedef union CANLIB_PARKING {
    secondary_acquisinator_jmp_to_blt_converted_t _acquisinator_jmp_to_blt;
    secondary_acquisinator_flash_0_tx_converted_t _acquisinator_flash_0_tx;
    secondary_acquisinator_flash_0_rx_converted_t _acquisinator_flash_0_rx;
    secondary_acquisinator_flash_1_tx_converted_t _acquisinator_flash_1_tx;
    secondary_acquisinator_flash_1_rx_converted_t _acquisinator_flash_1_rx;
    secondary_acquisinator_flash_2_tx_converted_t _acquisinator_flash_2_tx;
    secondary_acquisinator_flash_2_rx_converted_t _acquisinator_flash_2_rx;
    secondary_acquisinator_flash_3_tx_converted_t _acquisinator_flash_3_tx;
    secondary_acquisinator_flash_3_rx_converted_t _acquisinator_flash_3_rx;
    secondary_acquisinator_flash_4_tx_converted_t _acquisinator_flash_4_tx;
    secondary_acquisinator_flash_4_rx_converted_t _acquisinator_flash_4_rx;
    secondary_acquisinator_flash_5_tx_converted_t _acquisinator_flash_5_tx;
    secondary_acquisinator_flash_5_rx_converted_t _acquisinator_flash_5_rx;
    secondary_acquisinator_flash_6_tx_converted_t _acquisinator_flash_6_tx;
    secondary_acquisinator_flash_6_rx_converted_t _acquisinator_flash_6_rx;
    secondary_acquisinator_flash_7_tx_converted_t _acquisinator_flash_7_tx;
    secondary_acquisinator_flash_7_rx_converted_t _acquisinator_flash_7_rx;
    secondary_acquisinator_flash_8_tx_converted_t _acquisinator_flash_8_tx;
    secondary_acquisinator_flash_8_rx_converted_t _acquisinator_flash_8_rx;
    secondary_acquisinator_flash_9_tx_converted_t _acquisinator_flash_9_tx;
    secondary_acquisinator_flash_9_rx_converted_t _acquisinator_flash_9_rx;
    secondary_acquisinator_flash_10_tx_converted_t _acquisinator_flash_10_tx;
    secondary_acquisinator_flash_10_rx_converted_t _acquisinator_flash_10_rx;
    secondary_acquisinator_flash_11_tx_converted_t _acquisinator_flash_11_tx;
    secondary_acquisinator_flash_11_rx_converted_t _acquisinator_flash_11_rx;
    secondary_acquisinator_flash_12_tx_converted_t _acquisinator_flash_12_tx;
    secondary_acquisinator_flash_12_rx_converted_t _acquisinator_flash_12_rx;
    secondary_acquisinator_flash_13_tx_converted_t _acquisinator_flash_13_tx;
    secondary_acquisinator_flash_13_rx_converted_t _acquisinator_flash_13_rx;
    secondary_acquisinator_flash_14_tx_converted_t _acquisinator_flash_14_tx;
    secondary_acquisinator_flash_14_rx_converted_t _acquisinator_flash_14_rx;
    secondary_acquisinator_flash_15_tx_converted_t _acquisinator_flash_15_tx;
    secondary_acquisinator_flash_15_rx_converted_t _acquisinator_flash_15_rx;
    secondary_acquisinator_flash_16_tx_converted_t _acquisinator_flash_16_tx;
    secondary_acquisinator_flash_16_rx_converted_t _acquisinator_flash_16_rx;
    secondary_acquisinator_flash_17_tx_converted_t _acquisinator_flash_17_tx;
    secondary_acquisinator_flash_17_rx_converted_t _acquisinator_flash_17_rx;
    secondary_acquisinator_flash_18_tx_converted_t _acquisinator_flash_18_tx;
    secondary_acquisinator_flash_18_rx_converted_t _acquisinator_flash_18_rx;
    secondary_acquisinator_flash_19_tx_converted_t _acquisinator_flash_19_tx;
    secondary_acquisinator_flash_19_rx_converted_t _acquisinator_flash_19_rx;
    secondary_acquisinator_flash_20_tx_converted_t _acquisinator_flash_20_tx;
    secondary_acquisinator_flash_20_rx_converted_t _acquisinator_flash_20_rx;
    secondary_acquisinator_flash_21_tx_converted_t _acquisinator_flash_21_tx;
    secondary_acquisinator_flash_21_rx_converted_t _acquisinator_flash_21_rx;
    secondary_acquisinator_flash_22_tx_converted_t _acquisinator_flash_22_tx;
    secondary_acquisinator_flash_22_rx_converted_t _acquisinator_flash_22_rx;
    secondary_acquisinator_flash_23_tx_converted_t _acquisinator_flash_23_tx;
    secondary_acquisinator_flash_23_rx_converted_t _acquisinator_flash_23_rx;
    secondary_acquisinator_flash_24_tx_converted_t _acquisinator_flash_24_tx;
    secondary_acquisinator_flash_24_rx_converted_t _acquisinator_flash_24_rx;
    secondary_acquisinator_flash_25_tx_converted_t _acquisinator_flash_25_tx;
    secondary_acquisinator_flash_25_rx_converted_t _acquisinator_flash_25_rx;
    secondary_acquisinator_flash_26_tx_converted_t _acquisinator_flash_26_tx;
    secondary_acquisinator_flash_26_rx_converted_t _acquisinator_flash_26_rx;
    secondary_acquisinator_flash_27_tx_converted_t _acquisinator_flash_27_tx;
    secondary_acquisinator_flash_27_rx_converted_t _acquisinator_flash_27_rx;
    secondary_acquisinator_flash_28_tx_converted_t _acquisinator_flash_28_tx;
    secondary_acquisinator_flash_28_rx_converted_t _acquisinator_flash_28_rx;
    secondary_acquisinator_flash_29_tx_converted_t _acquisinator_flash_29_tx;
    secondary_acquisinator_flash_29_rx_converted_t _acquisinator_flash_29_rx;
    secondary_acquisinator_flash_30_tx_converted_t _acquisinator_flash_30_tx;
    secondary_acquisinator_flash_30_rx_converted_t _acquisinator_flash_30_rx;
    secondary_acquisinator_flash_31_tx_converted_t _acquisinator_flash_31_tx;
    secondary_acquisinator_flash_31_rx_converted_t _acquisinator_flash_31_rx;
    secondary_acquisinator_version_converted_t _acquisinator_version;
    secondary_imu_angular_rate_converted_t _imu_angular_rate;
    secondary_imu_acceleration_converted_t _imu_acceleration;
    secondary_irts_fl_0_converted_t _irts_fl_0;
    secondary_irts_fl_1_converted_t _irts_fl_1;
    secondary_irts_fl_2_converted_t _irts_fl_2;
    secondary_irts_fl_3_converted_t _irts_fl_3;
    secondary_irts_fr_0_converted_t _irts_fr_0;
    secondary_irts_fr_1_converted_t _irts_fr_1;
    secondary_irts_fr_2_converted_t _irts_fr_2;
    secondary_irts_fr_3_converted_t _irts_fr_3;
    secondary_irts_rl_0_converted_t _irts_rl_0;
    secondary_irts_rl_1_converted_t _irts_rl_1;
    secondary_irts_rl_2_converted_t _irts_rl_2;
    secondary_irts_rl_3_converted_t _irts_rl_3;
    secondary_irts_rr_0_converted_t _irts_rr_0;
    secondary_irts_rr_1_converted_t _irts_rr_1;
    secondary_irts_rr_2_converted_t _irts_rr_2;
    secondary_irts_rr_3_converted_t _irts_rr_3;
    secondary_vehicle_position_converted_t _vehicle_position;
    secondary_vehicle_speed_converted_t _vehicle_speed;
    secondary_vehicle_curvilinear_coordinates_converted_t _vehicle_curvilinear_coordinates;
    secondary_front_angular_velocity_converted_t _front_angular_velocity;
    secondary_rear_angular_velocity_converted_t _rear_angular_velocity;
    secondary_hv_soc_estimation_state_converted_t _hv_soc_estimation_state;
    secondary_hv_soc_estimation_covariance_converted_t _hv_soc_estimation_covariance;
    secondary_lv_soc_estimation_state_converted_t _lv_soc_estimation_state;
    secondary_lv_soc_estimation_covariance_converted_t _lv_soc_estimation_covariance;
    secondary_pedal_throttle_converted_t _pedal_throttle;
    secondary_pedal_brakes_pressure_converted_t _pedal_brakes_pressure;
    secondary_steer_angle_converted_t _steer_angle;
    secondary_odometer_converted_t _odometer;
    secondary_tpms_pressure_converted_t _tpms_pressure;
    secondary_tpms_temperature_converted_t _tpms_temperature;
    secondary_tlm_unix_timestamp_converted_t _tlm_unix_timestamp;
    secondary_tlm_lap_time_converted_t _tlm_lap_time;
    secondary_tlm_laps_stats_converted_t _tlm_laps_stats;
    secondary_tlm_network_interface_converted_t _tlm_network_interface;
    secondary_front_ammo_compression_converted_t _front_ammo_compression;
    secondary_rear_ammo_compression_converted_t _rear_ammo_compression;
    secondary_acquisinator_calibrations_offsets_converted_t _acquisinator_calibrations_offsets;
    secondary_acquisinator_errors_converted_t _acquisinator_errors;
    secondary_link_deformation_debug_voltages_converted_t _link_deformation_debug_voltages;
    secondary_link_deformation_fl_wheel_converted_t _link_deformation_fl_wheel;
    secondary_link_deformation_fr_wheel_converted_t _link_deformation_fr_wheel;
    secondary_link_deformation_rl_wheel_converted_t _link_deformation_rl_wheel;
    secondary_link_deformation_rr_wheel_converted_t _link_deformation_rr_wheel;
    secondary_link_deformation_set_calibration_converted_t _link_deformation_set_calibration;
    secondary_ammo_compression_set_calibration_converted_t _ammo_compression_set_calibration;
    secondary_debug_signal_5_converted_t _debug_signal_5;
    secondary_debug_signal_6_converted_t _debug_signal_6;
    secondary_debug_signal_7_converted_t _debug_signal_7;
    secondary_debug_signal_8_converted_t _debug_signal_8;
    secondary_cooling_temp_pumps_converted_t _cooling_temp_pumps;
    secondary_cooling_temp_radiators_converted_t _cooling_temp_radiators;
    secondary_lateral_controller_preview_point_errors_converted_t _lateral_controller_preview_point_errors;
    secondary_lateral_controller_errors_converted_t _lateral_controller_errors;

} _secondary_all_struct_converted;



#define secondary_MAX_STRUCT_SIZE_RAW sizeof(_secondary_all_struct_raw)
#define secondary_MAX_STRUCT_SIZE_CONVERSION sizeof(_secondary_all_struct_converted)

#ifdef __cplusplus
}
#endif

#endif
