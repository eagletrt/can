/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2018-2019 Erik Moqvist
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/**
 * This file was generated by cantools version 38.0.2 Tue Apr  9 11:16:19 2024.
 */

#ifndef SECONDARY_H
#define SECONDARY_H

#include <stdio.h>
#include <stdlib.h>
#include <inttypes.h>

#ifdef __cplusplus
extern "C" {
#endif

#include <stdint.h>
#include <stdbool.h>
#include <stddef.h>

#ifndef CANLIB_BUILD
#define CANLIB_BUILD
#define CANLIB_BUILD_TIME 1712661379
#endif // CANLIB_BUILD

#define canlib_min(a,b) (((a) < (b)) ? (a) : (b))
#define canlib_max(a,b) (((a) > (b)) ? (a) : (b))

#ifndef CANLIB_PARKING
/* We know it's PACKING but PARKING sounds a bit better ;) */
#if defined(__MINGW32__)
#define CANLIB_PARKING                                                           __attribute__((__gcc_struct__, __packed__)) // , __aligned__(1)))
#else
#define CANLIB_PARKING __attribute__((__packed__)) // , __aligned__(1)))
#endif                                             // defined(__MINGW32__)
#endif                                             // CANLIB_PARKING

#ifndef EINVAL
#    define EINVAL 22
#endif

/* General defines */
#define SECONDARY_ONESHOT (-1)

/* Frame ids. */
#define SECONDARY_IMU_ANGULAR_RATE_FRAME_ID (0x4ecu)
#define SECONDARY_IMU_ACCELERATION_FRAME_ID (0x4edu)
#define SECONDARY_IRTS_FL_0_FRAME_ID (0x5b0u)
#define SECONDARY_IRTS_FL_1_FRAME_ID (0x5b1u)
#define SECONDARY_IRTS_FL_2_FRAME_ID (0x5b2u)
#define SECONDARY_IRTS_FL_3_FRAME_ID (0x5b3u)
#define SECONDARY_IRTS_FR_0_FRAME_ID (0x5b8u)
#define SECONDARY_IRTS_FR_1_FRAME_ID (0x5b9u)
#define SECONDARY_IRTS_FR_2_FRAME_ID (0x5bau)
#define SECONDARY_IRTS_FR_3_FRAME_ID (0x5bbu)
#define SECONDARY_IRTS_RL_0_FRAME_ID (0x5bcu)
#define SECONDARY_IRTS_RL_1_FRAME_ID (0x5bdu)
#define SECONDARY_IRTS_RL_2_FRAME_ID (0x5beu)
#define SECONDARY_IRTS_RL_3_FRAME_ID (0x5bfu)
#define SECONDARY_IRTS_RR_0_FRAME_ID (0x4b0u)
#define SECONDARY_IRTS_RR_1_FRAME_ID (0x4b1u)
#define SECONDARY_IRTS_RR_2_FRAME_ID (0x4b2u)
#define SECONDARY_IRTS_RR_3_FRAME_ID (0x4b3u)
#define SECONDARY_GPS_COORDS_FRAME_ID (0x600u)
#define SECONDARY_GPS_SPEED_FRAME_ID (0x608u)
#define SECONDARY_ANGULAR_VELOCITY_FRAME_ID (0x610u)
#define SECONDARY_PEDAL_THROTTLE_FRAME_ID (0x618u)
#define SECONDARY_PEDAL_BRAKES_PRESSURE_FRAME_ID (0x620u)
#define SECONDARY_STEER_ANGLE_FRAME_ID (0x628u)
#define SECONDARY_TPMS_PRESSURE_FRAME_ID (0x630u)
#define SECONDARY_TPMS_TEMPERATURE_FRAME_ID (0x638u)
#define SECONDARY_TLM_UNIX_TIMESTAMP_FRAME_ID (0x640u)
#define SECONDARY_TLM_LAP_TIME_FRAME_ID (0x648u)
#define SECONDARY_TLM_LAPS_STATS_FRAME_ID (0x650u)
#define SECONDARY_AMMO_COMPRESSION_FRAME_ID (0x658u)
#define SECONDARY_LINK_DEFORMATION_FRAME_ID (0x660u)
#define SECONDARY_LINK_DEFORMATION_SET_CALIBRATION_FRAME_ID (0x00u)
#define SECONDARY_DEBUG_SIGNAL_1_FRAME_ID (0x668u)
#define SECONDARY_DEBUG_SIGNAL_2_FRAME_ID (0x670u)
#define SECONDARY_COOLING_TEMP_FRAME_ID (0x678u)

/* Frame lengths in bytes. */
#define SECONDARY_IMU_ANGULAR_RATE_BYTE_SIZE (6u)
#define SECONDARY_IMU_ACCELERATION_BYTE_SIZE (8u)
#define SECONDARY_IRTS_FL_0_BYTE_SIZE (8u)
#define SECONDARY_IRTS_FL_1_BYTE_SIZE (8u)
#define SECONDARY_IRTS_FL_2_BYTE_SIZE (8u)
#define SECONDARY_IRTS_FL_3_BYTE_SIZE (8u)
#define SECONDARY_IRTS_FR_0_BYTE_SIZE (8u)
#define SECONDARY_IRTS_FR_1_BYTE_SIZE (8u)
#define SECONDARY_IRTS_FR_2_BYTE_SIZE (8u)
#define SECONDARY_IRTS_FR_3_BYTE_SIZE (8u)
#define SECONDARY_IRTS_RL_0_BYTE_SIZE (8u)
#define SECONDARY_IRTS_RL_1_BYTE_SIZE (8u)
#define SECONDARY_IRTS_RL_2_BYTE_SIZE (8u)
#define SECONDARY_IRTS_RL_3_BYTE_SIZE (8u)
#define SECONDARY_IRTS_RR_0_BYTE_SIZE (8u)
#define SECONDARY_IRTS_RR_1_BYTE_SIZE (8u)
#define SECONDARY_IRTS_RR_2_BYTE_SIZE (8u)
#define SECONDARY_IRTS_RR_3_BYTE_SIZE (8u)
#define SECONDARY_GPS_COORDS_BYTE_SIZE (8u)
#define SECONDARY_GPS_SPEED_BYTE_SIZE (2u)
#define SECONDARY_ANGULAR_VELOCITY_BYTE_SIZE (4u)
#define SECONDARY_PEDAL_THROTTLE_BYTE_SIZE (2u)
#define SECONDARY_PEDAL_BRAKES_PRESSURE_BYTE_SIZE (4u)
#define SECONDARY_STEER_ANGLE_BYTE_SIZE (4u)
#define SECONDARY_TPMS_PRESSURE_BYTE_SIZE (4u)
#define SECONDARY_TPMS_TEMPERATURE_BYTE_SIZE (4u)
#define SECONDARY_TLM_UNIX_TIMESTAMP_BYTE_SIZE (8u)
#define SECONDARY_TLM_LAP_TIME_BYTE_SIZE (4u)
#define SECONDARY_TLM_LAPS_STATS_BYTE_SIZE (6u)
#define SECONDARY_AMMO_COMPRESSION_BYTE_SIZE (8u)
#define SECONDARY_LINK_DEFORMATION_BYTE_SIZE (5u)
#define SECONDARY_LINK_DEFORMATION_SET_CALIBRATION_BYTE_SIZE (5u)
#define SECONDARY_DEBUG_SIGNAL_1_BYTE_SIZE (8u)
#define SECONDARY_DEBUG_SIGNAL_2_BYTE_SIZE (8u)
#define SECONDARY_COOLING_TEMP_BYTE_SIZE (8u)

/* Extended or standard frame types. */
#define SECONDARY_IMU_ANGULAR_RATE_IS_EXTENDED (0)
#define SECONDARY_IMU_ACCELERATION_IS_EXTENDED (0)
#define SECONDARY_IRTS_FL_0_IS_EXTENDED (0)
#define SECONDARY_IRTS_FL_1_IS_EXTENDED (0)
#define SECONDARY_IRTS_FL_2_IS_EXTENDED (0)
#define SECONDARY_IRTS_FL_3_IS_EXTENDED (0)
#define SECONDARY_IRTS_FR_0_IS_EXTENDED (0)
#define SECONDARY_IRTS_FR_1_IS_EXTENDED (0)
#define SECONDARY_IRTS_FR_2_IS_EXTENDED (0)
#define SECONDARY_IRTS_FR_3_IS_EXTENDED (0)
#define SECONDARY_IRTS_RL_0_IS_EXTENDED (0)
#define SECONDARY_IRTS_RL_1_IS_EXTENDED (0)
#define SECONDARY_IRTS_RL_2_IS_EXTENDED (0)
#define SECONDARY_IRTS_RL_3_IS_EXTENDED (0)
#define SECONDARY_IRTS_RR_0_IS_EXTENDED (0)
#define SECONDARY_IRTS_RR_1_IS_EXTENDED (0)
#define SECONDARY_IRTS_RR_2_IS_EXTENDED (0)
#define SECONDARY_IRTS_RR_3_IS_EXTENDED (0)
#define SECONDARY_GPS_COORDS_IS_EXTENDED (0)
#define SECONDARY_GPS_SPEED_IS_EXTENDED (0)
#define SECONDARY_ANGULAR_VELOCITY_IS_EXTENDED (0)
#define SECONDARY_PEDAL_THROTTLE_IS_EXTENDED (0)
#define SECONDARY_PEDAL_BRAKES_PRESSURE_IS_EXTENDED (0)
#define SECONDARY_STEER_ANGLE_IS_EXTENDED (0)
#define SECONDARY_TPMS_PRESSURE_IS_EXTENDED (0)
#define SECONDARY_TPMS_TEMPERATURE_IS_EXTENDED (0)
#define SECONDARY_TLM_UNIX_TIMESTAMP_IS_EXTENDED (0)
#define SECONDARY_TLM_LAP_TIME_IS_EXTENDED (0)
#define SECONDARY_TLM_LAPS_STATS_IS_EXTENDED (0)
#define SECONDARY_AMMO_COMPRESSION_IS_EXTENDED (0)
#define SECONDARY_LINK_DEFORMATION_IS_EXTENDED (0)
#define SECONDARY_LINK_DEFORMATION_SET_CALIBRATION_IS_EXTENDED (0)
#define SECONDARY_DEBUG_SIGNAL_1_IS_EXTENDED (0)
#define SECONDARY_DEBUG_SIGNAL_2_IS_EXTENDED (0)
#define SECONDARY_COOLING_TEMP_IS_EXTENDED (0)

/* Frame cycle times in milliseconds. */
#define SECONDARY_ANGULAR_VELOCITY_CYCLE_TIME_MS (10u)
#define SECONDARY_PEDAL_THROTTLE_CYCLE_TIME_MS (10u)
#define SECONDARY_PEDAL_BRAKES_PRESSURE_CYCLE_TIME_MS (10u)
#define SECONDARY_STEER_ANGLE_CYCLE_TIME_MS (10u)
#define SECONDARY_TLM_UNIX_TIMESTAMP_CYCLE_TIME_MS (1000u)
#define SECONDARY_TLM_LAPS_STATS_CYCLE_TIME_MS (1000u)
#define SECONDARY_AMMO_COMPRESSION_CYCLE_TIME_MS (10u)
#define SECONDARY_LINK_DEFORMATION_CYCLE_TIME_MS (10u)
#define SECONDARY_DEBUG_SIGNAL_1_CYCLE_TIME_MS (10u)
#define SECONDARY_DEBUG_SIGNAL_2_CYCLE_TIME_MS (10u)
#define SECONDARY_COOLING_TEMP_CYCLE_TIME_MS (500u)
#define SECONDARY_IMU_ANGULAR_RATE_CYCLE_TIME_MS (SECONDARY_ONESHOT)
#define SECONDARY_IMU_ACCELERATION_CYCLE_TIME_MS (SECONDARY_ONESHOT)
#define SECONDARY_IRTS_FL_0_CYCLE_TIME_MS (SECONDARY_ONESHOT)
#define SECONDARY_IRTS_FL_1_CYCLE_TIME_MS (SECONDARY_ONESHOT)
#define SECONDARY_IRTS_FL_2_CYCLE_TIME_MS (SECONDARY_ONESHOT)
#define SECONDARY_IRTS_FL_3_CYCLE_TIME_MS (SECONDARY_ONESHOT)
#define SECONDARY_IRTS_FR_0_CYCLE_TIME_MS (SECONDARY_ONESHOT)
#define SECONDARY_IRTS_FR_1_CYCLE_TIME_MS (SECONDARY_ONESHOT)
#define SECONDARY_IRTS_FR_2_CYCLE_TIME_MS (SECONDARY_ONESHOT)
#define SECONDARY_IRTS_FR_3_CYCLE_TIME_MS (SECONDARY_ONESHOT)
#define SECONDARY_IRTS_RL_0_CYCLE_TIME_MS (SECONDARY_ONESHOT)
#define SECONDARY_IRTS_RL_1_CYCLE_TIME_MS (SECONDARY_ONESHOT)
#define SECONDARY_IRTS_RL_2_CYCLE_TIME_MS (SECONDARY_ONESHOT)
#define SECONDARY_IRTS_RL_3_CYCLE_TIME_MS (SECONDARY_ONESHOT)
#define SECONDARY_IRTS_RR_0_CYCLE_TIME_MS (SECONDARY_ONESHOT)
#define SECONDARY_IRTS_RR_1_CYCLE_TIME_MS (SECONDARY_ONESHOT)
#define SECONDARY_IRTS_RR_2_CYCLE_TIME_MS (SECONDARY_ONESHOT)
#define SECONDARY_IRTS_RR_3_CYCLE_TIME_MS (SECONDARY_ONESHOT)
#define SECONDARY_GPS_COORDS_CYCLE_TIME_MS (SECONDARY_ONESHOT)
#define SECONDARY_GPS_SPEED_CYCLE_TIME_MS (SECONDARY_ONESHOT)
#define SECONDARY_TPMS_PRESSURE_CYCLE_TIME_MS (SECONDARY_ONESHOT)
#define SECONDARY_TPMS_TEMPERATURE_CYCLE_TIME_MS (SECONDARY_ONESHOT)
#define SECONDARY_TLM_LAP_TIME_CYCLE_TIME_MS (SECONDARY_ONESHOT)
#define SECONDARY_LINK_DEFORMATION_SET_CALIBRATION_CYCLE_TIME_MS (SECONDARY_ONESHOT)

/* Topics masks */
/* TOPIC FIXED_IDS */
#define SECONDARY_TOPIC_MASK_FIXED_IDS 0b00000011111

#define SECONDARY_ID_IMU_ANGULAR_RATE 0x4EC // dec: 1260 bin: 0b10011101100
#define SECONDARY_ID_IMU_ACCELERATION 0x4ED // dec: 1261 bin: 0b10011101101
#define SECONDARY_ID_IRTS_FL_0 0x5B0 // dec: 1456 bin: 0b10110110000
#define SECONDARY_ID_IRTS_FL_1 0x5B1 // dec: 1457 bin: 0b10110110001
#define SECONDARY_ID_IRTS_FL_2 0x5B2 // dec: 1458 bin: 0b10110110010
#define SECONDARY_ID_IRTS_FL_3 0x5B3 // dec: 1459 bin: 0b10110110011
#define SECONDARY_ID_IRTS_FR_0 0x5B8 // dec: 1464 bin: 0b10110111000
#define SECONDARY_ID_IRTS_FR_1 0x5B9 // dec: 1465 bin: 0b10110111001
#define SECONDARY_ID_IRTS_FR_2 0x5BA // dec: 1466 bin: 0b10110111010
#define SECONDARY_ID_IRTS_FR_3 0x5BB // dec: 1467 bin: 0b10110111011
#define SECONDARY_ID_IRTS_RL_0 0x5BC // dec: 1468 bin: 0b10110111100
#define SECONDARY_ID_IRTS_RL_1 0x5BD // dec: 1469 bin: 0b10110111101
#define SECONDARY_ID_IRTS_RL_2 0x5BE // dec: 1470 bin: 0b10110111110
#define SECONDARY_ID_IRTS_RL_3 0x5BF // dec: 1471 bin: 0b10110111111
#define SECONDARY_ID_IRTS_RR_0 0x4B0 // dec: 1200 bin: 0b10010110000
#define SECONDARY_ID_IRTS_RR_1 0x4B1 // dec: 1201 bin: 0b10010110001
#define SECONDARY_ID_IRTS_RR_2 0x4B2 // dec: 1202 bin: 0b10010110010
#define SECONDARY_ID_IRTS_RR_3 0x4B3 // dec: 1203 bin: 0b10010110011

/* TOPIC HYDRA */
#define SECONDARY_TOPIC_MASK_HYDRA 0b00000011111

#define SECONDARY_TOPIC_FILTER_HYDRA 0x0 // dec: 0 bin: 0b00000000000

#define SECONDARY_ID_GPS_COORDS 0x600 // dec: 1536 bin: 0b11000000000
#define SECONDARY_ID_GPS_SPEED 0x608 // dec: 1544 bin: 0b11000001000
#define SECONDARY_ID_ANGULAR_VELOCITY 0x610 // dec: 1552 bin: 0b11000010000
#define SECONDARY_ID_PEDAL_THROTTLE 0x618 // dec: 1560 bin: 0b11000011000
#define SECONDARY_ID_PEDAL_BRAKES_PRESSURE 0x620 // dec: 1568 bin: 0b11000100000
#define SECONDARY_ID_STEER_ANGLE 0x628 // dec: 1576 bin: 0b11000101000
#define SECONDARY_ID_TPMS_PRESSURE 0x630 // dec: 1584 bin: 0b11000110000
#define SECONDARY_ID_TPMS_TEMPERATURE 0x638 // dec: 1592 bin: 0b11000111000
#define SECONDARY_ID_TLM_UNIX_TIMESTAMP 0x640 // dec: 1600 bin: 0b11001000000
#define SECONDARY_ID_TLM_LAP_TIME 0x648 // dec: 1608 bin: 0b11001001000
#define SECONDARY_ID_TLM_LAPS_STATS 0x650 // dec: 1616 bin: 0b11001010000
#define SECONDARY_ID_AMMO_COMPRESSION 0x658 // dec: 1624 bin: 0b11001011000
#define SECONDARY_ID_LINK_DEFORMATION 0x660 // dec: 1632 bin: 0b11001100000
#define SECONDARY_ID_LINK_DEFORMATION_SET_CALIBRATION 0x0 // dec: 0 bin: 0b00000000000
#define SECONDARY_ID_DEBUG_SIGNAL_1 0x668 // dec: 1640 bin: 0b11001101000
#define SECONDARY_ID_DEBUG_SIGNAL_2 0x670 // dec: 1648 bin: 0b11001110000
#define SECONDARY_ID_COOLING_TEMP 0x678 // dec: 1656 bin: 0b11001111000



/* Signal choices. */


/* Indexes */
#define SECONDARY_IMU_ANGULAR_RATE_INDEX 0
#define SECONDARY_IMU_ACCELERATION_INDEX 1
#define SECONDARY_IRTS_FL_0_INDEX 2
#define SECONDARY_IRTS_FL_1_INDEX 3
#define SECONDARY_IRTS_FL_2_INDEX 4
#define SECONDARY_IRTS_FL_3_INDEX 5
#define SECONDARY_IRTS_FR_0_INDEX 6
#define SECONDARY_IRTS_FR_1_INDEX 7
#define SECONDARY_IRTS_FR_2_INDEX 8
#define SECONDARY_IRTS_FR_3_INDEX 9
#define SECONDARY_IRTS_RL_0_INDEX 10
#define SECONDARY_IRTS_RL_1_INDEX 11
#define SECONDARY_IRTS_RL_2_INDEX 12
#define SECONDARY_IRTS_RL_3_INDEX 13
#define SECONDARY_IRTS_RR_0_INDEX 14
#define SECONDARY_IRTS_RR_1_INDEX 15
#define SECONDARY_IRTS_RR_2_INDEX 16
#define SECONDARY_IRTS_RR_3_INDEX 17
#define SECONDARY_GPS_COORDS_INDEX 18
#define SECONDARY_GPS_SPEED_INDEX 19
#define SECONDARY_ANGULAR_VELOCITY_INDEX 20
#define SECONDARY_PEDAL_THROTTLE_INDEX 21
#define SECONDARY_PEDAL_BRAKES_PRESSURE_INDEX 22
#define SECONDARY_STEER_ANGLE_INDEX 23
#define SECONDARY_TPMS_PRESSURE_INDEX 24
#define SECONDARY_TPMS_TEMPERATURE_INDEX 25
#define SECONDARY_TLM_UNIX_TIMESTAMP_INDEX 26
#define SECONDARY_TLM_LAP_TIME_INDEX 27
#define SECONDARY_TLM_LAPS_STATS_INDEX 28
#define SECONDARY_AMMO_COMPRESSION_INDEX 29
#define SECONDARY_LINK_DEFORMATION_INDEX 30
#define SECONDARY_LINK_DEFORMATION_SET_CALIBRATION_INDEX 31
#define SECONDARY_DEBUG_SIGNAL_1_INDEX 32
#define SECONDARY_DEBUG_SIGNAL_2_INDEX 33
#define SECONDARY_COOLING_TEMP_INDEX 34


#define secondary_MESSAGE_COUNT 35

#ifndef CANLIB_DEVICE_T
#define CANLIB_DEVICE_T
typedef struct {
    void* message;
    void* _converted;
    void* _raw;
    int _size_raw;
    int _size_converted;
} device_t;
void device_init(device_t *device);
void device_preallocate(device_t *device, int bytes);
void device_free(device_t *device);
void device_set_address(device_t *device, void* raw, size_t raw_size, void *converted, size_t converted_size);
#endif // CANLIB_DEVICE_T

#ifdef CANLIB_DEVICE_IMPLEMENTATION
#undef CANLIB_DEVICE_IMPLEMENTATION
void device_init(device_t *device) {
    device->message = NULL;
    device->_converted = NULL;
    device->_raw = NULL;
    device->_size_raw = 0;
    device->_size_converted = 0;
}
void device_preallocate(device_t *device, int bytes){
    if(device->_size_raw > 0)
        free(device->_raw);
    if(device->_size_converted > 0)
        free(device->_converted);
    device->_raw = malloc(bytes);
    device->_converted = malloc(bytes);
    device->_size_converted = device->_size_raw = bytes;
}
void device_free(device_t *device) {
    free(device->_raw);
    free(device->_converted);
    device->message = NULL;
    device->_raw = NULL;
    device->_converted = NULL;
    device->_size_raw = 0;
    device->_size_converted = 0;
}
void device_set_address(device_t *device, void* raw, size_t raw_size, void *converted, size_t converted_size) {
    device->_raw = raw;
    device->_converted = converted;
    device->_size_raw = raw_size;
    device->_size_converted = converted_size;
}
#endif // CANLIB_DEVICE_IMPLEMENTATION

void secondary_devices_deserialize_from_id(
    device_t* device,
    uint16_t message_id,
    uint8_t* data
#ifdef CANLIB_TIMESTAMP
    , uint64_t timestamp
#endif // CANLIB_TIMESTAMP
);

int secondary_message_name_from_id(uint16_t id, char* buffer);
int secondary_index_from_id(uint16_t id);
int secondary_id_from_index(int index);

/**
 * Signals in message IMU_ANGULAR_RATE.
 *
 * Inertial Measurement Unit [x,y,z]-axis angular rate value. 0.01dps per bit, Big-Endian, 16bit Total, signed
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..2450 (0..245 -)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t x;

    /**
     * Range: 0..2450 (0..245 -)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t y;

    /**
     * Range: 0..2450 (0..245 -)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t z;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_imu_angular_rate_t;

/**
 * Signals in message IMU_ANGULAR_RATE.
 *
 * Inertial Measurement Unit [x,y,z]-axis angular rate value. 0.01dps per bit, Big-Endian, 16bit Total, signed
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..2450 (0..245 -)
     * Scale: 0.1
     * Offset: 0
     */
    float x;

    /**
     * Range: 0..2450 (0..245 -)
     * Scale: 0.1
     * Offset: 0
     */
    float y;

    /**
     * Range: 0..2450 (0..245 -)
     * Scale: 0.1
     * Offset: 0
     */
    float z;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_imu_angular_rate_converted_t;

/**
 * Signals in message IMU_ACCELERATION.
 *
 * Inertial Measurement Unit [x,y,z]-axis acceleration value. 0.01g per bit, Big-Endian, 16bit Total, signed
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..800 (0..8 -)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t x;

    /**
     * Range: 0..800 (0..8 -)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t y;

    /**
     * Range: 0..800 (0..8 -)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t z;

    /**
     * Range: 0..65535 (-32768..32767 -)
     * Scale: 1
     * Offset: -32768
     */
    int16_t imu_temperature;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_imu_acceleration_t;

/**
 * Signals in message IMU_ACCELERATION.
 *
 * Inertial Measurement Unit [x,y,z]-axis acceleration value. 0.01g per bit, Big-Endian, 16bit Total, signed
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..800 (0..8 -)
     * Scale: 0.01
     * Offset: 0
     */
    float x;

    /**
     * Range: 0..800 (0..8 -)
     * Scale: 0.01
     * Offset: 0
     */
    float y;

    /**
     * Range: 0..800 (0..8 -)
     * Scale: 0.01
     * Offset: 0
     */
    float z;

    /**
     * Range: 0..65535 (-32768..32767 -)
     * Scale: 1
     * Offset: -32768
     */
    int16_t imu_temperature;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_imu_acceleration_converted_t;

/**
 * Signals in message IRTS_FL_0.
 *
 * Front Left wheel InfraRed Temperature Sensor data, channels 1 through 4. 0.1˚C per bit, -100˚C offset, Big-Endian, 16bit Total, unsigned.
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    uint16_t channel1;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    uint16_t channel2;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    uint16_t channel3;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    uint16_t channel4;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_irts_fl_0_t;

/**
 * Signals in message IRTS_FL_0.
 *
 * Front Left wheel InfraRed Temperature Sensor data, channels 1 through 4. 0.1˚C per bit, -100˚C offset, Big-Endian, 16bit Total, unsigned.
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    float channel1;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    float channel2;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    float channel3;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    float channel4;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_irts_fl_0_converted_t;

/**
 * Signals in message IRTS_FL_1.
 *
 * Front Left wheel InfraRed Temperature Sensor data, channels 5 through 8. 0.1˚C per bit, -100˚C offset, Big-Endian, 16bit Total, unsigned.
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    uint16_t channel5;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    uint16_t channel6;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    uint16_t channel7;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    uint16_t channel8;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_irts_fl_1_t;

/**
 * Signals in message IRTS_FL_1.
 *
 * Front Left wheel InfraRed Temperature Sensor data, channels 5 through 8. 0.1˚C per bit, -100˚C offset, Big-Endian, 16bit Total, unsigned.
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    float channel5;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    float channel6;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    float channel7;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    float channel8;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_irts_fl_1_converted_t;

/**
 * Signals in message IRTS_FL_2.
 *
 * Front Left wheel InfraRed Temperature Sensor data, channels 9 through 12. 0.1˚C per bit, -100˚C offset, Big-Endian, 16bit Total, unsigned.
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    uint16_t channel9;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    uint16_t channel10;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    uint16_t channel11;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    uint16_t channel12;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_irts_fl_2_t;

/**
 * Signals in message IRTS_FL_2.
 *
 * Front Left wheel InfraRed Temperature Sensor data, channels 9 through 12. 0.1˚C per bit, -100˚C offset, Big-Endian, 16bit Total, unsigned.
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    float channel9;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    float channel10;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    float channel11;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    float channel12;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_irts_fl_2_converted_t;

/**
 * Signals in message IRTS_FL_3.
 *
 * Front Left wheel InfraRed Temperature Sensor data, channels 13 through 16. 0.1˚C per bit, -100˚C offset, Big-Endian, 16bit Total, unsigned.
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    uint16_t channel13;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    uint16_t channel14;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    uint16_t channel15;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    uint16_t channel16;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_irts_fl_3_t;

/**
 * Signals in message IRTS_FL_3.
 *
 * Front Left wheel InfraRed Temperature Sensor data, channels 13 through 16. 0.1˚C per bit, -100˚C offset, Big-Endian, 16bit Total, unsigned.
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    float channel13;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    float channel14;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    float channel15;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    float channel16;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_irts_fl_3_converted_t;

/**
 * Signals in message IRTS_FR_0.
 *
 * Front Right wheel InfraRed Temperature Sensor data, channels 1 through 4. 0.1˚C per bit, -100˚C offset, Big-Endian, 16bit Total, unsigned.
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    uint16_t channel1;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    uint16_t channel2;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    uint16_t channel3;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    uint16_t channel4;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_irts_fr_0_t;

/**
 * Signals in message IRTS_FR_0.
 *
 * Front Right wheel InfraRed Temperature Sensor data, channels 1 through 4. 0.1˚C per bit, -100˚C offset, Big-Endian, 16bit Total, unsigned.
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    float channel1;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    float channel2;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    float channel3;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    float channel4;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_irts_fr_0_converted_t;

/**
 * Signals in message IRTS_FR_1.
 *
 * Front Right wheel InfraRed Temperature Sensor data, channels 5 through 8. 0.1˚C per bit, -100˚C offset, Big-Endian, 16bit Total, unsigned.
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    uint16_t channel5;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    uint16_t channel6;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    uint16_t channel7;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    uint16_t channel8;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_irts_fr_1_t;

/**
 * Signals in message IRTS_FR_1.
 *
 * Front Right wheel InfraRed Temperature Sensor data, channels 5 through 8. 0.1˚C per bit, -100˚C offset, Big-Endian, 16bit Total, unsigned.
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    float channel5;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    float channel6;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    float channel7;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    float channel8;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_irts_fr_1_converted_t;

/**
 * Signals in message IRTS_FR_2.
 *
 * Front Right wheel InfraRed Temperature Sensor data, channels 9 through 12. 0.1˚C per bit, -100˚C offset, Big-Endian, 16bit Total, unsigned.
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    uint16_t channel9;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    uint16_t channel10;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    uint16_t channel11;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    uint16_t channel12;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_irts_fr_2_t;

/**
 * Signals in message IRTS_FR_2.
 *
 * Front Right wheel InfraRed Temperature Sensor data, channels 9 through 12. 0.1˚C per bit, -100˚C offset, Big-Endian, 16bit Total, unsigned.
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    float channel9;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    float channel10;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    float channel11;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    float channel12;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_irts_fr_2_converted_t;

/**
 * Signals in message IRTS_FR_3.
 *
 * Front Right wheel InfraRed Temperature Sensor data, channels 13 through 16. 0.1˚C per bit, -100˚C offset, Big-Endian, 16bit Total, unsigned.
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    uint16_t channel13;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    uint16_t channel14;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    uint16_t channel15;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    uint16_t channel16;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_irts_fr_3_t;

/**
 * Signals in message IRTS_FR_3.
 *
 * Front Right wheel InfraRed Temperature Sensor data, channels 13 through 16. 0.1˚C per bit, -100˚C offset, Big-Endian, 16bit Total, unsigned.
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    float channel13;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    float channel14;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    float channel15;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    float channel16;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_irts_fr_3_converted_t;

/**
 * Signals in message IRTS_RL_0.
 *
 * Rear Left wheel InfraRed Temperature Sensor data, channels 1 through 4. 0.1˚C per bit, -100˚C offset, Big-Endian, 16bit Total, unsigned.
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    uint16_t channel1;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    uint16_t channel2;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    uint16_t channel3;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    uint16_t channel4;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_irts_rl_0_t;

/**
 * Signals in message IRTS_RL_0.
 *
 * Rear Left wheel InfraRed Temperature Sensor data, channels 1 through 4. 0.1˚C per bit, -100˚C offset, Big-Endian, 16bit Total, unsigned.
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    float channel1;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    float channel2;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    float channel3;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    float channel4;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_irts_rl_0_converted_t;

/**
 * Signals in message IRTS_RL_1.
 *
 * Rear Left wheel InfraRed Temperature Sensor data, channels 5 through 8. 0.1˚C per bit, -100˚C offset, Big-Endian, 16bit Total, unsigned.
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    uint16_t channel5;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    uint16_t channel6;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    uint16_t channel7;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    uint16_t channel8;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_irts_rl_1_t;

/**
 * Signals in message IRTS_RL_1.
 *
 * Rear Left wheel InfraRed Temperature Sensor data, channels 5 through 8. 0.1˚C per bit, -100˚C offset, Big-Endian, 16bit Total, unsigned.
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    float channel5;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    float channel6;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    float channel7;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    float channel8;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_irts_rl_1_converted_t;

/**
 * Signals in message IRTS_RL_2.
 *
 * Rear Left wheel InfraRed Temperature Sensor data, channels 9 through 12. 0.1˚C per bit, -100˚C offset, Big-Endian, 16bit Total, unsigned.
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    uint16_t channel9;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    uint16_t channel10;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    uint16_t channel11;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    uint16_t channel12;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_irts_rl_2_t;

/**
 * Signals in message IRTS_RL_2.
 *
 * Rear Left wheel InfraRed Temperature Sensor data, channels 9 through 12. 0.1˚C per bit, -100˚C offset, Big-Endian, 16bit Total, unsigned.
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    float channel9;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    float channel10;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    float channel11;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    float channel12;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_irts_rl_2_converted_t;

/**
 * Signals in message IRTS_RL_3.
 *
 * Rear Left wheel InfraRed Temperature Sensor data, channels 13 through 16. 0.1˚C per bit, -100˚C offset, Big-Endian, 16bit Total, unsigned.
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    uint16_t channel13;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    uint16_t channel14;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    uint16_t channel15;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    uint16_t channel16;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_irts_rl_3_t;

/**
 * Signals in message IRTS_RL_3.
 *
 * Rear Left wheel InfraRed Temperature Sensor data, channels 13 through 16. 0.1˚C per bit, -100˚C offset, Big-Endian, 16bit Total, unsigned.
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    float channel13;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    float channel14;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    float channel15;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    float channel16;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_irts_rl_3_converted_t;

/**
 * Signals in message IRTS_RR_0.
 *
 * Rear Right wheel InfraRed Temperature Sensor data, channels 1 through 4. 0.1˚C per bit, -100˚C offset, Big-Endian, 16bit Total, unsigned.
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    uint16_t channel1;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    uint16_t channel2;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    uint16_t channel3;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    uint16_t channel4;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_irts_rr_0_t;

/**
 * Signals in message IRTS_RR_0.
 *
 * Rear Right wheel InfraRed Temperature Sensor data, channels 1 through 4. 0.1˚C per bit, -100˚C offset, Big-Endian, 16bit Total, unsigned.
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    float channel1;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    float channel2;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    float channel3;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    float channel4;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_irts_rr_0_converted_t;

/**
 * Signals in message IRTS_RR_1.
 *
 * Rear Right wheel InfraRed Temperature Sensor data, channels 5 through 8. 0.1˚C per bit, -100˚C offset, Big-Endian, 16bit Total, unsigned.
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    uint16_t channel5;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    uint16_t channel6;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    uint16_t channel7;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    uint16_t channel8;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_irts_rr_1_t;

/**
 * Signals in message IRTS_RR_1.
 *
 * Rear Right wheel InfraRed Temperature Sensor data, channels 5 through 8. 0.1˚C per bit, -100˚C offset, Big-Endian, 16bit Total, unsigned.
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    float channel5;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    float channel6;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    float channel7;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    float channel8;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_irts_rr_1_converted_t;

/**
 * Signals in message IRTS_RR_2.
 *
 * Rear Right wheel InfraRed Temperature Sensor data, channels 9 through 12. 0.1˚C per bit, -100˚C offset, Big-Endian, 16bit Total, unsigned.
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    uint16_t channel9;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    uint16_t channel10;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    uint16_t channel11;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    uint16_t channel12;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_irts_rr_2_t;

/**
 * Signals in message IRTS_RR_2.
 *
 * Rear Right wheel InfraRed Temperature Sensor data, channels 9 through 12. 0.1˚C per bit, -100˚C offset, Big-Endian, 16bit Total, unsigned.
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    float channel9;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    float channel10;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    float channel11;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    float channel12;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_irts_rr_2_converted_t;

/**
 * Signals in message IRTS_RR_3.
 *
 * Rear Right wheel InfraRed Temperature Sensor data, channels 13 through 16. 0.1˚C per bit, -100˚C offset, Big-Endian, 16bit Total, unsigned.
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    uint16_t channel13;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    uint16_t channel14;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    uint16_t channel15;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    uint16_t channel16;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_irts_rr_3_t;

/**
 * Signals in message IRTS_RR_3.
 *
 * Rear Right wheel InfraRed Temperature Sensor data, channels 13 through 16. 0.1˚C per bit, -100˚C offset, Big-Endian, 16bit Total, unsigned.
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    float channel13;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    float channel14;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    float channel15;

    /**
     * Range: 0..1000 (-100..0 -)
     * Scale: 0.1
     * Offset: -100
     */
    float channel16;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_irts_rr_3_converted_t;

/**
 * Signals in message GPS_COORDS.
 *
 * Coordinates received from GPS
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..4294967295 (0..4294967295 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t latitude;

    /**
     * Range: 0..4294967295 (0..4294967295 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t longitude;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_gps_coords_t;

/**
 * Signals in message GPS_COORDS.
 *
 * Coordinates received from GPS
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..4294967295 (0..4294967295 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t latitude;

    /**
     * Range: 0..4294967295 (0..4294967295 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t longitude;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_gps_coords_converted_t;

/**
 * Signals in message GPS_SPEED.
 *
 * Speed received from GPS
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t speed;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_gps_speed_t;

/**
 * Signals in message GPS_SPEED.
 *
 * Speed received from GPS
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t speed;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_gps_speed_converted_t;

/**
 * Signals in message ANGULAR_VELOCITY.
 *
 * Encoder and inverter speed in rad/sec
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (-200..200 -)
     * Scale: 0.006103608758678569
     * Offset: -200
     */
    uint16_t fl;

    /**
     * Range: 0..65535 (-200..200 -)
     * Scale: 0.006103608758678569
     * Offset: -200
     */
    uint16_t fr;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_angular_velocity_t;

/**
 * Signals in message ANGULAR_VELOCITY.
 *
 * Encoder and inverter speed in rad/sec
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (-200..200 -)
     * Scale: 0.006103608758678569
     * Offset: -200
     */
    float fl;

    /**
     * Range: 0..65535 (-200..200 -)
     * Scale: 0.006103608758678569
     * Offset: -200
     */
    float fr;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_angular_velocity_converted_t;

/**
 * Signals in message PEDAL_THROTTLE.
 *
 * Pedal Throttle , already calibrated
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (0..1 -)
     * Scale: 1.5259021896696422e-05
     * Offset: 0
     */
    uint16_t throttle;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_pedal_throttle_t;

/**
 * Signals in message PEDAL_THROTTLE.
 *
 * Pedal Throttle , already calibrated
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (0..1 -)
     * Scale: 1.5259021896696422e-05
     * Offset: 0
     */
    float throttle;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_pedal_throttle_converted_t;

/**
 * Signals in message PEDAL_BRAKES_PRESSURE.
 *
 * Pedal brakes pressures in bar, already calibrated
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (0..100 -)
     * Scale: 0.0015259021896696422
     * Offset: 0
     */
    uint16_t front;

    /**
     * Range: 0..65535 (0..100 -)
     * Scale: 0.0015259021896696422
     * Offset: 0
     */
    uint16_t rear;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_pedal_brakes_pressure_t;

/**
 * Signals in message PEDAL_BRAKES_PRESSURE.
 *
 * Pedal brakes pressures in bar, already calibrated
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (0..100 -)
     * Scale: 0.0015259021896696422
     * Offset: 0
     */
    float front;

    /**
     * Range: 0..65535 (0..100 -)
     * Scale: 0.0015259021896696422
     * Offset: 0
     */
    float rear;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_pedal_brakes_pressure_converted_t;

/**
 * Signals in message STEER_ANGLE.
 *
 * Steering angle in degrees
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..4294967295 (-180..180 -)
     * Scale: 8.38190317349087e-08
     * Offset: -180
     */
    uint32_t angle;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_steer_angle_t;

/**
 * Signals in message STEER_ANGLE.
 *
 * Steering angle in degrees
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..4294967295 (-180..180 -)
     * Scale: 8.38190317349087e-08
     * Offset: -180
     */
    float angle;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_steer_angle_converted_t;

/**
 * Signals in message TPMS_PRESSURE.
 *
 * Tire Pressure Monitoring System, pressure of each tire
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1.0
     * Offset: 0
     */
    uint8_t fl;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1.0
     * Offset: 0
     */
    uint8_t fr;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1.0
     * Offset: 0
     */
    uint8_t rl;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1.0
     * Offset: 0
     */
    uint8_t rr;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_tpms_pressure_t;

/**
 * Signals in message TPMS_PRESSURE.
 *
 * Tire Pressure Monitoring System, pressure of each tire
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1.0
     * Offset: 0
     */
    uint8_t fl;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1.0
     * Offset: 0
     */
    uint8_t fr;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1.0
     * Offset: 0
     */
    uint8_t rl;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1.0
     * Offset: 0
     */
    uint8_t rr;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_tpms_pressure_converted_t;

/**
 * Signals in message TPMS_TEMPERATURE.
 *
 * Tire Pressure Monitoring System, temperature of each tire
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1.0
     * Offset: 0
     */
    uint8_t fl;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1.0
     * Offset: 0
     */
    uint8_t fr;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1.0
     * Offset: 0
     */
    uint8_t rl;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1.0
     * Offset: 0
     */
    uint8_t rr;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_tpms_temperature_t;

/**
 * Signals in message TPMS_TEMPERATURE.
 *
 * Tire Pressure Monitoring System, temperature of each tire
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1.0
     * Offset: 0
     */
    uint8_t fl;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1.0
     * Offset: 0
     */
    uint8_t fr;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1.0
     * Offset: 0
     */
    uint8_t rl;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1.0
     * Offset: 0
     */
    uint8_t rr;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_tpms_temperature_converted_t;

/**
 * Signals in message TLM_UNIX_TIMESTAMP.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..18446744073709551616 (0..18446744073709551615 -)
     * Scale: 1
     * Offset: 0
     */
    uint64_t timestamp;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_tlm_unix_timestamp_t;

/**
 * Signals in message TLM_UNIX_TIMESTAMP.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..18446744073709551616 (0..18446744073709551615 -)
     * Scale: 1
     * Offset: 0
     */
    uint64_t timestamp;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_tlm_unix_timestamp_converted_t;

/**
 * Signals in message TLM_LAP_TIME.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t lap_count;

    /**
     * Range: 0..65535 (0..1000 -)
     * Scale: 0.015259021896696421
     * Offset: 0
     */
    uint16_t lap_time;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_tlm_lap_time_t;

/**
 * Signals in message TLM_LAP_TIME.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t lap_count;

    /**
     * Range: 0..65535 (0..1000 -)
     * Scale: 0.015259021896696421
     * Offset: 0
     */
    float lap_time;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_tlm_lap_time_converted_t;

/**
 * Signals in message TLM_LAPS_STATS.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t lap_number;

    /**
     * Range: 0..65535 (0..1000 -)
     * Scale: 0.015259021896696421
     * Offset: 0
     */
    uint16_t best_time;

    /**
     * Range: 0..65535 (0..1000 -)
     * Scale: 0.015259021896696421
     * Offset: 0
     */
    uint16_t last_time;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_tlm_laps_stats_t;

/**
 * Signals in message TLM_LAPS_STATS.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t lap_number;

    /**
     * Range: 0..65535 (0..1000 -)
     * Scale: 0.015259021896696421
     * Offset: 0
     */
    float best_time;

    /**
     * Range: 0..65535 (0..1000 -)
     * Scale: 0.015259021896696421
     * Offset: 0
     */
    float last_time;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_tlm_laps_stats_converted_t;

/**
 * Signals in message AMMO_COMPRESSION.
 *
 * Position of the ammos
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65534.99999999999 (-50..20 -)
     * Scale: 0.0010681315327687496
     * Offset: -50
     */
    uint16_t rl;

    /**
     * Range: 0..65534.99999999999 (-50..20 -)
     * Scale: 0.0010681315327687496
     * Offset: -50
     */
    uint16_t rr;

    /**
     * Range: 0..65534.99999999999 (-20..50 -)
     * Scale: 0.0010681315327687496
     * Offset: -20
     */
    uint16_t fl;

    /**
     * Range: 0..65534.99999999999 (-20..50 -)
     * Scale: 0.0010681315327687496
     * Offset: -20
     */
    uint16_t fr;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_ammo_compression_t;

/**
 * Signals in message AMMO_COMPRESSION.
 *
 * Position of the ammos
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65534.99999999999 (-50..20 -)
     * Scale: 0.0010681315327687496
     * Offset: -50
     */
    float rl;

    /**
     * Range: 0..65534.99999999999 (-50..20 -)
     * Scale: 0.0010681315327687496
     * Offset: -50
     */
    float rr;

    /**
     * Range: 0..65534.99999999999 (-20..50 -)
     * Scale: 0.0010681315327687496
     * Offset: -20
     */
    float fl;

    /**
     * Range: 0..65534.99999999999 (-20..50 -)
     * Scale: 0.0010681315327687496
     * Offset: -20
     */
    float fr;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_ammo_compression_converted_t;

/**
 * Signals in message LINK_DEFORMATION.
 *
 * Message for the arm deformation
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t rod_id;

    /**
     * Range: 0..4294967295 (-3.0..3.0 -)
     * Scale: 1.3969838622484784e-09
     * Offset: -3.0
     */
    uint32_t deformation;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_link_deformation_t;

/**
 * Signals in message LINK_DEFORMATION.
 *
 * Message for the arm deformation
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t rod_id;

    /**
     * Range: 0..4294967295 (-3.0..3.0 -)
     * Scale: 1.3969838622484784e-09
     * Offset: -3.0
     */
    float deformation;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_link_deformation_converted_t;

/**
 * Signals in message LINK_DEFORMATION_SET_CALIBRATION.
 *
 * Calibration command for link deformation
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t rod_id;

    /**
     * Range: 0..4294967295 (-3.0..3.0 -)
     * Scale: 1.3969838622484784e-09
     * Offset: -3.0
     */
    uint32_t deformation;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_link_deformation_set_calibration_t;

/**
 * Signals in message LINK_DEFORMATION_SET_CALIBRATION.
 *
 * Calibration command for link deformation
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t rod_id;

    /**
     * Range: 0..4294967295 (-3.0..3.0 -)
     * Scale: 1.3969838622484784e-09
     * Offset: -3.0
     */
    float deformation;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_link_deformation_set_calibration_converted_t;

/**
 * Signals in message DEBUG_SIGNAL_1.
 *
 * Debug signals
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (-1..1 -)
     * Scale: 3.0518043793392844e-05
     * Offset: -1
     */
    uint16_t field_1;

    /**
     * Range: 0..65535 (-1..1 -)
     * Scale: 3.0518043793392844e-05
     * Offset: -1
     */
    uint16_t field_2;

    /**
     * Range: 0..65535 (-1..1 -)
     * Scale: 3.0518043793392844e-05
     * Offset: -1
     */
    uint16_t field_3;

    /**
     * Range: 0..65535 (-1..1 -)
     * Scale: 3.0518043793392844e-05
     * Offset: -1
     */
    uint16_t field_4;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_debug_signal_1_t;

/**
 * Signals in message DEBUG_SIGNAL_1.
 *
 * Debug signals
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (-1..1 -)
     * Scale: 3.0518043793392844e-05
     * Offset: -1
     */
    float field_1;

    /**
     * Range: 0..65535 (-1..1 -)
     * Scale: 3.0518043793392844e-05
     * Offset: -1
     */
    float field_2;

    /**
     * Range: 0..65535 (-1..1 -)
     * Scale: 3.0518043793392844e-05
     * Offset: -1
     */
    float field_3;

    /**
     * Range: 0..65535 (-1..1 -)
     * Scale: 3.0518043793392844e-05
     * Offset: -1
     */
    float field_4;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_debug_signal_1_converted_t;

/**
 * Signals in message DEBUG_SIGNAL_2.
 *
 * Debug signals
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (-1..1 -)
     * Scale: 3.0518043793392844e-05
     * Offset: -1
     */
    uint16_t field_1;

    /**
     * Range: 0..65535 (-1..1 -)
     * Scale: 3.0518043793392844e-05
     * Offset: -1
     */
    uint16_t field_2;

    /**
     * Range: 0..65535 (-1..1 -)
     * Scale: 3.0518043793392844e-05
     * Offset: -1
     */
    uint16_t field_3;

    /**
     * Range: 0..65535 (-1..1 -)
     * Scale: 3.0518043793392844e-05
     * Offset: -1
     */
    uint16_t field_4;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_debug_signal_2_t;

/**
 * Signals in message DEBUG_SIGNAL_2.
 *
 * Debug signals
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (-1..1 -)
     * Scale: 3.0518043793392844e-05
     * Offset: -1
     */
    float field_1;

    /**
     * Range: 0..65535 (-1..1 -)
     * Scale: 3.0518043793392844e-05
     * Offset: -1
     */
    float field_2;

    /**
     * Range: 0..65535 (-1..1 -)
     * Scale: 3.0518043793392844e-05
     * Offset: -1
     */
    float field_3;

    /**
     * Range: 0..65535 (-1..1 -)
     * Scale: 3.0518043793392844e-05
     * Offset: -1
     */
    float field_4;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_debug_signal_2_converted_t;

/**
 * Signals in message COOLING_TEMP.
 *
 * Cooling temperature
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (-10..110 -)
     * Scale: 0.0018310826276035706
     * Offset: -10
     */
    uint16_t top_left;

    /**
     * Range: 0..65535 (-10..110 -)
     * Scale: 0.0018310826276035706
     * Offset: -10
     */
    uint16_t bottom_left;

    /**
     * Range: 0..65535 (-10..110 -)
     * Scale: 0.0018310826276035706
     * Offset: -10
     */
    uint16_t top_right;

    /**
     * Range: 0..65535 (-10..110 -)
     * Scale: 0.0018310826276035706
     * Offset: -10
     */
    uint16_t bottom_right;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_cooling_temp_t;

/**
 * Signals in message COOLING_TEMP.
 *
 * Cooling temperature
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (-10..110 -)
     * Scale: 0.0018310826276035706
     * Offset: -10
     */
    float top_left;

    /**
     * Range: 0..65535 (-10..110 -)
     * Scale: 0.0018310826276035706
     * Offset: -10
     */
    float bottom_left;

    /**
     * Range: 0..65535 (-10..110 -)
     * Scale: 0.0018310826276035706
     * Offset: -10
     */
    float top_right;

    /**
     * Range: 0..65535 (-10..110 -)
     * Scale: 0.0018310826276035706
     * Offset: -10
     */
    float bottom_right;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} secondary_cooling_temp_converted_t;


void secondary_imu_angular_rate_raw_to_conversion(
    secondary_imu_angular_rate_converted_t *conversion,
    float x,
    float y,
    float z
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_imu_angular_rate_conversion_to_raw(
    secondary_imu_angular_rate_t *raw,
    float x,
    float y,
    float z
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_imu_angular_rate_raw_to_conversion_struct(
    secondary_imu_angular_rate_converted_t *conversion, 
    const secondary_imu_angular_rate_t *raw);


void secondary_imu_angular_rate_conversion_to_raw_struct(
    secondary_imu_angular_rate_t *raw,
    const secondary_imu_angular_rate_converted_t *conversion);


int secondary_imu_angular_rate_converted_to_string(secondary_imu_angular_rate_converted_t *message, char *buffer);

int secondary_imu_angular_rate_converted_to_string_file(secondary_imu_angular_rate_converted_t *message, FILE *buffer);

int secondary_imu_angular_rate_fields(char *buffer);

int secondary_imu_angular_rate_fields_file(FILE *buffer);

/**
 * Pack message IMU_ANGULAR_RATE.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_imu_angular_rate_pack(
    uint8_t *dst_p,
    const secondary_imu_angular_rate_t *src_p,
    size_t byte_size);

/**
 * Unpack message IMU_ANGULAR_RATE.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_imu_angular_rate_unpack(
    secondary_imu_angular_rate_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t secondary_imu_angular_rate_x_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_imu_angular_rate_x_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_imu_angular_rate_x_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t secondary_imu_angular_rate_y_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_imu_angular_rate_y_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_imu_angular_rate_y_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t secondary_imu_angular_rate_z_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_imu_angular_rate_z_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_imu_angular_rate_z_is_in_range(int16_t value);


void secondary_imu_acceleration_raw_to_conversion(
    secondary_imu_acceleration_converted_t *conversion,
    float x,
    float y,
    float z,
    int16_t imu_temperature
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_imu_acceleration_conversion_to_raw(
    secondary_imu_acceleration_t *raw,
    float x,
    float y,
    float z,
    int16_t imu_temperature
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_imu_acceleration_raw_to_conversion_struct(
    secondary_imu_acceleration_converted_t *conversion, 
    const secondary_imu_acceleration_t *raw);


void secondary_imu_acceleration_conversion_to_raw_struct(
    secondary_imu_acceleration_t *raw,
    const secondary_imu_acceleration_converted_t *conversion);


int secondary_imu_acceleration_converted_to_string(secondary_imu_acceleration_converted_t *message, char *buffer);

int secondary_imu_acceleration_converted_to_string_file(secondary_imu_acceleration_converted_t *message, FILE *buffer);

int secondary_imu_acceleration_fields(char *buffer);

int secondary_imu_acceleration_fields_file(FILE *buffer);

/**
 * Pack message IMU_ACCELERATION.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_imu_acceleration_pack(
    uint8_t *dst_p,
    const secondary_imu_acceleration_t *src_p,
    size_t byte_size);

/**
 * Unpack message IMU_ACCELERATION.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_imu_acceleration_unpack(
    secondary_imu_acceleration_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t secondary_imu_acceleration_x_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_imu_acceleration_x_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_imu_acceleration_x_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t secondary_imu_acceleration_y_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_imu_acceleration_y_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_imu_acceleration_y_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t secondary_imu_acceleration_z_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_imu_acceleration_z_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_imu_acceleration_z_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_imu_acceleration_imu_temperature_is_in_range(int16_t value);


void secondary_irts_fl_0_raw_to_conversion(
    secondary_irts_fl_0_converted_t *conversion,
    float channel1,
    float channel2,
    float channel3,
    float channel4
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_irts_fl_0_conversion_to_raw(
    secondary_irts_fl_0_t *raw,
    float channel1,
    float channel2,
    float channel3,
    float channel4
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_irts_fl_0_raw_to_conversion_struct(
    secondary_irts_fl_0_converted_t *conversion, 
    const secondary_irts_fl_0_t *raw);


void secondary_irts_fl_0_conversion_to_raw_struct(
    secondary_irts_fl_0_t *raw,
    const secondary_irts_fl_0_converted_t *conversion);


int secondary_irts_fl_0_converted_to_string(secondary_irts_fl_0_converted_t *message, char *buffer);

int secondary_irts_fl_0_converted_to_string_file(secondary_irts_fl_0_converted_t *message, FILE *buffer);

int secondary_irts_fl_0_fields(char *buffer);

int secondary_irts_fl_0_fields_file(FILE *buffer);

/**
 * Pack message IRTS_FL_0.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_irts_fl_0_pack(
    uint8_t *dst_p,
    const secondary_irts_fl_0_t *src_p,
    size_t byte_size);

/**
 * Unpack message IRTS_FL_0.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_irts_fl_0_unpack(
    secondary_irts_fl_0_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_irts_fl_0_channel1_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_irts_fl_0_channel1_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_fl_0_channel1_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_irts_fl_0_channel2_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_irts_fl_0_channel2_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_fl_0_channel2_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_irts_fl_0_channel3_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_irts_fl_0_channel3_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_fl_0_channel3_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_irts_fl_0_channel4_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_irts_fl_0_channel4_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_fl_0_channel4_is_in_range(uint16_t value);


void secondary_irts_fl_1_raw_to_conversion(
    secondary_irts_fl_1_converted_t *conversion,
    float channel5,
    float channel6,
    float channel7,
    float channel8
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_irts_fl_1_conversion_to_raw(
    secondary_irts_fl_1_t *raw,
    float channel5,
    float channel6,
    float channel7,
    float channel8
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_irts_fl_1_raw_to_conversion_struct(
    secondary_irts_fl_1_converted_t *conversion, 
    const secondary_irts_fl_1_t *raw);


void secondary_irts_fl_1_conversion_to_raw_struct(
    secondary_irts_fl_1_t *raw,
    const secondary_irts_fl_1_converted_t *conversion);


int secondary_irts_fl_1_converted_to_string(secondary_irts_fl_1_converted_t *message, char *buffer);

int secondary_irts_fl_1_converted_to_string_file(secondary_irts_fl_1_converted_t *message, FILE *buffer);

int secondary_irts_fl_1_fields(char *buffer);

int secondary_irts_fl_1_fields_file(FILE *buffer);

/**
 * Pack message IRTS_FL_1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_irts_fl_1_pack(
    uint8_t *dst_p,
    const secondary_irts_fl_1_t *src_p,
    size_t byte_size);

/**
 * Unpack message IRTS_FL_1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_irts_fl_1_unpack(
    secondary_irts_fl_1_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_irts_fl_1_channel5_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_irts_fl_1_channel5_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_fl_1_channel5_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_irts_fl_1_channel6_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_irts_fl_1_channel6_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_fl_1_channel6_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_irts_fl_1_channel7_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_irts_fl_1_channel7_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_fl_1_channel7_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_irts_fl_1_channel8_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_irts_fl_1_channel8_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_fl_1_channel8_is_in_range(uint16_t value);


void secondary_irts_fl_2_raw_to_conversion(
    secondary_irts_fl_2_converted_t *conversion,
    float channel9,
    float channel10,
    float channel11,
    float channel12
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_irts_fl_2_conversion_to_raw(
    secondary_irts_fl_2_t *raw,
    float channel9,
    float channel10,
    float channel11,
    float channel12
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_irts_fl_2_raw_to_conversion_struct(
    secondary_irts_fl_2_converted_t *conversion, 
    const secondary_irts_fl_2_t *raw);


void secondary_irts_fl_2_conversion_to_raw_struct(
    secondary_irts_fl_2_t *raw,
    const secondary_irts_fl_2_converted_t *conversion);


int secondary_irts_fl_2_converted_to_string(secondary_irts_fl_2_converted_t *message, char *buffer);

int secondary_irts_fl_2_converted_to_string_file(secondary_irts_fl_2_converted_t *message, FILE *buffer);

int secondary_irts_fl_2_fields(char *buffer);

int secondary_irts_fl_2_fields_file(FILE *buffer);

/**
 * Pack message IRTS_FL_2.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_irts_fl_2_pack(
    uint8_t *dst_p,
    const secondary_irts_fl_2_t *src_p,
    size_t byte_size);

/**
 * Unpack message IRTS_FL_2.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_irts_fl_2_unpack(
    secondary_irts_fl_2_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_irts_fl_2_channel9_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_irts_fl_2_channel9_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_fl_2_channel9_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_irts_fl_2_channel10_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_irts_fl_2_channel10_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_fl_2_channel10_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_irts_fl_2_channel11_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_irts_fl_2_channel11_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_fl_2_channel11_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_irts_fl_2_channel12_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_irts_fl_2_channel12_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_fl_2_channel12_is_in_range(uint16_t value);


void secondary_irts_fl_3_raw_to_conversion(
    secondary_irts_fl_3_converted_t *conversion,
    float channel13,
    float channel14,
    float channel15,
    float channel16
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_irts_fl_3_conversion_to_raw(
    secondary_irts_fl_3_t *raw,
    float channel13,
    float channel14,
    float channel15,
    float channel16
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_irts_fl_3_raw_to_conversion_struct(
    secondary_irts_fl_3_converted_t *conversion, 
    const secondary_irts_fl_3_t *raw);


void secondary_irts_fl_3_conversion_to_raw_struct(
    secondary_irts_fl_3_t *raw,
    const secondary_irts_fl_3_converted_t *conversion);


int secondary_irts_fl_3_converted_to_string(secondary_irts_fl_3_converted_t *message, char *buffer);

int secondary_irts_fl_3_converted_to_string_file(secondary_irts_fl_3_converted_t *message, FILE *buffer);

int secondary_irts_fl_3_fields(char *buffer);

int secondary_irts_fl_3_fields_file(FILE *buffer);

/**
 * Pack message IRTS_FL_3.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_irts_fl_3_pack(
    uint8_t *dst_p,
    const secondary_irts_fl_3_t *src_p,
    size_t byte_size);

/**
 * Unpack message IRTS_FL_3.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_irts_fl_3_unpack(
    secondary_irts_fl_3_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_irts_fl_3_channel13_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_irts_fl_3_channel13_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_fl_3_channel13_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_irts_fl_3_channel14_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_irts_fl_3_channel14_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_fl_3_channel14_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_irts_fl_3_channel15_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_irts_fl_3_channel15_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_fl_3_channel15_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_irts_fl_3_channel16_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_irts_fl_3_channel16_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_fl_3_channel16_is_in_range(uint16_t value);


void secondary_irts_fr_0_raw_to_conversion(
    secondary_irts_fr_0_converted_t *conversion,
    float channel1,
    float channel2,
    float channel3,
    float channel4
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_irts_fr_0_conversion_to_raw(
    secondary_irts_fr_0_t *raw,
    float channel1,
    float channel2,
    float channel3,
    float channel4
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_irts_fr_0_raw_to_conversion_struct(
    secondary_irts_fr_0_converted_t *conversion, 
    const secondary_irts_fr_0_t *raw);


void secondary_irts_fr_0_conversion_to_raw_struct(
    secondary_irts_fr_0_t *raw,
    const secondary_irts_fr_0_converted_t *conversion);


int secondary_irts_fr_0_converted_to_string(secondary_irts_fr_0_converted_t *message, char *buffer);

int secondary_irts_fr_0_converted_to_string_file(secondary_irts_fr_0_converted_t *message, FILE *buffer);

int secondary_irts_fr_0_fields(char *buffer);

int secondary_irts_fr_0_fields_file(FILE *buffer);

/**
 * Pack message IRTS_FR_0.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_irts_fr_0_pack(
    uint8_t *dst_p,
    const secondary_irts_fr_0_t *src_p,
    size_t byte_size);

/**
 * Unpack message IRTS_FR_0.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_irts_fr_0_unpack(
    secondary_irts_fr_0_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_irts_fr_0_channel1_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_irts_fr_0_channel1_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_fr_0_channel1_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_irts_fr_0_channel2_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_irts_fr_0_channel2_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_fr_0_channel2_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_irts_fr_0_channel3_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_irts_fr_0_channel3_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_fr_0_channel3_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_irts_fr_0_channel4_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_irts_fr_0_channel4_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_fr_0_channel4_is_in_range(uint16_t value);


void secondary_irts_fr_1_raw_to_conversion(
    secondary_irts_fr_1_converted_t *conversion,
    float channel5,
    float channel6,
    float channel7,
    float channel8
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_irts_fr_1_conversion_to_raw(
    secondary_irts_fr_1_t *raw,
    float channel5,
    float channel6,
    float channel7,
    float channel8
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_irts_fr_1_raw_to_conversion_struct(
    secondary_irts_fr_1_converted_t *conversion, 
    const secondary_irts_fr_1_t *raw);


void secondary_irts_fr_1_conversion_to_raw_struct(
    secondary_irts_fr_1_t *raw,
    const secondary_irts_fr_1_converted_t *conversion);


int secondary_irts_fr_1_converted_to_string(secondary_irts_fr_1_converted_t *message, char *buffer);

int secondary_irts_fr_1_converted_to_string_file(secondary_irts_fr_1_converted_t *message, FILE *buffer);

int secondary_irts_fr_1_fields(char *buffer);

int secondary_irts_fr_1_fields_file(FILE *buffer);

/**
 * Pack message IRTS_FR_1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_irts_fr_1_pack(
    uint8_t *dst_p,
    const secondary_irts_fr_1_t *src_p,
    size_t byte_size);

/**
 * Unpack message IRTS_FR_1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_irts_fr_1_unpack(
    secondary_irts_fr_1_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_irts_fr_1_channel5_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_irts_fr_1_channel5_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_fr_1_channel5_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_irts_fr_1_channel6_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_irts_fr_1_channel6_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_fr_1_channel6_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_irts_fr_1_channel7_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_irts_fr_1_channel7_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_fr_1_channel7_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_irts_fr_1_channel8_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_irts_fr_1_channel8_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_fr_1_channel8_is_in_range(uint16_t value);


void secondary_irts_fr_2_raw_to_conversion(
    secondary_irts_fr_2_converted_t *conversion,
    float channel9,
    float channel10,
    float channel11,
    float channel12
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_irts_fr_2_conversion_to_raw(
    secondary_irts_fr_2_t *raw,
    float channel9,
    float channel10,
    float channel11,
    float channel12
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_irts_fr_2_raw_to_conversion_struct(
    secondary_irts_fr_2_converted_t *conversion, 
    const secondary_irts_fr_2_t *raw);


void secondary_irts_fr_2_conversion_to_raw_struct(
    secondary_irts_fr_2_t *raw,
    const secondary_irts_fr_2_converted_t *conversion);


int secondary_irts_fr_2_converted_to_string(secondary_irts_fr_2_converted_t *message, char *buffer);

int secondary_irts_fr_2_converted_to_string_file(secondary_irts_fr_2_converted_t *message, FILE *buffer);

int secondary_irts_fr_2_fields(char *buffer);

int secondary_irts_fr_2_fields_file(FILE *buffer);

/**
 * Pack message IRTS_FR_2.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_irts_fr_2_pack(
    uint8_t *dst_p,
    const secondary_irts_fr_2_t *src_p,
    size_t byte_size);

/**
 * Unpack message IRTS_FR_2.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_irts_fr_2_unpack(
    secondary_irts_fr_2_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_irts_fr_2_channel9_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_irts_fr_2_channel9_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_fr_2_channel9_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_irts_fr_2_channel10_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_irts_fr_2_channel10_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_fr_2_channel10_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_irts_fr_2_channel11_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_irts_fr_2_channel11_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_fr_2_channel11_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_irts_fr_2_channel12_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_irts_fr_2_channel12_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_fr_2_channel12_is_in_range(uint16_t value);


void secondary_irts_fr_3_raw_to_conversion(
    secondary_irts_fr_3_converted_t *conversion,
    float channel13,
    float channel14,
    float channel15,
    float channel16
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_irts_fr_3_conversion_to_raw(
    secondary_irts_fr_3_t *raw,
    float channel13,
    float channel14,
    float channel15,
    float channel16
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_irts_fr_3_raw_to_conversion_struct(
    secondary_irts_fr_3_converted_t *conversion, 
    const secondary_irts_fr_3_t *raw);


void secondary_irts_fr_3_conversion_to_raw_struct(
    secondary_irts_fr_3_t *raw,
    const secondary_irts_fr_3_converted_t *conversion);


int secondary_irts_fr_3_converted_to_string(secondary_irts_fr_3_converted_t *message, char *buffer);

int secondary_irts_fr_3_converted_to_string_file(secondary_irts_fr_3_converted_t *message, FILE *buffer);

int secondary_irts_fr_3_fields(char *buffer);

int secondary_irts_fr_3_fields_file(FILE *buffer);

/**
 * Pack message IRTS_FR_3.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_irts_fr_3_pack(
    uint8_t *dst_p,
    const secondary_irts_fr_3_t *src_p,
    size_t byte_size);

/**
 * Unpack message IRTS_FR_3.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_irts_fr_3_unpack(
    secondary_irts_fr_3_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_irts_fr_3_channel13_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_irts_fr_3_channel13_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_fr_3_channel13_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_irts_fr_3_channel14_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_irts_fr_3_channel14_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_fr_3_channel14_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_irts_fr_3_channel15_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_irts_fr_3_channel15_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_fr_3_channel15_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_irts_fr_3_channel16_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_irts_fr_3_channel16_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_fr_3_channel16_is_in_range(uint16_t value);


void secondary_irts_rl_0_raw_to_conversion(
    secondary_irts_rl_0_converted_t *conversion,
    float channel1,
    float channel2,
    float channel3,
    float channel4
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_irts_rl_0_conversion_to_raw(
    secondary_irts_rl_0_t *raw,
    float channel1,
    float channel2,
    float channel3,
    float channel4
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_irts_rl_0_raw_to_conversion_struct(
    secondary_irts_rl_0_converted_t *conversion, 
    const secondary_irts_rl_0_t *raw);


void secondary_irts_rl_0_conversion_to_raw_struct(
    secondary_irts_rl_0_t *raw,
    const secondary_irts_rl_0_converted_t *conversion);


int secondary_irts_rl_0_converted_to_string(secondary_irts_rl_0_converted_t *message, char *buffer);

int secondary_irts_rl_0_converted_to_string_file(secondary_irts_rl_0_converted_t *message, FILE *buffer);

int secondary_irts_rl_0_fields(char *buffer);

int secondary_irts_rl_0_fields_file(FILE *buffer);

/**
 * Pack message IRTS_RL_0.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_irts_rl_0_pack(
    uint8_t *dst_p,
    const secondary_irts_rl_0_t *src_p,
    size_t byte_size);

/**
 * Unpack message IRTS_RL_0.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_irts_rl_0_unpack(
    secondary_irts_rl_0_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_irts_rl_0_channel1_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_irts_rl_0_channel1_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_rl_0_channel1_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_irts_rl_0_channel2_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_irts_rl_0_channel2_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_rl_0_channel2_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_irts_rl_0_channel3_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_irts_rl_0_channel3_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_rl_0_channel3_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_irts_rl_0_channel4_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_irts_rl_0_channel4_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_rl_0_channel4_is_in_range(uint16_t value);


void secondary_irts_rl_1_raw_to_conversion(
    secondary_irts_rl_1_converted_t *conversion,
    float channel5,
    float channel6,
    float channel7,
    float channel8
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_irts_rl_1_conversion_to_raw(
    secondary_irts_rl_1_t *raw,
    float channel5,
    float channel6,
    float channel7,
    float channel8
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_irts_rl_1_raw_to_conversion_struct(
    secondary_irts_rl_1_converted_t *conversion, 
    const secondary_irts_rl_1_t *raw);


void secondary_irts_rl_1_conversion_to_raw_struct(
    secondary_irts_rl_1_t *raw,
    const secondary_irts_rl_1_converted_t *conversion);


int secondary_irts_rl_1_converted_to_string(secondary_irts_rl_1_converted_t *message, char *buffer);

int secondary_irts_rl_1_converted_to_string_file(secondary_irts_rl_1_converted_t *message, FILE *buffer);

int secondary_irts_rl_1_fields(char *buffer);

int secondary_irts_rl_1_fields_file(FILE *buffer);

/**
 * Pack message IRTS_RL_1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_irts_rl_1_pack(
    uint8_t *dst_p,
    const secondary_irts_rl_1_t *src_p,
    size_t byte_size);

/**
 * Unpack message IRTS_RL_1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_irts_rl_1_unpack(
    secondary_irts_rl_1_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_irts_rl_1_channel5_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_irts_rl_1_channel5_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_rl_1_channel5_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_irts_rl_1_channel6_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_irts_rl_1_channel6_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_rl_1_channel6_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_irts_rl_1_channel7_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_irts_rl_1_channel7_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_rl_1_channel7_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_irts_rl_1_channel8_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_irts_rl_1_channel8_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_rl_1_channel8_is_in_range(uint16_t value);


void secondary_irts_rl_2_raw_to_conversion(
    secondary_irts_rl_2_converted_t *conversion,
    float channel9,
    float channel10,
    float channel11,
    float channel12
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_irts_rl_2_conversion_to_raw(
    secondary_irts_rl_2_t *raw,
    float channel9,
    float channel10,
    float channel11,
    float channel12
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_irts_rl_2_raw_to_conversion_struct(
    secondary_irts_rl_2_converted_t *conversion, 
    const secondary_irts_rl_2_t *raw);


void secondary_irts_rl_2_conversion_to_raw_struct(
    secondary_irts_rl_2_t *raw,
    const secondary_irts_rl_2_converted_t *conversion);


int secondary_irts_rl_2_converted_to_string(secondary_irts_rl_2_converted_t *message, char *buffer);

int secondary_irts_rl_2_converted_to_string_file(secondary_irts_rl_2_converted_t *message, FILE *buffer);

int secondary_irts_rl_2_fields(char *buffer);

int secondary_irts_rl_2_fields_file(FILE *buffer);

/**
 * Pack message IRTS_RL_2.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_irts_rl_2_pack(
    uint8_t *dst_p,
    const secondary_irts_rl_2_t *src_p,
    size_t byte_size);

/**
 * Unpack message IRTS_RL_2.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_irts_rl_2_unpack(
    secondary_irts_rl_2_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_irts_rl_2_channel9_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_irts_rl_2_channel9_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_rl_2_channel9_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_irts_rl_2_channel10_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_irts_rl_2_channel10_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_rl_2_channel10_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_irts_rl_2_channel11_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_irts_rl_2_channel11_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_rl_2_channel11_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_irts_rl_2_channel12_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_irts_rl_2_channel12_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_rl_2_channel12_is_in_range(uint16_t value);


void secondary_irts_rl_3_raw_to_conversion(
    secondary_irts_rl_3_converted_t *conversion,
    float channel13,
    float channel14,
    float channel15,
    float channel16
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_irts_rl_3_conversion_to_raw(
    secondary_irts_rl_3_t *raw,
    float channel13,
    float channel14,
    float channel15,
    float channel16
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_irts_rl_3_raw_to_conversion_struct(
    secondary_irts_rl_3_converted_t *conversion, 
    const secondary_irts_rl_3_t *raw);


void secondary_irts_rl_3_conversion_to_raw_struct(
    secondary_irts_rl_3_t *raw,
    const secondary_irts_rl_3_converted_t *conversion);


int secondary_irts_rl_3_converted_to_string(secondary_irts_rl_3_converted_t *message, char *buffer);

int secondary_irts_rl_3_converted_to_string_file(secondary_irts_rl_3_converted_t *message, FILE *buffer);

int secondary_irts_rl_3_fields(char *buffer);

int secondary_irts_rl_3_fields_file(FILE *buffer);

/**
 * Pack message IRTS_RL_3.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_irts_rl_3_pack(
    uint8_t *dst_p,
    const secondary_irts_rl_3_t *src_p,
    size_t byte_size);

/**
 * Unpack message IRTS_RL_3.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_irts_rl_3_unpack(
    secondary_irts_rl_3_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_irts_rl_3_channel13_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_irts_rl_3_channel13_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_rl_3_channel13_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_irts_rl_3_channel14_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_irts_rl_3_channel14_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_rl_3_channel14_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_irts_rl_3_channel15_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_irts_rl_3_channel15_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_rl_3_channel15_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_irts_rl_3_channel16_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_irts_rl_3_channel16_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_rl_3_channel16_is_in_range(uint16_t value);


void secondary_irts_rr_0_raw_to_conversion(
    secondary_irts_rr_0_converted_t *conversion,
    float channel1,
    float channel2,
    float channel3,
    float channel4
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_irts_rr_0_conversion_to_raw(
    secondary_irts_rr_0_t *raw,
    float channel1,
    float channel2,
    float channel3,
    float channel4
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_irts_rr_0_raw_to_conversion_struct(
    secondary_irts_rr_0_converted_t *conversion, 
    const secondary_irts_rr_0_t *raw);


void secondary_irts_rr_0_conversion_to_raw_struct(
    secondary_irts_rr_0_t *raw,
    const secondary_irts_rr_0_converted_t *conversion);


int secondary_irts_rr_0_converted_to_string(secondary_irts_rr_0_converted_t *message, char *buffer);

int secondary_irts_rr_0_converted_to_string_file(secondary_irts_rr_0_converted_t *message, FILE *buffer);

int secondary_irts_rr_0_fields(char *buffer);

int secondary_irts_rr_0_fields_file(FILE *buffer);

/**
 * Pack message IRTS_RR_0.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_irts_rr_0_pack(
    uint8_t *dst_p,
    const secondary_irts_rr_0_t *src_p,
    size_t byte_size);

/**
 * Unpack message IRTS_RR_0.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_irts_rr_0_unpack(
    secondary_irts_rr_0_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_irts_rr_0_channel1_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_irts_rr_0_channel1_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_rr_0_channel1_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_irts_rr_0_channel2_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_irts_rr_0_channel2_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_rr_0_channel2_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_irts_rr_0_channel3_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_irts_rr_0_channel3_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_rr_0_channel3_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_irts_rr_0_channel4_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_irts_rr_0_channel4_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_rr_0_channel4_is_in_range(uint16_t value);


void secondary_irts_rr_1_raw_to_conversion(
    secondary_irts_rr_1_converted_t *conversion,
    float channel5,
    float channel6,
    float channel7,
    float channel8
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_irts_rr_1_conversion_to_raw(
    secondary_irts_rr_1_t *raw,
    float channel5,
    float channel6,
    float channel7,
    float channel8
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_irts_rr_1_raw_to_conversion_struct(
    secondary_irts_rr_1_converted_t *conversion, 
    const secondary_irts_rr_1_t *raw);


void secondary_irts_rr_1_conversion_to_raw_struct(
    secondary_irts_rr_1_t *raw,
    const secondary_irts_rr_1_converted_t *conversion);


int secondary_irts_rr_1_converted_to_string(secondary_irts_rr_1_converted_t *message, char *buffer);

int secondary_irts_rr_1_converted_to_string_file(secondary_irts_rr_1_converted_t *message, FILE *buffer);

int secondary_irts_rr_1_fields(char *buffer);

int secondary_irts_rr_1_fields_file(FILE *buffer);

/**
 * Pack message IRTS_RR_1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_irts_rr_1_pack(
    uint8_t *dst_p,
    const secondary_irts_rr_1_t *src_p,
    size_t byte_size);

/**
 * Unpack message IRTS_RR_1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_irts_rr_1_unpack(
    secondary_irts_rr_1_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_irts_rr_1_channel5_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_irts_rr_1_channel5_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_rr_1_channel5_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_irts_rr_1_channel6_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_irts_rr_1_channel6_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_rr_1_channel6_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_irts_rr_1_channel7_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_irts_rr_1_channel7_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_rr_1_channel7_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_irts_rr_1_channel8_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_irts_rr_1_channel8_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_rr_1_channel8_is_in_range(uint16_t value);


void secondary_irts_rr_2_raw_to_conversion(
    secondary_irts_rr_2_converted_t *conversion,
    float channel9,
    float channel10,
    float channel11,
    float channel12
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_irts_rr_2_conversion_to_raw(
    secondary_irts_rr_2_t *raw,
    float channel9,
    float channel10,
    float channel11,
    float channel12
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_irts_rr_2_raw_to_conversion_struct(
    secondary_irts_rr_2_converted_t *conversion, 
    const secondary_irts_rr_2_t *raw);


void secondary_irts_rr_2_conversion_to_raw_struct(
    secondary_irts_rr_2_t *raw,
    const secondary_irts_rr_2_converted_t *conversion);


int secondary_irts_rr_2_converted_to_string(secondary_irts_rr_2_converted_t *message, char *buffer);

int secondary_irts_rr_2_converted_to_string_file(secondary_irts_rr_2_converted_t *message, FILE *buffer);

int secondary_irts_rr_2_fields(char *buffer);

int secondary_irts_rr_2_fields_file(FILE *buffer);

/**
 * Pack message IRTS_RR_2.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_irts_rr_2_pack(
    uint8_t *dst_p,
    const secondary_irts_rr_2_t *src_p,
    size_t byte_size);

/**
 * Unpack message IRTS_RR_2.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_irts_rr_2_unpack(
    secondary_irts_rr_2_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_irts_rr_2_channel9_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_irts_rr_2_channel9_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_rr_2_channel9_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_irts_rr_2_channel10_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_irts_rr_2_channel10_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_rr_2_channel10_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_irts_rr_2_channel11_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_irts_rr_2_channel11_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_rr_2_channel11_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_irts_rr_2_channel12_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_irts_rr_2_channel12_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_rr_2_channel12_is_in_range(uint16_t value);


void secondary_irts_rr_3_raw_to_conversion(
    secondary_irts_rr_3_converted_t *conversion,
    float channel13,
    float channel14,
    float channel15,
    float channel16
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_irts_rr_3_conversion_to_raw(
    secondary_irts_rr_3_t *raw,
    float channel13,
    float channel14,
    float channel15,
    float channel16
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_irts_rr_3_raw_to_conversion_struct(
    secondary_irts_rr_3_converted_t *conversion, 
    const secondary_irts_rr_3_t *raw);


void secondary_irts_rr_3_conversion_to_raw_struct(
    secondary_irts_rr_3_t *raw,
    const secondary_irts_rr_3_converted_t *conversion);


int secondary_irts_rr_3_converted_to_string(secondary_irts_rr_3_converted_t *message, char *buffer);

int secondary_irts_rr_3_converted_to_string_file(secondary_irts_rr_3_converted_t *message, FILE *buffer);

int secondary_irts_rr_3_fields(char *buffer);

int secondary_irts_rr_3_fields_file(FILE *buffer);

/**
 * Pack message IRTS_RR_3.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_irts_rr_3_pack(
    uint8_t *dst_p,
    const secondary_irts_rr_3_t *src_p,
    size_t byte_size);

/**
 * Unpack message IRTS_RR_3.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_irts_rr_3_unpack(
    secondary_irts_rr_3_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_irts_rr_3_channel13_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_irts_rr_3_channel13_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_rr_3_channel13_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_irts_rr_3_channel14_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_irts_rr_3_channel14_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_rr_3_channel14_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_irts_rr_3_channel15_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_irts_rr_3_channel15_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_rr_3_channel15_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_irts_rr_3_channel16_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_irts_rr_3_channel16_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_irts_rr_3_channel16_is_in_range(uint16_t value);


void secondary_gps_coords_raw_to_conversion(
    secondary_gps_coords_converted_t *conversion,
    uint32_t latitude,
    uint32_t longitude
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_gps_coords_conversion_to_raw(
    secondary_gps_coords_t *raw,
    uint32_t latitude,
    uint32_t longitude
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_gps_coords_raw_to_conversion_struct(
    secondary_gps_coords_converted_t *conversion, 
    const secondary_gps_coords_t *raw);


void secondary_gps_coords_conversion_to_raw_struct(
    secondary_gps_coords_t *raw,
    const secondary_gps_coords_converted_t *conversion);


int secondary_gps_coords_to_string(secondary_gps_coords_t *message, char *buffer);

int secondary_gps_coords_to_string_file(secondary_gps_coords_t *message, FILE *buffer);

int secondary_gps_coords_fields(char *buffer);

int secondary_gps_coords_fields_file(FILE *buffer);

/**
 * Pack message GPS_COORDS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_gps_coords_pack(
    uint8_t *dst_p,
    const secondary_gps_coords_t *src_p,
    size_t byte_size);

/**
 * Unpack message GPS_COORDS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_gps_coords_unpack(
    secondary_gps_coords_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_gps_coords_latitude_is_in_range(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_gps_coords_longitude_is_in_range(uint32_t value);


void secondary_gps_speed_raw_to_conversion(
    secondary_gps_speed_converted_t *conversion,
    uint16_t speed
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_gps_speed_conversion_to_raw(
    secondary_gps_speed_t *raw,
    uint16_t speed
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_gps_speed_raw_to_conversion_struct(
    secondary_gps_speed_converted_t *conversion, 
    const secondary_gps_speed_t *raw);


void secondary_gps_speed_conversion_to_raw_struct(
    secondary_gps_speed_t *raw,
    const secondary_gps_speed_converted_t *conversion);


int secondary_gps_speed_to_string(secondary_gps_speed_t *message, char *buffer);

int secondary_gps_speed_to_string_file(secondary_gps_speed_t *message, FILE *buffer);

int secondary_gps_speed_fields(char *buffer);

int secondary_gps_speed_fields_file(FILE *buffer);

/**
 * Pack message GPS_SPEED.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_gps_speed_pack(
    uint8_t *dst_p,
    const secondary_gps_speed_t *src_p,
    size_t byte_size);

/**
 * Unpack message GPS_SPEED.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_gps_speed_unpack(
    secondary_gps_speed_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_gps_speed_speed_is_in_range(uint16_t value);


void secondary_angular_velocity_raw_to_conversion(
    secondary_angular_velocity_converted_t *conversion,
    float fl,
    float fr
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_angular_velocity_conversion_to_raw(
    secondary_angular_velocity_t *raw,
    float fl,
    float fr
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_angular_velocity_raw_to_conversion_struct(
    secondary_angular_velocity_converted_t *conversion, 
    const secondary_angular_velocity_t *raw);


void secondary_angular_velocity_conversion_to_raw_struct(
    secondary_angular_velocity_t *raw,
    const secondary_angular_velocity_converted_t *conversion);


int secondary_angular_velocity_converted_to_string(secondary_angular_velocity_converted_t *message, char *buffer);

int secondary_angular_velocity_converted_to_string_file(secondary_angular_velocity_converted_t *message, FILE *buffer);

int secondary_angular_velocity_fields(char *buffer);

int secondary_angular_velocity_fields_file(FILE *buffer);

/**
 * Pack message ANGULAR_VELOCITY.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_angular_velocity_pack(
    uint8_t *dst_p,
    const secondary_angular_velocity_t *src_p,
    size_t byte_size);

/**
 * Unpack message ANGULAR_VELOCITY.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_angular_velocity_unpack(
    secondary_angular_velocity_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_angular_velocity_fl_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_angular_velocity_fl_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_angular_velocity_fl_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_angular_velocity_fr_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_angular_velocity_fr_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_angular_velocity_fr_is_in_range(uint16_t value);


void secondary_pedal_throttle_raw_to_conversion(
    secondary_pedal_throttle_converted_t *conversion,
    float throttle
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_pedal_throttle_conversion_to_raw(
    secondary_pedal_throttle_t *raw,
    float throttle
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_pedal_throttle_raw_to_conversion_struct(
    secondary_pedal_throttle_converted_t *conversion, 
    const secondary_pedal_throttle_t *raw);


void secondary_pedal_throttle_conversion_to_raw_struct(
    secondary_pedal_throttle_t *raw,
    const secondary_pedal_throttle_converted_t *conversion);


int secondary_pedal_throttle_converted_to_string(secondary_pedal_throttle_converted_t *message, char *buffer);

int secondary_pedal_throttle_converted_to_string_file(secondary_pedal_throttle_converted_t *message, FILE *buffer);

int secondary_pedal_throttle_fields(char *buffer);

int secondary_pedal_throttle_fields_file(FILE *buffer);

/**
 * Pack message PEDAL_THROTTLE.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_pedal_throttle_pack(
    uint8_t *dst_p,
    const secondary_pedal_throttle_t *src_p,
    size_t byte_size);

/**
 * Unpack message PEDAL_THROTTLE.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_pedal_throttle_unpack(
    secondary_pedal_throttle_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_pedal_throttle_throttle_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_pedal_throttle_throttle_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_pedal_throttle_throttle_is_in_range(uint16_t value);


void secondary_pedal_brakes_pressure_raw_to_conversion(
    secondary_pedal_brakes_pressure_converted_t *conversion,
    float front,
    float rear
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_pedal_brakes_pressure_conversion_to_raw(
    secondary_pedal_brakes_pressure_t *raw,
    float front,
    float rear
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_pedal_brakes_pressure_raw_to_conversion_struct(
    secondary_pedal_brakes_pressure_converted_t *conversion, 
    const secondary_pedal_brakes_pressure_t *raw);


void secondary_pedal_brakes_pressure_conversion_to_raw_struct(
    secondary_pedal_brakes_pressure_t *raw,
    const secondary_pedal_brakes_pressure_converted_t *conversion);


int secondary_pedal_brakes_pressure_converted_to_string(secondary_pedal_brakes_pressure_converted_t *message, char *buffer);

int secondary_pedal_brakes_pressure_converted_to_string_file(secondary_pedal_brakes_pressure_converted_t *message, FILE *buffer);

int secondary_pedal_brakes_pressure_fields(char *buffer);

int secondary_pedal_brakes_pressure_fields_file(FILE *buffer);

/**
 * Pack message PEDAL_BRAKES_PRESSURE.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_pedal_brakes_pressure_pack(
    uint8_t *dst_p,
    const secondary_pedal_brakes_pressure_t *src_p,
    size_t byte_size);

/**
 * Unpack message PEDAL_BRAKES_PRESSURE.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_pedal_brakes_pressure_unpack(
    secondary_pedal_brakes_pressure_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_pedal_brakes_pressure_front_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_pedal_brakes_pressure_front_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_pedal_brakes_pressure_front_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_pedal_brakes_pressure_rear_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_pedal_brakes_pressure_rear_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_pedal_brakes_pressure_rear_is_in_range(uint16_t value);


void secondary_steer_angle_raw_to_conversion(
    secondary_steer_angle_converted_t *conversion,
    float angle
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_steer_angle_conversion_to_raw(
    secondary_steer_angle_t *raw,
    float angle
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_steer_angle_raw_to_conversion_struct(
    secondary_steer_angle_converted_t *conversion, 
    const secondary_steer_angle_t *raw);


void secondary_steer_angle_conversion_to_raw_struct(
    secondary_steer_angle_t *raw,
    const secondary_steer_angle_converted_t *conversion);


int secondary_steer_angle_converted_to_string(secondary_steer_angle_converted_t *message, char *buffer);

int secondary_steer_angle_converted_to_string_file(secondary_steer_angle_converted_t *message, FILE *buffer);

int secondary_steer_angle_fields(char *buffer);

int secondary_steer_angle_fields_file(FILE *buffer);

/**
 * Pack message STEER_ANGLE.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_steer_angle_pack(
    uint8_t *dst_p,
    const secondary_steer_angle_t *src_p,
    size_t byte_size);

/**
 * Unpack message STEER_ANGLE.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_steer_angle_unpack(
    secondary_steer_angle_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t secondary_steer_angle_angle_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_steer_angle_angle_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_steer_angle_angle_is_in_range(uint32_t value);


void secondary_tpms_pressure_raw_to_conversion(
    secondary_tpms_pressure_converted_t *conversion,
    uint8_t fl,
    uint8_t fr,
    uint8_t rl,
    uint8_t rr
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_tpms_pressure_conversion_to_raw(
    secondary_tpms_pressure_t *raw,
    uint8_t fl,
    uint8_t fr,
    uint8_t rl,
    uint8_t rr
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_tpms_pressure_raw_to_conversion_struct(
    secondary_tpms_pressure_converted_t *conversion, 
    const secondary_tpms_pressure_t *raw);


void secondary_tpms_pressure_conversion_to_raw_struct(
    secondary_tpms_pressure_t *raw,
    const secondary_tpms_pressure_converted_t *conversion);


int secondary_tpms_pressure_to_string(secondary_tpms_pressure_t *message, char *buffer);

int secondary_tpms_pressure_to_string_file(secondary_tpms_pressure_t *message, FILE *buffer);

int secondary_tpms_pressure_fields(char *buffer);

int secondary_tpms_pressure_fields_file(FILE *buffer);

/**
 * Pack message TPMS_PRESSURE.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_tpms_pressure_pack(
    uint8_t *dst_p,
    const secondary_tpms_pressure_t *src_p,
    size_t byte_size);

/**
 * Unpack message TPMS_PRESSURE.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_tpms_pressure_unpack(
    secondary_tpms_pressure_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_tpms_pressure_fl_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_tpms_pressure_fr_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_tpms_pressure_rl_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_tpms_pressure_rr_is_in_range(uint8_t value);


void secondary_tpms_temperature_raw_to_conversion(
    secondary_tpms_temperature_converted_t *conversion,
    uint8_t fl,
    uint8_t fr,
    uint8_t rl,
    uint8_t rr
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_tpms_temperature_conversion_to_raw(
    secondary_tpms_temperature_t *raw,
    uint8_t fl,
    uint8_t fr,
    uint8_t rl,
    uint8_t rr
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_tpms_temperature_raw_to_conversion_struct(
    secondary_tpms_temperature_converted_t *conversion, 
    const secondary_tpms_temperature_t *raw);


void secondary_tpms_temperature_conversion_to_raw_struct(
    secondary_tpms_temperature_t *raw,
    const secondary_tpms_temperature_converted_t *conversion);


int secondary_tpms_temperature_to_string(secondary_tpms_temperature_t *message, char *buffer);

int secondary_tpms_temperature_to_string_file(secondary_tpms_temperature_t *message, FILE *buffer);

int secondary_tpms_temperature_fields(char *buffer);

int secondary_tpms_temperature_fields_file(FILE *buffer);

/**
 * Pack message TPMS_TEMPERATURE.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_tpms_temperature_pack(
    uint8_t *dst_p,
    const secondary_tpms_temperature_t *src_p,
    size_t byte_size);

/**
 * Unpack message TPMS_TEMPERATURE.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_tpms_temperature_unpack(
    secondary_tpms_temperature_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_tpms_temperature_fl_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_tpms_temperature_fr_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_tpms_temperature_rl_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_tpms_temperature_rr_is_in_range(uint8_t value);


void secondary_tlm_unix_timestamp_raw_to_conversion(
    secondary_tlm_unix_timestamp_converted_t *conversion,
    uint64_t timestamp
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_tlm_unix_timestamp_conversion_to_raw(
    secondary_tlm_unix_timestamp_t *raw,
    uint64_t timestamp
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_tlm_unix_timestamp_raw_to_conversion_struct(
    secondary_tlm_unix_timestamp_converted_t *conversion, 
    const secondary_tlm_unix_timestamp_t *raw);


void secondary_tlm_unix_timestamp_conversion_to_raw_struct(
    secondary_tlm_unix_timestamp_t *raw,
    const secondary_tlm_unix_timestamp_converted_t *conversion);


int secondary_tlm_unix_timestamp_to_string(secondary_tlm_unix_timestamp_t *message, char *buffer);

int secondary_tlm_unix_timestamp_to_string_file(secondary_tlm_unix_timestamp_t *message, FILE *buffer);

int secondary_tlm_unix_timestamp_fields(char *buffer);

int secondary_tlm_unix_timestamp_fields_file(FILE *buffer);

/**
 * Pack message TLM_UNIX_TIMESTAMP.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_tlm_unix_timestamp_pack(
    uint8_t *dst_p,
    const secondary_tlm_unix_timestamp_t *src_p,
    size_t byte_size);

/**
 * Unpack message TLM_UNIX_TIMESTAMP.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_tlm_unix_timestamp_unpack(
    secondary_tlm_unix_timestamp_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_tlm_unix_timestamp_timestamp_is_in_range(uint64_t value);


void secondary_tlm_lap_time_raw_to_conversion(
    secondary_tlm_lap_time_converted_t *conversion,
    uint16_t lap_count,
    float lap_time
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_tlm_lap_time_conversion_to_raw(
    secondary_tlm_lap_time_t *raw,
    uint16_t lap_count,
    float lap_time
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_tlm_lap_time_raw_to_conversion_struct(
    secondary_tlm_lap_time_converted_t *conversion, 
    const secondary_tlm_lap_time_t *raw);


void secondary_tlm_lap_time_conversion_to_raw_struct(
    secondary_tlm_lap_time_t *raw,
    const secondary_tlm_lap_time_converted_t *conversion);


int secondary_tlm_lap_time_converted_to_string(secondary_tlm_lap_time_converted_t *message, char *buffer);

int secondary_tlm_lap_time_converted_to_string_file(secondary_tlm_lap_time_converted_t *message, FILE *buffer);

int secondary_tlm_lap_time_fields(char *buffer);

int secondary_tlm_lap_time_fields_file(FILE *buffer);

/**
 * Pack message TLM_LAP_TIME.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_tlm_lap_time_pack(
    uint8_t *dst_p,
    const secondary_tlm_lap_time_t *src_p,
    size_t byte_size);

/**
 * Unpack message TLM_LAP_TIME.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_tlm_lap_time_unpack(
    secondary_tlm_lap_time_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_tlm_lap_time_lap_count_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_tlm_lap_time_lap_time_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_tlm_lap_time_lap_time_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_tlm_lap_time_lap_time_is_in_range(uint16_t value);


void secondary_tlm_laps_stats_raw_to_conversion(
    secondary_tlm_laps_stats_converted_t *conversion,
    uint16_t lap_number,
    float best_time,
    float last_time
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_tlm_laps_stats_conversion_to_raw(
    secondary_tlm_laps_stats_t *raw,
    uint16_t lap_number,
    float best_time,
    float last_time
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_tlm_laps_stats_raw_to_conversion_struct(
    secondary_tlm_laps_stats_converted_t *conversion, 
    const secondary_tlm_laps_stats_t *raw);


void secondary_tlm_laps_stats_conversion_to_raw_struct(
    secondary_tlm_laps_stats_t *raw,
    const secondary_tlm_laps_stats_converted_t *conversion);


int secondary_tlm_laps_stats_converted_to_string(secondary_tlm_laps_stats_converted_t *message, char *buffer);

int secondary_tlm_laps_stats_converted_to_string_file(secondary_tlm_laps_stats_converted_t *message, FILE *buffer);

int secondary_tlm_laps_stats_fields(char *buffer);

int secondary_tlm_laps_stats_fields_file(FILE *buffer);

/**
 * Pack message TLM_LAPS_STATS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_tlm_laps_stats_pack(
    uint8_t *dst_p,
    const secondary_tlm_laps_stats_t *src_p,
    size_t byte_size);

/**
 * Unpack message TLM_LAPS_STATS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_tlm_laps_stats_unpack(
    secondary_tlm_laps_stats_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_tlm_laps_stats_lap_number_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_tlm_laps_stats_best_time_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_tlm_laps_stats_best_time_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_tlm_laps_stats_best_time_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_tlm_laps_stats_last_time_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_tlm_laps_stats_last_time_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_tlm_laps_stats_last_time_is_in_range(uint16_t value);


void secondary_ammo_compression_raw_to_conversion(
    secondary_ammo_compression_converted_t *conversion,
    float rl,
    float rr,
    float fl,
    float fr
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_ammo_compression_conversion_to_raw(
    secondary_ammo_compression_t *raw,
    float rl,
    float rr,
    float fl,
    float fr
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_ammo_compression_raw_to_conversion_struct(
    secondary_ammo_compression_converted_t *conversion, 
    const secondary_ammo_compression_t *raw);


void secondary_ammo_compression_conversion_to_raw_struct(
    secondary_ammo_compression_t *raw,
    const secondary_ammo_compression_converted_t *conversion);


int secondary_ammo_compression_converted_to_string(secondary_ammo_compression_converted_t *message, char *buffer);

int secondary_ammo_compression_converted_to_string_file(secondary_ammo_compression_converted_t *message, FILE *buffer);

int secondary_ammo_compression_fields(char *buffer);

int secondary_ammo_compression_fields_file(FILE *buffer);

/**
 * Pack message AMMO_COMPRESSION.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_ammo_compression_pack(
    uint8_t *dst_p,
    const secondary_ammo_compression_t *src_p,
    size_t byte_size);

/**
 * Unpack message AMMO_COMPRESSION.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_ammo_compression_unpack(
    secondary_ammo_compression_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_ammo_compression_rl_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_ammo_compression_rl_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_ammo_compression_rl_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_ammo_compression_rr_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_ammo_compression_rr_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_ammo_compression_rr_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_ammo_compression_fl_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_ammo_compression_fl_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_ammo_compression_fl_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_ammo_compression_fr_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_ammo_compression_fr_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_ammo_compression_fr_is_in_range(uint16_t value);


void secondary_link_deformation_raw_to_conversion(
    secondary_link_deformation_converted_t *conversion,
    uint8_t rod_id,
    float deformation
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_link_deformation_conversion_to_raw(
    secondary_link_deformation_t *raw,
    uint8_t rod_id,
    float deformation
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_link_deformation_raw_to_conversion_struct(
    secondary_link_deformation_converted_t *conversion, 
    const secondary_link_deformation_t *raw);


void secondary_link_deformation_conversion_to_raw_struct(
    secondary_link_deformation_t *raw,
    const secondary_link_deformation_converted_t *conversion);


int secondary_link_deformation_converted_to_string(secondary_link_deformation_converted_t *message, char *buffer);

int secondary_link_deformation_converted_to_string_file(secondary_link_deformation_converted_t *message, FILE *buffer);

int secondary_link_deformation_fields(char *buffer);

int secondary_link_deformation_fields_file(FILE *buffer);

/**
 * Pack message LINK_DEFORMATION.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_link_deformation_pack(
    uint8_t *dst_p,
    const secondary_link_deformation_t *src_p,
    size_t byte_size);

/**
 * Unpack message LINK_DEFORMATION.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_link_deformation_unpack(
    secondary_link_deformation_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_link_deformation_rod_id_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t secondary_link_deformation_deformation_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_link_deformation_deformation_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_link_deformation_deformation_is_in_range(uint32_t value);


void secondary_link_deformation_set_calibration_raw_to_conversion(
    secondary_link_deformation_set_calibration_converted_t *conversion,
    uint8_t rod_id,
    float deformation
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_link_deformation_set_calibration_conversion_to_raw(
    secondary_link_deformation_set_calibration_t *raw,
    uint8_t rod_id,
    float deformation
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_link_deformation_set_calibration_raw_to_conversion_struct(
    secondary_link_deformation_set_calibration_converted_t *conversion, 
    const secondary_link_deformation_set_calibration_t *raw);


void secondary_link_deformation_set_calibration_conversion_to_raw_struct(
    secondary_link_deformation_set_calibration_t *raw,
    const secondary_link_deformation_set_calibration_converted_t *conversion);


int secondary_link_deformation_set_calibration_converted_to_string(secondary_link_deformation_set_calibration_converted_t *message, char *buffer);

int secondary_link_deformation_set_calibration_converted_to_string_file(secondary_link_deformation_set_calibration_converted_t *message, FILE *buffer);

int secondary_link_deformation_set_calibration_fields(char *buffer);

int secondary_link_deformation_set_calibration_fields_file(FILE *buffer);

/**
 * Pack message LINK_DEFORMATION_SET_CALIBRATION.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_link_deformation_set_calibration_pack(
    uint8_t *dst_p,
    const secondary_link_deformation_set_calibration_t *src_p,
    size_t byte_size);

/**
 * Unpack message LINK_DEFORMATION_SET_CALIBRATION.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_link_deformation_set_calibration_unpack(
    secondary_link_deformation_set_calibration_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_link_deformation_set_calibration_rod_id_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t secondary_link_deformation_set_calibration_deformation_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_link_deformation_set_calibration_deformation_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_link_deformation_set_calibration_deformation_is_in_range(uint32_t value);


void secondary_debug_signal_1_raw_to_conversion(
    secondary_debug_signal_1_converted_t *conversion,
    float field_1,
    float field_2,
    float field_3,
    float field_4
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_debug_signal_1_conversion_to_raw(
    secondary_debug_signal_1_t *raw,
    float field_1,
    float field_2,
    float field_3,
    float field_4
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_debug_signal_1_raw_to_conversion_struct(
    secondary_debug_signal_1_converted_t *conversion, 
    const secondary_debug_signal_1_t *raw);


void secondary_debug_signal_1_conversion_to_raw_struct(
    secondary_debug_signal_1_t *raw,
    const secondary_debug_signal_1_converted_t *conversion);


int secondary_debug_signal_1_converted_to_string(secondary_debug_signal_1_converted_t *message, char *buffer);

int secondary_debug_signal_1_converted_to_string_file(secondary_debug_signal_1_converted_t *message, FILE *buffer);

int secondary_debug_signal_1_fields(char *buffer);

int secondary_debug_signal_1_fields_file(FILE *buffer);

/**
 * Pack message DEBUG_SIGNAL_1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_debug_signal_1_pack(
    uint8_t *dst_p,
    const secondary_debug_signal_1_t *src_p,
    size_t byte_size);

/**
 * Unpack message DEBUG_SIGNAL_1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_debug_signal_1_unpack(
    secondary_debug_signal_1_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_debug_signal_1_field_1_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_debug_signal_1_field_1_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_debug_signal_1_field_1_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_debug_signal_1_field_2_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_debug_signal_1_field_2_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_debug_signal_1_field_2_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_debug_signal_1_field_3_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_debug_signal_1_field_3_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_debug_signal_1_field_3_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_debug_signal_1_field_4_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_debug_signal_1_field_4_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_debug_signal_1_field_4_is_in_range(uint16_t value);


void secondary_debug_signal_2_raw_to_conversion(
    secondary_debug_signal_2_converted_t *conversion,
    float field_1,
    float field_2,
    float field_3,
    float field_4
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_debug_signal_2_conversion_to_raw(
    secondary_debug_signal_2_t *raw,
    float field_1,
    float field_2,
    float field_3,
    float field_4
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_debug_signal_2_raw_to_conversion_struct(
    secondary_debug_signal_2_converted_t *conversion, 
    const secondary_debug_signal_2_t *raw);


void secondary_debug_signal_2_conversion_to_raw_struct(
    secondary_debug_signal_2_t *raw,
    const secondary_debug_signal_2_converted_t *conversion);


int secondary_debug_signal_2_converted_to_string(secondary_debug_signal_2_converted_t *message, char *buffer);

int secondary_debug_signal_2_converted_to_string_file(secondary_debug_signal_2_converted_t *message, FILE *buffer);

int secondary_debug_signal_2_fields(char *buffer);

int secondary_debug_signal_2_fields_file(FILE *buffer);

/**
 * Pack message DEBUG_SIGNAL_2.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_debug_signal_2_pack(
    uint8_t *dst_p,
    const secondary_debug_signal_2_t *src_p,
    size_t byte_size);

/**
 * Unpack message DEBUG_SIGNAL_2.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_debug_signal_2_unpack(
    secondary_debug_signal_2_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_debug_signal_2_field_1_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_debug_signal_2_field_1_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_debug_signal_2_field_1_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_debug_signal_2_field_2_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_debug_signal_2_field_2_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_debug_signal_2_field_2_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_debug_signal_2_field_3_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_debug_signal_2_field_3_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_debug_signal_2_field_3_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_debug_signal_2_field_4_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_debug_signal_2_field_4_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_debug_signal_2_field_4_is_in_range(uint16_t value);


void secondary_cooling_temp_raw_to_conversion(
    secondary_cooling_temp_converted_t *conversion,
    float top_left,
    float bottom_left,
    float top_right,
    float bottom_right
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_cooling_temp_conversion_to_raw(
    secondary_cooling_temp_t *raw,
    float top_left,
    float bottom_left,
    float top_right,
    float bottom_right
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void secondary_cooling_temp_raw_to_conversion_struct(
    secondary_cooling_temp_converted_t *conversion, 
    const secondary_cooling_temp_t *raw);


void secondary_cooling_temp_conversion_to_raw_struct(
    secondary_cooling_temp_t *raw,
    const secondary_cooling_temp_converted_t *conversion);


int secondary_cooling_temp_converted_to_string(secondary_cooling_temp_converted_t *message, char *buffer);

int secondary_cooling_temp_converted_to_string_file(secondary_cooling_temp_converted_t *message, FILE *buffer);

int secondary_cooling_temp_fields(char *buffer);

int secondary_cooling_temp_fields_file(FILE *buffer);

/**
 * Pack message COOLING_TEMP.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int secondary_cooling_temp_pack(
    uint8_t *dst_p,
    const secondary_cooling_temp_t *src_p,
    size_t byte_size);

/**
 * Unpack message COOLING_TEMP.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int secondary_cooling_temp_unpack(
    secondary_cooling_temp_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_cooling_temp_top_left_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_cooling_temp_top_left_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_cooling_temp_top_left_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_cooling_temp_bottom_left_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_cooling_temp_bottom_left_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_cooling_temp_bottom_left_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_cooling_temp_top_right_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_cooling_temp_top_right_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_cooling_temp_top_right_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t secondary_cooling_temp_bottom_right_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float secondary_cooling_temp_bottom_right_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool secondary_cooling_temp_bottom_right_is_in_range(uint16_t value);

bool secondary_id_is_message(uint16_t id);

int secondary_to_string_from_id(uint16_t message_id, void* message, char* buffer);
int secondary_fields_from_id(uint16_t message_id, char* buffer);
int secondary_to_string_file_from_id(uint16_t message_id, void* message, FILE* buffer);
int secondary_fields_file_from_id(uint16_t message_id, FILE* buffer);


typedef union CANLIB_PARKING {
    secondary_imu_angular_rate_t _imu_angular_rate;
    secondary_imu_acceleration_t _imu_acceleration;
    secondary_irts_fl_0_t _irts_fl_0;
    secondary_irts_fl_1_t _irts_fl_1;
    secondary_irts_fl_2_t _irts_fl_2;
    secondary_irts_fl_3_t _irts_fl_3;
    secondary_irts_fr_0_t _irts_fr_0;
    secondary_irts_fr_1_t _irts_fr_1;
    secondary_irts_fr_2_t _irts_fr_2;
    secondary_irts_fr_3_t _irts_fr_3;
    secondary_irts_rl_0_t _irts_rl_0;
    secondary_irts_rl_1_t _irts_rl_1;
    secondary_irts_rl_2_t _irts_rl_2;
    secondary_irts_rl_3_t _irts_rl_3;
    secondary_irts_rr_0_t _irts_rr_0;
    secondary_irts_rr_1_t _irts_rr_1;
    secondary_irts_rr_2_t _irts_rr_2;
    secondary_irts_rr_3_t _irts_rr_3;
    secondary_gps_coords_t _gps_coords;
    secondary_gps_speed_t _gps_speed;
    secondary_angular_velocity_t _angular_velocity;
    secondary_pedal_throttle_t _pedal_throttle;
    secondary_pedal_brakes_pressure_t _pedal_brakes_pressure;
    secondary_steer_angle_t _steer_angle;
    secondary_tpms_pressure_t _tpms_pressure;
    secondary_tpms_temperature_t _tpms_temperature;
    secondary_tlm_unix_timestamp_t _tlm_unix_timestamp;
    secondary_tlm_lap_time_t _tlm_lap_time;
    secondary_tlm_laps_stats_t _tlm_laps_stats;
    secondary_ammo_compression_t _ammo_compression;
    secondary_link_deformation_t _link_deformation;
    secondary_link_deformation_set_calibration_t _link_deformation_set_calibration;
    secondary_debug_signal_1_t _debug_signal_1;
    secondary_debug_signal_2_t _debug_signal_2;
    secondary_cooling_temp_t _cooling_temp;

} _secondary_all_struct_raw;

typedef union CANLIB_PARKING {
    secondary_imu_angular_rate_converted_t _imu_angular_rate;
    secondary_imu_acceleration_converted_t _imu_acceleration;
    secondary_irts_fl_0_converted_t _irts_fl_0;
    secondary_irts_fl_1_converted_t _irts_fl_1;
    secondary_irts_fl_2_converted_t _irts_fl_2;
    secondary_irts_fl_3_converted_t _irts_fl_3;
    secondary_irts_fr_0_converted_t _irts_fr_0;
    secondary_irts_fr_1_converted_t _irts_fr_1;
    secondary_irts_fr_2_converted_t _irts_fr_2;
    secondary_irts_fr_3_converted_t _irts_fr_3;
    secondary_irts_rl_0_converted_t _irts_rl_0;
    secondary_irts_rl_1_converted_t _irts_rl_1;
    secondary_irts_rl_2_converted_t _irts_rl_2;
    secondary_irts_rl_3_converted_t _irts_rl_3;
    secondary_irts_rr_0_converted_t _irts_rr_0;
    secondary_irts_rr_1_converted_t _irts_rr_1;
    secondary_irts_rr_2_converted_t _irts_rr_2;
    secondary_irts_rr_3_converted_t _irts_rr_3;
    secondary_gps_coords_converted_t _gps_coords;
    secondary_gps_speed_converted_t _gps_speed;
    secondary_angular_velocity_converted_t _angular_velocity;
    secondary_pedal_throttle_converted_t _pedal_throttle;
    secondary_pedal_brakes_pressure_converted_t _pedal_brakes_pressure;
    secondary_steer_angle_converted_t _steer_angle;
    secondary_tpms_pressure_converted_t _tpms_pressure;
    secondary_tpms_temperature_converted_t _tpms_temperature;
    secondary_tlm_unix_timestamp_converted_t _tlm_unix_timestamp;
    secondary_tlm_lap_time_converted_t _tlm_lap_time;
    secondary_tlm_laps_stats_converted_t _tlm_laps_stats;
    secondary_ammo_compression_converted_t _ammo_compression;
    secondary_link_deformation_converted_t _link_deformation;
    secondary_link_deformation_set_calibration_converted_t _link_deformation_set_calibration;
    secondary_debug_signal_1_converted_t _debug_signal_1;
    secondary_debug_signal_2_converted_t _debug_signal_2;
    secondary_cooling_temp_converted_t _cooling_temp;

} _secondary_all_struct_converted;



#define secondary_MAX_STRUCT_SIZE_RAW sizeof(_secondary_all_struct_raw)
#define secondary_MAX_STRUCT_SIZE_CONVERSION sizeof(_secondary_all_struct_converted)

#ifdef __cplusplus
}
#endif

#endif
