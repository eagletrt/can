/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2018-2019 Erik Moqvist
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/**
 * This file was generated by cantools version 38.0.2 Tue Jul  4 09:23:03 2023.
 */

#ifndef PRIMARY_H
#define PRIMARY_H

#include <stdio.h>
#include <stdlib.h>
#include <inttypes.h>

#ifdef __cplusplus
extern "C" {
#endif

#include <stdint.h>
#include <stdbool.h>
#include <stddef.h>

#ifndef CANLIB_BUILD
#define CANLIB_BUILD
#define CANLIB_BUILD_TIME 1688462583
#endif // CANLIB_BUILD

#ifndef CANLIB_PARKING
/* We know it's PACKING but PARKING sounds a bit better ;) */
#if defined(__MINGW32__)
#define CANLIB_PARKING                                                           __attribute__((__gcc_struct__, __packed__)) // , __aligned__(1)))
#else
#define CANLIB_PARKING __attribute__((__packed__)) // , __aligned__(1)))
#endif                                             // defined(__MINGW32__)
#endif                                             // CANLIB_PARKING

#ifndef EINVAL
#    define EINVAL 22
#endif

/* Frame ids. */
#define PRIMARY_NLG5_DIAG_TX_FRAME_ID (0x71au)
#define PRIMARY_NLG5_DIAG_RX_FRAME_ID (0x718u)
#define PRIMARY_NLG5_ERR_FRAME_ID (0x614u)
#define PRIMARY_NLG5_TEMP_FRAME_ID (0x613u)
#define PRIMARY_NLG5_ACT_II_FRAME_ID (0x612u)
#define PRIMARY_NLG5_ACT_I_FRAME_ID (0x611u)
#define PRIMARY_NLG5_ST_FRAME_ID (0x610u)
#define PRIMARY_NLG5_CTL_FRAME_ID (0x618u)
#define PRIMARY_BMS_HV_JMP_TO_BLT_FRAME_ID (0x00u)
#define PRIMARY_FLASH_BMS_HV_TX_FRAME_ID (0x01u)
#define PRIMARY_FLASH_BMS_HV_RX_FRAME_ID (0x02u)
#define PRIMARY_HV_CAN_FORWARD_FRAME_ID (0x03u)
#define PRIMARY_FLASH_CELLBOARD_0_TX_FRAME_ID (0x04u)
#define PRIMARY_FLASH_CELLBOARD_0_RX_FRAME_ID (0x05u)
#define PRIMARY_FLASH_CELLBOARD_1_TX_FRAME_ID (0x06u)
#define PRIMARY_FLASH_CELLBOARD_1_RX_FRAME_ID (0x07u)
#define PRIMARY_FLASH_CELLBOARD_2_TX_FRAME_ID (0x08u)
#define PRIMARY_FLASH_CELLBOARD_2_RX_FRAME_ID (0x09u)
#define PRIMARY_FLASH_CELLBOARD_3_TX_FRAME_ID (0x0au)
#define PRIMARY_FLASH_CELLBOARD_3_RX_FRAME_ID (0x0bu)
#define PRIMARY_FLASH_CELLBOARD_4_TX_FRAME_ID (0x0cu)
#define PRIMARY_FLASH_CELLBOARD_4_RX_FRAME_ID (0x0du)
#define PRIMARY_FLASH_CELLBOARD_5_TX_FRAME_ID (0x0eu)
#define PRIMARY_FLASH_CELLBOARD_5_RX_FRAME_ID (0x0fu)
#define PRIMARY_BMS_LV_JMP_TO_BLT_FRAME_ID (0x10u)
#define PRIMARY_FLASH_BMS_LV_TX_FRAME_ID (0x11u)
#define PRIMARY_FLASH_BMS_LV_RX_FRAME_ID (0x12u)
#define PRIMARY_ECU_JMP_TO_BLT_FRAME_ID (0x13u)
#define PRIMARY_FLASH_ECU_TX_FRAME_ID (0x14u)
#define PRIMARY_FLASH_ECU_RX_FRAME_ID (0x15u)
#define PRIMARY_STEERING_JMP_TO_BLT_FRAME_ID (0x16u)
#define PRIMARY_FLASH_STEERING_TX_FRAME_ID (0x17u)
#define PRIMARY_FLASH_STEERING_RX_FRAME_ID (0x18u)
#define PRIMARY_STEER_VERSION_FRAME_ID (0x2bcu)
#define PRIMARY_DAS_VERSION_FRAME_ID (0x2bdu)
#define PRIMARY_HV_VERSION_FRAME_ID (0x2beu)
#define PRIMARY_LV_VERSION_FRAME_ID (0x2bfu)
#define PRIMARY_TLM_VERSION_FRAME_ID (0x2c0u)
#define PRIMARY_TIMESTAMP_FRAME_ID (0x106u)
#define PRIMARY_AMBIENT_TEMPERATURE_FRAME_ID (0x126u)
#define PRIMARY_DATA_LOGGER_FRAME_ID (0x430u)
#define PRIMARY_SET_TLM_STATUS_FRAME_ID (0x103u)
#define PRIMARY_TLM_STATUS_FRAME_ID (0x100u)
#define PRIMARY_STEER_SYSTEM_STATUS_FRAME_ID (0x703u)
#define PRIMARY_HV_VOLTAGE_FRAME_ID (0x307u)
#define PRIMARY_HV_CURRENT_FRAME_ID (0x327u)
#define PRIMARY_HV_TEMP_FRAME_ID (0x347u)
#define PRIMARY_HV_ERRORS_FRAME_ID (0x27u)
#define PRIMARY_HV_FANS_OVERRIDE_FRAME_ID (0x28u)
#define PRIMARY_HV_CAN_FORWARD_STATUS_FRAME_ID (0x29u)
#define PRIMARY_HV_FANS_OVERRIDE_STATUS_FRAME_ID (0x309u)
#define PRIMARY_HV_FEEDBACKS_STATUS_FRAME_ID (0x302u)
#define PRIMARY_HV_IMD_STATUS_FRAME_ID (0x322u)
#define PRIMARY_TS_STATUS_FRAME_ID (0x54u)
#define PRIMARY_SET_TS_STATUS_DAS_FRAME_ID (0x52u)
#define PRIMARY_SET_TS_STATUS_HANDCART_FRAME_ID (0x53u)
#define PRIMARY_STEER_STATUS_FRAME_ID (0x104u)
#define PRIMARY_SET_CAR_STATUS_FRAME_ID (0x50u)
#define PRIMARY_SET_PEDAL_CALIBRATION_FRAME_ID (0x404u)
#define PRIMARY_PEDAL_CALIBRATION_ACK_FRAME_ID (0x400u)
#define PRIMARY_CAR_STATUS_FRAME_ID (0x51u)
#define PRIMARY_DAS_ERRORS_FRAME_ID (0x20u)
#define PRIMARY_ECU_FEEDBACKS_FRAME_ID (0x303u)
#define PRIMARY_LV_STATUS_FRAME_ID (0x323u)
#define PRIMARY_LV_CURRENTS_FRAME_ID (0x342u)
#define PRIMARY_LV_CELLS_VOLTAGE_FRAME_ID (0x362u)
#define PRIMARY_LV_TOTAL_VOLTAGE_FRAME_ID (0x382u)
#define PRIMARY_LV_CELLS_TEMP_FRAME_ID (0x3a2u)
#define PRIMARY_COOLING_STATUS_FRAME_ID (0x3c2u)
#define PRIMARY_SET_RADIATOR_SPEED_FRAME_ID (0x305u)
#define PRIMARY_SET_PUMPS_SPEED_FRAME_ID (0x325u)
#define PRIMARY_SET_INVERTER_CONNECTION_STATUS_FRAME_ID (0x105u)
#define PRIMARY_INVERTER_CONNECTION_STATUS_FRAME_ID (0x102u)
#define PRIMARY_LV_ERRORS_FRAME_ID (0x222u)
#define PRIMARY_LV_HEALTH_SIGNALS_FRAME_ID (0x122u)
#define PRIMARY_LV_FEEDBACKS_FRAME_ID (0x142u)
#define PRIMARY_SHUTDOWN_STATUS_FRAME_ID (0x162u)
#define PRIMARY_LV_CAN_FLASH_REQ_FRAME_ID (0x723u)
#define PRIMARY_LV_CAN_FLASH_ACK_FRAME_ID (0x743u)
#define PRIMARY_MARKER_FRAME_ID (0x23u)
#define PRIMARY_HV_CELLS_VOLTAGE_FRAME_ID (0x209u)
#define PRIMARY_HV_CELLS_TEMP_FRAME_ID (0x229u)
#define PRIMARY_HV_CELL_BALANCING_STATUS_FRAME_ID (0x249u)
#define PRIMARY_SET_CELL_BALANCING_STATUS_FRAME_ID (0x208u)
#define PRIMARY_SPEED_FRAME_ID (0x200u)
#define PRIMARY_INV_L_REQUEST_FRAME_ID (0x201u)
#define PRIMARY_INV_R_REQUEST_FRAME_ID (0x202u)
#define PRIMARY_INV_L_RESPONSE_FRAME_ID (0x181u)
#define PRIMARY_INV_R_RESPONSE_FRAME_ID (0x182u)
#define PRIMARY_CONTROL_OUTPUT_FRAME_ID (0x120u)
#define PRIMARY_LC_RESET_FRAME_ID (0x221u)
#define PRIMARY_HANDCART_STATUS_FRAME_ID (0x308u)
#define PRIMARY_HANDCART_SETTINGS_FRAME_ID (0x328u)
#define PRIMARY_HANDCART_SETTINGS_SET_FRAME_ID (0x348u)
#define PRIMARY_SET_PTT_STATUS_FRAME_ID (0x242u)
#define PRIMARY_PTT_STATUS_FRAME_ID (0x262u)

/* Frame lengths in bytes. */
#define PRIMARY_NLG5_DIAG_TX_BYTE_SIZE (8u)
#define PRIMARY_NLG5_DIAG_RX_BYTE_SIZE (8u)
#define PRIMARY_NLG5_ERR_BYTE_SIZE (5u)
#define PRIMARY_NLG5_TEMP_BYTE_SIZE (8u)
#define PRIMARY_NLG5_ACT_II_BYTE_SIZE (8u)
#define PRIMARY_NLG5_ACT_I_BYTE_SIZE (8u)
#define PRIMARY_NLG5_ST_BYTE_SIZE (4u)
#define PRIMARY_NLG5_CTL_BYTE_SIZE (7u)
#define PRIMARY_BMS_HV_JMP_TO_BLT_BYTE_SIZE (0u)
#define PRIMARY_FLASH_BMS_HV_TX_BYTE_SIZE (0u)
#define PRIMARY_FLASH_BMS_HV_RX_BYTE_SIZE (0u)
#define PRIMARY_HV_CAN_FORWARD_BYTE_SIZE (1u)
#define PRIMARY_FLASH_CELLBOARD_0_TX_BYTE_SIZE (0u)
#define PRIMARY_FLASH_CELLBOARD_0_RX_BYTE_SIZE (0u)
#define PRIMARY_FLASH_CELLBOARD_1_TX_BYTE_SIZE (0u)
#define PRIMARY_FLASH_CELLBOARD_1_RX_BYTE_SIZE (0u)
#define PRIMARY_FLASH_CELLBOARD_2_TX_BYTE_SIZE (0u)
#define PRIMARY_FLASH_CELLBOARD_2_RX_BYTE_SIZE (0u)
#define PRIMARY_FLASH_CELLBOARD_3_TX_BYTE_SIZE (0u)
#define PRIMARY_FLASH_CELLBOARD_3_RX_BYTE_SIZE (0u)
#define PRIMARY_FLASH_CELLBOARD_4_TX_BYTE_SIZE (0u)
#define PRIMARY_FLASH_CELLBOARD_4_RX_BYTE_SIZE (0u)
#define PRIMARY_FLASH_CELLBOARD_5_TX_BYTE_SIZE (0u)
#define PRIMARY_FLASH_CELLBOARD_5_RX_BYTE_SIZE (0u)
#define PRIMARY_BMS_LV_JMP_TO_BLT_BYTE_SIZE (0u)
#define PRIMARY_FLASH_BMS_LV_TX_BYTE_SIZE (0u)
#define PRIMARY_FLASH_BMS_LV_RX_BYTE_SIZE (0u)
#define PRIMARY_ECU_JMP_TO_BLT_BYTE_SIZE (0u)
#define PRIMARY_FLASH_ECU_TX_BYTE_SIZE (0u)
#define PRIMARY_FLASH_ECU_RX_BYTE_SIZE (0u)
#define PRIMARY_STEERING_JMP_TO_BLT_BYTE_SIZE (0u)
#define PRIMARY_FLASH_STEERING_TX_BYTE_SIZE (0u)
#define PRIMARY_FLASH_STEERING_RX_BYTE_SIZE (0u)
#define PRIMARY_STEER_VERSION_BYTE_SIZE (5u)
#define PRIMARY_DAS_VERSION_BYTE_SIZE (5u)
#define PRIMARY_HV_VERSION_BYTE_SIZE (5u)
#define PRIMARY_LV_VERSION_BYTE_SIZE (5u)
#define PRIMARY_TLM_VERSION_BYTE_SIZE (5u)
#define PRIMARY_TIMESTAMP_BYTE_SIZE (4u)
#define PRIMARY_AMBIENT_TEMPERATURE_BYTE_SIZE (2u)
#define PRIMARY_DATA_LOGGER_BYTE_SIZE (8u)
#define PRIMARY_SET_TLM_STATUS_BYTE_SIZE (1u)
#define PRIMARY_TLM_STATUS_BYTE_SIZE (1u)
#define PRIMARY_STEER_SYSTEM_STATUS_BYTE_SIZE (1u)
#define PRIMARY_HV_VOLTAGE_BYTE_SIZE (8u)
#define PRIMARY_HV_CURRENT_BYTE_SIZE (7u)
#define PRIMARY_HV_TEMP_BYTE_SIZE (3u)
#define PRIMARY_HV_ERRORS_BYTE_SIZE (4u)
#define PRIMARY_HV_FANS_OVERRIDE_BYTE_SIZE (3u)
#define PRIMARY_HV_CAN_FORWARD_STATUS_BYTE_SIZE (1u)
#define PRIMARY_HV_FANS_OVERRIDE_STATUS_BYTE_SIZE (3u)
#define PRIMARY_HV_FEEDBACKS_STATUS_BYTE_SIZE (5u)
#define PRIMARY_HV_IMD_STATUS_BYTE_SIZE (5u)
#define PRIMARY_TS_STATUS_BYTE_SIZE (1u)
#define PRIMARY_SET_TS_STATUS_DAS_BYTE_SIZE (1u)
#define PRIMARY_SET_TS_STATUS_HANDCART_BYTE_SIZE (1u)
#define PRIMARY_STEER_STATUS_BYTE_SIZE (3u)
#define PRIMARY_SET_CAR_STATUS_BYTE_SIZE (1u)
#define PRIMARY_SET_PEDAL_CALIBRATION_BYTE_SIZE (1u)
#define PRIMARY_PEDAL_CALIBRATION_ACK_BYTE_SIZE (1u)
#define PRIMARY_CAR_STATUS_BYTE_SIZE (1u)
#define PRIMARY_DAS_ERRORS_BYTE_SIZE (2u)
#define PRIMARY_ECU_FEEDBACKS_BYTE_SIZE (1u)
#define PRIMARY_LV_STATUS_BYTE_SIZE (1u)
#define PRIMARY_LV_CURRENTS_BYTE_SIZE (6u)
#define PRIMARY_LV_CELLS_VOLTAGE_BYTE_SIZE (7u)
#define PRIMARY_LV_TOTAL_VOLTAGE_BYTE_SIZE (4u)
#define PRIMARY_LV_CELLS_TEMP_BYTE_SIZE (7u)
#define PRIMARY_COOLING_STATUS_BYTE_SIZE (4u)
#define PRIMARY_SET_RADIATOR_SPEED_BYTE_SIZE (2u)
#define PRIMARY_SET_PUMPS_SPEED_BYTE_SIZE (2u)
#define PRIMARY_SET_INVERTER_CONNECTION_STATUS_BYTE_SIZE (1u)
#define PRIMARY_INVERTER_CONNECTION_STATUS_BYTE_SIZE (1u)
#define PRIMARY_LV_ERRORS_BYTE_SIZE (5u)
#define PRIMARY_LV_HEALTH_SIGNALS_BYTE_SIZE (2u)
#define PRIMARY_LV_FEEDBACKS_BYTE_SIZE (7u)
#define PRIMARY_SHUTDOWN_STATUS_BYTE_SIZE (1u)
#define PRIMARY_LV_CAN_FLASH_REQ_BYTE_SIZE (0u)
#define PRIMARY_LV_CAN_FLASH_ACK_BYTE_SIZE (1u)
#define PRIMARY_MARKER_BYTE_SIZE (0u)
#define PRIMARY_HV_CELLS_VOLTAGE_BYTE_SIZE (7u)
#define PRIMARY_HV_CELLS_TEMP_BYTE_SIZE (5u)
#define PRIMARY_HV_CELL_BALANCING_STATUS_BYTE_SIZE (4u)
#define PRIMARY_SET_CELL_BALANCING_STATUS_BYTE_SIZE (1u)
#define PRIMARY_SPEED_BYTE_SIZE (8u)
#define PRIMARY_INV_L_REQUEST_BYTE_SIZE (8u)
#define PRIMARY_INV_R_REQUEST_BYTE_SIZE (8u)
#define PRIMARY_INV_L_RESPONSE_BYTE_SIZE (8u)
#define PRIMARY_INV_R_RESPONSE_BYTE_SIZE (8u)
#define PRIMARY_CONTROL_OUTPUT_BYTE_SIZE (8u)
#define PRIMARY_LC_RESET_BYTE_SIZE (0u)
#define PRIMARY_HANDCART_STATUS_BYTE_SIZE (1u)
#define PRIMARY_HANDCART_SETTINGS_BYTE_SIZE (5u)
#define PRIMARY_HANDCART_SETTINGS_SET_BYTE_SIZE (5u)
#define PRIMARY_SET_PTT_STATUS_BYTE_SIZE (1u)
#define PRIMARY_PTT_STATUS_BYTE_SIZE (1u)

/* Extended or standard frame types. */
#define PRIMARY_NLG5_DIAG_TX_IS_EXTENDED (0)
#define PRIMARY_NLG5_DIAG_RX_IS_EXTENDED (0)
#define PRIMARY_NLG5_ERR_IS_EXTENDED (0)
#define PRIMARY_NLG5_TEMP_IS_EXTENDED (0)
#define PRIMARY_NLG5_ACT_II_IS_EXTENDED (0)
#define PRIMARY_NLG5_ACT_I_IS_EXTENDED (0)
#define PRIMARY_NLG5_ST_IS_EXTENDED (0)
#define PRIMARY_NLG5_CTL_IS_EXTENDED (0)
#define PRIMARY_BMS_HV_JMP_TO_BLT_IS_EXTENDED (0)
#define PRIMARY_FLASH_BMS_HV_TX_IS_EXTENDED (0)
#define PRIMARY_FLASH_BMS_HV_RX_IS_EXTENDED (0)
#define PRIMARY_HV_CAN_FORWARD_IS_EXTENDED (0)
#define PRIMARY_FLASH_CELLBOARD_0_TX_IS_EXTENDED (0)
#define PRIMARY_FLASH_CELLBOARD_0_RX_IS_EXTENDED (0)
#define PRIMARY_FLASH_CELLBOARD_1_TX_IS_EXTENDED (0)
#define PRIMARY_FLASH_CELLBOARD_1_RX_IS_EXTENDED (0)
#define PRIMARY_FLASH_CELLBOARD_2_TX_IS_EXTENDED (0)
#define PRIMARY_FLASH_CELLBOARD_2_RX_IS_EXTENDED (0)
#define PRIMARY_FLASH_CELLBOARD_3_TX_IS_EXTENDED (0)
#define PRIMARY_FLASH_CELLBOARD_3_RX_IS_EXTENDED (0)
#define PRIMARY_FLASH_CELLBOARD_4_TX_IS_EXTENDED (0)
#define PRIMARY_FLASH_CELLBOARD_4_RX_IS_EXTENDED (0)
#define PRIMARY_FLASH_CELLBOARD_5_TX_IS_EXTENDED (0)
#define PRIMARY_FLASH_CELLBOARD_5_RX_IS_EXTENDED (0)
#define PRIMARY_BMS_LV_JMP_TO_BLT_IS_EXTENDED (0)
#define PRIMARY_FLASH_BMS_LV_TX_IS_EXTENDED (0)
#define PRIMARY_FLASH_BMS_LV_RX_IS_EXTENDED (0)
#define PRIMARY_ECU_JMP_TO_BLT_IS_EXTENDED (0)
#define PRIMARY_FLASH_ECU_TX_IS_EXTENDED (0)
#define PRIMARY_FLASH_ECU_RX_IS_EXTENDED (0)
#define PRIMARY_STEERING_JMP_TO_BLT_IS_EXTENDED (0)
#define PRIMARY_FLASH_STEERING_TX_IS_EXTENDED (0)
#define PRIMARY_FLASH_STEERING_RX_IS_EXTENDED (0)
#define PRIMARY_STEER_VERSION_IS_EXTENDED (0)
#define PRIMARY_DAS_VERSION_IS_EXTENDED (0)
#define PRIMARY_HV_VERSION_IS_EXTENDED (0)
#define PRIMARY_LV_VERSION_IS_EXTENDED (0)
#define PRIMARY_TLM_VERSION_IS_EXTENDED (0)
#define PRIMARY_TIMESTAMP_IS_EXTENDED (0)
#define PRIMARY_AMBIENT_TEMPERATURE_IS_EXTENDED (0)
#define PRIMARY_DATA_LOGGER_IS_EXTENDED (0)
#define PRIMARY_SET_TLM_STATUS_IS_EXTENDED (0)
#define PRIMARY_TLM_STATUS_IS_EXTENDED (0)
#define PRIMARY_STEER_SYSTEM_STATUS_IS_EXTENDED (0)
#define PRIMARY_HV_VOLTAGE_IS_EXTENDED (0)
#define PRIMARY_HV_CURRENT_IS_EXTENDED (0)
#define PRIMARY_HV_TEMP_IS_EXTENDED (0)
#define PRIMARY_HV_ERRORS_IS_EXTENDED (0)
#define PRIMARY_HV_FANS_OVERRIDE_IS_EXTENDED (0)
#define PRIMARY_HV_CAN_FORWARD_STATUS_IS_EXTENDED (0)
#define PRIMARY_HV_FANS_OVERRIDE_STATUS_IS_EXTENDED (0)
#define PRIMARY_HV_FEEDBACKS_STATUS_IS_EXTENDED (0)
#define PRIMARY_HV_IMD_STATUS_IS_EXTENDED (0)
#define PRIMARY_TS_STATUS_IS_EXTENDED (0)
#define PRIMARY_SET_TS_STATUS_DAS_IS_EXTENDED (0)
#define PRIMARY_SET_TS_STATUS_HANDCART_IS_EXTENDED (0)
#define PRIMARY_STEER_STATUS_IS_EXTENDED (0)
#define PRIMARY_SET_CAR_STATUS_IS_EXTENDED (0)
#define PRIMARY_SET_PEDAL_CALIBRATION_IS_EXTENDED (0)
#define PRIMARY_PEDAL_CALIBRATION_ACK_IS_EXTENDED (0)
#define PRIMARY_CAR_STATUS_IS_EXTENDED (0)
#define PRIMARY_DAS_ERRORS_IS_EXTENDED (0)
#define PRIMARY_ECU_FEEDBACKS_IS_EXTENDED (0)
#define PRIMARY_LV_STATUS_IS_EXTENDED (0)
#define PRIMARY_LV_CURRENTS_IS_EXTENDED (0)
#define PRIMARY_LV_CELLS_VOLTAGE_IS_EXTENDED (0)
#define PRIMARY_LV_TOTAL_VOLTAGE_IS_EXTENDED (0)
#define PRIMARY_LV_CELLS_TEMP_IS_EXTENDED (0)
#define PRIMARY_COOLING_STATUS_IS_EXTENDED (0)
#define PRIMARY_SET_RADIATOR_SPEED_IS_EXTENDED (0)
#define PRIMARY_SET_PUMPS_SPEED_IS_EXTENDED (0)
#define PRIMARY_SET_INVERTER_CONNECTION_STATUS_IS_EXTENDED (0)
#define PRIMARY_INVERTER_CONNECTION_STATUS_IS_EXTENDED (0)
#define PRIMARY_LV_ERRORS_IS_EXTENDED (0)
#define PRIMARY_LV_HEALTH_SIGNALS_IS_EXTENDED (0)
#define PRIMARY_LV_FEEDBACKS_IS_EXTENDED (0)
#define PRIMARY_SHUTDOWN_STATUS_IS_EXTENDED (0)
#define PRIMARY_LV_CAN_FLASH_REQ_IS_EXTENDED (0)
#define PRIMARY_LV_CAN_FLASH_ACK_IS_EXTENDED (0)
#define PRIMARY_MARKER_IS_EXTENDED (0)
#define PRIMARY_HV_CELLS_VOLTAGE_IS_EXTENDED (0)
#define PRIMARY_HV_CELLS_TEMP_IS_EXTENDED (0)
#define PRIMARY_HV_CELL_BALANCING_STATUS_IS_EXTENDED (0)
#define PRIMARY_SET_CELL_BALANCING_STATUS_IS_EXTENDED (0)
#define PRIMARY_SPEED_IS_EXTENDED (0)
#define PRIMARY_INV_L_REQUEST_IS_EXTENDED (0)
#define PRIMARY_INV_R_REQUEST_IS_EXTENDED (0)
#define PRIMARY_INV_L_RESPONSE_IS_EXTENDED (0)
#define PRIMARY_INV_R_RESPONSE_IS_EXTENDED (0)
#define PRIMARY_CONTROL_OUTPUT_IS_EXTENDED (0)
#define PRIMARY_LC_RESET_IS_EXTENDED (0)
#define PRIMARY_HANDCART_STATUS_IS_EXTENDED (0)
#define PRIMARY_HANDCART_SETTINGS_IS_EXTENDED (0)
#define PRIMARY_HANDCART_SETTINGS_SET_IS_EXTENDED (0)
#define PRIMARY_SET_PTT_STATUS_IS_EXTENDED (0)
#define PRIMARY_PTT_STATUS_IS_EXTENDED (0)

/* Frame cycle times in milliseconds. */
#define PRIMARY_STEER_VERSION_CYCLE_TIME_MS (1000u)
#define PRIMARY_DAS_VERSION_CYCLE_TIME_MS (1000u)
#define PRIMARY_HV_VERSION_CYCLE_TIME_MS (1000u)
#define PRIMARY_LV_VERSION_CYCLE_TIME_MS (1000u)
#define PRIMARY_TLM_VERSION_CYCLE_TIME_MS (1000u)
#define PRIMARY_TIMESTAMP_CYCLE_TIME_MS (1000u)
#define PRIMARY_AMBIENT_TEMPERATURE_CYCLE_TIME_MS (1000u)
#define PRIMARY_DATA_LOGGER_CYCLE_TIME_MS (1000u)
#define PRIMARY_TLM_STATUS_CYCLE_TIME_MS (1000u)
#define PRIMARY_STEER_SYSTEM_STATUS_CYCLE_TIME_MS (1000u)
#define PRIMARY_HV_VOLTAGE_CYCLE_TIME_MS (10u)
#define PRIMARY_HV_CURRENT_CYCLE_TIME_MS (10u)
#define PRIMARY_HV_TEMP_CYCLE_TIME_MS (100u)
#define PRIMARY_HV_ERRORS_CYCLE_TIME_MS (10u)
#define PRIMARY_TS_STATUS_CYCLE_TIME_MS (10u)
#define PRIMARY_SET_TS_STATUS_DAS_CYCLE_TIME_MS (100u)
#define PRIMARY_SET_TS_STATUS_HANDCART_CYCLE_TIME_MS (100u)
#define PRIMARY_STEER_STATUS_CYCLE_TIME_MS (100u)
#define PRIMARY_CAR_STATUS_CYCLE_TIME_MS (100u)
#define PRIMARY_DAS_ERRORS_CYCLE_TIME_MS (10u)
#define PRIMARY_LV_STATUS_CYCLE_TIME_MS (200u)
#define PRIMARY_LV_CURRENTS_CYCLE_TIME_MS (300u)
#define PRIMARY_LV_CELLS_VOLTAGE_CYCLE_TIME_MS (200u)
#define PRIMARY_LV_TOTAL_VOLTAGE_CYCLE_TIME_MS (200u)
#define PRIMARY_LV_CELLS_TEMP_CYCLE_TIME_MS (200u)
#define PRIMARY_COOLING_STATUS_CYCLE_TIME_MS (1000u)
#define PRIMARY_SET_INVERTER_CONNECTION_STATUS_CYCLE_TIME_MS (100u)
#define PRIMARY_INVERTER_CONNECTION_STATUS_CYCLE_TIME_MS (300u)
#define PRIMARY_LV_ERRORS_CYCLE_TIME_MS (300u)
#define PRIMARY_LV_HEALTH_SIGNALS_CYCLE_TIME_MS (300u)
#define PRIMARY_LV_FEEDBACKS_CYCLE_TIME_MS (300u)
#define PRIMARY_SHUTDOWN_STATUS_CYCLE_TIME_MS (500u)
#define PRIMARY_LV_CAN_FLASH_ACK_CYCLE_TIME_MS (50u)
#define PRIMARY_HV_CELLS_VOLTAGE_CYCLE_TIME_MS (100u)
#define PRIMARY_HV_CELLS_TEMP_CYCLE_TIME_MS (100u)
#define PRIMARY_HV_CELL_BALANCING_STATUS_CYCLE_TIME_MS (500u)
#define PRIMARY_SPEED_CYCLE_TIME_MS (10u)
#define PRIMARY_INV_L_REQUEST_CYCLE_TIME_MS (10u)
#define PRIMARY_INV_R_REQUEST_CYCLE_TIME_MS (10u)
#define PRIMARY_INV_L_RESPONSE_CYCLE_TIME_MS (100u)
#define PRIMARY_INV_R_RESPONSE_CYCLE_TIME_MS (100u)
#define PRIMARY_CONTROL_OUTPUT_CYCLE_TIME_MS (100u)
#define PRIMARY_HANDCART_STATUS_CYCLE_TIME_MS (500u)
#define PRIMARY_HANDCART_SETTINGS_CYCLE_TIME_MS (500u)
#define PRIMARY_HANDCART_SETTINGS_SET_CYCLE_TIME_MS (500u)

/* Topics masks */
/* TOPIC FIXED_IDS */
#define PRIMARY_TOPIC_MASK_FIXED_IDS 0b00000011111

#define PRIMARY_ID_BMS_HV_JMP_TO_BLT 0x0 // dec: 0 bin: 0b00000000000
#define PRIMARY_ID_FLASH_BMS_HV_TX 0x1 // dec: 1 bin: 0b00000000001
#define PRIMARY_ID_FLASH_BMS_HV_RX 0x2 // dec: 2 bin: 0b00000000010
#define PRIMARY_ID_HV_CAN_FORWARD 0x3 // dec: 3 bin: 0b00000000011
#define PRIMARY_ID_FLASH_CELLBOARD_0_TX 0x4 // dec: 4 bin: 0b00000000100
#define PRIMARY_ID_FLASH_CELLBOARD_0_RX 0x5 // dec: 5 bin: 0b00000000101
#define PRIMARY_ID_FLASH_CELLBOARD_1_TX 0x6 // dec: 6 bin: 0b00000000110
#define PRIMARY_ID_FLASH_CELLBOARD_1_RX 0x7 // dec: 7 bin: 0b00000000111
#define PRIMARY_ID_FLASH_CELLBOARD_2_TX 0x8 // dec: 8 bin: 0b00000001000
#define PRIMARY_ID_FLASH_CELLBOARD_2_RX 0x9 // dec: 9 bin: 0b00000001001
#define PRIMARY_ID_FLASH_CELLBOARD_3_TX 0xA // dec: 10 bin: 0b00000001010
#define PRIMARY_ID_FLASH_CELLBOARD_3_RX 0xB // dec: 11 bin: 0b00000001011
#define PRIMARY_ID_FLASH_CELLBOARD_4_TX 0xC // dec: 12 bin: 0b00000001100
#define PRIMARY_ID_FLASH_CELLBOARD_4_RX 0xD // dec: 13 bin: 0b00000001101
#define PRIMARY_ID_FLASH_CELLBOARD_5_TX 0xE // dec: 14 bin: 0b00000001110
#define PRIMARY_ID_FLASH_CELLBOARD_5_RX 0xF // dec: 15 bin: 0b00000001111
#define PRIMARY_ID_BMS_LV_JMP_TO_BLT 0x10 // dec: 16 bin: 0b00000010000
#define PRIMARY_ID_FLASH_BMS_LV_TX 0x11 // dec: 17 bin: 0b00000010001
#define PRIMARY_ID_FLASH_BMS_LV_RX 0x12 // dec: 18 bin: 0b00000010010
#define PRIMARY_ID_ECU_JMP_TO_BLT 0x13 // dec: 19 bin: 0b00000010011
#define PRIMARY_ID_FLASH_ECU_TX 0x14 // dec: 20 bin: 0b00000010100
#define PRIMARY_ID_FLASH_ECU_RX 0x15 // dec: 21 bin: 0b00000010101
#define PRIMARY_ID_STEERING_JMP_TO_BLT 0x16 // dec: 22 bin: 0b00000010110
#define PRIMARY_ID_FLASH_STEERING_TX 0x17 // dec: 23 bin: 0b00000010111
#define PRIMARY_ID_FLASH_STEERING_RX 0x18 // dec: 24 bin: 0b00000011000
#define PRIMARY_ID_STEER_VERSION 0x2BC // dec: 700 bin: 0b01010111100
#define PRIMARY_ID_DAS_VERSION 0x2BD // dec: 701 bin: 0b01010111101
#define PRIMARY_ID_HV_VERSION 0x2BE // dec: 702 bin: 0b01010111110
#define PRIMARY_ID_LV_VERSION 0x2BF // dec: 703 bin: 0b01010111111
#define PRIMARY_ID_TLM_VERSION 0x2C0 // dec: 704 bin: 0b01011000000
#define PRIMARY_ID_DATA_LOGGER 0x430 // dec: 1072 bin: 0b10000110000
#define PRIMARY_ID_TS_STATUS 0x54 // dec: 84 bin: 0b00001010100
#define PRIMARY_ID_SET_TS_STATUS_DAS 0x52 // dec: 82 bin: 0b00001010010
#define PRIMARY_ID_SET_TS_STATUS_HANDCART 0x53 // dec: 83 bin: 0b00001010011
#define PRIMARY_ID_SET_CAR_STATUS 0x50 // dec: 80 bin: 0b00001010000
#define PRIMARY_ID_CAR_STATUS 0x51 // dec: 81 bin: 0b00001010001
#define PRIMARY_ID_INV_L_REQUEST 0x201 // dec: 513 bin: 0b01000000001
#define PRIMARY_ID_INV_R_REQUEST 0x202 // dec: 514 bin: 0b01000000010
#define PRIMARY_ID_INV_L_RESPONSE 0x181 // dec: 385 bin: 0b00110000001
#define PRIMARY_ID_INV_R_RESPONSE 0x182 // dec: 386 bin: 0b00110000010

/* TOPIC BROADCAST */
#define PRIMARY_TOPIC_MASK_BROADCAST 0b00000011111

#define PRIMARY_TOPIC_FILTER_BROADCAST 0x6 // dec: 6 bin: 0b00000000110

#define PRIMARY_ID_TIMESTAMP 0x106 // dec: 262 bin: 0b00100000110
#define PRIMARY_ID_AMBIENT_TEMPERATURE 0x126 // dec: 294 bin: 0b00100100110

/* TOPIC TLM */
#define PRIMARY_TOPIC_MASK_TLM 0b00000011111

#define PRIMARY_TOPIC_FILTER_TLM 0x3 // dec: 3 bin: 0b00000000011

#define PRIMARY_ID_SET_TLM_STATUS 0x103 // dec: 259 bin: 0b00100000011
#define PRIMARY_ID_STEER_SYSTEM_STATUS 0x703 // dec: 1795 bin: 0b11100000011
#define PRIMARY_ID_ECU_FEEDBACKS 0x303 // dec: 771 bin: 0b01100000011
#define PRIMARY_ID_LV_STATUS 0x323 // dec: 803 bin: 0b01100100011
#define PRIMARY_ID_LV_CAN_FLASH_REQ 0x723 // dec: 1827 bin: 0b11100100011
#define PRIMARY_ID_LV_CAN_FLASH_ACK 0x743 // dec: 1859 bin: 0b11101000011
#define PRIMARY_ID_MARKER 0x23 // dec: 35 bin: 0b00000100011

/* TOPIC STEER */
#define PRIMARY_TOPIC_MASK_STEER 0b00000011111

#define PRIMARY_TOPIC_FILTER_STEER 0x0 // dec: 0 bin: 0b00000000000

#define PRIMARY_ID_TLM_STATUS 0x100 // dec: 256 bin: 0b00100000000
#define PRIMARY_ID_PEDAL_CALIBRATION_ACK 0x400 // dec: 1024 bin: 0b10000000000
#define PRIMARY_ID_DAS_ERRORS 0x20 // dec: 32 bin: 0b00000100000
#define PRIMARY_ID_SPEED 0x200 // dec: 512 bin: 0b01000000000
#define PRIMARY_ID_CONTROL_OUTPUT 0x120 // dec: 288 bin: 0b00100100000

/* TOPIC DASNSTEERNCART */
#define PRIMARY_TOPIC_MASK_DASNSTEERNCART 0b00000011111

#define PRIMARY_TOPIC_FILTER_DASNSTEERNCART 0x7 // dec: 7 bin: 0b00000000111

#define PRIMARY_ID_HV_VOLTAGE 0x307 // dec: 775 bin: 0b01100000111
#define PRIMARY_ID_HV_CURRENT 0x327 // dec: 807 bin: 0b01100100111
#define PRIMARY_ID_HV_TEMP 0x347 // dec: 839 bin: 0b01101000111
#define PRIMARY_ID_HV_ERRORS 0x27 // dec: 39 bin: 0b00000100111

/* TOPIC BMS_HV */
#define PRIMARY_TOPIC_MASK_BMS_HV 0b00000011111

#define PRIMARY_TOPIC_FILTER_BMS_HV 0x8 // dec: 8 bin: 0b00000001000

#define PRIMARY_ID_HV_FANS_OVERRIDE 0x28 // dec: 40 bin: 0b00000101000
#define PRIMARY_ID_SET_CELL_BALANCING_STATUS 0x208 // dec: 520 bin: 0b01000001000
#define PRIMARY_ID_HANDCART_STATUS 0x308 // dec: 776 bin: 0b01100001000
#define PRIMARY_ID_HANDCART_SETTINGS 0x328 // dec: 808 bin: 0b01100101000
#define PRIMARY_ID_HANDCART_SETTINGS_SET 0x348 // dec: 840 bin: 0b01101001000

/* TOPIC HANDCART */
#define PRIMARY_TOPIC_MASK_HANDCART 0b00000011111

#define PRIMARY_TOPIC_FILTER_HANDCART 0x9 // dec: 9 bin: 0b00000001001

#define PRIMARY_ID_HV_CAN_FORWARD_STATUS 0x29 // dec: 41 bin: 0b00000101001
#define PRIMARY_ID_HV_FANS_OVERRIDE_STATUS 0x309 // dec: 777 bin: 0b01100001001
#define PRIMARY_ID_HV_CELLS_VOLTAGE 0x209 // dec: 521 bin: 0b01000001001
#define PRIMARY_ID_HV_CELLS_TEMP 0x229 // dec: 553 bin: 0b01000101001
#define PRIMARY_ID_HV_CELL_BALANCING_STATUS 0x249 // dec: 585 bin: 0b01001001001

/* TOPIC DASNSTEER */
#define PRIMARY_TOPIC_MASK_DASNSTEER 0b00000011111

#define PRIMARY_TOPIC_FILTER_DASNSTEER 0x2 // dec: 2 bin: 0b00000000010

#define PRIMARY_ID_HV_FEEDBACKS_STATUS 0x302 // dec: 770 bin: 0b01100000010
#define PRIMARY_ID_HV_IMD_STATUS 0x322 // dec: 802 bin: 0b01100100010
#define PRIMARY_ID_LV_CURRENTS 0x342 // dec: 834 bin: 0b01101000010
#define PRIMARY_ID_LV_CELLS_VOLTAGE 0x362 // dec: 866 bin: 0b01101100010
#define PRIMARY_ID_LV_TOTAL_VOLTAGE 0x382 // dec: 898 bin: 0b01110000010
#define PRIMARY_ID_LV_CELLS_TEMP 0x3A2 // dec: 930 bin: 0b01110100010
#define PRIMARY_ID_COOLING_STATUS 0x3C2 // dec: 962 bin: 0b01111000010
#define PRIMARY_ID_INVERTER_CONNECTION_STATUS 0x102 // dec: 258 bin: 0b00100000010
#define PRIMARY_ID_LV_ERRORS 0x222 // dec: 546 bin: 0b01000100010
#define PRIMARY_ID_LV_HEALTH_SIGNALS 0x122 // dec: 290 bin: 0b00100100010
#define PRIMARY_ID_LV_FEEDBACKS 0x142 // dec: 322 bin: 0b00101000010
#define PRIMARY_ID_SHUTDOWN_STATUS 0x162 // dec: 354 bin: 0b00101100010
#define PRIMARY_ID_SET_PTT_STATUS 0x242 // dec: 578 bin: 0b01001000010
#define PRIMARY_ID_PTT_STATUS 0x262 // dec: 610 bin: 0b01001100010

/* TOPIC DAS */
#define PRIMARY_TOPIC_MASK_DAS 0b00000011111

#define PRIMARY_TOPIC_FILTER_DAS 0x4 // dec: 4 bin: 0b00000000100

#define PRIMARY_ID_STEER_STATUS 0x104 // dec: 260 bin: 0b00100000100
#define PRIMARY_ID_SET_PEDAL_CALIBRATION 0x404 // dec: 1028 bin: 0b10000000100

/* TOPIC LV */
#define PRIMARY_TOPIC_MASK_LV 0b00000011111

#define PRIMARY_TOPIC_FILTER_LV 0x5 // dec: 5 bin: 0b00000000101

#define PRIMARY_ID_SET_RADIATOR_SPEED 0x305 // dec: 773 bin: 0b01100000101
#define PRIMARY_ID_SET_PUMPS_SPEED 0x325 // dec: 805 bin: 0b01100100101
#define PRIMARY_ID_SET_INVERTER_CONNECTION_STATUS 0x105 // dec: 261 bin: 0b00100000101

/* TOPIC LAPCOUNTER */
#define PRIMARY_TOPIC_MASK_LAPCOUNTER 0b00000011111

#define PRIMARY_TOPIC_FILTER_LAPCOUNTER 0x1 // dec: 1 bin: 0b00000000001

#define PRIMARY_ID_LC_RESET 0x221 // dec: 545 bin: 0b01000100001



/* Signal choices. */
#define PRIMARY_HV_CAN_FORWARD_CAN_FORWARD_SET_OFF_CHOICE (0u)
#define PRIMARY_HV_CAN_FORWARD_CAN_FORWARD_SET_ON_CHOICE (1u)

#define PRIMARY_SET_TLM_STATUS_TLM_STATUS_OFF_CHOICE (0u)
#define PRIMARY_SET_TLM_STATUS_TLM_STATUS_ON_CHOICE (1u)

#define PRIMARY_TLM_STATUS_TLM_STATUS_OFF_CHOICE (0u)
#define PRIMARY_TLM_STATUS_TLM_STATUS_ON_CHOICE (1u)

#define PRIMARY_HV_FANS_OVERRIDE_FANS_OVERRIDE_OFF_CHOICE (0u)
#define PRIMARY_HV_FANS_OVERRIDE_FANS_OVERRIDE_ON_CHOICE (1u)

#define PRIMARY_HV_CAN_FORWARD_STATUS_CAN_FORWARD_STATUS_OFF_CHOICE (0u)
#define PRIMARY_HV_CAN_FORWARD_STATUS_CAN_FORWARD_STATUS_ON_CHOICE (1u)

#define PRIMARY_HV_FANS_OVERRIDE_STATUS_FANS_OVERRIDE_OFF_CHOICE (0u)
#define PRIMARY_HV_FANS_OVERRIDE_STATUS_FANS_OVERRIDE_ON_CHOICE (1u)

#define PRIMARY_HV_IMD_STATUS_IMD_STATUS_IMD_SC_CHOICE (0u)
#define PRIMARY_HV_IMD_STATUS_IMD_STATUS_IMD_NORMAL_CHOICE (1u)
#define PRIMARY_HV_IMD_STATUS_IMD_STATUS_IMD_UNDER_VOLTAGE_CHOICE (2u)
#define PRIMARY_HV_IMD_STATUS_IMD_STATUS_IMD_START_MEASURE_CHOICE (3u)
#define PRIMARY_HV_IMD_STATUS_IMD_STATUS_IMD_DEVICE_ERROR_CHOICE (4u)
#define PRIMARY_HV_IMD_STATUS_IMD_STATUS_IMD_EARTH_FAULT_CHOICE (5u)

#define PRIMARY_TS_STATUS_TS_STATUS_OFF_CHOICE (0u)
#define PRIMARY_TS_STATUS_TS_STATUS_PRECHARGE_CHOICE (1u)
#define PRIMARY_TS_STATUS_TS_STATUS_ON_CHOICE (2u)
#define PRIMARY_TS_STATUS_TS_STATUS_FATAL_CHOICE (3u)

#define PRIMARY_SET_TS_STATUS_DAS_TS_STATUS_SET_OFF_CHOICE (0u)
#define PRIMARY_SET_TS_STATUS_DAS_TS_STATUS_SET_ON_CHOICE (1u)

#define PRIMARY_SET_TS_STATUS_HANDCART_TS_STATUS_SET_OFF_CHOICE (0u)
#define PRIMARY_SET_TS_STATUS_HANDCART_TS_STATUS_SET_ON_CHOICE (1u)

#define PRIMARY_SET_CAR_STATUS_CAR_STATUS_SET_IDLE_CHOICE (0u)
#define PRIMARY_SET_CAR_STATUS_CAR_STATUS_SET_READY_CHOICE (1u)
#define PRIMARY_SET_CAR_STATUS_CAR_STATUS_SET_DRIVE_CHOICE (2u)

#define PRIMARY_SET_PEDAL_CALIBRATION_PEDAL_ACCELERATOR_CHOICE (0u)
#define PRIMARY_SET_PEDAL_CALIBRATION_PEDAL_BRAKE_CHOICE (1u)

#define PRIMARY_SET_PEDAL_CALIBRATION_BOUND_SET_MAX_CHOICE (0u)
#define PRIMARY_SET_PEDAL_CALIBRATION_BOUND_SET_MIN_CHOICE (1u)

#define PRIMARY_PEDAL_CALIBRATION_ACK_PEDAL_ACCELERATOR_CHOICE (0u)
#define PRIMARY_PEDAL_CALIBRATION_ACK_PEDAL_BRAKE_CHOICE (1u)

#define PRIMARY_PEDAL_CALIBRATION_ACK_BOUND_SET_MAX_CHOICE (0u)
#define PRIMARY_PEDAL_CALIBRATION_ACK_BOUND_SET_MIN_CHOICE (1u)

#define PRIMARY_CAR_STATUS_INVERTER_L_OFF_CHOICE (0u)
#define PRIMARY_CAR_STATUS_INVERTER_L_IDLE_CHOICE (1u)
#define PRIMARY_CAR_STATUS_INVERTER_L_ON_CHOICE (2u)

#define PRIMARY_CAR_STATUS_INVERTER_R_OFF_CHOICE (0u)
#define PRIMARY_CAR_STATUS_INVERTER_R_IDLE_CHOICE (1u)
#define PRIMARY_CAR_STATUS_INVERTER_R_ON_CHOICE (2u)

#define PRIMARY_CAR_STATUS_CAR_STATUS_INIT_CHOICE (0u)
#define PRIMARY_CAR_STATUS_CAR_STATUS_ENABLE_INV_UPDATES_CHOICE (1u)
#define PRIMARY_CAR_STATUS_CAR_STATUS_CHECK_INV_SETTINGS_CHOICE (2u)
#define PRIMARY_CAR_STATUS_CAR_STATUS_IDLE_CHOICE (3u)
#define PRIMARY_CAR_STATUS_CAR_STATUS_START_TS_PRECHARGE_CHOICE (4u)
#define PRIMARY_CAR_STATUS_CAR_STATUS_WAIT_TS_PRECHARGE_CHOICE (5u)
#define PRIMARY_CAR_STATUS_CAR_STATUS_WAIT_DRIVER_CHOICE (6u)
#define PRIMARY_CAR_STATUS_CAR_STATUS_ENABLE_INV_DRIVE_CHOICE (7u)
#define PRIMARY_CAR_STATUS_CAR_STATUS_DRIVE_CHOICE (8u)
#define PRIMARY_CAR_STATUS_CAR_STATUS_DISABLE_INV_DRIVE_CHOICE (9u)
#define PRIMARY_CAR_STATUS_CAR_STATUS_START_TS_DISCHARGE_CHOICE (10u)
#define PRIMARY_CAR_STATUS_CAR_STATUS_WAIT_TS_DISCHARGE_CHOICE (11u)
#define PRIMARY_CAR_STATUS_CAR_STATUS_FATAL_ERROR_CHOICE (12u)

#define PRIMARY_LV_STATUS_STATUS_INIT_CHOICE (0u)
#define PRIMARY_LV_STATUS_STATUS_RUN_CHOICE (1u)
#define PRIMARY_LV_STATUS_STATUS_ERROR_CHOICE (2u)

#define PRIMARY_SET_INVERTER_CONNECTION_STATUS_STATUS_OFF_CHOICE (0u)
#define PRIMARY_SET_INVERTER_CONNECTION_STATUS_STATUS_ON_CHOICE (1u)

#define PRIMARY_INVERTER_CONNECTION_STATUS_STATUS_OFF_CHOICE (0u)
#define PRIMARY_INVERTER_CONNECTION_STATUS_STATUS_ON_CHOICE (1u)

#define PRIMARY_LV_CAN_FLASH_ACK_RESPONSE_NO_FLASH_CHOICE (0u)
#define PRIMARY_LV_CAN_FLASH_ACK_RESPONSE_FLASH_CHOICE (1u)
#define PRIMARY_LV_CAN_FLASH_ACK_RESPONSE_PREPARING_TO_FLASH_CHOICE (2u)

#define PRIMARY_HV_CELL_BALANCING_STATUS_CELLBOARD_ID_CELLBOARD_0_CHOICE (0u)
#define PRIMARY_HV_CELL_BALANCING_STATUS_CELLBOARD_ID_CELLBOARD_1_CHOICE (1u)
#define PRIMARY_HV_CELL_BALANCING_STATUS_CELLBOARD_ID_CELLBOARD_2_CHOICE (2u)
#define PRIMARY_HV_CELL_BALANCING_STATUS_CELLBOARD_ID_CELLBOARD_3_CHOICE (3u)
#define PRIMARY_HV_CELL_BALANCING_STATUS_CELLBOARD_ID_CELLBOARD_4_CHOICE (4u)
#define PRIMARY_HV_CELL_BALANCING_STATUS_CELLBOARD_ID_CELLBOARD_5_CHOICE (5u)

#define PRIMARY_HV_CELL_BALANCING_STATUS_BALANCING_STATUS_OFF_CHOICE (0u)
#define PRIMARY_HV_CELL_BALANCING_STATUS_BALANCING_STATUS_ON_CHOICE (1u)

#define PRIMARY_SET_CELL_BALANCING_STATUS_SET_BALANCING_STATUS_OFF_CHOICE (0u)
#define PRIMARY_SET_CELL_BALANCING_STATUS_SET_BALANCING_STATUS_ON_CHOICE (1u)

#define PRIMARY_HANDCART_SETTINGS_FANS_OVERRIDE_OFF_CHOICE (0u)
#define PRIMARY_HANDCART_SETTINGS_FANS_OVERRIDE_ON_CHOICE (1u)

#define PRIMARY_HANDCART_SETTINGS_STATUS_NONE_CHOICE (0u)
#define PRIMARY_HANDCART_SETTINGS_STATUS_CHECK_CHOICE (1u)
#define PRIMARY_HANDCART_SETTINGS_STATUS_IDLE_CHOICE (2u)
#define PRIMARY_HANDCART_SETTINGS_STATUS_PRECHARGE_CHOICE (3u)
#define PRIMARY_HANDCART_SETTINGS_STATUS_READY_CHOICE (4u)
#define PRIMARY_HANDCART_SETTINGS_STATUS_CHARGE_CHOICE (5u)
#define PRIMARY_HANDCART_SETTINGS_STATUS_CHARGE_DONE_CHOICE (6u)
#define PRIMARY_HANDCART_SETTINGS_STATUS_BALANCING_CHOICE (7u)
#define PRIMARY_HANDCART_SETTINGS_STATUS_ERROR_CHOICE (8u)

#define PRIMARY_HANDCART_SETTINGS_SET_FANS_OVERRIDE_OFF_CHOICE (0u)
#define PRIMARY_HANDCART_SETTINGS_SET_FANS_OVERRIDE_ON_CHOICE (1u)

#define PRIMARY_HANDCART_SETTINGS_SET_STATUS_NONE_CHOICE (0u)
#define PRIMARY_HANDCART_SETTINGS_SET_STATUS_CHECK_CHOICE (1u)
#define PRIMARY_HANDCART_SETTINGS_SET_STATUS_IDLE_CHOICE (2u)
#define PRIMARY_HANDCART_SETTINGS_SET_STATUS_PRECHARGE_CHOICE (3u)
#define PRIMARY_HANDCART_SETTINGS_SET_STATUS_READY_CHOICE (4u)
#define PRIMARY_HANDCART_SETTINGS_SET_STATUS_CHARGE_CHOICE (5u)
#define PRIMARY_HANDCART_SETTINGS_SET_STATUS_CHARGE_DONE_CHOICE (6u)
#define PRIMARY_HANDCART_SETTINGS_SET_STATUS_BALANCING_CHOICE (7u)
#define PRIMARY_HANDCART_SETTINGS_SET_STATUS_ERROR_CHOICE (8u)

#define PRIMARY_SET_PTT_STATUS_STATUS_OFF_CHOICE (0u)
#define PRIMARY_SET_PTT_STATUS_STATUS_ON_CHOICE (1u)

#define PRIMARY_PTT_STATUS_STATUS_OFF_CHOICE (0u)
#define PRIMARY_PTT_STATUS_STATUS_ON_CHOICE (1u)

/* Indexes */
#define PRIMARY_NLG5_DIAG_TX_INDEX 0
#define PRIMARY_NLG5_DIAG_RX_INDEX 1
#define PRIMARY_NLG5_ERR_INDEX 2
#define PRIMARY_NLG5_TEMP_INDEX 3
#define PRIMARY_NLG5_ACT_II_INDEX 4
#define PRIMARY_NLG5_ACT_I_INDEX 5
#define PRIMARY_NLG5_ST_INDEX 6
#define PRIMARY_NLG5_CTL_INDEX 7
#define PRIMARY_BMS_HV_JMP_TO_BLT_INDEX 8
#define PRIMARY_FLASH_BMS_HV_TX_INDEX 9
#define PRIMARY_FLASH_BMS_HV_RX_INDEX 10
#define PRIMARY_HV_CAN_FORWARD_INDEX 11
#define PRIMARY_FLASH_CELLBOARD_0_TX_INDEX 12
#define PRIMARY_FLASH_CELLBOARD_0_RX_INDEX 13
#define PRIMARY_FLASH_CELLBOARD_1_TX_INDEX 14
#define PRIMARY_FLASH_CELLBOARD_1_RX_INDEX 15
#define PRIMARY_FLASH_CELLBOARD_2_TX_INDEX 16
#define PRIMARY_FLASH_CELLBOARD_2_RX_INDEX 17
#define PRIMARY_FLASH_CELLBOARD_3_TX_INDEX 18
#define PRIMARY_FLASH_CELLBOARD_3_RX_INDEX 19
#define PRIMARY_FLASH_CELLBOARD_4_TX_INDEX 20
#define PRIMARY_FLASH_CELLBOARD_4_RX_INDEX 21
#define PRIMARY_FLASH_CELLBOARD_5_TX_INDEX 22
#define PRIMARY_FLASH_CELLBOARD_5_RX_INDEX 23
#define PRIMARY_BMS_LV_JMP_TO_BLT_INDEX 24
#define PRIMARY_FLASH_BMS_LV_TX_INDEX 25
#define PRIMARY_FLASH_BMS_LV_RX_INDEX 26
#define PRIMARY_ECU_JMP_TO_BLT_INDEX 27
#define PRIMARY_FLASH_ECU_TX_INDEX 28
#define PRIMARY_FLASH_ECU_RX_INDEX 29
#define PRIMARY_STEERING_JMP_TO_BLT_INDEX 30
#define PRIMARY_FLASH_STEERING_TX_INDEX 31
#define PRIMARY_FLASH_STEERING_RX_INDEX 32
#define PRIMARY_STEER_VERSION_INDEX 33
#define PRIMARY_DAS_VERSION_INDEX 34
#define PRIMARY_HV_VERSION_INDEX 35
#define PRIMARY_LV_VERSION_INDEX 36
#define PRIMARY_TLM_VERSION_INDEX 37
#define PRIMARY_TIMESTAMP_INDEX 38
#define PRIMARY_AMBIENT_TEMPERATURE_INDEX 39
#define PRIMARY_DATA_LOGGER_INDEX 40
#define PRIMARY_SET_TLM_STATUS_INDEX 41
#define PRIMARY_TLM_STATUS_INDEX 42
#define PRIMARY_STEER_SYSTEM_STATUS_INDEX 43
#define PRIMARY_HV_VOLTAGE_INDEX 44
#define PRIMARY_HV_CURRENT_INDEX 45
#define PRIMARY_HV_TEMP_INDEX 46
#define PRIMARY_HV_ERRORS_INDEX 47
#define PRIMARY_HV_FANS_OVERRIDE_INDEX 48
#define PRIMARY_HV_CAN_FORWARD_STATUS_INDEX 49
#define PRIMARY_HV_FANS_OVERRIDE_STATUS_INDEX 50
#define PRIMARY_HV_FEEDBACKS_STATUS_INDEX 51
#define PRIMARY_HV_IMD_STATUS_INDEX 52
#define PRIMARY_TS_STATUS_INDEX 53
#define PRIMARY_SET_TS_STATUS_DAS_INDEX 54
#define PRIMARY_SET_TS_STATUS_HANDCART_INDEX 55
#define PRIMARY_STEER_STATUS_INDEX 56
#define PRIMARY_SET_CAR_STATUS_INDEX 57
#define PRIMARY_SET_PEDAL_CALIBRATION_INDEX 58
#define PRIMARY_PEDAL_CALIBRATION_ACK_INDEX 59
#define PRIMARY_CAR_STATUS_INDEX 60
#define PRIMARY_DAS_ERRORS_INDEX 61
#define PRIMARY_ECU_FEEDBACKS_INDEX 62
#define PRIMARY_LV_STATUS_INDEX 63
#define PRIMARY_LV_CURRENTS_INDEX 64
#define PRIMARY_LV_CELLS_VOLTAGE_INDEX 65
#define PRIMARY_LV_TOTAL_VOLTAGE_INDEX 66
#define PRIMARY_LV_CELLS_TEMP_INDEX 67
#define PRIMARY_COOLING_STATUS_INDEX 68
#define PRIMARY_SET_RADIATOR_SPEED_INDEX 69
#define PRIMARY_SET_PUMPS_SPEED_INDEX 70
#define PRIMARY_SET_INVERTER_CONNECTION_STATUS_INDEX 71
#define PRIMARY_INVERTER_CONNECTION_STATUS_INDEX 72
#define PRIMARY_LV_ERRORS_INDEX 73
#define PRIMARY_LV_HEALTH_SIGNALS_INDEX 74
#define PRIMARY_LV_FEEDBACKS_INDEX 75
#define PRIMARY_SHUTDOWN_STATUS_INDEX 76
#define PRIMARY_LV_CAN_FLASH_REQ_INDEX 77
#define PRIMARY_LV_CAN_FLASH_ACK_INDEX 78
#define PRIMARY_MARKER_INDEX 79
#define PRIMARY_HV_CELLS_VOLTAGE_INDEX 80
#define PRIMARY_HV_CELLS_TEMP_INDEX 81
#define PRIMARY_HV_CELL_BALANCING_STATUS_INDEX 82
#define PRIMARY_SET_CELL_BALANCING_STATUS_INDEX 83
#define PRIMARY_SPEED_INDEX 84
#define PRIMARY_INV_L_REQUEST_INDEX 85
#define PRIMARY_INV_R_REQUEST_INDEX 86
#define PRIMARY_INV_L_RESPONSE_INDEX 87
#define PRIMARY_INV_R_RESPONSE_INDEX 88
#define PRIMARY_CONTROL_OUTPUT_INDEX 89
#define PRIMARY_LC_RESET_INDEX 90
#define PRIMARY_HANDCART_STATUS_INDEX 91
#define PRIMARY_HANDCART_SETTINGS_INDEX 92
#define PRIMARY_HANDCART_SETTINGS_SET_INDEX 93
#define PRIMARY_SET_PTT_STATUS_INDEX 94
#define PRIMARY_PTT_STATUS_INDEX 95


#define primary_MESSAGE_COUNT 96

#ifndef CANLIB_DEVICE_T
#define CANLIB_DEVICE_T
typedef struct {
    void* message;
    void* _converted;
    void* _raw;
    int _size_raw;
    int _size_converted;
} device_t;
void device_init(device_t *device);
void device_preallocate(device_t *device, int bytes);
void device_free(device_t *device);
void device_set_address(device_t *device, void* raw, size_t raw_size, void *converted, size_t converted_size);
#endif // CANLIB_DEVICE_T

#ifdef CANLIB_DEVICE_IMPLEMENTATION
#undef CANLIB_DEVICE_IMPLEMENTATION
void device_init(device_t *device) {
    device->message = NULL;
    device->_converted = NULL;
    device->_raw = NULL;
    device->_size_raw = 0;
    device->_size_converted = 0;
}
void device_preallocate(device_t *device, int bytes){
    if(device->_size_raw > 0)
        free(device->_raw);
    if(device->_size_converted > 0)
        free(device->_converted);
    device->_raw = malloc(bytes);
    device->_converted = malloc(bytes);
    device->_size_converted = device->_size_raw = bytes;
}
void device_free(device_t *device) {
    free(device->_raw);
    free(device->_converted);
    device->message = NULL;
    device->_raw = NULL;
    device->_converted = NULL;
    device->_size_raw = 0;
    device->_size_converted = 0;
}
void device_set_address(device_t *device, void* raw, size_t raw_size, void *converted, size_t converted_size) {
    device->_raw = raw;
    device->_converted = converted;
    device->_size_raw = raw_size;
    device->_size_converted = converted_size;
}
#endif // CANLIB_DEVICE_IMPLEMENTATION

void primary_devices_deserialize_from_id(
    device_t* device,
    uint16_t message_id,
    uint8_t* data
#ifdef CANLIB_TIMESTAMP
    , uint64_t timestamp
#endif // CANLIB_TIMESTAMP
);

int primary_message_name_from_id(uint16_t id, char* buffer);
int primary_index_from_id(uint16_t id);
int primary_id_from_index(int index);

typedef enum {
	primary_hv_can_forward_can_forward_set_OFF = 0,
	primary_hv_can_forward_can_forward_set_ON = 1,
} primary_hv_can_forward_can_forward_set;

typedef enum {
	primary_set_tlm_status_tlm_status_OFF = 0,
	primary_set_tlm_status_tlm_status_ON = 1,
} primary_set_tlm_status_tlm_status;

typedef enum {
	primary_tlm_status_tlm_status_OFF = 0,
	primary_tlm_status_tlm_status_ON = 1,
} primary_tlm_status_tlm_status;

typedef enum {
	primary_hv_fans_override_fans_override_OFF = 0,
	primary_hv_fans_override_fans_override_ON = 1,
} primary_hv_fans_override_fans_override;

typedef enum {
	primary_hv_can_forward_status_can_forward_status_OFF = 0,
	primary_hv_can_forward_status_can_forward_status_ON = 1,
} primary_hv_can_forward_status_can_forward_status;

typedef enum {
	primary_hv_fans_override_status_fans_override_OFF = 0,
	primary_hv_fans_override_status_fans_override_ON = 1,
} primary_hv_fans_override_status_fans_override;

typedef enum {
	primary_hv_imd_status_imd_status_IMD_SC = 0,
	primary_hv_imd_status_imd_status_IMD_NORMAL = 1,
	primary_hv_imd_status_imd_status_IMD_UNDER_VOLTAGE = 2,
	primary_hv_imd_status_imd_status_IMD_START_MEASURE = 3,
	primary_hv_imd_status_imd_status_IMD_DEVICE_ERROR = 4,
	primary_hv_imd_status_imd_status_IMD_EARTH_FAULT = 5,
} primary_hv_imd_status_imd_status;

typedef enum {
	primary_ts_status_ts_status_OFF = 0,
	primary_ts_status_ts_status_PRECHARGE = 1,
	primary_ts_status_ts_status_ON = 2,
	primary_ts_status_ts_status_FATAL = 3,
} primary_ts_status_ts_status;

typedef enum {
	primary_set_ts_status_das_ts_status_set_OFF = 0,
	primary_set_ts_status_das_ts_status_set_ON = 1,
} primary_set_ts_status_das_ts_status_set;

typedef enum {
	primary_set_ts_status_handcart_ts_status_set_OFF = 0,
	primary_set_ts_status_handcart_ts_status_set_ON = 1,
} primary_set_ts_status_handcart_ts_status_set;

typedef enum {
	primary_set_car_status_car_status_set_IDLE = 0,
	primary_set_car_status_car_status_set_READY = 1,
	primary_set_car_status_car_status_set_DRIVE = 2,
} primary_set_car_status_car_status_set;

typedef enum {
	primary_set_pedal_calibration_pedal_ACCELERATOR = 0,
	primary_set_pedal_calibration_pedal_BRAKE = 1,
} primary_set_pedal_calibration_pedal;

typedef enum {
	primary_set_pedal_calibration_bound_SET_MAX = 0,
	primary_set_pedal_calibration_bound_SET_MIN = 1,
} primary_set_pedal_calibration_bound;

typedef enum {
	primary_pedal_calibration_ack_pedal_ACCELERATOR = 0,
	primary_pedal_calibration_ack_pedal_BRAKE = 1,
} primary_pedal_calibration_ack_pedal;

typedef enum {
	primary_pedal_calibration_ack_bound_SET_MAX = 0,
	primary_pedal_calibration_ack_bound_SET_MIN = 1,
} primary_pedal_calibration_ack_bound;

typedef enum {
	primary_car_status_inverter_l_OFF = 0,
	primary_car_status_inverter_l_IDLE = 1,
	primary_car_status_inverter_l_ON = 2,
} primary_car_status_inverter_l;

typedef enum {
	primary_car_status_inverter_r_OFF = 0,
	primary_car_status_inverter_r_IDLE = 1,
	primary_car_status_inverter_r_ON = 2,
} primary_car_status_inverter_r;

typedef enum {
	primary_car_status_car_status_INIT = 0,
	primary_car_status_car_status_ENABLE_INV_UPDATES = 1,
	primary_car_status_car_status_CHECK_INV_SETTINGS = 2,
	primary_car_status_car_status_IDLE = 3,
	primary_car_status_car_status_START_TS_PRECHARGE = 4,
	primary_car_status_car_status_WAIT_TS_PRECHARGE = 5,
	primary_car_status_car_status_WAIT_DRIVER = 6,
	primary_car_status_car_status_ENABLE_INV_DRIVE = 7,
	primary_car_status_car_status_DRIVE = 8,
	primary_car_status_car_status_DISABLE_INV_DRIVE = 9,
	primary_car_status_car_status_START_TS_DISCHARGE = 10,
	primary_car_status_car_status_WAIT_TS_DISCHARGE = 11,
	primary_car_status_car_status_FATAL_ERROR = 12,
} primary_car_status_car_status;

typedef enum {
	primary_lv_status_status_INIT = 0,
	primary_lv_status_status_RUN = 1,
	primary_lv_status_status_ERROR = 2,
} primary_lv_status_status;

typedef enum {
	primary_set_inverter_connection_status_status_OFF = 0,
	primary_set_inverter_connection_status_status_ON = 1,
} primary_set_inverter_connection_status_status;

typedef enum {
	primary_inverter_connection_status_status_OFF = 0,
	primary_inverter_connection_status_status_ON = 1,
} primary_inverter_connection_status_status;

typedef enum {
	primary_lv_can_flash_ack_response_NO_FLASH = 0,
	primary_lv_can_flash_ack_response_FLASH = 1,
	primary_lv_can_flash_ack_response_PREPARING_TO_FLASH = 2,
} primary_lv_can_flash_ack_response;

typedef enum {
	primary_hv_cell_balancing_status_cellboard_id_CELLBOARD_0 = 0,
	primary_hv_cell_balancing_status_cellboard_id_CELLBOARD_1 = 1,
	primary_hv_cell_balancing_status_cellboard_id_CELLBOARD_2 = 2,
	primary_hv_cell_balancing_status_cellboard_id_CELLBOARD_3 = 3,
	primary_hv_cell_balancing_status_cellboard_id_CELLBOARD_4 = 4,
	primary_hv_cell_balancing_status_cellboard_id_CELLBOARD_5 = 5,
} primary_hv_cell_balancing_status_cellboard_id;

typedef enum {
	primary_hv_cell_balancing_status_balancing_status_OFF = 0,
	primary_hv_cell_balancing_status_balancing_status_ON = 1,
} primary_hv_cell_balancing_status_balancing_status;

typedef enum {
	primary_set_cell_balancing_status_set_balancing_status_OFF = 0,
	primary_set_cell_balancing_status_set_balancing_status_ON = 1,
} primary_set_cell_balancing_status_set_balancing_status;

typedef enum {
	primary_handcart_settings_fans_override_OFF = 0,
	primary_handcart_settings_fans_override_ON = 1,
} primary_handcart_settings_fans_override;

typedef enum {
	primary_handcart_settings_status_NONE = 0,
	primary_handcart_settings_status_CHECK = 1,
	primary_handcart_settings_status_IDLE = 2,
	primary_handcart_settings_status_PRECHARGE = 3,
	primary_handcart_settings_status_READY = 4,
	primary_handcart_settings_status_CHARGE = 5,
	primary_handcart_settings_status_CHARGE_DONE = 6,
	primary_handcart_settings_status_BALANCING = 7,
	primary_handcart_settings_status_ERROR = 8,
} primary_handcart_settings_status;

typedef enum {
	primary_handcart_settings_set_fans_override_OFF = 0,
	primary_handcart_settings_set_fans_override_ON = 1,
} primary_handcart_settings_set_fans_override;

typedef enum {
	primary_handcart_settings_set_status_NONE = 0,
	primary_handcart_settings_set_status_CHECK = 1,
	primary_handcart_settings_set_status_IDLE = 2,
	primary_handcart_settings_set_status_PRECHARGE = 3,
	primary_handcart_settings_set_status_READY = 4,
	primary_handcart_settings_set_status_CHARGE = 5,
	primary_handcart_settings_set_status_CHARGE_DONE = 6,
	primary_handcart_settings_set_status_BALANCING = 7,
	primary_handcart_settings_set_status_ERROR = 8,
} primary_handcart_settings_set_status;

typedef enum {
	primary_set_ptt_status_status_OFF = 0,
	primary_set_ptt_status_status_ON = 1,
} primary_set_ptt_status_status;

typedef enum {
	primary_ptt_status_status_OFF = 0,
	primary_ptt_status_status_ON = 1,
} primary_ptt_status_status;

/**
 * Signals in message NLG5_DIAG_TX.
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Diag responded data to host
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint64_t lad_d_paramrp;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_nlg5_diag_tx_t;

/**
 * Signals in message NLG5_DIAG_TX.
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Diag responded data to host
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint64_t lad_d_paramrp;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_nlg5_diag_tx_converted_t;

/**
 * Signals in message NLG5_DIAG_RX.
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Diag requested data from host
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint64_t lad_d_paramrq;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_nlg5_diag_rx_t;

/**
 * Signals in message NLG5_DIAG_RX.
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Diag requested data from host
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint64_t lad_d_paramrq;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_nlg5_diag_rx_converted_t;

/**
 * Signals in message NLG5_ERR.
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * battery output overvoltage; error can only be cleared by cycling power ON-OFF-ON
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_e_oov;

    /**
     * Mains overvoltage 2 detected
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_e_mov_ii;

    /**
     * Mains overvoltage 1 detected
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_e_mov_i;

    /**
     * power stage short circuit condition detected; error can only be cleared by cycling power ON-OFF-ON
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_e_sc;

    /**
     * plausibility battery output voltage measurement wrong
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_e_p_om;

    /**
     * plausibility mains voltage measurement wrong
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_e_p_mv;

    /**
     * output fuse defective
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_e_of;

    /**
     * Mains fuse defective
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_e_mf;

    /**
     * wrong battery polarity;  error can only be cleared by cycling power ON-OFF-ON
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_e_b_p;

    /**
     * Temperature sensor for prim capacitor defective
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_e_t_c;

    /**
     * Temperature sensor for prim power stage defective
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_e_t_pow;

    /**
     * Temperature sensor for diodes defective
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_e_t_dio;

    /**
     * Temperature sensor for transformer defective
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_e_t_tr;

    /**
     * Ext. temperature sensor 1 defective (if enabled)
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_e_t_ext1;

    /**
     * Ext. temperature sensor 2 defective (if enabled)
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_e_t_ext2;

    /**
     * Ext. temperature sensor 3 defective (if enabled)
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_e_t_ext3;

    /**
     * Flash memory checksum failure
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_e_f_crc;

    /**
     * NVSRAM check sum failure; contains most of the scaling & calibration values, CAN ID's and  charging profile etc.
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_e_nv_crc;

    /**
     * Sys EEPROM checksum failure
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_e_es_crc;

    /**
     * Pow EEPROM checksum failure
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_e_ep_crc;

    /**
     * Internal Watchdog Timeout
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_e_wdt;

    /**
     * Initialization error
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_e_init;

    /**
     * CAN timeout, no control message received for >300ms
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_e_c_to;

    /**
     * CAN off, transmit buffer >255
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_e_c_off;

    /**
     * CAN transmit buffer >127
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_e_c_tx;

    /**
     * CAN receiver buffer >127
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_e_c_rx;

    /**
     * Emergency Shutdown Threshold 'Battery Temperature' is exceeded; see ChargeStar help section 'protective features';  error can only be cleared by cycling power ON-OFF-ON
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_e_sdt_bt;

    /**
     * Emergency Shutdown Threshold 'Battery Voltage' is exceeded; see ChargeStar help section 'protective features';  error can only be cleared by cycling power ON-OFF-ON
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_e_sdt_bv;

    /**
     * Emergency Shutdown Threshold 'Amp Hours' is exceeded; see ChargeStar help section 'protective features';  error can only be cleared by cycling power ON-OFF-ON
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_e_sdt_ah;

    /**
     * Emergency Shutdown Threshold 'Charging Time' is exceeded; see ChargeStar help section 'protective features';  error can only be cleared by cycling power ON-OFF-ON
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_e_sdt_ct;

    /**
     * Output power limited by low mains voltage
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_w_pl_mv;

    /**
     * Output power limited by low battery voltage
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_w_pl_bv;

    /**
     * Output power limited by charger internal overtemperature
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_w_pl_it;

    /**
     * Commanded value is out of specified range; max or min applicable value is assumed instead
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_w_c_vor;

    /**
     * NLG5 Control message not active
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_w_cm_na;

    /**
     * LED Output driver defective, LEDs cant be controlled by NLG5 anymore. Charging is still possible.
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_w_od;

    /**
     * Save-Charging-Mode reduces primary current to 3.95 A as long as one of the four internal temperature sensors indicates -18 C or less.
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_w_sc_m;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_nlg5_err_t;

/**
 * Signals in message NLG5_ERR.
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * battery output overvoltage; error can only be cleared by cycling power ON-OFF-ON
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int nlg5_e_oov : 1;

    /**
     * Mains overvoltage 2 detected
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int nlg5_e_mov_ii : 1;

    /**
     * Mains overvoltage 1 detected
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int nlg5_e_mov_i : 1;

    /**
     * power stage short circuit condition detected; error can only be cleared by cycling power ON-OFF-ON
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int nlg5_e_sc : 1;

    /**
     * plausibility battery output voltage measurement wrong
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int nlg5_e_p_om : 1;

    /**
     * plausibility mains voltage measurement wrong
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int nlg5_e_p_mv : 1;

    /**
     * output fuse defective
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int nlg5_e_of : 1;

    /**
     * Mains fuse defective
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int nlg5_e_mf : 1;

    /**
     * wrong battery polarity;  error can only be cleared by cycling power ON-OFF-ON
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int nlg5_e_b_p : 1;

    /**
     * Temperature sensor for prim capacitor defective
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int nlg5_e_t_c : 1;

    /**
     * Temperature sensor for prim power stage defective
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int nlg5_e_t_pow : 1;

    /**
     * Temperature sensor for diodes defective
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int nlg5_e_t_dio : 1;

    /**
     * Temperature sensor for transformer defective
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int nlg5_e_t_tr : 1;

    /**
     * Ext. temperature sensor 1 defective (if enabled)
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int nlg5_e_t_ext1 : 1;

    /**
     * Ext. temperature sensor 2 defective (if enabled)
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int nlg5_e_t_ext2 : 1;

    /**
     * Ext. temperature sensor 3 defective (if enabled)
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int nlg5_e_t_ext3 : 1;

    /**
     * Flash memory checksum failure
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int nlg5_e_f_crc : 1;

    /**
     * NVSRAM check sum failure; contains most of the scaling & calibration values, CAN ID's and  charging profile etc.
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int nlg5_e_nv_crc : 1;

    /**
     * Sys EEPROM checksum failure
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int nlg5_e_es_crc : 1;

    /**
     * Pow EEPROM checksum failure
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int nlg5_e_ep_crc : 1;

    /**
     * Internal Watchdog Timeout
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int nlg5_e_wdt : 1;

    /**
     * Initialization error
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int nlg5_e_init : 1;

    /**
     * CAN timeout, no control message received for >300ms
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int nlg5_e_c_to : 1;

    /**
     * CAN off, transmit buffer >255
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int nlg5_e_c_off : 1;

    /**
     * CAN transmit buffer >127
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int nlg5_e_c_tx : 1;

    /**
     * CAN receiver buffer >127
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int nlg5_e_c_rx : 1;

    /**
     * Emergency Shutdown Threshold 'Battery Temperature' is exceeded; see ChargeStar help section 'protective features';  error can only be cleared by cycling power ON-OFF-ON
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int nlg5_e_sdt_bt : 1;

    /**
     * Emergency Shutdown Threshold 'Battery Voltage' is exceeded; see ChargeStar help section 'protective features';  error can only be cleared by cycling power ON-OFF-ON
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int nlg5_e_sdt_bv : 1;

    /**
     * Emergency Shutdown Threshold 'Amp Hours' is exceeded; see ChargeStar help section 'protective features';  error can only be cleared by cycling power ON-OFF-ON
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int nlg5_e_sdt_ah : 1;

    /**
     * Emergency Shutdown Threshold 'Charging Time' is exceeded; see ChargeStar help section 'protective features';  error can only be cleared by cycling power ON-OFF-ON
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int nlg5_e_sdt_ct : 1;

    /**
     * Output power limited by low mains voltage
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int nlg5_w_pl_mv : 1;

    /**
     * Output power limited by low battery voltage
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int nlg5_w_pl_bv : 1;

    /**
     * Output power limited by charger internal overtemperature
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int nlg5_w_pl_it : 1;

    /**
     * Commanded value is out of specified range; max or min applicable value is assumed instead
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int nlg5_w_c_vor : 1;

    /**
     * NLG5 Control message not active
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    unsigned int nlg5_w_cm_na : 1;

    /**
     * LED Output driver defective, LEDs cant be controlled by NLG5 anymore. Charging is still possible.
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    unsigned int nlg5_w_od : 1;

    /**
     * Save-Charging-Mode reduces primary current to 3.95 A as long as one of the four internal temperature sensors indicates -18 C or less.
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    unsigned int nlg5_w_sc_m : 1;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_nlg5_err_converted_t;

/**
 * Signals in message NLG5_TEMP.
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Power stage temperature
     *
     * Range: -400..3000 (-40..300 C)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t nlg5_p_tmp;

    /**
     * Value of external battery temperature sensor #1 (if connected and enabled)
     *
     * Range: -400..3000 (-40..300 C)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t nlg5_tmp_ext1;

    /**
     * Value of external battery temperature sensor #2 (if connected and enabled)
     *
     * Range: -400..3000 (-40..300 C)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t nlg5_temp_ext2;

    /**
     * Value of external battery temperature sensor #3 (if connected and enabled)
     *
     * Range: -400..3000 (-40..300 C)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t nlg5_tmp_ext3;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_nlg5_temp_t;

/**
 * Signals in message NLG5_TEMP.
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Power stage temperature
     *
     * Range: -400..3000 (-40..300 C)
     * Scale: 0.1
     * Offset: 0
     */
    float nlg5_p_tmp;

    /**
     * Value of external battery temperature sensor #1 (if connected and enabled)
     *
     * Range: -400..3000 (-40..300 C)
     * Scale: 0.1
     * Offset: 0
     */
    float nlg5_tmp_ext1;

    /**
     * Value of external battery temperature sensor #2 (if connected and enabled)
     *
     * Range: -400..3000 (-40..300 C)
     * Scale: 0.1
     * Offset: 0
     */
    float nlg5_temp_ext2;

    /**
     * Value of external battery temperature sensor #3 (if connected and enabled)
     *
     * Range: -400..3000 (-40..300 C)
     * Scale: 0.1
     * Offset: 0
     */
    float nlg5_tmp_ext3;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_nlg5_temp_converted_t;

/**
 * Signals in message NLG5_ACT_II.
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Value of mains current limit, commanded by the control pilot (SAE J1772) signal
     *
     * Range: 0..1000 (0..100 A)
     * Scale: 0.1
     * Offset: 0
     */
    uint16_t nlg5_s_mc_m_cp;

    /**
     * Value of mains current limit, commanded by the 'power indicator' (PI) analog input signal
     *
     * Range: 0..200 (0..20 A)
     * Scale: 0.1
     * Offset: 0
     */
    uint8_t nlg5_s_mc_m_pi;

    /**
     * Aux battery voltage
     *
     * Range: 0..250 (0..25 V)
     * Scale: 0.1
     * Offset: 0
     */
    uint8_t nlg5_abv;

    /**
     * Charge balance obtained via  Ext. Ah counter connected to DI1 / DI2
     *
     * Range: -32768..32767 (-327.68..327.67 Ah)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t nlg5_ahc_ext;

    /**
     * output current of the booster (if one is present and active)
     *
     * Range: 0..5000 (0..50 A)
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t nlg5_oc_bo;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_nlg5_act_ii_t;

/**
 * Signals in message NLG5_ACT_II.
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Value of mains current limit, commanded by the control pilot (SAE J1772) signal
     *
     * Range: 0..1000 (0..100 A)
     * Scale: 0.1
     * Offset: 0
     */
    float nlg5_s_mc_m_cp;

    /**
     * Value of mains current limit, commanded by the 'power indicator' (PI) analog input signal
     *
     * Range: 0..200 (0..20 A)
     * Scale: 0.1
     * Offset: 0
     */
    float nlg5_s_mc_m_pi;

    /**
     * Aux battery voltage
     *
     * Range: 0..250 (0..25 V)
     * Scale: 0.1
     * Offset: 0
     */
    float nlg5_abv;

    /**
     * Charge balance obtained via  Ext. Ah counter connected to DI1 / DI2
     *
     * Range: -32768..32767 (-327.68..327.67 Ah)
     * Scale: 0.01
     * Offset: 0
     */
    float nlg5_ahc_ext;

    /**
     * output current of the booster (if one is present and active)
     *
     * Range: 0..5000 (0..50 A)
     * Scale: 0.01
     * Offset: 0
     */
    float nlg5_oc_bo;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_nlg5_act_ii_converted_t;

/**
 * Signals in message NLG5_ACT_I.
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Actual mains current
     *
     * Range: 0..5000 (0..50 A)
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t nlg5_mc_act;

    /**
     * Actual mains voltage
     *
     * Range: 0..5000 (0..500 V)
     * Scale: 0.1
     * Offset: 0
     */
    uint16_t nlg5_mv_act;

    /**
     * Actual battery output voltage
     *
     * Range: 0..10000 (0..1000 V)
     * Scale: 0.1
     * Offset: 0
     */
    uint16_t nlg5_ov_act;

    /**
     * output current to the battery
     *
     * Range: 0..15000 (0..150 A)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t nlg5_oc_act;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_nlg5_act_i_t;

/**
 * Signals in message NLG5_ACT_I.
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Actual mains current
     *
     * Range: 0..5000 (0..50 A)
     * Scale: 0.01
     * Offset: 0
     */
    float nlg5_mc_act;

    /**
     * Actual mains voltage
     *
     * Range: 0..5000 (0..500 V)
     * Scale: 0.1
     * Offset: 0
     */
    float nlg5_mv_act;

    /**
     * Actual battery output voltage
     *
     * Range: 0..10000 (0..1000 V)
     * Scale: 0.1
     * Offset: 0
     */
    float nlg5_ov_act;

    /**
     * output current to the battery
     *
     * Range: 0..15000 (0..150 A)
     * Scale: 0.01
     * Offset: 0
     */
    float nlg5_oc_act;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_nlg5_act_i_converted_t;

/**
 * Signals in message NLG5_ST.
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Indicates if hardware enabled, i.e. a hi or lo signal is fed to the 'Power On' pin (pin3 of control connector)
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_s_he;

    /**
     * An error has been detected, red LED is ON, no power is output
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_s_err;

    /**
     * Warning condition on, i.e. charging power limited due to any limiting condition; red LED is blinking
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_s_war;

    /**
     * Charger cooling fan is active
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_s_fan;

    /**
     * European mains input detected (230V, 50Hz)
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_s_eum;

    /**
     * US mains level 1 (120VAC / 60Hz) detected
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_s_um_i;

    /**
     * US mains level 2 (240VAC / 60Hz) detected
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_s_um_ii;

    /**
     * Control pilot signal (SAE J1772) detected
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_s_cp_dt;

    /**
     * Bypass detection bit 1; 00: no bypass, 01: DC bypass detected, 10:AC bypass in phase, 11: AC bypass not in phase
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_s_bpd_i;

    /**
     * Bypass detection bit 2; 00: no bypass, 01: DC bypass detected, 10:AC bypass in phase, 11: AC bypass not in phase
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_s_bpd_ii;

    /**
     * Output power limited by battery output voltage limit
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_s_l_ov;

    /**
     * Output power limited by battery output current limit
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_s_l_oc;

    /**
     * Output power limited by mains current limit
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_s_l_mc;

    /**
     * Output power limited by analog input 'power indicator' (PI) limit
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_s_l_pi;

    /**
     * Output power limited by control pilot signal (SAE J1772)
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_s_l_cp;

    /**
     * Output power limited by maximum power capability of NLG5
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_s_l_pmax;

    /**
     * Output power limited by maximum mains current capability of NLG5
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_s_l_mc_max;

    /**
     * Output power limited by maximum output current capability of NLG5
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_s_l_oc_max;

    /**
     * Output power limited by maximum output voltage capability of NLG5
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_s_l_mo_max;

    /**
     * Output power limited by temperature of primary capacitors
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_s_l_t_cprim;

    /**
     * Output power limited by temperature of power stage
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_s_l_t_pow;

    /**
     * Output power limited by temperature of diodes
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_s_l_t_dio;

    /**
     * Output power limited by temperature of transformer
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_s_l_t_tr;

    /**
     * Output power limited by battery temperature
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_s_l_t_batt;

    /**
     * AUX 12 V Automatic Charging Active
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_s_aac;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_nlg5_st_t;

/**
 * Signals in message NLG5_ST.
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Indicates if hardware enabled, i.e. a hi or lo signal is fed to the 'Power On' pin (pin3 of control connector)
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int nlg5_s_he : 1;

    /**
     * An error has been detected, red LED is ON, no power is output
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int nlg5_s_err : 1;

    /**
     * Warning condition on, i.e. charging power limited due to any limiting condition; red LED is blinking
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int nlg5_s_war : 1;

    /**
     * Charger cooling fan is active
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int nlg5_s_fan : 1;

    /**
     * European mains input detected (230V, 50Hz)
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int nlg5_s_eum : 1;

    /**
     * US mains level 1 (120VAC / 60Hz) detected
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int nlg5_s_um_i : 1;

    /**
     * US mains level 2 (240VAC / 60Hz) detected
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int nlg5_s_um_ii : 1;

    /**
     * Control pilot signal (SAE J1772) detected
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int nlg5_s_cp_dt : 1;

    /**
     * Bypass detection bit 1; 00: no bypass, 01: DC bypass detected, 10:AC bypass in phase, 11: AC bypass not in phase
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int nlg5_s_bpd_i : 1;

    /**
     * Bypass detection bit 2; 00: no bypass, 01: DC bypass detected, 10:AC bypass in phase, 11: AC bypass not in phase
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int nlg5_s_bpd_ii : 1;

    /**
     * Output power limited by battery output voltage limit
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int nlg5_s_l_ov : 1;

    /**
     * Output power limited by battery output current limit
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int nlg5_s_l_oc : 1;

    /**
     * Output power limited by mains current limit
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int nlg5_s_l_mc : 1;

    /**
     * Output power limited by analog input 'power indicator' (PI) limit
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int nlg5_s_l_pi : 1;

    /**
     * Output power limited by control pilot signal (SAE J1772)
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int nlg5_s_l_cp : 1;

    /**
     * Output power limited by maximum power capability of NLG5
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int nlg5_s_l_pmax : 1;

    /**
     * Output power limited by maximum mains current capability of NLG5
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int nlg5_s_l_mc_max : 1;

    /**
     * Output power limited by maximum output current capability of NLG5
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int nlg5_s_l_oc_max : 1;

    /**
     * Output power limited by maximum output voltage capability of NLG5
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int nlg5_s_l_mo_max : 1;

    /**
     * Output power limited by temperature of primary capacitors
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int nlg5_s_l_t_cprim : 1;

    /**
     * Output power limited by temperature of power stage
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int nlg5_s_l_t_pow : 1;

    /**
     * Output power limited by temperature of diodes
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int nlg5_s_l_t_dio : 1;

    /**
     * Output power limited by temperature of transformer
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int nlg5_s_l_t_tr : 1;

    /**
     * Output power limited by battery temperature
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int nlg5_s_l_t_batt : 1;

    /**
     * AUX 12 V Automatic Charging Active
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int nlg5_s_aac : 1;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_nlg5_st_converted_t;

/**
 * Signals in message NLG5_CTL.
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Must be ON to enable power stage of the charger
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_c_c_en;

    /**
     * cycle this value 0-1-0 to clear all latched charger errors
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_c_c_el;

    /**
     * special signal to tell a charging station equipped with the Control Pilot interface (SAE J1772) to switch on the facility's ventilation (in order to get rid of battery gases like hydrogen, e.g.)
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_c_cp_v;

    /**
     * Enables CP-State C to request mains voltage
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_c_mr;

    /**
     * Maximum current to be drawn from the mains outlet, usually 16A. Must always contain a valid value in order to keep on charging.
     *
     * Range: 0..500 (0..50 A)
     * Scale: 0.1
     * Offset: 0
     */
    uint16_t nlg5_mc_max;

    /**
     * Desired voltage to be output to the battery. Must always contain a valid value in order to keep on charging.
     *
     * Range: 0..10000 (0..1000 V)
     * Scale: 0.1
     * Offset: 0
     */
    uint16_t nlg5_ov_com;

    /**
     * Desired battery current. Must always contain a valid value in order to keep on charging.
     *
     * Range: 0..1500 (0..150 A)
     * Scale: 0.1
     * Offset: 0
     */
    uint16_t nlg5_oc_com;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_nlg5_ctl_t;

/**
 * Signals in message NLG5_CTL.
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Must be ON to enable power stage of the charger
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int nlg5_c_c_en : 1;

    /**
     * cycle this value 0-1-0 to clear all latched charger errors
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int nlg5_c_c_el : 1;

    /**
     * special signal to tell a charging station equipped with the Control Pilot interface (SAE J1772) to switch on the facility's ventilation (in order to get rid of battery gases like hydrogen, e.g.)
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int nlg5_c_cp_v : 1;

    /**
     * Enables CP-State C to request mains voltage
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int nlg5_c_mr : 1;

    /**
     * Maximum current to be drawn from the mains outlet, usually 16A. Must always contain a valid value in order to keep on charging.
     *
     * Range: 0..500 (0..50 A)
     * Scale: 0.1
     * Offset: 0
     */
    float nlg5_mc_max;

    /**
     * Desired voltage to be output to the battery. Must always contain a valid value in order to keep on charging.
     *
     * Range: 0..10000 (0..1000 V)
     * Scale: 0.1
     * Offset: 0
     */
    float nlg5_ov_com;

    /**
     * Desired battery current. Must always contain a valid value in order to keep on charging.
     *
     * Range: 0..1500 (0..150 A)
     * Scale: 0.1
     * Offset: 0
     */
    float nlg5_oc_com;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_nlg5_ctl_converted_t;

/**
 * Signals in message BMS_HV_JMP_TO_BLT.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_bms_hv_jmp_to_blt_t;

/**
 * Signals in message BMS_HV_JMP_TO_BLT.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_bms_hv_jmp_to_blt_converted_t;

/**
 * Signals in message FLASH_BMS_HV_TX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_flash_bms_hv_tx_t;

/**
 * Signals in message FLASH_BMS_HV_TX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_flash_bms_hv_tx_converted_t;

/**
 * Signals in message FLASH_BMS_HV_RX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_flash_bms_hv_rx_t;

/**
 * Signals in message FLASH_BMS_HV_RX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_flash_bms_hv_rx_converted_t;

/**
 * Signals in message HV_CAN_FORWARD.
 *
 * Enable/disable can forwarding to internal bms network
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_hv_can_forward_can_forward_set can_forward_set;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_can_forward_t;

/**
 * Signals in message HV_CAN_FORWARD.
 *
 * Enable/disable can forwarding to internal bms network
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_hv_can_forward_can_forward_set can_forward_set;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_can_forward_converted_t;

/**
 * Signals in message FLASH_CELLBOARD_0_TX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_flash_cellboard_0_tx_t;

/**
 * Signals in message FLASH_CELLBOARD_0_TX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_flash_cellboard_0_tx_converted_t;

/**
 * Signals in message FLASH_CELLBOARD_0_RX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_flash_cellboard_0_rx_t;

/**
 * Signals in message FLASH_CELLBOARD_0_RX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_flash_cellboard_0_rx_converted_t;

/**
 * Signals in message FLASH_CELLBOARD_1_TX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_flash_cellboard_1_tx_t;

/**
 * Signals in message FLASH_CELLBOARD_1_TX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_flash_cellboard_1_tx_converted_t;

/**
 * Signals in message FLASH_CELLBOARD_1_RX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_flash_cellboard_1_rx_t;

/**
 * Signals in message FLASH_CELLBOARD_1_RX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_flash_cellboard_1_rx_converted_t;

/**
 * Signals in message FLASH_CELLBOARD_2_TX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_flash_cellboard_2_tx_t;

/**
 * Signals in message FLASH_CELLBOARD_2_TX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_flash_cellboard_2_tx_converted_t;

/**
 * Signals in message FLASH_CELLBOARD_2_RX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_flash_cellboard_2_rx_t;

/**
 * Signals in message FLASH_CELLBOARD_2_RX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_flash_cellboard_2_rx_converted_t;

/**
 * Signals in message FLASH_CELLBOARD_3_TX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_flash_cellboard_3_tx_t;

/**
 * Signals in message FLASH_CELLBOARD_3_TX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_flash_cellboard_3_tx_converted_t;

/**
 * Signals in message FLASH_CELLBOARD_3_RX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_flash_cellboard_3_rx_t;

/**
 * Signals in message FLASH_CELLBOARD_3_RX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_flash_cellboard_3_rx_converted_t;

/**
 * Signals in message FLASH_CELLBOARD_4_TX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_flash_cellboard_4_tx_t;

/**
 * Signals in message FLASH_CELLBOARD_4_TX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_flash_cellboard_4_tx_converted_t;

/**
 * Signals in message FLASH_CELLBOARD_4_RX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_flash_cellboard_4_rx_t;

/**
 * Signals in message FLASH_CELLBOARD_4_RX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_flash_cellboard_4_rx_converted_t;

/**
 * Signals in message FLASH_CELLBOARD_5_TX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_flash_cellboard_5_tx_t;

/**
 * Signals in message FLASH_CELLBOARD_5_TX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_flash_cellboard_5_tx_converted_t;

/**
 * Signals in message FLASH_CELLBOARD_5_RX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_flash_cellboard_5_rx_t;

/**
 * Signals in message FLASH_CELLBOARD_5_RX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_flash_cellboard_5_rx_converted_t;

/**
 * Signals in message BMS_LV_JMP_TO_BLT.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_bms_lv_jmp_to_blt_t;

/**
 * Signals in message BMS_LV_JMP_TO_BLT.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_bms_lv_jmp_to_blt_converted_t;

/**
 * Signals in message FLASH_BMS_LV_TX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_flash_bms_lv_tx_t;

/**
 * Signals in message FLASH_BMS_LV_TX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_flash_bms_lv_tx_converted_t;

/**
 * Signals in message FLASH_BMS_LV_RX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_flash_bms_lv_rx_t;

/**
 * Signals in message FLASH_BMS_LV_RX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_flash_bms_lv_rx_converted_t;

/**
 * Signals in message ECU_JMP_TO_BLT.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_ecu_jmp_to_blt_t;

/**
 * Signals in message ECU_JMP_TO_BLT.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_ecu_jmp_to_blt_converted_t;

/**
 * Signals in message FLASH_ECU_TX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_flash_ecu_tx_t;

/**
 * Signals in message FLASH_ECU_TX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_flash_ecu_tx_converted_t;

/**
 * Signals in message FLASH_ECU_RX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_flash_ecu_rx_t;

/**
 * Signals in message FLASH_ECU_RX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_flash_ecu_rx_converted_t;

/**
 * Signals in message STEERING_JMP_TO_BLT.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_steering_jmp_to_blt_t;

/**
 * Signals in message STEERING_JMP_TO_BLT.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_steering_jmp_to_blt_converted_t;

/**
 * Signals in message FLASH_STEERING_TX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_flash_steering_tx_t;

/**
 * Signals in message FLASH_STEERING_TX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_flash_steering_tx_converted_t;

/**
 * Signals in message FLASH_STEERING_RX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_flash_steering_rx_t;

/**
 * Signals in message FLASH_STEERING_RX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_flash_steering_rx_converted_t;

/**
 * Signals in message STEER_VERSION.
 *
 * periodic message containing current can definitions version
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t component_version;

    /**
     * Range: 0..4294967295 (0..4294967295 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t canlib_build_time;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_steer_version_t;

/**
 * Signals in message STEER_VERSION.
 *
 * periodic message containing current can definitions version
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t component_version;

    /**
     * Range: 0..4294967295 (0..4294967295 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t canlib_build_time;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_steer_version_converted_t;

/**
 * Signals in message DAS_VERSION.
 *
 * periodic message containing current can definitions version
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t component_version;

    /**
     * Range: 0..4294967295 (0..4294967295 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t canlib_build_time;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_das_version_t;

/**
 * Signals in message DAS_VERSION.
 *
 * periodic message containing current can definitions version
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t component_version;

    /**
     * Range: 0..4294967295 (0..4294967295 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t canlib_build_time;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_das_version_converted_t;

/**
 * Signals in message HV_VERSION.
 *
 * periodic message containing current can definitions version
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t component_version;

    /**
     * Range: 0..4294967295 (0..4294967295 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t canlib_build_time;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_version_t;

/**
 * Signals in message HV_VERSION.
 *
 * periodic message containing current can definitions version
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t component_version;

    /**
     * Range: 0..4294967295 (0..4294967295 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t canlib_build_time;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_version_converted_t;

/**
 * Signals in message LV_VERSION.
 *
 * periodic message containing current can definitions version
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t component_version;

    /**
     * Range: 0..4294967295 (0..4294967295 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t canlib_build_time;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_lv_version_t;

/**
 * Signals in message LV_VERSION.
 *
 * periodic message containing current can definitions version
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t component_version;

    /**
     * Range: 0..4294967295 (0..4294967295 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t canlib_build_time;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_lv_version_converted_t;

/**
 * Signals in message TLM_VERSION.
 *
 * periodic message containing current can definitions version
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t component_version;

    /**
     * Range: 0..4294967295 (0..4294967295 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t canlib_build_time;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_tlm_version_t;

/**
 * Signals in message TLM_VERSION.
 *
 * periodic message containing current can definitions version
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t component_version;

    /**
     * Range: 0..4294967295 (0..4294967295 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t canlib_build_time;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_tlm_version_converted_t;

/**
 * Signals in message TIMESTAMP.
 *
 * every second unix encoded time and date used by logging devices to sync
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..4294967295 (0..4294967295 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t timestamp;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_timestamp_t;

/**
 * Signals in message TIMESTAMP.
 *
 * every second unix encoded time and date used by logging devices to sync
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..4294967295 (0..4294967295 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t timestamp;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_timestamp_converted_t;

/**
 * Signals in message AMBIENT_TEMPERATURE.
 *
 * ambient temperature as send from IMU
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (-32768..32767 -)
     * Scale: 1
     * Offset: -32768
     */
    int16_t temp;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_ambient_temperature_t;

/**
 * Signals in message AMBIENT_TEMPERATURE.
 *
 * ambient temperature as send from IMU
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (-32768..32767 -)
     * Scale: 1
     * Offset: -32768
     */
    int16_t temp;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_ambient_temperature_converted_t;

/**
 * Signals in message DATA_LOGGER.
 *
 * data logger message
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..4294967295 (0..4294967295 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t placeholder1;

    /**
     * Range: 0..4294967295 (0..4294967295 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t placeholder2;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_data_logger_t;

/**
 * Signals in message DATA_LOGGER.
 *
 * data logger message
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..4294967295 (0..4294967295 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t placeholder1;

    /**
     * Range: 0..4294967295 (0..4294967295 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t placeholder2;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_data_logger_converted_t;

/**
 * Signals in message SET_TLM_STATUS.
 *
 * Ask telemetry to turn on/off and send a tuple containing the current{test, driver, map); only once
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_set_tlm_status_tlm_status tlm_status;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_set_tlm_status_t;

/**
 * Signals in message SET_TLM_STATUS.
 *
 * Ask telemetry to turn on/off and send a tuple containing the current{test, driver, map); only once
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_set_tlm_status_tlm_status tlm_status;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_set_tlm_status_converted_t;

/**
 * Signals in message TLM_STATUS.
 *
 * The answer to the steering wheel's message that changes the status of the telemetry
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_tlm_status_tlm_status tlm_status;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_tlm_status_t;

/**
 * Signals in message TLM_STATUS.
 *
 * The answer to the steering wheel's message that changes the status of the telemetry
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_tlm_status_tlm_status tlm_status;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_tlm_status_converted_t;

/**
 * Signals in message STEER_SYSTEM_STATUS.
 *
 * System stats of the raspberry pi inside the steering wheel
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t soc_temp;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_steer_system_status_t;

/**
 * Signals in message STEER_SYSTEM_STATUS.
 *
 * System stats of the raspberry pi inside the steering wheel
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t soc_temp;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_steer_system_status_converted_t;

/**
 * Signals in message HV_VOLTAGE.
 *
 * Pack stats
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (0..460 -)
     * Scale: 0.007019150072480354
     * Offset: 0
     */
    uint16_t pack_voltage;

    /**
     * Range: 0..65535 (0..460 -)
     * Scale: 0.007019150072480354
     * Offset: 0
     */
    uint16_t bus_voltage;

    /**
     * Range: 0..65535 (0..5 -)
     * Scale: 7.629510948348211e-05
     * Offset: 0
     */
    uint16_t max_cell_voltage;

    /**
     * Range: 0..65535 (0..5 -)
     * Scale: 7.629510948348211e-05
     * Offset: 0
     */
    uint16_t min_cell_voltage;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_voltage_t;

/**
 * Signals in message HV_VOLTAGE.
 *
 * Pack stats
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (0..460 -)
     * Scale: 0.007019150072480354
     * Offset: 0
     */
    float pack_voltage;

    /**
     * Range: 0..65535 (0..460 -)
     * Scale: 0.007019150072480354
     * Offset: 0
     */
    float bus_voltage;

    /**
     * Range: 0..65535 (0..5 -)
     * Scale: 7.629510948348211e-05
     * Offset: 0
     */
    float max_cell_voltage;

    /**
     * Range: 0..65535 (0..5 -)
     * Scale: 7.629510948348211e-05
     * Offset: 0
     */
    float min_cell_voltage;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_voltage_converted_t;

/**
 * Signals in message HV_CURRENT.
 *
 * Current and power supplied by the pack, energy and state of charge of the pack
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (-10..200 -)
     * Scale: 0.0032043945983062485
     * Offset: -10
     */
    uint16_t current;

    /**
     * Range: 0..65535 (0..100 -)
     * Scale: 0.0015259021896696422
     * Offset: 0
     */
    uint16_t power;

    /**
     * Range: 0..65535 (0..7000 -)
     * Scale: 0.10681315327687495
     * Offset: 0
     */
    uint16_t energy;

    /**
     * Range: 0..255 (0..100 -)
     * Scale: 0.39215686274509803
     * Offset: 0
     */
    uint8_t soc;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_current_t;

/**
 * Signals in message HV_CURRENT.
 *
 * Current and power supplied by the pack, energy and state of charge of the pack
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (-10..200 -)
     * Scale: 0.0032043945983062485
     * Offset: -10
     */
    float current;

    /**
     * Range: 0..65535 (0..100 -)
     * Scale: 0.0015259021896696422
     * Offset: 0
     */
    float power;

    /**
     * Range: 0..65535 (0..7000 -)
     * Scale: 0.10681315327687495
     * Offset: 0
     */
    float energy;

    /**
     * Range: 0..255 (0..100 -)
     * Scale: 0.39215686274509803
     * Offset: 0
     */
    float soc;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_current_converted_t;

/**
 * Signals in message HV_TEMP.
 *
 * Cell temperatures
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..255 (-20..80 -)
     * Scale: 0.39215686274509803
     * Offset: -20
     */
    uint8_t average_temp;

    /**
     * Range: 0..255 (-20..80 -)
     * Scale: 0.39215686274509803
     * Offset: -20
     */
    uint8_t max_temp;

    /**
     * Range: 0..255 (-20..80 -)
     * Scale: 0.39215686274509803
     * Offset: -20
     */
    uint8_t min_temp;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_temp_t;

/**
 * Signals in message HV_TEMP.
 *
 * Cell temperatures
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..255 (-20..80 -)
     * Scale: 0.39215686274509803
     * Offset: -20
     */
    float average_temp;

    /**
     * Range: 0..255 (-20..80 -)
     * Scale: 0.39215686274509803
     * Offset: -20
     */
    float max_temp;

    /**
     * Range: 0..255 (-20..80 -)
     * Scale: 0.39215686274509803
     * Offset: -20
     */
    float min_temp;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_temp_converted_t;

/**
 * Signals in message HV_ERRORS.
 *
 * Battery-related errors
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t warnings_cell_low_voltage;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t warnings_cell_under_voltage;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t warnings_cell_over_voltage;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t warnings_cell_high_temperature;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t warnings_cell_over_temperature;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t warnings_over_current;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t warnings_can;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t warnings_int_voltage_mismatch;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t warnings_cellboard_comm;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t warnings_cellboard_internal;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t warnings_connector_disconnected;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t warnings_fans_disconnected;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t warnings_feedback;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t warnings_feedback_circuitry;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t warnings_eeprom_comm;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t warnings_eeprom_write;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_cell_low_voltage;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_cell_under_voltage;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_cell_over_voltage;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_cell_high_temperature;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_cell_over_temperature;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_over_current;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_can;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_int_voltage_mismatch;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_cellboard_comm;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_cellboard_internal;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_connector_disconnected;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_fans_disconnected;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_feedback;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_feedback_circuitry;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_eeprom_comm;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_eeprom_write;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_errors_t;

/**
 * Signals in message HV_ERRORS.
 *
 * Battery-related errors
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int warnings_cell_low_voltage : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int warnings_cell_under_voltage : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int warnings_cell_over_voltage : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int warnings_cell_high_temperature : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int warnings_cell_over_temperature : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int warnings_over_current : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int warnings_can : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int warnings_int_voltage_mismatch : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int warnings_cellboard_comm : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int warnings_cellboard_internal : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int warnings_connector_disconnected : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int warnings_fans_disconnected : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int warnings_feedback : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int warnings_feedback_circuitry : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int warnings_eeprom_comm : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int warnings_eeprom_write : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_cell_low_voltage : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_cell_under_voltage : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_cell_over_voltage : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_cell_high_temperature : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_cell_over_temperature : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_over_current : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_can : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_int_voltage_mismatch : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_cellboard_comm : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_cellboard_internal : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_connector_disconnected : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_fans_disconnected : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_feedback : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_feedback_circuitry : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_eeprom_comm : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_eeprom_write : 1;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_errors_converted_t;

/**
 * Signals in message HV_FANS_OVERRIDE.
 *
 * override fans speed
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_hv_fans_override_fans_override fans_override;

    /**
     * Range: 0..65535 (0..1 -)
     * Scale: 1.5259021896696422e-05
     * Offset: 0
     */
    uint16_t fans_speed;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_fans_override_t;

/**
 * Signals in message HV_FANS_OVERRIDE.
 *
 * override fans speed
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_hv_fans_override_fans_override fans_override;

    /**
     * Range: 0..65535 (0..1 -)
     * Scale: 1.5259021896696422e-05
     * Offset: 0
     */
    float fans_speed;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_fans_override_converted_t;

/**
 * Signals in message HV_CAN_FORWARD_STATUS.
 *
 * Status of can forwarding to internal bms network
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_hv_can_forward_status_can_forward_status can_forward_status;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_can_forward_status_t;

/**
 * Signals in message HV_CAN_FORWARD_STATUS.
 *
 * Status of can forwarding to internal bms network
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_hv_can_forward_status_can_forward_status can_forward_status;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_can_forward_status_converted_t;

/**
 * Signals in message HV_FANS_OVERRIDE_STATUS.
 *
 * Status of fans override
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_hv_fans_override_status_fans_override fans_override;

    /**
     * Range: 0..65535 (0..1 -)
     * Scale: 1.5259021896696422e-05
     * Offset: 0
     */
    uint16_t fans_speed;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_fans_override_status_t;

/**
 * Signals in message HV_FANS_OVERRIDE_STATUS.
 *
 * Status of fans override
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_hv_fans_override_status_fans_override fans_override;

    /**
     * Range: 0..65535 (0..1 -)
     * Scale: 1.5259021896696422e-05
     * Offset: 0
     */
    float fans_speed;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_fans_override_status_converted_t;

/**
 * Signals in message HV_FEEDBACKS_STATUS.
 *
 * Errors on the feedbacks checks
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t feedbacks_status_feedback_implausibility_detected;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t feedbacks_status_feedback_imd_cockpit;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t feedbacks_status_feedback_tsal_green_fault_latched;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t feedbacks_status_feedback_bms_cockpit;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t feedbacks_status_feedback_ext_latched;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t feedbacks_status_feedback_tsal_green;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t feedbacks_status_feedback_ts_over_60v_status;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t feedbacks_status_feedback_airn_status;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t feedbacks_status_feedback_airp_status;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t feedbacks_status_feedback_airp_gate;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t feedbacks_status_feedback_airn_gate;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t feedbacks_status_feedback_precharge_status;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t feedbacks_status_feedback_tsp_over_60v_status;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t feedbacks_status_feedback_imd_fault;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t feedbacks_status_feedback_check_mux;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t feedbacks_status_feedback_sd_end;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t feedbacks_status_feedback_sd_out;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t feedbacks_status_feedback_sd_in;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t feedbacks_status_feedback_sd_bms;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t feedbacks_status_feedback_sd_imd;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t is_circuitry_error_feedback_implausibility_detected;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t is_circuitry_error_feedback_imd_cockpit;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t is_circuitry_error_feedback_tsal_green_fault_latched;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t is_circuitry_error_feedback_bms_cockpit;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t is_circuitry_error_feedback_ext_latched;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t is_circuitry_error_feedback_tsal_green;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t is_circuitry_error_feedback_ts_over_60v_status;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t is_circuitry_error_feedback_airn_status;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t is_circuitry_error_feedback_airp_status;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t is_circuitry_error_feedback_airp_gate;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t is_circuitry_error_feedback_airn_gate;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t is_circuitry_error_feedback_precharge_status;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t is_circuitry_error_feedback_tsp_over_60v_status;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t is_circuitry_error_feedback_imd_fault;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t is_circuitry_error_feedback_check_mux;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t is_circuitry_error_feedback_sd_end;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t is_circuitry_error_feedback_sd_out;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t is_circuitry_error_feedback_sd_in;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t is_circuitry_error_feedback_sd_bms;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t is_circuitry_error_feedback_sd_imd;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_feedbacks_status_t;

/**
 * Signals in message HV_FEEDBACKS_STATUS.
 *
 * Errors on the feedbacks checks
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int feedbacks_status_feedback_implausibility_detected : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int feedbacks_status_feedback_imd_cockpit : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int feedbacks_status_feedback_tsal_green_fault_latched : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int feedbacks_status_feedback_bms_cockpit : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int feedbacks_status_feedback_ext_latched : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int feedbacks_status_feedback_tsal_green : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int feedbacks_status_feedback_ts_over_60v_status : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int feedbacks_status_feedback_airn_status : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int feedbacks_status_feedback_airp_status : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int feedbacks_status_feedback_airp_gate : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int feedbacks_status_feedback_airn_gate : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int feedbacks_status_feedback_precharge_status : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int feedbacks_status_feedback_tsp_over_60v_status : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int feedbacks_status_feedback_imd_fault : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int feedbacks_status_feedback_check_mux : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int feedbacks_status_feedback_sd_end : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int feedbacks_status_feedback_sd_out : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int feedbacks_status_feedback_sd_in : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int feedbacks_status_feedback_sd_bms : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int feedbacks_status_feedback_sd_imd : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int is_circuitry_error_feedback_implausibility_detected : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int is_circuitry_error_feedback_imd_cockpit : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int is_circuitry_error_feedback_tsal_green_fault_latched : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int is_circuitry_error_feedback_bms_cockpit : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int is_circuitry_error_feedback_ext_latched : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int is_circuitry_error_feedback_tsal_green : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int is_circuitry_error_feedback_ts_over_60v_status : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int is_circuitry_error_feedback_airn_status : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int is_circuitry_error_feedback_airp_status : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int is_circuitry_error_feedback_airp_gate : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int is_circuitry_error_feedback_airn_gate : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int is_circuitry_error_feedback_precharge_status : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int is_circuitry_error_feedback_tsp_over_60v_status : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int is_circuitry_error_feedback_imd_fault : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int is_circuitry_error_feedback_check_mux : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int is_circuitry_error_feedback_sd_end : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int is_circuitry_error_feedback_sd_out : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int is_circuitry_error_feedback_sd_in : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int is_circuitry_error_feedback_sd_bms : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int is_circuitry_error_feedback_sd_imd : 1;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_feedbacks_status_converted_t;

/**
 * Signals in message HV_IMD_STATUS.
 *
 * Status of fans override
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t imd_fault;

    /**
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    primary_hv_imd_status_imd_status imd_status;

    /**
     * Range: 0..4294967295 (-2147483648..2147483647 -)
     * Scale: 1
     * Offset: -2147483648
     */
    int32_t imd_info;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_imd_status_t;

/**
 * Signals in message HV_IMD_STATUS.
 *
 * Status of fans override
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int imd_fault : 1;

    /**
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    primary_hv_imd_status_imd_status imd_status;

    /**
     * Range: 0..4294967295 (-2147483648..2147483647 -)
     * Scale: 1
     * Offset: -2147483648
     */
    int32_t imd_info;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_imd_status_converted_t;

/**
 * Signals in message TS_STATUS.
 *
 * BMS status
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    primary_ts_status_ts_status ts_status;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_ts_status_t;

/**
 * Signals in message TS_STATUS.
 *
 * BMS status
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    primary_ts_status_ts_status ts_status;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_ts_status_converted_t;

/**
 * Signals in message SET_TS_STATUS_DAS.
 *
 * Requests a TS status; only once
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_set_ts_status_das_ts_status_set ts_status_set;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_set_ts_status_das_t;

/**
 * Signals in message SET_TS_STATUS_DAS.
 *
 * Requests a TS status; only once
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_set_ts_status_das_ts_status_set ts_status_set;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_set_ts_status_das_converted_t;

/**
 * Signals in message SET_TS_STATUS_HANDCART.
 *
 * Requests a TS status; only once
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_set_ts_status_handcart_ts_status_set ts_status_set;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_set_ts_status_handcart_t;

/**
 * Signals in message SET_TS_STATUS_HANDCART.
 *
 * Requests a TS status; only once
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_set_ts_status_handcart_ts_status_set ts_status_set;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_set_ts_status_handcart_converted_t;

/**
 * Signals in message STEER_STATUS.
 *
 * Send update of the tuneable values from the steering wheel
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..15 (-0.5..1 -)
     * Scale: 0.1
     * Offset: -0.5
     */
    uint8_t map_pw;

    /**
     * Range: 0..15 (0..1 -)
     * Scale: 0.06666666666666667
     * Offset: 0
     */
    uint8_t map_sc;

    /**
     * Range: 0..15 (0..1 -)
     * Scale: 0.06666666666666667
     * Offset: 0
     */
    uint8_t map_tv;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_steer_status_t;

/**
 * Signals in message STEER_STATUS.
 *
 * Send update of the tuneable values from the steering wheel
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..15 (-0.5..1 -)
     * Scale: 0.1
     * Offset: -0.5
     */
    float map_pw;

    /**
     * Range: 0..15 (0..1 -)
     * Scale: 0.06666666666666667
     * Offset: 0
     */
    float map_sc;

    /**
     * Range: 0..15 (0..1 -)
     * Scale: 0.06666666666666667
     * Offset: 0
     */
    float map_tv;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_steer_status_converted_t;

/**
 * Signals in message SET_CAR_STATUS.
 *
 * Ask to DAS to change car status; only once
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    primary_set_car_status_car_status_set car_status_set;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_set_car_status_t;

/**
 * Signals in message SET_CAR_STATUS.
 *
 * Ask to DAS to change car status; only once
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    primary_set_car_status_car_status_set car_status_set;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_set_car_status_converted_t;

/**
 * Signals in message SET_PEDAL_CALIBRATION.
 *
 * Ask to calibrate pedals by specifying which pedal and if the value is the max or min
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_set_pedal_calibration_pedal pedal;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_set_pedal_calibration_bound bound;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_set_pedal_calibration_t;

/**
 * Signals in message SET_PEDAL_CALIBRATION.
 *
 * Ask to calibrate pedals by specifying which pedal and if the value is the max or min
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_set_pedal_calibration_pedal pedal;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_set_pedal_calibration_bound bound;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_set_pedal_calibration_converted_t;

/**
 * Signals in message PEDAL_CALIBRATION_ACK.
 *
 * Acknowledge the calibration of a pedal
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_pedal_calibration_ack_pedal pedal;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_pedal_calibration_ack_bound bound;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_pedal_calibration_ack_t;

/**
 * Signals in message PEDAL_CALIBRATION_ACK.
 *
 * Acknowledge the calibration of a pedal
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_pedal_calibration_ack_pedal pedal;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_pedal_calibration_ack_bound bound;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_pedal_calibration_ack_converted_t;

/**
 * Signals in message CAR_STATUS.
 *
 * Car status, all states managed by the DAS will be send (car status, inverters status)
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    primary_car_status_inverter_l inverter_l;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    primary_car_status_inverter_r inverter_r;

    /**
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    primary_car_status_car_status car_status;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_car_status_t;

/**
 * Signals in message CAR_STATUS.
 *
 * Car status, all states managed by the DAS will be send (car status, inverters status)
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    primary_car_status_inverter_l inverter_l;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    primary_car_status_inverter_r inverter_r;

    /**
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    primary_car_status_car_status car_status;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_car_status_converted_t;

/**
 * Signals in message DAS_ERRORS.
 *
 * DAS errors messages
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t das_error_pedal_adc;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t das_error_pedal_implausibility;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t das_error_imu_tout;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t das_error_irts_tout;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t das_error_ts_tout;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t das_error_invl_tout;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t das_error_invr_tout;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t das_error_steer_tout;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t das_error_fsm;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_das_errors_t;

/**
 * Signals in message DAS_ERRORS.
 *
 * DAS errors messages
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int das_error_pedal_adc : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int das_error_pedal_implausibility : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int das_error_imu_tout : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int das_error_irts_tout : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int das_error_ts_tout : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int das_error_invl_tout : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int das_error_invr_tout : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int das_error_steer_tout : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int das_error_fsm : 1;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_das_errors_converted_t;

/**
 * Signals in message ECU_FEEDBACKS.
 *
 * Send feedbacks status
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ecu_feedbacks_sd_cock_fb;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ecu_feedbacks_sd_fb1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ecu_feedbacks_sd_bots_fb;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ecu_feedbacks_sd_interial_fb;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ecu_feedbacks_sd_fb3;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ecu_feedbacks_sd_in;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ecu_feedbacks_sd_our;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ecu_feedbacks_sd_ctrl_pin;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_ecu_feedbacks_t;

/**
 * Signals in message ECU_FEEDBACKS.
 *
 * Send feedbacks status
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int ecu_feedbacks_sd_cock_fb : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int ecu_feedbacks_sd_fb1 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int ecu_feedbacks_sd_bots_fb : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int ecu_feedbacks_sd_interial_fb : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int ecu_feedbacks_sd_fb3 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int ecu_feedbacks_sd_in : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int ecu_feedbacks_sd_our : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int ecu_feedbacks_sd_ctrl_pin : 1;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_ecu_feedbacks_converted_t;

/**
 * Signals in message LV_STATUS.
 *
 * BMS LV internal state
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    primary_lv_status_status status;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_lv_status_t;

/**
 * Signals in message LV_STATUS.
 *
 * BMS LV internal state
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    primary_lv_status_status status;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_lv_status_converted_t;

/**
 * Signals in message LV_CURRENTS.
 *
 * Currents of AS Battery system, LV Battery and Charger
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (-10..50 -)
     * Scale: 0.0009155413138017853
     * Offset: -10
     */
    uint16_t current_as_battery;

    /**
     * Range: 0..65535 (-10..50 -)
     * Scale: 0.0009155413138017853
     * Offset: -10
     */
    uint16_t current_lv_battery;

    /**
     * Range: 0..65535 (-30..30 -)
     * Scale: 0.0009155413138017853
     * Offset: -30
     */
    uint16_t current_charger;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_lv_currents_t;

/**
 * Signals in message LV_CURRENTS.
 *
 * Currents of AS Battery system, LV Battery and Charger
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (-10..50 -)
     * Scale: 0.0009155413138017853
     * Offset: -10
     */
    float current_as_battery;

    /**
     * Range: 0..65535 (-10..50 -)
     * Scale: 0.0009155413138017853
     * Offset: -10
     */
    float current_lv_battery;

    /**
     * Range: 0..65535 (-30..30 -)
     * Scale: 0.0009155413138017853
     * Offset: -30
     */
    float current_charger;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_lv_currents_converted_t;

/**
 * Signals in message LV_CELLS_VOLTAGE.
 *
 * LV Voltages for each cell
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t start_index;

    /**
     * Range: 0..65535 (0..5 -)
     * Scale: 7.629510948348211e-05
     * Offset: 0
     */
    uint16_t voltage_0;

    /**
     * Range: 0..65535 (0..5 -)
     * Scale: 7.629510948348211e-05
     * Offset: 0
     */
    uint16_t voltage_1;

    /**
     * Range: 0..65535 (0..5 -)
     * Scale: 7.629510948348211e-05
     * Offset: 0
     */
    uint16_t voltage_2;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_lv_cells_voltage_t;

/**
 * Signals in message LV_CELLS_VOLTAGE.
 *
 * LV Voltages for each cell
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t start_index;

    /**
     * Range: 0..65535 (0..5 -)
     * Scale: 7.629510948348211e-05
     * Offset: 0
     */
    float voltage_0;

    /**
     * Range: 0..65535 (0..5 -)
     * Scale: 7.629510948348211e-05
     * Offset: 0
     */
    float voltage_1;

    /**
     * Range: 0..65535 (0..5 -)
     * Scale: 7.629510948348211e-05
     * Offset: 0
     */
    float voltage_2;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_lv_cells_voltage_converted_t;

/**
 * Signals in message LV_TOTAL_VOLTAGE.
 *
 * Voltage of LV battery pack
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..262143 (0..26 -)
     * Scale: 9.918250725748923e-05
     * Offset: 0
     */
    uint32_t total_voltage;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_lv_total_voltage_t;

/**
 * Signals in message LV_TOTAL_VOLTAGE.
 *
 * Voltage of LV battery pack
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..262143 (0..26 -)
     * Scale: 9.918250725748923e-05
     * Offset: 0
     */
    float total_voltage;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_lv_total_voltage_converted_t;

/**
 * Signals in message LV_CELLS_TEMP.
 *
 * Temperature C for each cell
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t start_index;

    /**
     * Range: 0..16383 (-20..80 -)
     * Scale: 0.0061038881767686015
     * Offset: -20
     */
    uint16_t temp_0;

    /**
     * Range: 0..16383 (-20..80 -)
     * Scale: 0.0061038881767686015
     * Offset: -20
     */
    uint16_t temp_1;

    /**
     * Range: 0..16383 (-20..80 -)
     * Scale: 0.0061038881767686015
     * Offset: -20
     */
    uint16_t temp_2;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_lv_cells_temp_t;

/**
 * Signals in message LV_CELLS_TEMP.
 *
 * Temperature C for each cell
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t start_index;

    /**
     * Range: 0..16383 (-20..80 -)
     * Scale: 0.0061038881767686015
     * Offset: -20
     */
    float temp_0;

    /**
     * Range: 0..16383 (-20..80 -)
     * Scale: 0.0061038881767686015
     * Offset: -20
     */
    float temp_1;

    /**
     * Range: 0..16383 (-20..80 -)
     * Scale: 0.0061038881767686015
     * Offset: -20
     */
    float temp_2;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_lv_cells_temp_converted_t;

/**
 * Signals in message COOLING_STATUS.
 *
 * Percentage value from 0% to 100% of radiator fans and pumps speed, 8bit
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (-1..1 -)
     * Scale: 3.0518043793392844e-05
     * Offset: -1
     */
    uint16_t radiators_speed;

    /**
     * Range: 0..65535 (-1..1 -)
     * Scale: 3.0518043793392844e-05
     * Offset: -1
     */
    uint16_t pumps_speed;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_cooling_status_t;

/**
 * Signals in message COOLING_STATUS.
 *
 * Percentage value from 0% to 100% of radiator fans and pumps speed, 8bit
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (-1..1 -)
     * Scale: 3.0518043793392844e-05
     * Offset: -1
     */
    float radiators_speed;

    /**
     * Range: 0..65535 (-1..1 -)
     * Scale: 3.0518043793392844e-05
     * Offset: -1
     */
    float pumps_speed;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_cooling_status_converted_t;

/**
 * Signals in message SET_RADIATOR_SPEED.
 *
 * Set both radiators speed
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (-1..1 -)
     * Scale: 3.0518043793392844e-05
     * Offset: -1
     */
    uint16_t radiators_speed;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_set_radiator_speed_t;

/**
 * Signals in message SET_RADIATOR_SPEED.
 *
 * Set both radiators speed
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (-1..1 -)
     * Scale: 3.0518043793392844e-05
     * Offset: -1
     */
    float radiators_speed;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_set_radiator_speed_converted_t;

/**
 * Signals in message SET_PUMPS_SPEED.
 *
 * Set both pumps speed
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (-1..1 -)
     * Scale: 3.0518043793392844e-05
     * Offset: -1
     */
    uint16_t pumps_speed;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_set_pumps_speed_t;

/**
 * Signals in message SET_PUMPS_SPEED.
 *
 * Set both pumps speed
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (-1..1 -)
     * Scale: 3.0518043793392844e-05
     * Offset: -1
     */
    float pumps_speed;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_set_pumps_speed_converted_t;

/**
 * Signals in message SET_INVERTER_CONNECTION_STATUS.
 *
 * Set the status of the inverter inputs RFE and RUN
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_set_inverter_connection_status_status status;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_set_inverter_connection_status_t;

/**
 * Signals in message SET_INVERTER_CONNECTION_STATUS.
 *
 * Set the status of the inverter inputs RFE and RUN
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_set_inverter_connection_status_status status;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_set_inverter_connection_status_converted_t;

/**
 * Signals in message INVERTER_CONNECTION_STATUS.
 *
 * Inverter status
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_connection_status_status status;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_inverter_connection_status_t;

/**
 * Signals in message INVERTER_CONNECTION_STATUS.
 *
 * Inverter status
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_connection_status_status status;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_inverter_connection_status_converted_t;

/**
 * Signals in message LV_ERRORS.
 *
 * LV Battery-related errors
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t warnings_cell_undervoltage;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t warnings_cell_overvoltage;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t warnings_battery_open_wire;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t warnings_can;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t warnings_spi;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t warnings_over_current;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t warnings_cell_under_temperature;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t warnings_cell_over_temperature;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t warnings_relay;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t warnings_bms_monitor;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t warnings_voltages_not_ready;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t warnings_mcp23017;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t warnings_radiator;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t warnings_fan;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t warnings_pump;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t warnings_adc_init;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t warnings_mux;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_cell_undervoltage;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_cell_overvoltage;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_battery_open_wire;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_can;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_spi;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_over_current;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_cell_under_temperature;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_cell_over_temperature;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_relay;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_bms_monitor;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_voltages_not_ready;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_mcp23017;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_radiator;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_fan;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_pump;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_adc_init;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_mux;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_lv_errors_t;

/**
 * Signals in message LV_ERRORS.
 *
 * LV Battery-related errors
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int warnings_cell_undervoltage : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int warnings_cell_overvoltage : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int warnings_battery_open_wire : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int warnings_can : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int warnings_spi : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int warnings_over_current : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int warnings_cell_under_temperature : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int warnings_cell_over_temperature : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int warnings_relay : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int warnings_bms_monitor : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int warnings_voltages_not_ready : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int warnings_mcp23017 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int warnings_radiator : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int warnings_fan : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int warnings_pump : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int warnings_adc_init : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int warnings_mux : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_cell_undervoltage : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_cell_overvoltage : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_battery_open_wire : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_can : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_spi : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_over_current : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_cell_under_temperature : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_cell_over_temperature : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_relay : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_bms_monitor : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_voltages_not_ready : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_mcp23017 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_radiator : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_fan : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_pump : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_adc_init : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_mux : 1;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_lv_errors_converted_t;

/**
 * Signals in message LV_HEALTH_SIGNALS.
 *
 * LV Battery health signals
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t health_signals_lvms_out;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t health_signals_relay_out;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t health_signals_battery_voltage_out;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t health_signals_charger_current;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t health_signals_battery_current;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t health_signals_sign_battery_current;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t health_code;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_lv_health_signals_t;

/**
 * Signals in message LV_HEALTH_SIGNALS.
 *
 * LV Battery health signals
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int health_signals_lvms_out : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int health_signals_relay_out : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int health_signals_battery_voltage_out : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int health_signals_charger_current : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int health_signals_battery_current : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int health_signals_sign_battery_current : 1;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t health_code;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_lv_health_signals_converted_t;

/**
 * Signals in message LV_FEEDBACKS.
 *
 * LV Battery-related errors
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t feedbacks_bspd_fb;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t feedbacks_hvd_fb;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t feedbacks_lvms_fb;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t feedbacks_res_fb;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t feedbacks_lv_encl;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t feedbacks_invc_lid_fb;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t feedbacks_hv_encl_2_fb;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t feedbacks_back_plate_fb;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t feedbacks_invc_interlock_fb;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t feedbacks_ams_fb;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t feedbacks_asms_fb;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t feedbacks_interlock_fb;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t feedbacks_inverters_fb;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t feedbacks_pcbs_fb;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t feedbacks_pumps_fb;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t feedbacks_shutdown_fb;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t feedbacks_radiators_fb;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t feedbacks_fan_fb;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t feedbacks_as_actuation_fb;

    /**
     * Range: 0..2047 (0..12 -)
     * Scale: 0.005862237420615535
     * Offset: 0
     */
    uint16_t sd_start;

    /**
     * Range: 0..2047 (0..12 -)
     * Scale: 0.005862237420615535
     * Offset: 0
     */
    uint16_t sd_end;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_lv_feedbacks_t;

/**
 * Signals in message LV_FEEDBACKS.
 *
 * LV Battery-related errors
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int feedbacks_bspd_fb : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int feedbacks_hvd_fb : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int feedbacks_lvms_fb : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int feedbacks_res_fb : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int feedbacks_lv_encl : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int feedbacks_invc_lid_fb : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int feedbacks_hv_encl_2_fb : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int feedbacks_back_plate_fb : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int feedbacks_invc_interlock_fb : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int feedbacks_ams_fb : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int feedbacks_asms_fb : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int feedbacks_interlock_fb : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int feedbacks_inverters_fb : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int feedbacks_pcbs_fb : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int feedbacks_pumps_fb : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int feedbacks_shutdown_fb : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int feedbacks_radiators_fb : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int feedbacks_fan_fb : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int feedbacks_as_actuation_fb : 1;

    /**
     * Range: 0..2047 (0..12 -)
     * Scale: 0.005862237420615535
     * Offset: 0
     */
    float sd_start;

    /**
     * Range: 0..2047 (0..12 -)
     * Scale: 0.005862237420615535
     * Offset: 0
     */
    float sd_end;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_lv_feedbacks_converted_t;

/**
 * Signals in message SHUTDOWN_STATUS.
 *
 * Shutdown status
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t input;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t output;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_shutdown_status_t;

/**
 * Signals in message SHUTDOWN_STATUS.
 *
 * Shutdown status
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int input : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int output : 1;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_shutdown_status_converted_t;

/**
 * Signals in message LV_CAN_FLASH_REQ.
 *
 * Request to flash the LV BMS via CAN
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_lv_can_flash_req_t;

/**
 * Signals in message LV_CAN_FLASH_REQ.
 *
 * Request to flash the LV BMS via CAN
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_lv_can_flash_req_converted_t;

/**
 * Signals in message LV_CAN_FLASH_ACK.
 *
 * Acknowledge to flash the LV BMS via CAN
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    primary_lv_can_flash_ack_response response;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_lv_can_flash_ack_t;

/**
 * Signals in message LV_CAN_FLASH_ACK.
 *
 * Acknowledge to flash the LV BMS via CAN
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    primary_lv_can_flash_ack_response response;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_lv_can_flash_ack_converted_t;

/**
 * Signals in message MARKER.
 *
 * Send a marker to telemetry
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_marker_t;

/**
 * Signals in message MARKER.
 *
 * Send a marker to telemetry
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_marker_converted_t;

/**
 * Signals in message HV_CELLS_VOLTAGE.
 *
 * Voltages for each cell
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t start_index;

    /**
     * Range: 0..65535 (0..5 -)
     * Scale: 7.629510948348211e-05
     * Offset: 0
     */
    uint16_t voltage_0;

    /**
     * Range: 0..65535 (0..5 -)
     * Scale: 7.629510948348211e-05
     * Offset: 0
     */
    uint16_t voltage_1;

    /**
     * Range: 0..65535 (0..5 -)
     * Scale: 7.629510948348211e-05
     * Offset: 0
     */
    uint16_t voltage_2;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_cells_voltage_t;

/**
 * Signals in message HV_CELLS_VOLTAGE.
 *
 * Voltages for each cell
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t start_index;

    /**
     * Range: 0..65535 (0..5 -)
     * Scale: 7.629510948348211e-05
     * Offset: 0
     */
    float voltage_0;

    /**
     * Range: 0..65535 (0..5 -)
     * Scale: 7.629510948348211e-05
     * Offset: 0
     */
    float voltage_1;

    /**
     * Range: 0..65535 (0..5 -)
     * Scale: 7.629510948348211e-05
     * Offset: 0
     */
    float voltage_2;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_cells_voltage_converted_t;

/**
 * Signals in message HV_CELLS_TEMP.
 *
 * Cell temperatures
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t start_index;

    /**
     * Range: 0..255 (-20..80 -)
     * Scale: 0.39215686274509803
     * Offset: -20
     */
    uint8_t temp_0;

    /**
     * Range: 0..255 (-20..80 -)
     * Scale: 0.39215686274509803
     * Offset: -20
     */
    uint8_t temp_1;

    /**
     * Range: 0..255 (-20..80 -)
     * Scale: 0.39215686274509803
     * Offset: -20
     */
    uint8_t temp_2;

    /**
     * Range: 0..255 (-20..80 -)
     * Scale: 0.39215686274509803
     * Offset: -20
     */
    uint8_t temp_3;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_cells_temp_t;

/**
 * Signals in message HV_CELLS_TEMP.
 *
 * Cell temperatures
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t start_index;

    /**
     * Range: 0..255 (-20..80 -)
     * Scale: 0.39215686274509803
     * Offset: -20
     */
    float temp_0;

    /**
     * Range: 0..255 (-20..80 -)
     * Scale: 0.39215686274509803
     * Offset: -20
     */
    float temp_1;

    /**
     * Range: 0..255 (-20..80 -)
     * Scale: 0.39215686274509803
     * Offset: -20
     */
    float temp_2;

    /**
     * Range: 0..255 (-20..80 -)
     * Scale: 0.39215686274509803
     * Offset: -20
     */
    float temp_3;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_cells_temp_converted_t;

/**
 * Signals in message HV_CELL_BALANCING_STATUS.
 *
 * Cell balancing status
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    primary_hv_cell_balancing_status_cellboard_id cellboard_id;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_hv_cell_balancing_status_balancing_status balancing_status;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_can_comm;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_ltc_comm;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_temp_comm_0;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_temp_comm_1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_temp_comm_2;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_temp_comm_3;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_temp_comm_4;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_temp_comm_5;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_open_wire;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t balancing_cells_cell0;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t balancing_cells_cell1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t balancing_cells_cell2;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t balancing_cells_cell3;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t balancing_cells_cell4;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t balancing_cells_cell5;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t balancing_cells_cell6;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t balancing_cells_cell7;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t balancing_cells_cell8;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t balancing_cells_cell9;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t balancing_cells_cell10;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t balancing_cells_cell11;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t balancing_cells_cell12;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t balancing_cells_cell13;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t balancing_cells_cell14;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t balancing_cells_cell15;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t balancing_cells_cell16;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t balancing_cells_cell17;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_cell_balancing_status_t;

/**
 * Signals in message HV_CELL_BALANCING_STATUS.
 *
 * Cell balancing status
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    primary_hv_cell_balancing_status_cellboard_id cellboard_id;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_hv_cell_balancing_status_balancing_status balancing_status;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_can_comm : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_ltc_comm : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_temp_comm_0 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_temp_comm_1 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_temp_comm_2 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_temp_comm_3 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_temp_comm_4 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_temp_comm_5 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_open_wire : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int balancing_cells_cell0 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int balancing_cells_cell1 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int balancing_cells_cell2 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int balancing_cells_cell3 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int balancing_cells_cell4 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int balancing_cells_cell5 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int balancing_cells_cell6 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int balancing_cells_cell7 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int balancing_cells_cell8 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int balancing_cells_cell9 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int balancing_cells_cell10 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int balancing_cells_cell11 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int balancing_cells_cell12 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int balancing_cells_cell13 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int balancing_cells_cell14 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int balancing_cells_cell15 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int balancing_cells_cell16 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int balancing_cells_cell17 : 1;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_cell_balancing_status_converted_t;

/**
 * Signals in message SET_CELL_BALANCING_STATUS.
 *
 * Set cell balancing status; only once
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_set_cell_balancing_status_set_balancing_status set_balancing_status;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_set_cell_balancing_status_t;

/**
 * Signals in message SET_CELL_BALANCING_STATUS.
 *
 * Set cell balancing status; only once
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_set_cell_balancing_status_set_balancing_status set_balancing_status;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_set_cell_balancing_status_converted_t;

/**
 * Signals in message SPEED.
 *
 * Encoder and inverter speed in rad/sec
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (-200..200 -)
     * Scale: 0.006103608758678569
     * Offset: -200
     */
    uint16_t encoder_r;

    /**
     * Range: 0..65535 (-200..200 -)
     * Scale: 0.006103608758678569
     * Offset: -200
     */
    uint16_t encoder_l;

    /**
     * Range: 0..65535 (-200..200 -)
     * Scale: 0.006103608758678569
     * Offset: -200
     */
    uint16_t inverter_r;

    /**
     * Range: 0..65535 (-200..200 -)
     * Scale: 0.006103608758678569
     * Offset: -200
     */
    uint16_t inverter_l;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_speed_t;

/**
 * Signals in message SPEED.
 *
 * Encoder and inverter speed in rad/sec
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (-200..200 -)
     * Scale: 0.006103608758678569
     * Offset: -200
     */
    float encoder_r;

    /**
     * Range: 0..65535 (-200..200 -)
     * Scale: 0.006103608758678569
     * Offset: -200
     */
    float encoder_l;

    /**
     * Range: 0..65535 (-200..200 -)
     * Scale: 0.006103608758678569
     * Offset: -200
     */
    float inverter_r;

    /**
     * Range: 0..65535 (-200..200 -)
     * Scale: 0.006103608758678569
     * Offset: -200
     */
    float inverter_l;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_speed_converted_t;

/**
 * Signals in message INV_L_REQUEST.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_0;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_1;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_2;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_3;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_4;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_5;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_6;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_7;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_inv_l_request_t;

/**
 * Signals in message INV_L_REQUEST.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_0;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_1;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_2;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_3;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_4;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_5;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_6;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_7;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_inv_l_request_converted_t;

/**
 * Signals in message INV_R_REQUEST.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_0;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_1;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_2;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_3;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_4;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_5;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_6;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_7;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_inv_r_request_t;

/**
 * Signals in message INV_R_REQUEST.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_0;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_1;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_2;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_3;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_4;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_5;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_6;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_7;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_inv_r_request_converted_t;

/**
 * Signals in message INV_L_RESPONSE.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t reg_id;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_0;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_1;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_2;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_3;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_4;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_5;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_6;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_inv_l_response_t;

/**
 * Signals in message INV_L_RESPONSE.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t reg_id;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_0;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_1;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_2;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_3;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_4;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_5;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_6;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_inv_l_response_converted_t;

/**
 * Signals in message INV_R_RESPONSE.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t reg_id;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_0;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_1;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_2;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_3;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_4;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_5;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_6;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_inv_r_response_t;

/**
 * Signals in message INV_R_RESPONSE.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t reg_id;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_0;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_1;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_2;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_3;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_4;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_5;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_6;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_inv_r_response_converted_t;

/**
 * Signals in message CONTROL_OUTPUT.
 *
 * Control output, N*m
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (-10..50 -)
     * Scale: 0.0009155413138017853
     * Offset: -10
     */
    uint16_t estimated_velocity;

    /**
     * Range: 0..255 (0..80 -)
     * Scale: 0.3137254901960784
     * Offset: 0
     */
    uint8_t tmax_r;

    /**
     * Range: 0..255 (0..80 -)
     * Scale: 0.3137254901960784
     * Offset: 0
     */
    uint8_t tmax_l;

    /**
     * Range: 0..65535 (0..80 -)
     * Scale: 0.0012207217517357137
     * Offset: 0
     */
    uint16_t torque_l;

    /**
     * Range: 0..65535 (0..80 -)
     * Scale: 0.0012207217517357137
     * Offset: 0
     */
    uint16_t torque_r;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_control_output_t;

/**
 * Signals in message CONTROL_OUTPUT.
 *
 * Control output, N*m
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (-10..50 -)
     * Scale: 0.0009155413138017853
     * Offset: -10
     */
    float estimated_velocity;

    /**
     * Range: 0..255 (0..80 -)
     * Scale: 0.3137254901960784
     * Offset: 0
     */
    float tmax_r;

    /**
     * Range: 0..255 (0..80 -)
     * Scale: 0.3137254901960784
     * Offset: 0
     */
    float tmax_l;

    /**
     * Range: 0..65535 (0..80 -)
     * Scale: 0.0012207217517357137
     * Offset: 0
     */
    float torque_l;

    /**
     * Range: 0..65535 (0..80 -)
     * Scale: 0.0012207217517357137
     * Offset: 0
     */
    float torque_r;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_control_output_converted_t;

/**
 * Signals in message LC_RESET.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_lc_reset_t;

/**
 * Signals in message LC_RESET.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_lc_reset_converted_t;

/**
 * Signals in message HANDCART_STATUS.
 *
 * Sends updates on the presence of the handcart
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t connected;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_handcart_status_t;

/**
 * Signals in message HANDCART_STATUS.
 *
 * Sends updates on the presence of the handcart
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int connected : 1;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_handcart_status_converted_t;

/**
 * Signals in message HANDCART_SETTINGS.
 *
 * Setting from handcart to CAN
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..255.00000000000003 (300..454 -)
     * Scale: 0.6039215686274509
     * Offset: 300
     */
    uint8_t target_voltage;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_handcart_settings_fans_override fans_override;

    /**
     * Range: 0..255 (0..1 -)
     * Scale: 0.00392156862745098
     * Offset: 0
     */
    uint8_t fans_speed;

    /**
     * Range: 0..255 (1..16 -)
     * Scale: 0.058823529411764705
     * Offset: 1
     */
    uint8_t acc_charge_current;

    /**
     * Range: 0..255 (1..16 -)
     * Scale: 0.058823529411764705
     * Offset: 1
     */
    uint8_t grid_max_current;

    /**
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    primary_handcart_settings_status status;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_handcart_settings_t;

/**
 * Signals in message HANDCART_SETTINGS.
 *
 * Setting from handcart to CAN
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..255.00000000000003 (300..454 -)
     * Scale: 0.6039215686274509
     * Offset: 300
     */
    float target_voltage;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_handcart_settings_fans_override fans_override;

    /**
     * Range: 0..255 (0..1 -)
     * Scale: 0.00392156862745098
     * Offset: 0
     */
    float fans_speed;

    /**
     * Range: 0..255 (1..16 -)
     * Scale: 0.058823529411764705
     * Offset: 1
     */
    float acc_charge_current;

    /**
     * Range: 0..255 (1..16 -)
     * Scale: 0.058823529411764705
     * Offset: 1
     */
    float grid_max_current;

    /**
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    primary_handcart_settings_status status;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_handcart_settings_converted_t;

/**
 * Signals in message HANDCART_SETTINGS_SET.
 *
 * Setting from telemetry to handcart
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..255.00000000000003 (300..454 -)
     * Scale: 0.6039215686274509
     * Offset: 300
     */
    uint8_t target_voltage;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_handcart_settings_set_fans_override fans_override;

    /**
     * Range: 0..255 (0..1 -)
     * Scale: 0.00392156862745098
     * Offset: 0
     */
    uint8_t fans_speed;

    /**
     * Range: 0..255 (1..16 -)
     * Scale: 0.058823529411764705
     * Offset: 1
     */
    uint8_t acc_charge_current;

    /**
     * Range: 0..255 (1..16 -)
     * Scale: 0.058823529411764705
     * Offset: 1
     */
    uint8_t grid_max_current;

    /**
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    primary_handcart_settings_set_status status;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_handcart_settings_set_t;

/**
 * Signals in message HANDCART_SETTINGS_SET.
 *
 * Setting from telemetry to handcart
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..255.00000000000003 (300..454 -)
     * Scale: 0.6039215686274509
     * Offset: 300
     */
    float target_voltage;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_handcart_settings_set_fans_override fans_override;

    /**
     * Range: 0..255 (0..1 -)
     * Scale: 0.00392156862745098
     * Offset: 0
     */
    float fans_speed;

    /**
     * Range: 0..255 (1..16 -)
     * Scale: 0.058823529411764705
     * Offset: 1
     */
    float acc_charge_current;

    /**
     * Range: 0..255 (1..16 -)
     * Scale: 0.058823529411764705
     * Offset: 1
     */
    float grid_max_current;

    /**
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    primary_handcart_settings_set_status status;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_handcart_settings_set_converted_t;

/**
 * Signals in message SET_PTT_STATUS.
 *
 * PTT activation/deactivation status set
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_set_ptt_status_status status;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_set_ptt_status_t;

/**
 * Signals in message SET_PTT_STATUS.
 *
 * PTT activation/deactivation status set
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_set_ptt_status_status status;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_set_ptt_status_converted_t;

/**
 * Signals in message PTT_STATUS.
 *
 * PTT activation/deactivation status
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_ptt_status_status status;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_ptt_status_t;

/**
 * Signals in message PTT_STATUS.
 *
 * PTT activation/deactivation status
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_ptt_status_status status;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_ptt_status_converted_t;


void primary_nlg5_diag_tx_raw_to_conversion(
    primary_nlg5_diag_tx_converted_t *conversion,
    uint64_t lad_d_paramrp
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_nlg5_diag_tx_conversion_to_raw(
    primary_nlg5_diag_tx_t *raw,
    uint64_t lad_d_paramrp
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_nlg5_diag_tx_raw_to_conversion_struct(
    primary_nlg5_diag_tx_converted_t *conversion, 
    const primary_nlg5_diag_tx_t *raw);


void primary_nlg5_diag_tx_conversion_to_raw_struct(
    primary_nlg5_diag_tx_t *raw,
    const primary_nlg5_diag_tx_converted_t *conversion);


int primary_nlg5_diag_tx_to_string(primary_nlg5_diag_tx_t *message, char *buffer);

int primary_nlg5_diag_tx_to_string_file(primary_nlg5_diag_tx_t *message, FILE *buffer);

int primary_nlg5_diag_tx_fields(char *buffer);

int primary_nlg5_diag_tx_fields_file(FILE *buffer);

/**
 * Pack message NLG5_DIAG_TX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_nlg5_diag_tx_pack(
    uint8_t *dst_p,
    const primary_nlg5_diag_tx_t *src_p,
    size_t byte_size);

/**
 * Unpack message NLG5_DIAG_TX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_nlg5_diag_tx_unpack(
    primary_nlg5_diag_tx_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_diag_tx_lad_d_paramrp_is_in_range(uint64_t value);


void primary_nlg5_diag_rx_raw_to_conversion(
    primary_nlg5_diag_rx_converted_t *conversion,
    uint64_t lad_d_paramrq
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_nlg5_diag_rx_conversion_to_raw(
    primary_nlg5_diag_rx_t *raw,
    uint64_t lad_d_paramrq
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_nlg5_diag_rx_raw_to_conversion_struct(
    primary_nlg5_diag_rx_converted_t *conversion, 
    const primary_nlg5_diag_rx_t *raw);


void primary_nlg5_diag_rx_conversion_to_raw_struct(
    primary_nlg5_diag_rx_t *raw,
    const primary_nlg5_diag_rx_converted_t *conversion);


int primary_nlg5_diag_rx_to_string(primary_nlg5_diag_rx_t *message, char *buffer);

int primary_nlg5_diag_rx_to_string_file(primary_nlg5_diag_rx_t *message, FILE *buffer);

int primary_nlg5_diag_rx_fields(char *buffer);

int primary_nlg5_diag_rx_fields_file(FILE *buffer);

/**
 * Pack message NLG5_DIAG_RX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_nlg5_diag_rx_pack(
    uint8_t *dst_p,
    const primary_nlg5_diag_rx_t *src_p,
    size_t byte_size);

/**
 * Unpack message NLG5_DIAG_RX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_nlg5_diag_rx_unpack(
    primary_nlg5_diag_rx_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_diag_rx_lad_d_paramrq_is_in_range(uint64_t value);


void primary_nlg5_err_raw_to_conversion(
    primary_nlg5_err_converted_t *conversion,
    uint8_t nlg5_e_oov,
    uint8_t nlg5_e_mov_ii,
    uint8_t nlg5_e_mov_i,
    uint8_t nlg5_e_sc,
    uint8_t nlg5_e_p_om,
    uint8_t nlg5_e_p_mv,
    uint8_t nlg5_e_of,
    uint8_t nlg5_e_mf,
    uint8_t nlg5_e_b_p,
    uint8_t nlg5_e_t_c,
    uint8_t nlg5_e_t_pow,
    uint8_t nlg5_e_t_dio,
    uint8_t nlg5_e_t_tr,
    uint8_t nlg5_e_t_ext1,
    uint8_t nlg5_e_t_ext2,
    uint8_t nlg5_e_t_ext3,
    uint8_t nlg5_e_f_crc,
    uint8_t nlg5_e_nv_crc,
    uint8_t nlg5_e_es_crc,
    uint8_t nlg5_e_ep_crc,
    uint8_t nlg5_e_wdt,
    uint8_t nlg5_e_init,
    uint8_t nlg5_e_c_to,
    uint8_t nlg5_e_c_off,
    uint8_t nlg5_e_c_tx,
    uint8_t nlg5_e_c_rx,
    uint8_t nlg5_e_sdt_bt,
    uint8_t nlg5_e_sdt_bv,
    uint8_t nlg5_e_sdt_ah,
    uint8_t nlg5_e_sdt_ct,
    uint8_t nlg5_w_pl_mv,
    uint8_t nlg5_w_pl_bv,
    uint8_t nlg5_w_pl_it,
    uint8_t nlg5_w_c_vor,
    uint8_t nlg5_w_cm_na,
    uint8_t nlg5_w_od,
    uint8_t nlg5_w_sc_m
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_nlg5_err_conversion_to_raw(
    primary_nlg5_err_t *raw,
    uint8_t nlg5_e_oov,
    uint8_t nlg5_e_mov_ii,
    uint8_t nlg5_e_mov_i,
    uint8_t nlg5_e_sc,
    uint8_t nlg5_e_p_om,
    uint8_t nlg5_e_p_mv,
    uint8_t nlg5_e_of,
    uint8_t nlg5_e_mf,
    uint8_t nlg5_e_b_p,
    uint8_t nlg5_e_t_c,
    uint8_t nlg5_e_t_pow,
    uint8_t nlg5_e_t_dio,
    uint8_t nlg5_e_t_tr,
    uint8_t nlg5_e_t_ext1,
    uint8_t nlg5_e_t_ext2,
    uint8_t nlg5_e_t_ext3,
    uint8_t nlg5_e_f_crc,
    uint8_t nlg5_e_nv_crc,
    uint8_t nlg5_e_es_crc,
    uint8_t nlg5_e_ep_crc,
    uint8_t nlg5_e_wdt,
    uint8_t nlg5_e_init,
    uint8_t nlg5_e_c_to,
    uint8_t nlg5_e_c_off,
    uint8_t nlg5_e_c_tx,
    uint8_t nlg5_e_c_rx,
    uint8_t nlg5_e_sdt_bt,
    uint8_t nlg5_e_sdt_bv,
    uint8_t nlg5_e_sdt_ah,
    uint8_t nlg5_e_sdt_ct,
    uint8_t nlg5_w_pl_mv,
    uint8_t nlg5_w_pl_bv,
    uint8_t nlg5_w_pl_it,
    uint8_t nlg5_w_c_vor,
    uint8_t nlg5_w_cm_na,
    uint8_t nlg5_w_od,
    uint8_t nlg5_w_sc_m
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_nlg5_err_raw_to_conversion_struct(
    primary_nlg5_err_converted_t *conversion, 
    const primary_nlg5_err_t *raw);


void primary_nlg5_err_conversion_to_raw_struct(
    primary_nlg5_err_t *raw,
    const primary_nlg5_err_converted_t *conversion);


int primary_nlg5_err_to_string(primary_nlg5_err_t *message, char *buffer);

int primary_nlg5_err_to_string_file(primary_nlg5_err_t *message, FILE *buffer);

int primary_nlg5_err_fields(char *buffer);

int primary_nlg5_err_fields_file(FILE *buffer);

/**
 * Pack message NLG5_ERR.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_nlg5_err_pack(
    uint8_t *dst_p,
    const primary_nlg5_err_t *src_p,
    size_t byte_size);

/**
 * Unpack message NLG5_ERR.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_nlg5_err_unpack(
    primary_nlg5_err_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_err_nlg5_e_oov_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_err_nlg5_e_mov_ii_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_err_nlg5_e_mov_i_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_err_nlg5_e_sc_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_err_nlg5_e_p_om_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_err_nlg5_e_p_mv_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_err_nlg5_e_of_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_err_nlg5_e_mf_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_err_nlg5_e_b_p_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_err_nlg5_e_t_c_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_err_nlg5_e_t_pow_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_err_nlg5_e_t_dio_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_err_nlg5_e_t_tr_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_err_nlg5_e_t_ext1_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_err_nlg5_e_t_ext2_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_err_nlg5_e_t_ext3_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_err_nlg5_e_f_crc_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_err_nlg5_e_nv_crc_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_err_nlg5_e_es_crc_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_err_nlg5_e_ep_crc_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_err_nlg5_e_wdt_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_err_nlg5_e_init_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_err_nlg5_e_c_to_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_err_nlg5_e_c_off_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_err_nlg5_e_c_tx_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_err_nlg5_e_c_rx_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_err_nlg5_e_sdt_bt_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_err_nlg5_e_sdt_bv_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_err_nlg5_e_sdt_ah_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_err_nlg5_e_sdt_ct_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_err_nlg5_w_pl_mv_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_err_nlg5_w_pl_bv_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_err_nlg5_w_pl_it_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_err_nlg5_w_c_vor_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_err_nlg5_w_cm_na_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_err_nlg5_w_od_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_err_nlg5_w_sc_m_is_in_range(uint8_t value);


void primary_nlg5_temp_raw_to_conversion(
    primary_nlg5_temp_converted_t *conversion,
    float nlg5_p_tmp,
    float nlg5_tmp_ext1,
    float nlg5_temp_ext2,
    float nlg5_tmp_ext3
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_nlg5_temp_conversion_to_raw(
    primary_nlg5_temp_t *raw,
    float nlg5_p_tmp,
    float nlg5_tmp_ext1,
    float nlg5_temp_ext2,
    float nlg5_tmp_ext3
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_nlg5_temp_raw_to_conversion_struct(
    primary_nlg5_temp_converted_t *conversion, 
    const primary_nlg5_temp_t *raw);


void primary_nlg5_temp_conversion_to_raw_struct(
    primary_nlg5_temp_t *raw,
    const primary_nlg5_temp_converted_t *conversion);


int primary_nlg5_temp_converted_to_string(primary_nlg5_temp_converted_t *message, char *buffer);

int primary_nlg5_temp_converted_to_string_file(primary_nlg5_temp_converted_t *message, FILE *buffer);

int primary_nlg5_temp_fields(char *buffer);

int primary_nlg5_temp_fields_file(FILE *buffer);

/**
 * Pack message NLG5_TEMP.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_nlg5_temp_pack(
    uint8_t *dst_p,
    const primary_nlg5_temp_t *src_p,
    size_t byte_size);

/**
 * Unpack message NLG5_TEMP.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_nlg5_temp_unpack(
    primary_nlg5_temp_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t primary_nlg5_temp_nlg5_p_tmp_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_nlg5_temp_nlg5_p_tmp_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_temp_nlg5_p_tmp_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t primary_nlg5_temp_nlg5_tmp_ext1_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_nlg5_temp_nlg5_tmp_ext1_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_temp_nlg5_tmp_ext1_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t primary_nlg5_temp_nlg5_temp_ext2_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_nlg5_temp_nlg5_temp_ext2_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_temp_nlg5_temp_ext2_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t primary_nlg5_temp_nlg5_tmp_ext3_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_nlg5_temp_nlg5_tmp_ext3_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_temp_nlg5_tmp_ext3_is_in_range(int16_t value);


void primary_nlg5_act_ii_raw_to_conversion(
    primary_nlg5_act_ii_converted_t *conversion,
    float nlg5_s_mc_m_cp,
    float nlg5_s_mc_m_pi,
    float nlg5_abv,
    float nlg5_ahc_ext,
    float nlg5_oc_bo
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_nlg5_act_ii_conversion_to_raw(
    primary_nlg5_act_ii_t *raw,
    float nlg5_s_mc_m_cp,
    float nlg5_s_mc_m_pi,
    float nlg5_abv,
    float nlg5_ahc_ext,
    float nlg5_oc_bo
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_nlg5_act_ii_raw_to_conversion_struct(
    primary_nlg5_act_ii_converted_t *conversion, 
    const primary_nlg5_act_ii_t *raw);


void primary_nlg5_act_ii_conversion_to_raw_struct(
    primary_nlg5_act_ii_t *raw,
    const primary_nlg5_act_ii_converted_t *conversion);


int primary_nlg5_act_ii_converted_to_string(primary_nlg5_act_ii_converted_t *message, char *buffer);

int primary_nlg5_act_ii_converted_to_string_file(primary_nlg5_act_ii_converted_t *message, FILE *buffer);

int primary_nlg5_act_ii_fields(char *buffer);

int primary_nlg5_act_ii_fields_file(FILE *buffer);

/**
 * Pack message NLG5_ACT_II.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_nlg5_act_ii_pack(
    uint8_t *dst_p,
    const primary_nlg5_act_ii_t *src_p,
    size_t byte_size);

/**
 * Unpack message NLG5_ACT_II.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_nlg5_act_ii_unpack(
    primary_nlg5_act_ii_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_nlg5_act_ii_nlg5_s_mc_m_cp_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_nlg5_act_ii_nlg5_s_mc_m_cp_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_act_ii_nlg5_s_mc_m_cp_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t primary_nlg5_act_ii_nlg5_s_mc_m_pi_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_nlg5_act_ii_nlg5_s_mc_m_pi_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_act_ii_nlg5_s_mc_m_pi_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t primary_nlg5_act_ii_nlg5_abv_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_nlg5_act_ii_nlg5_abv_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_act_ii_nlg5_abv_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t primary_nlg5_act_ii_nlg5_ahc_ext_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_nlg5_act_ii_nlg5_ahc_ext_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_act_ii_nlg5_ahc_ext_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_nlg5_act_ii_nlg5_oc_bo_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_nlg5_act_ii_nlg5_oc_bo_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_act_ii_nlg5_oc_bo_is_in_range(uint16_t value);


void primary_nlg5_act_i_raw_to_conversion(
    primary_nlg5_act_i_converted_t *conversion,
    float nlg5_mc_act,
    float nlg5_mv_act,
    float nlg5_ov_act,
    float nlg5_oc_act
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_nlg5_act_i_conversion_to_raw(
    primary_nlg5_act_i_t *raw,
    float nlg5_mc_act,
    float nlg5_mv_act,
    float nlg5_ov_act,
    float nlg5_oc_act
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_nlg5_act_i_raw_to_conversion_struct(
    primary_nlg5_act_i_converted_t *conversion, 
    const primary_nlg5_act_i_t *raw);


void primary_nlg5_act_i_conversion_to_raw_struct(
    primary_nlg5_act_i_t *raw,
    const primary_nlg5_act_i_converted_t *conversion);


int primary_nlg5_act_i_converted_to_string(primary_nlg5_act_i_converted_t *message, char *buffer);

int primary_nlg5_act_i_converted_to_string_file(primary_nlg5_act_i_converted_t *message, FILE *buffer);

int primary_nlg5_act_i_fields(char *buffer);

int primary_nlg5_act_i_fields_file(FILE *buffer);

/**
 * Pack message NLG5_ACT_I.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_nlg5_act_i_pack(
    uint8_t *dst_p,
    const primary_nlg5_act_i_t *src_p,
    size_t byte_size);

/**
 * Unpack message NLG5_ACT_I.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_nlg5_act_i_unpack(
    primary_nlg5_act_i_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_nlg5_act_i_nlg5_mc_act_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_nlg5_act_i_nlg5_mc_act_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_act_i_nlg5_mc_act_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_nlg5_act_i_nlg5_mv_act_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_nlg5_act_i_nlg5_mv_act_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_act_i_nlg5_mv_act_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_nlg5_act_i_nlg5_ov_act_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_nlg5_act_i_nlg5_ov_act_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_act_i_nlg5_ov_act_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t primary_nlg5_act_i_nlg5_oc_act_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_nlg5_act_i_nlg5_oc_act_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_act_i_nlg5_oc_act_is_in_range(int16_t value);


void primary_nlg5_st_raw_to_conversion(
    primary_nlg5_st_converted_t *conversion,
    uint8_t nlg5_s_he,
    uint8_t nlg5_s_err,
    uint8_t nlg5_s_war,
    uint8_t nlg5_s_fan,
    uint8_t nlg5_s_eum,
    uint8_t nlg5_s_um_i,
    uint8_t nlg5_s_um_ii,
    uint8_t nlg5_s_cp_dt,
    uint8_t nlg5_s_bpd_i,
    uint8_t nlg5_s_bpd_ii,
    uint8_t nlg5_s_l_ov,
    uint8_t nlg5_s_l_oc,
    uint8_t nlg5_s_l_mc,
    uint8_t nlg5_s_l_pi,
    uint8_t nlg5_s_l_cp,
    uint8_t nlg5_s_l_pmax,
    uint8_t nlg5_s_l_mc_max,
    uint8_t nlg5_s_l_oc_max,
    uint8_t nlg5_s_l_mo_max,
    uint8_t nlg5_s_l_t_cprim,
    uint8_t nlg5_s_l_t_pow,
    uint8_t nlg5_s_l_t_dio,
    uint8_t nlg5_s_l_t_tr,
    uint8_t nlg5_s_l_t_batt,
    uint8_t nlg5_s_aac
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_nlg5_st_conversion_to_raw(
    primary_nlg5_st_t *raw,
    uint8_t nlg5_s_he,
    uint8_t nlg5_s_err,
    uint8_t nlg5_s_war,
    uint8_t nlg5_s_fan,
    uint8_t nlg5_s_eum,
    uint8_t nlg5_s_um_i,
    uint8_t nlg5_s_um_ii,
    uint8_t nlg5_s_cp_dt,
    uint8_t nlg5_s_bpd_i,
    uint8_t nlg5_s_bpd_ii,
    uint8_t nlg5_s_l_ov,
    uint8_t nlg5_s_l_oc,
    uint8_t nlg5_s_l_mc,
    uint8_t nlg5_s_l_pi,
    uint8_t nlg5_s_l_cp,
    uint8_t nlg5_s_l_pmax,
    uint8_t nlg5_s_l_mc_max,
    uint8_t nlg5_s_l_oc_max,
    uint8_t nlg5_s_l_mo_max,
    uint8_t nlg5_s_l_t_cprim,
    uint8_t nlg5_s_l_t_pow,
    uint8_t nlg5_s_l_t_dio,
    uint8_t nlg5_s_l_t_tr,
    uint8_t nlg5_s_l_t_batt,
    uint8_t nlg5_s_aac
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_nlg5_st_raw_to_conversion_struct(
    primary_nlg5_st_converted_t *conversion, 
    const primary_nlg5_st_t *raw);


void primary_nlg5_st_conversion_to_raw_struct(
    primary_nlg5_st_t *raw,
    const primary_nlg5_st_converted_t *conversion);


int primary_nlg5_st_to_string(primary_nlg5_st_t *message, char *buffer);

int primary_nlg5_st_to_string_file(primary_nlg5_st_t *message, FILE *buffer);

int primary_nlg5_st_fields(char *buffer);

int primary_nlg5_st_fields_file(FILE *buffer);

/**
 * Pack message NLG5_ST.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_nlg5_st_pack(
    uint8_t *dst_p,
    const primary_nlg5_st_t *src_p,
    size_t byte_size);

/**
 * Unpack message NLG5_ST.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_nlg5_st_unpack(
    primary_nlg5_st_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_st_nlg5_s_he_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_st_nlg5_s_err_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_st_nlg5_s_war_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_st_nlg5_s_fan_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_st_nlg5_s_eum_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_st_nlg5_s_um_i_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_st_nlg5_s_um_ii_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_st_nlg5_s_cp_dt_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_st_nlg5_s_bpd_i_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_st_nlg5_s_bpd_ii_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_st_nlg5_s_l_ov_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_st_nlg5_s_l_oc_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_st_nlg5_s_l_mc_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_st_nlg5_s_l_pi_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_st_nlg5_s_l_cp_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_st_nlg5_s_l_pmax_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_st_nlg5_s_l_mc_max_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_st_nlg5_s_l_oc_max_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_st_nlg5_s_l_mo_max_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_st_nlg5_s_l_t_cprim_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_st_nlg5_s_l_t_pow_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_st_nlg5_s_l_t_dio_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_st_nlg5_s_l_t_tr_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_st_nlg5_s_l_t_batt_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_st_nlg5_s_aac_is_in_range(uint8_t value);


void primary_nlg5_ctl_raw_to_conversion(
    primary_nlg5_ctl_converted_t *conversion,
    uint8_t nlg5_c_c_en,
    uint8_t nlg5_c_c_el,
    uint8_t nlg5_c_cp_v,
    uint8_t nlg5_c_mr,
    float nlg5_mc_max,
    float nlg5_ov_com,
    float nlg5_oc_com
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_nlg5_ctl_conversion_to_raw(
    primary_nlg5_ctl_t *raw,
    uint8_t nlg5_c_c_en,
    uint8_t nlg5_c_c_el,
    uint8_t nlg5_c_cp_v,
    uint8_t nlg5_c_mr,
    float nlg5_mc_max,
    float nlg5_ov_com,
    float nlg5_oc_com
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_nlg5_ctl_raw_to_conversion_struct(
    primary_nlg5_ctl_converted_t *conversion, 
    const primary_nlg5_ctl_t *raw);


void primary_nlg5_ctl_conversion_to_raw_struct(
    primary_nlg5_ctl_t *raw,
    const primary_nlg5_ctl_converted_t *conversion);


int primary_nlg5_ctl_converted_to_string(primary_nlg5_ctl_converted_t *message, char *buffer);

int primary_nlg5_ctl_converted_to_string_file(primary_nlg5_ctl_converted_t *message, FILE *buffer);

int primary_nlg5_ctl_fields(char *buffer);

int primary_nlg5_ctl_fields_file(FILE *buffer);

/**
 * Pack message NLG5_CTL.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_nlg5_ctl_pack(
    uint8_t *dst_p,
    const primary_nlg5_ctl_t *src_p,
    size_t byte_size);

/**
 * Unpack message NLG5_CTL.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_nlg5_ctl_unpack(
    primary_nlg5_ctl_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_ctl_nlg5_c_c_en_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_ctl_nlg5_c_c_el_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_ctl_nlg5_c_cp_v_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_ctl_nlg5_c_mr_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_nlg5_ctl_nlg5_mc_max_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_nlg5_ctl_nlg5_mc_max_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_ctl_nlg5_mc_max_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_nlg5_ctl_nlg5_ov_com_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_nlg5_ctl_nlg5_ov_com_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_ctl_nlg5_ov_com_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_nlg5_ctl_nlg5_oc_com_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_nlg5_ctl_nlg5_oc_com_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_ctl_nlg5_oc_com_is_in_range(uint16_t value);


;


;


void primary_bms_hv_jmp_to_blt_raw_to_conversion_struct(
    primary_bms_hv_jmp_to_blt_converted_t *conversion, 
    const primary_bms_hv_jmp_to_blt_t *raw);


void primary_bms_hv_jmp_to_blt_conversion_to_raw_struct(
    primary_bms_hv_jmp_to_blt_t *raw,
    const primary_bms_hv_jmp_to_blt_converted_t *conversion);


int primary_bms_hv_jmp_to_blt_to_string(primary_bms_hv_jmp_to_blt_t *message, char *buffer);

int primary_bms_hv_jmp_to_blt_to_string_file(primary_bms_hv_jmp_to_blt_t *message, FILE *buffer);

int primary_bms_hv_jmp_to_blt_fields(char *buffer);

int primary_bms_hv_jmp_to_blt_fields_file(FILE *buffer);

/**
 * Pack message BMS_HV_JMP_TO_BLT.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_bms_hv_jmp_to_blt_pack(
    uint8_t *dst_p,
    const primary_bms_hv_jmp_to_blt_t *src_p,
    size_t byte_size);

/**
 * Unpack message BMS_HV_JMP_TO_BLT.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_bms_hv_jmp_to_blt_unpack(
    primary_bms_hv_jmp_to_blt_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void primary_flash_bms_hv_tx_raw_to_conversion_struct(
    primary_flash_bms_hv_tx_converted_t *conversion, 
    const primary_flash_bms_hv_tx_t *raw);


void primary_flash_bms_hv_tx_conversion_to_raw_struct(
    primary_flash_bms_hv_tx_t *raw,
    const primary_flash_bms_hv_tx_converted_t *conversion);


int primary_flash_bms_hv_tx_to_string(primary_flash_bms_hv_tx_t *message, char *buffer);

int primary_flash_bms_hv_tx_to_string_file(primary_flash_bms_hv_tx_t *message, FILE *buffer);

int primary_flash_bms_hv_tx_fields(char *buffer);

int primary_flash_bms_hv_tx_fields_file(FILE *buffer);

/**
 * Pack message FLASH_BMS_HV_TX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_flash_bms_hv_tx_pack(
    uint8_t *dst_p,
    const primary_flash_bms_hv_tx_t *src_p,
    size_t byte_size);

/**
 * Unpack message FLASH_BMS_HV_TX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_flash_bms_hv_tx_unpack(
    primary_flash_bms_hv_tx_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void primary_flash_bms_hv_rx_raw_to_conversion_struct(
    primary_flash_bms_hv_rx_converted_t *conversion, 
    const primary_flash_bms_hv_rx_t *raw);


void primary_flash_bms_hv_rx_conversion_to_raw_struct(
    primary_flash_bms_hv_rx_t *raw,
    const primary_flash_bms_hv_rx_converted_t *conversion);


int primary_flash_bms_hv_rx_to_string(primary_flash_bms_hv_rx_t *message, char *buffer);

int primary_flash_bms_hv_rx_to_string_file(primary_flash_bms_hv_rx_t *message, FILE *buffer);

int primary_flash_bms_hv_rx_fields(char *buffer);

int primary_flash_bms_hv_rx_fields_file(FILE *buffer);

/**
 * Pack message FLASH_BMS_HV_RX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_flash_bms_hv_rx_pack(
    uint8_t *dst_p,
    const primary_flash_bms_hv_rx_t *src_p,
    size_t byte_size);

/**
 * Unpack message FLASH_BMS_HV_RX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_flash_bms_hv_rx_unpack(
    primary_flash_bms_hv_rx_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


void primary_hv_can_forward_raw_to_conversion(
    primary_hv_can_forward_converted_t *conversion,
    primary_hv_can_forward_can_forward_set can_forward_set
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_hv_can_forward_conversion_to_raw(
    primary_hv_can_forward_t *raw,
    primary_hv_can_forward_can_forward_set can_forward_set
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_hv_can_forward_raw_to_conversion_struct(
    primary_hv_can_forward_converted_t *conversion, 
    const primary_hv_can_forward_t *raw);


void primary_hv_can_forward_conversion_to_raw_struct(
    primary_hv_can_forward_t *raw,
    const primary_hv_can_forward_converted_t *conversion);

int primary_hv_can_forward_can_forward_set_enum_to_string(primary_hv_can_forward_can_forward_set value, char *buffer);

int primary_hv_can_forward_to_string(primary_hv_can_forward_t *message, char *buffer);

int primary_hv_can_forward_to_string_file(primary_hv_can_forward_t *message, FILE *buffer);

int primary_hv_can_forward_fields(char *buffer);

int primary_hv_can_forward_fields_file(FILE *buffer);

/**
 * Pack message HV_CAN_FORWARD.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_hv_can_forward_pack(
    uint8_t *dst_p,
    const primary_hv_can_forward_t *src_p,
    size_t byte_size);

/**
 * Unpack message HV_CAN_FORWARD.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_hv_can_forward_unpack(
    primary_hv_can_forward_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_can_forward_can_forward_set_is_in_range(uint8_t value);


;


;


void primary_flash_cellboard_0_tx_raw_to_conversion_struct(
    primary_flash_cellboard_0_tx_converted_t *conversion, 
    const primary_flash_cellboard_0_tx_t *raw);


void primary_flash_cellboard_0_tx_conversion_to_raw_struct(
    primary_flash_cellboard_0_tx_t *raw,
    const primary_flash_cellboard_0_tx_converted_t *conversion);


int primary_flash_cellboard_0_tx_to_string(primary_flash_cellboard_0_tx_t *message, char *buffer);

int primary_flash_cellboard_0_tx_to_string_file(primary_flash_cellboard_0_tx_t *message, FILE *buffer);

int primary_flash_cellboard_0_tx_fields(char *buffer);

int primary_flash_cellboard_0_tx_fields_file(FILE *buffer);

/**
 * Pack message FLASH_CELLBOARD_0_TX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_flash_cellboard_0_tx_pack(
    uint8_t *dst_p,
    const primary_flash_cellboard_0_tx_t *src_p,
    size_t byte_size);

/**
 * Unpack message FLASH_CELLBOARD_0_TX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_flash_cellboard_0_tx_unpack(
    primary_flash_cellboard_0_tx_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void primary_flash_cellboard_0_rx_raw_to_conversion_struct(
    primary_flash_cellboard_0_rx_converted_t *conversion, 
    const primary_flash_cellboard_0_rx_t *raw);


void primary_flash_cellboard_0_rx_conversion_to_raw_struct(
    primary_flash_cellboard_0_rx_t *raw,
    const primary_flash_cellboard_0_rx_converted_t *conversion);


int primary_flash_cellboard_0_rx_to_string(primary_flash_cellboard_0_rx_t *message, char *buffer);

int primary_flash_cellboard_0_rx_to_string_file(primary_flash_cellboard_0_rx_t *message, FILE *buffer);

int primary_flash_cellboard_0_rx_fields(char *buffer);

int primary_flash_cellboard_0_rx_fields_file(FILE *buffer);

/**
 * Pack message FLASH_CELLBOARD_0_RX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_flash_cellboard_0_rx_pack(
    uint8_t *dst_p,
    const primary_flash_cellboard_0_rx_t *src_p,
    size_t byte_size);

/**
 * Unpack message FLASH_CELLBOARD_0_RX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_flash_cellboard_0_rx_unpack(
    primary_flash_cellboard_0_rx_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void primary_flash_cellboard_1_tx_raw_to_conversion_struct(
    primary_flash_cellboard_1_tx_converted_t *conversion, 
    const primary_flash_cellboard_1_tx_t *raw);


void primary_flash_cellboard_1_tx_conversion_to_raw_struct(
    primary_flash_cellboard_1_tx_t *raw,
    const primary_flash_cellboard_1_tx_converted_t *conversion);


int primary_flash_cellboard_1_tx_to_string(primary_flash_cellboard_1_tx_t *message, char *buffer);

int primary_flash_cellboard_1_tx_to_string_file(primary_flash_cellboard_1_tx_t *message, FILE *buffer);

int primary_flash_cellboard_1_tx_fields(char *buffer);

int primary_flash_cellboard_1_tx_fields_file(FILE *buffer);

/**
 * Pack message FLASH_CELLBOARD_1_TX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_flash_cellboard_1_tx_pack(
    uint8_t *dst_p,
    const primary_flash_cellboard_1_tx_t *src_p,
    size_t byte_size);

/**
 * Unpack message FLASH_CELLBOARD_1_TX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_flash_cellboard_1_tx_unpack(
    primary_flash_cellboard_1_tx_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void primary_flash_cellboard_1_rx_raw_to_conversion_struct(
    primary_flash_cellboard_1_rx_converted_t *conversion, 
    const primary_flash_cellboard_1_rx_t *raw);


void primary_flash_cellboard_1_rx_conversion_to_raw_struct(
    primary_flash_cellboard_1_rx_t *raw,
    const primary_flash_cellboard_1_rx_converted_t *conversion);


int primary_flash_cellboard_1_rx_to_string(primary_flash_cellboard_1_rx_t *message, char *buffer);

int primary_flash_cellboard_1_rx_to_string_file(primary_flash_cellboard_1_rx_t *message, FILE *buffer);

int primary_flash_cellboard_1_rx_fields(char *buffer);

int primary_flash_cellboard_1_rx_fields_file(FILE *buffer);

/**
 * Pack message FLASH_CELLBOARD_1_RX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_flash_cellboard_1_rx_pack(
    uint8_t *dst_p,
    const primary_flash_cellboard_1_rx_t *src_p,
    size_t byte_size);

/**
 * Unpack message FLASH_CELLBOARD_1_RX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_flash_cellboard_1_rx_unpack(
    primary_flash_cellboard_1_rx_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void primary_flash_cellboard_2_tx_raw_to_conversion_struct(
    primary_flash_cellboard_2_tx_converted_t *conversion, 
    const primary_flash_cellboard_2_tx_t *raw);


void primary_flash_cellboard_2_tx_conversion_to_raw_struct(
    primary_flash_cellboard_2_tx_t *raw,
    const primary_flash_cellboard_2_tx_converted_t *conversion);


int primary_flash_cellboard_2_tx_to_string(primary_flash_cellboard_2_tx_t *message, char *buffer);

int primary_flash_cellboard_2_tx_to_string_file(primary_flash_cellboard_2_tx_t *message, FILE *buffer);

int primary_flash_cellboard_2_tx_fields(char *buffer);

int primary_flash_cellboard_2_tx_fields_file(FILE *buffer);

/**
 * Pack message FLASH_CELLBOARD_2_TX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_flash_cellboard_2_tx_pack(
    uint8_t *dst_p,
    const primary_flash_cellboard_2_tx_t *src_p,
    size_t byte_size);

/**
 * Unpack message FLASH_CELLBOARD_2_TX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_flash_cellboard_2_tx_unpack(
    primary_flash_cellboard_2_tx_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void primary_flash_cellboard_2_rx_raw_to_conversion_struct(
    primary_flash_cellboard_2_rx_converted_t *conversion, 
    const primary_flash_cellboard_2_rx_t *raw);


void primary_flash_cellboard_2_rx_conversion_to_raw_struct(
    primary_flash_cellboard_2_rx_t *raw,
    const primary_flash_cellboard_2_rx_converted_t *conversion);


int primary_flash_cellboard_2_rx_to_string(primary_flash_cellboard_2_rx_t *message, char *buffer);

int primary_flash_cellboard_2_rx_to_string_file(primary_flash_cellboard_2_rx_t *message, FILE *buffer);

int primary_flash_cellboard_2_rx_fields(char *buffer);

int primary_flash_cellboard_2_rx_fields_file(FILE *buffer);

/**
 * Pack message FLASH_CELLBOARD_2_RX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_flash_cellboard_2_rx_pack(
    uint8_t *dst_p,
    const primary_flash_cellboard_2_rx_t *src_p,
    size_t byte_size);

/**
 * Unpack message FLASH_CELLBOARD_2_RX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_flash_cellboard_2_rx_unpack(
    primary_flash_cellboard_2_rx_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void primary_flash_cellboard_3_tx_raw_to_conversion_struct(
    primary_flash_cellboard_3_tx_converted_t *conversion, 
    const primary_flash_cellboard_3_tx_t *raw);


void primary_flash_cellboard_3_tx_conversion_to_raw_struct(
    primary_flash_cellboard_3_tx_t *raw,
    const primary_flash_cellboard_3_tx_converted_t *conversion);


int primary_flash_cellboard_3_tx_to_string(primary_flash_cellboard_3_tx_t *message, char *buffer);

int primary_flash_cellboard_3_tx_to_string_file(primary_flash_cellboard_3_tx_t *message, FILE *buffer);

int primary_flash_cellboard_3_tx_fields(char *buffer);

int primary_flash_cellboard_3_tx_fields_file(FILE *buffer);

/**
 * Pack message FLASH_CELLBOARD_3_TX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_flash_cellboard_3_tx_pack(
    uint8_t *dst_p,
    const primary_flash_cellboard_3_tx_t *src_p,
    size_t byte_size);

/**
 * Unpack message FLASH_CELLBOARD_3_TX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_flash_cellboard_3_tx_unpack(
    primary_flash_cellboard_3_tx_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void primary_flash_cellboard_3_rx_raw_to_conversion_struct(
    primary_flash_cellboard_3_rx_converted_t *conversion, 
    const primary_flash_cellboard_3_rx_t *raw);


void primary_flash_cellboard_3_rx_conversion_to_raw_struct(
    primary_flash_cellboard_3_rx_t *raw,
    const primary_flash_cellboard_3_rx_converted_t *conversion);


int primary_flash_cellboard_3_rx_to_string(primary_flash_cellboard_3_rx_t *message, char *buffer);

int primary_flash_cellboard_3_rx_to_string_file(primary_flash_cellboard_3_rx_t *message, FILE *buffer);

int primary_flash_cellboard_3_rx_fields(char *buffer);

int primary_flash_cellboard_3_rx_fields_file(FILE *buffer);

/**
 * Pack message FLASH_CELLBOARD_3_RX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_flash_cellboard_3_rx_pack(
    uint8_t *dst_p,
    const primary_flash_cellboard_3_rx_t *src_p,
    size_t byte_size);

/**
 * Unpack message FLASH_CELLBOARD_3_RX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_flash_cellboard_3_rx_unpack(
    primary_flash_cellboard_3_rx_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void primary_flash_cellboard_4_tx_raw_to_conversion_struct(
    primary_flash_cellboard_4_tx_converted_t *conversion, 
    const primary_flash_cellboard_4_tx_t *raw);


void primary_flash_cellboard_4_tx_conversion_to_raw_struct(
    primary_flash_cellboard_4_tx_t *raw,
    const primary_flash_cellboard_4_tx_converted_t *conversion);


int primary_flash_cellboard_4_tx_to_string(primary_flash_cellboard_4_tx_t *message, char *buffer);

int primary_flash_cellboard_4_tx_to_string_file(primary_flash_cellboard_4_tx_t *message, FILE *buffer);

int primary_flash_cellboard_4_tx_fields(char *buffer);

int primary_flash_cellboard_4_tx_fields_file(FILE *buffer);

/**
 * Pack message FLASH_CELLBOARD_4_TX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_flash_cellboard_4_tx_pack(
    uint8_t *dst_p,
    const primary_flash_cellboard_4_tx_t *src_p,
    size_t byte_size);

/**
 * Unpack message FLASH_CELLBOARD_4_TX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_flash_cellboard_4_tx_unpack(
    primary_flash_cellboard_4_tx_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void primary_flash_cellboard_4_rx_raw_to_conversion_struct(
    primary_flash_cellboard_4_rx_converted_t *conversion, 
    const primary_flash_cellboard_4_rx_t *raw);


void primary_flash_cellboard_4_rx_conversion_to_raw_struct(
    primary_flash_cellboard_4_rx_t *raw,
    const primary_flash_cellboard_4_rx_converted_t *conversion);


int primary_flash_cellboard_4_rx_to_string(primary_flash_cellboard_4_rx_t *message, char *buffer);

int primary_flash_cellboard_4_rx_to_string_file(primary_flash_cellboard_4_rx_t *message, FILE *buffer);

int primary_flash_cellboard_4_rx_fields(char *buffer);

int primary_flash_cellboard_4_rx_fields_file(FILE *buffer);

/**
 * Pack message FLASH_CELLBOARD_4_RX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_flash_cellboard_4_rx_pack(
    uint8_t *dst_p,
    const primary_flash_cellboard_4_rx_t *src_p,
    size_t byte_size);

/**
 * Unpack message FLASH_CELLBOARD_4_RX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_flash_cellboard_4_rx_unpack(
    primary_flash_cellboard_4_rx_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void primary_flash_cellboard_5_tx_raw_to_conversion_struct(
    primary_flash_cellboard_5_tx_converted_t *conversion, 
    const primary_flash_cellboard_5_tx_t *raw);


void primary_flash_cellboard_5_tx_conversion_to_raw_struct(
    primary_flash_cellboard_5_tx_t *raw,
    const primary_flash_cellboard_5_tx_converted_t *conversion);


int primary_flash_cellboard_5_tx_to_string(primary_flash_cellboard_5_tx_t *message, char *buffer);

int primary_flash_cellboard_5_tx_to_string_file(primary_flash_cellboard_5_tx_t *message, FILE *buffer);

int primary_flash_cellboard_5_tx_fields(char *buffer);

int primary_flash_cellboard_5_tx_fields_file(FILE *buffer);

/**
 * Pack message FLASH_CELLBOARD_5_TX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_flash_cellboard_5_tx_pack(
    uint8_t *dst_p,
    const primary_flash_cellboard_5_tx_t *src_p,
    size_t byte_size);

/**
 * Unpack message FLASH_CELLBOARD_5_TX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_flash_cellboard_5_tx_unpack(
    primary_flash_cellboard_5_tx_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void primary_flash_cellboard_5_rx_raw_to_conversion_struct(
    primary_flash_cellboard_5_rx_converted_t *conversion, 
    const primary_flash_cellboard_5_rx_t *raw);


void primary_flash_cellboard_5_rx_conversion_to_raw_struct(
    primary_flash_cellboard_5_rx_t *raw,
    const primary_flash_cellboard_5_rx_converted_t *conversion);


int primary_flash_cellboard_5_rx_to_string(primary_flash_cellboard_5_rx_t *message, char *buffer);

int primary_flash_cellboard_5_rx_to_string_file(primary_flash_cellboard_5_rx_t *message, FILE *buffer);

int primary_flash_cellboard_5_rx_fields(char *buffer);

int primary_flash_cellboard_5_rx_fields_file(FILE *buffer);

/**
 * Pack message FLASH_CELLBOARD_5_RX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_flash_cellboard_5_rx_pack(
    uint8_t *dst_p,
    const primary_flash_cellboard_5_rx_t *src_p,
    size_t byte_size);

/**
 * Unpack message FLASH_CELLBOARD_5_RX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_flash_cellboard_5_rx_unpack(
    primary_flash_cellboard_5_rx_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void primary_bms_lv_jmp_to_blt_raw_to_conversion_struct(
    primary_bms_lv_jmp_to_blt_converted_t *conversion, 
    const primary_bms_lv_jmp_to_blt_t *raw);


void primary_bms_lv_jmp_to_blt_conversion_to_raw_struct(
    primary_bms_lv_jmp_to_blt_t *raw,
    const primary_bms_lv_jmp_to_blt_converted_t *conversion);


int primary_bms_lv_jmp_to_blt_to_string(primary_bms_lv_jmp_to_blt_t *message, char *buffer);

int primary_bms_lv_jmp_to_blt_to_string_file(primary_bms_lv_jmp_to_blt_t *message, FILE *buffer);

int primary_bms_lv_jmp_to_blt_fields(char *buffer);

int primary_bms_lv_jmp_to_blt_fields_file(FILE *buffer);

/**
 * Pack message BMS_LV_JMP_TO_BLT.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_bms_lv_jmp_to_blt_pack(
    uint8_t *dst_p,
    const primary_bms_lv_jmp_to_blt_t *src_p,
    size_t byte_size);

/**
 * Unpack message BMS_LV_JMP_TO_BLT.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_bms_lv_jmp_to_blt_unpack(
    primary_bms_lv_jmp_to_blt_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void primary_flash_bms_lv_tx_raw_to_conversion_struct(
    primary_flash_bms_lv_tx_converted_t *conversion, 
    const primary_flash_bms_lv_tx_t *raw);


void primary_flash_bms_lv_tx_conversion_to_raw_struct(
    primary_flash_bms_lv_tx_t *raw,
    const primary_flash_bms_lv_tx_converted_t *conversion);


int primary_flash_bms_lv_tx_to_string(primary_flash_bms_lv_tx_t *message, char *buffer);

int primary_flash_bms_lv_tx_to_string_file(primary_flash_bms_lv_tx_t *message, FILE *buffer);

int primary_flash_bms_lv_tx_fields(char *buffer);

int primary_flash_bms_lv_tx_fields_file(FILE *buffer);

/**
 * Pack message FLASH_BMS_LV_TX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_flash_bms_lv_tx_pack(
    uint8_t *dst_p,
    const primary_flash_bms_lv_tx_t *src_p,
    size_t byte_size);

/**
 * Unpack message FLASH_BMS_LV_TX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_flash_bms_lv_tx_unpack(
    primary_flash_bms_lv_tx_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void primary_flash_bms_lv_rx_raw_to_conversion_struct(
    primary_flash_bms_lv_rx_converted_t *conversion, 
    const primary_flash_bms_lv_rx_t *raw);


void primary_flash_bms_lv_rx_conversion_to_raw_struct(
    primary_flash_bms_lv_rx_t *raw,
    const primary_flash_bms_lv_rx_converted_t *conversion);


int primary_flash_bms_lv_rx_to_string(primary_flash_bms_lv_rx_t *message, char *buffer);

int primary_flash_bms_lv_rx_to_string_file(primary_flash_bms_lv_rx_t *message, FILE *buffer);

int primary_flash_bms_lv_rx_fields(char *buffer);

int primary_flash_bms_lv_rx_fields_file(FILE *buffer);

/**
 * Pack message FLASH_BMS_LV_RX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_flash_bms_lv_rx_pack(
    uint8_t *dst_p,
    const primary_flash_bms_lv_rx_t *src_p,
    size_t byte_size);

/**
 * Unpack message FLASH_BMS_LV_RX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_flash_bms_lv_rx_unpack(
    primary_flash_bms_lv_rx_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void primary_ecu_jmp_to_blt_raw_to_conversion_struct(
    primary_ecu_jmp_to_blt_converted_t *conversion, 
    const primary_ecu_jmp_to_blt_t *raw);


void primary_ecu_jmp_to_blt_conversion_to_raw_struct(
    primary_ecu_jmp_to_blt_t *raw,
    const primary_ecu_jmp_to_blt_converted_t *conversion);


int primary_ecu_jmp_to_blt_to_string(primary_ecu_jmp_to_blt_t *message, char *buffer);

int primary_ecu_jmp_to_blt_to_string_file(primary_ecu_jmp_to_blt_t *message, FILE *buffer);

int primary_ecu_jmp_to_blt_fields(char *buffer);

int primary_ecu_jmp_to_blt_fields_file(FILE *buffer);

/**
 * Pack message ECU_JMP_TO_BLT.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_ecu_jmp_to_blt_pack(
    uint8_t *dst_p,
    const primary_ecu_jmp_to_blt_t *src_p,
    size_t byte_size);

/**
 * Unpack message ECU_JMP_TO_BLT.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_ecu_jmp_to_blt_unpack(
    primary_ecu_jmp_to_blt_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void primary_flash_ecu_tx_raw_to_conversion_struct(
    primary_flash_ecu_tx_converted_t *conversion, 
    const primary_flash_ecu_tx_t *raw);


void primary_flash_ecu_tx_conversion_to_raw_struct(
    primary_flash_ecu_tx_t *raw,
    const primary_flash_ecu_tx_converted_t *conversion);


int primary_flash_ecu_tx_to_string(primary_flash_ecu_tx_t *message, char *buffer);

int primary_flash_ecu_tx_to_string_file(primary_flash_ecu_tx_t *message, FILE *buffer);

int primary_flash_ecu_tx_fields(char *buffer);

int primary_flash_ecu_tx_fields_file(FILE *buffer);

/**
 * Pack message FLASH_ECU_TX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_flash_ecu_tx_pack(
    uint8_t *dst_p,
    const primary_flash_ecu_tx_t *src_p,
    size_t byte_size);

/**
 * Unpack message FLASH_ECU_TX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_flash_ecu_tx_unpack(
    primary_flash_ecu_tx_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void primary_flash_ecu_rx_raw_to_conversion_struct(
    primary_flash_ecu_rx_converted_t *conversion, 
    const primary_flash_ecu_rx_t *raw);


void primary_flash_ecu_rx_conversion_to_raw_struct(
    primary_flash_ecu_rx_t *raw,
    const primary_flash_ecu_rx_converted_t *conversion);


int primary_flash_ecu_rx_to_string(primary_flash_ecu_rx_t *message, char *buffer);

int primary_flash_ecu_rx_to_string_file(primary_flash_ecu_rx_t *message, FILE *buffer);

int primary_flash_ecu_rx_fields(char *buffer);

int primary_flash_ecu_rx_fields_file(FILE *buffer);

/**
 * Pack message FLASH_ECU_RX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_flash_ecu_rx_pack(
    uint8_t *dst_p,
    const primary_flash_ecu_rx_t *src_p,
    size_t byte_size);

/**
 * Unpack message FLASH_ECU_RX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_flash_ecu_rx_unpack(
    primary_flash_ecu_rx_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void primary_steering_jmp_to_blt_raw_to_conversion_struct(
    primary_steering_jmp_to_blt_converted_t *conversion, 
    const primary_steering_jmp_to_blt_t *raw);


void primary_steering_jmp_to_blt_conversion_to_raw_struct(
    primary_steering_jmp_to_blt_t *raw,
    const primary_steering_jmp_to_blt_converted_t *conversion);


int primary_steering_jmp_to_blt_to_string(primary_steering_jmp_to_blt_t *message, char *buffer);

int primary_steering_jmp_to_blt_to_string_file(primary_steering_jmp_to_blt_t *message, FILE *buffer);

int primary_steering_jmp_to_blt_fields(char *buffer);

int primary_steering_jmp_to_blt_fields_file(FILE *buffer);

/**
 * Pack message STEERING_JMP_TO_BLT.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_steering_jmp_to_blt_pack(
    uint8_t *dst_p,
    const primary_steering_jmp_to_blt_t *src_p,
    size_t byte_size);

/**
 * Unpack message STEERING_JMP_TO_BLT.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_steering_jmp_to_blt_unpack(
    primary_steering_jmp_to_blt_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void primary_flash_steering_tx_raw_to_conversion_struct(
    primary_flash_steering_tx_converted_t *conversion, 
    const primary_flash_steering_tx_t *raw);


void primary_flash_steering_tx_conversion_to_raw_struct(
    primary_flash_steering_tx_t *raw,
    const primary_flash_steering_tx_converted_t *conversion);


int primary_flash_steering_tx_to_string(primary_flash_steering_tx_t *message, char *buffer);

int primary_flash_steering_tx_to_string_file(primary_flash_steering_tx_t *message, FILE *buffer);

int primary_flash_steering_tx_fields(char *buffer);

int primary_flash_steering_tx_fields_file(FILE *buffer);

/**
 * Pack message FLASH_STEERING_TX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_flash_steering_tx_pack(
    uint8_t *dst_p,
    const primary_flash_steering_tx_t *src_p,
    size_t byte_size);

/**
 * Unpack message FLASH_STEERING_TX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_flash_steering_tx_unpack(
    primary_flash_steering_tx_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void primary_flash_steering_rx_raw_to_conversion_struct(
    primary_flash_steering_rx_converted_t *conversion, 
    const primary_flash_steering_rx_t *raw);


void primary_flash_steering_rx_conversion_to_raw_struct(
    primary_flash_steering_rx_t *raw,
    const primary_flash_steering_rx_converted_t *conversion);


int primary_flash_steering_rx_to_string(primary_flash_steering_rx_t *message, char *buffer);

int primary_flash_steering_rx_to_string_file(primary_flash_steering_rx_t *message, FILE *buffer);

int primary_flash_steering_rx_fields(char *buffer);

int primary_flash_steering_rx_fields_file(FILE *buffer);

/**
 * Pack message FLASH_STEERING_RX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_flash_steering_rx_pack(
    uint8_t *dst_p,
    const primary_flash_steering_rx_t *src_p,
    size_t byte_size);

/**
 * Unpack message FLASH_STEERING_RX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_flash_steering_rx_unpack(
    primary_flash_steering_rx_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


void primary_steer_version_raw_to_conversion(
    primary_steer_version_converted_t *conversion,
    uint8_t component_version,
    uint32_t canlib_build_time
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_steer_version_conversion_to_raw(
    primary_steer_version_t *raw,
    uint8_t component_version,
    uint32_t canlib_build_time
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_steer_version_raw_to_conversion_struct(
    primary_steer_version_converted_t *conversion, 
    const primary_steer_version_t *raw);


void primary_steer_version_conversion_to_raw_struct(
    primary_steer_version_t *raw,
    const primary_steer_version_converted_t *conversion);


int primary_steer_version_to_string(primary_steer_version_t *message, char *buffer);

int primary_steer_version_to_string_file(primary_steer_version_t *message, FILE *buffer);

int primary_steer_version_fields(char *buffer);

int primary_steer_version_fields_file(FILE *buffer);

/**
 * Pack message STEER_VERSION.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_steer_version_pack(
    uint8_t *dst_p,
    const primary_steer_version_t *src_p,
    size_t byte_size);

/**
 * Unpack message STEER_VERSION.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_steer_version_unpack(
    primary_steer_version_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_steer_version_component_version_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_steer_version_canlib_build_time_is_in_range(uint32_t value);


void primary_das_version_raw_to_conversion(
    primary_das_version_converted_t *conversion,
    uint8_t component_version,
    uint32_t canlib_build_time
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_das_version_conversion_to_raw(
    primary_das_version_t *raw,
    uint8_t component_version,
    uint32_t canlib_build_time
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_das_version_raw_to_conversion_struct(
    primary_das_version_converted_t *conversion, 
    const primary_das_version_t *raw);


void primary_das_version_conversion_to_raw_struct(
    primary_das_version_t *raw,
    const primary_das_version_converted_t *conversion);


int primary_das_version_to_string(primary_das_version_t *message, char *buffer);

int primary_das_version_to_string_file(primary_das_version_t *message, FILE *buffer);

int primary_das_version_fields(char *buffer);

int primary_das_version_fields_file(FILE *buffer);

/**
 * Pack message DAS_VERSION.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_das_version_pack(
    uint8_t *dst_p,
    const primary_das_version_t *src_p,
    size_t byte_size);

/**
 * Unpack message DAS_VERSION.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_das_version_unpack(
    primary_das_version_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_das_version_component_version_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_das_version_canlib_build_time_is_in_range(uint32_t value);


void primary_hv_version_raw_to_conversion(
    primary_hv_version_converted_t *conversion,
    uint8_t component_version,
    uint32_t canlib_build_time
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_hv_version_conversion_to_raw(
    primary_hv_version_t *raw,
    uint8_t component_version,
    uint32_t canlib_build_time
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_hv_version_raw_to_conversion_struct(
    primary_hv_version_converted_t *conversion, 
    const primary_hv_version_t *raw);


void primary_hv_version_conversion_to_raw_struct(
    primary_hv_version_t *raw,
    const primary_hv_version_converted_t *conversion);


int primary_hv_version_to_string(primary_hv_version_t *message, char *buffer);

int primary_hv_version_to_string_file(primary_hv_version_t *message, FILE *buffer);

int primary_hv_version_fields(char *buffer);

int primary_hv_version_fields_file(FILE *buffer);

/**
 * Pack message HV_VERSION.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_hv_version_pack(
    uint8_t *dst_p,
    const primary_hv_version_t *src_p,
    size_t byte_size);

/**
 * Unpack message HV_VERSION.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_hv_version_unpack(
    primary_hv_version_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_version_component_version_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_version_canlib_build_time_is_in_range(uint32_t value);


void primary_lv_version_raw_to_conversion(
    primary_lv_version_converted_t *conversion,
    uint8_t component_version,
    uint32_t canlib_build_time
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_lv_version_conversion_to_raw(
    primary_lv_version_t *raw,
    uint8_t component_version,
    uint32_t canlib_build_time
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_lv_version_raw_to_conversion_struct(
    primary_lv_version_converted_t *conversion, 
    const primary_lv_version_t *raw);


void primary_lv_version_conversion_to_raw_struct(
    primary_lv_version_t *raw,
    const primary_lv_version_converted_t *conversion);


int primary_lv_version_to_string(primary_lv_version_t *message, char *buffer);

int primary_lv_version_to_string_file(primary_lv_version_t *message, FILE *buffer);

int primary_lv_version_fields(char *buffer);

int primary_lv_version_fields_file(FILE *buffer);

/**
 * Pack message LV_VERSION.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_lv_version_pack(
    uint8_t *dst_p,
    const primary_lv_version_t *src_p,
    size_t byte_size);

/**
 * Unpack message LV_VERSION.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_lv_version_unpack(
    primary_lv_version_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_version_component_version_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_version_canlib_build_time_is_in_range(uint32_t value);


void primary_tlm_version_raw_to_conversion(
    primary_tlm_version_converted_t *conversion,
    uint8_t component_version,
    uint32_t canlib_build_time
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_tlm_version_conversion_to_raw(
    primary_tlm_version_t *raw,
    uint8_t component_version,
    uint32_t canlib_build_time
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_tlm_version_raw_to_conversion_struct(
    primary_tlm_version_converted_t *conversion, 
    const primary_tlm_version_t *raw);


void primary_tlm_version_conversion_to_raw_struct(
    primary_tlm_version_t *raw,
    const primary_tlm_version_converted_t *conversion);


int primary_tlm_version_to_string(primary_tlm_version_t *message, char *buffer);

int primary_tlm_version_to_string_file(primary_tlm_version_t *message, FILE *buffer);

int primary_tlm_version_fields(char *buffer);

int primary_tlm_version_fields_file(FILE *buffer);

/**
 * Pack message TLM_VERSION.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_tlm_version_pack(
    uint8_t *dst_p,
    const primary_tlm_version_t *src_p,
    size_t byte_size);

/**
 * Unpack message TLM_VERSION.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_tlm_version_unpack(
    primary_tlm_version_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_tlm_version_component_version_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_tlm_version_canlib_build_time_is_in_range(uint32_t value);


void primary_timestamp_raw_to_conversion(
    primary_timestamp_converted_t *conversion,
    uint32_t timestamp
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_timestamp_conversion_to_raw(
    primary_timestamp_t *raw,
    uint32_t timestamp
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_timestamp_raw_to_conversion_struct(
    primary_timestamp_converted_t *conversion, 
    const primary_timestamp_t *raw);


void primary_timestamp_conversion_to_raw_struct(
    primary_timestamp_t *raw,
    const primary_timestamp_converted_t *conversion);


int primary_timestamp_to_string(primary_timestamp_t *message, char *buffer);

int primary_timestamp_to_string_file(primary_timestamp_t *message, FILE *buffer);

int primary_timestamp_fields(char *buffer);

int primary_timestamp_fields_file(FILE *buffer);

/**
 * Pack message TIMESTAMP.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_timestamp_pack(
    uint8_t *dst_p,
    const primary_timestamp_t *src_p,
    size_t byte_size);

/**
 * Unpack message TIMESTAMP.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_timestamp_unpack(
    primary_timestamp_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_timestamp_timestamp_is_in_range(uint32_t value);


void primary_ambient_temperature_raw_to_conversion(
    primary_ambient_temperature_converted_t *conversion,
    int16_t temp
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_ambient_temperature_conversion_to_raw(
    primary_ambient_temperature_t *raw,
    int16_t temp
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_ambient_temperature_raw_to_conversion_struct(
    primary_ambient_temperature_converted_t *conversion, 
    const primary_ambient_temperature_t *raw);


void primary_ambient_temperature_conversion_to_raw_struct(
    primary_ambient_temperature_t *raw,
    const primary_ambient_temperature_converted_t *conversion);


int primary_ambient_temperature_to_string(primary_ambient_temperature_t *message, char *buffer);

int primary_ambient_temperature_to_string_file(primary_ambient_temperature_t *message, FILE *buffer);

int primary_ambient_temperature_fields(char *buffer);

int primary_ambient_temperature_fields_file(FILE *buffer);

/**
 * Pack message AMBIENT_TEMPERATURE.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_ambient_temperature_pack(
    uint8_t *dst_p,
    const primary_ambient_temperature_t *src_p,
    size_t byte_size);

/**
 * Unpack message AMBIENT_TEMPERATURE.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_ambient_temperature_unpack(
    primary_ambient_temperature_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_ambient_temperature_temp_is_in_range(int16_t value);


void primary_data_logger_raw_to_conversion(
    primary_data_logger_converted_t *conversion,
    uint32_t placeholder1,
    uint32_t placeholder2
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_data_logger_conversion_to_raw(
    primary_data_logger_t *raw,
    uint32_t placeholder1,
    uint32_t placeholder2
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_data_logger_raw_to_conversion_struct(
    primary_data_logger_converted_t *conversion, 
    const primary_data_logger_t *raw);


void primary_data_logger_conversion_to_raw_struct(
    primary_data_logger_t *raw,
    const primary_data_logger_converted_t *conversion);


int primary_data_logger_to_string(primary_data_logger_t *message, char *buffer);

int primary_data_logger_to_string_file(primary_data_logger_t *message, FILE *buffer);

int primary_data_logger_fields(char *buffer);

int primary_data_logger_fields_file(FILE *buffer);

/**
 * Pack message DATA_LOGGER.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_data_logger_pack(
    uint8_t *dst_p,
    const primary_data_logger_t *src_p,
    size_t byte_size);

/**
 * Unpack message DATA_LOGGER.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_data_logger_unpack(
    primary_data_logger_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_data_logger_placeholder1_is_in_range(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_data_logger_placeholder2_is_in_range(uint32_t value);


void primary_set_tlm_status_raw_to_conversion(
    primary_set_tlm_status_converted_t *conversion,
    primary_set_tlm_status_tlm_status tlm_status
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_set_tlm_status_conversion_to_raw(
    primary_set_tlm_status_t *raw,
    primary_set_tlm_status_tlm_status tlm_status
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_set_tlm_status_raw_to_conversion_struct(
    primary_set_tlm_status_converted_t *conversion, 
    const primary_set_tlm_status_t *raw);


void primary_set_tlm_status_conversion_to_raw_struct(
    primary_set_tlm_status_t *raw,
    const primary_set_tlm_status_converted_t *conversion);

int primary_set_tlm_status_tlm_status_enum_to_string(primary_set_tlm_status_tlm_status value, char *buffer);

int primary_set_tlm_status_to_string(primary_set_tlm_status_t *message, char *buffer);

int primary_set_tlm_status_to_string_file(primary_set_tlm_status_t *message, FILE *buffer);

int primary_set_tlm_status_fields(char *buffer);

int primary_set_tlm_status_fields_file(FILE *buffer);

/**
 * Pack message SET_TLM_STATUS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_set_tlm_status_pack(
    uint8_t *dst_p,
    const primary_set_tlm_status_t *src_p,
    size_t byte_size);

/**
 * Unpack message SET_TLM_STATUS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_set_tlm_status_unpack(
    primary_set_tlm_status_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_set_tlm_status_tlm_status_is_in_range(uint8_t value);


void primary_tlm_status_raw_to_conversion(
    primary_tlm_status_converted_t *conversion,
    primary_tlm_status_tlm_status tlm_status
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_tlm_status_conversion_to_raw(
    primary_tlm_status_t *raw,
    primary_tlm_status_tlm_status tlm_status
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_tlm_status_raw_to_conversion_struct(
    primary_tlm_status_converted_t *conversion, 
    const primary_tlm_status_t *raw);


void primary_tlm_status_conversion_to_raw_struct(
    primary_tlm_status_t *raw,
    const primary_tlm_status_converted_t *conversion);

int primary_tlm_status_tlm_status_enum_to_string(primary_tlm_status_tlm_status value, char *buffer);

int primary_tlm_status_to_string(primary_tlm_status_t *message, char *buffer);

int primary_tlm_status_to_string_file(primary_tlm_status_t *message, FILE *buffer);

int primary_tlm_status_fields(char *buffer);

int primary_tlm_status_fields_file(FILE *buffer);

/**
 * Pack message TLM_STATUS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_tlm_status_pack(
    uint8_t *dst_p,
    const primary_tlm_status_t *src_p,
    size_t byte_size);

/**
 * Unpack message TLM_STATUS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_tlm_status_unpack(
    primary_tlm_status_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_tlm_status_tlm_status_is_in_range(uint8_t value);


void primary_steer_system_status_raw_to_conversion(
    primary_steer_system_status_converted_t *conversion,
    uint8_t soc_temp
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_steer_system_status_conversion_to_raw(
    primary_steer_system_status_t *raw,
    uint8_t soc_temp
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_steer_system_status_raw_to_conversion_struct(
    primary_steer_system_status_converted_t *conversion, 
    const primary_steer_system_status_t *raw);


void primary_steer_system_status_conversion_to_raw_struct(
    primary_steer_system_status_t *raw,
    const primary_steer_system_status_converted_t *conversion);


int primary_steer_system_status_to_string(primary_steer_system_status_t *message, char *buffer);

int primary_steer_system_status_to_string_file(primary_steer_system_status_t *message, FILE *buffer);

int primary_steer_system_status_fields(char *buffer);

int primary_steer_system_status_fields_file(FILE *buffer);

/**
 * Pack message STEER_SYSTEM_STATUS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_steer_system_status_pack(
    uint8_t *dst_p,
    const primary_steer_system_status_t *src_p,
    size_t byte_size);

/**
 * Unpack message STEER_SYSTEM_STATUS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_steer_system_status_unpack(
    primary_steer_system_status_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_steer_system_status_soc_temp_is_in_range(uint8_t value);


void primary_hv_voltage_raw_to_conversion(
    primary_hv_voltage_converted_t *conversion,
    float pack_voltage,
    float bus_voltage,
    float max_cell_voltage,
    float min_cell_voltage
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_hv_voltage_conversion_to_raw(
    primary_hv_voltage_t *raw,
    float pack_voltage,
    float bus_voltage,
    float max_cell_voltage,
    float min_cell_voltage
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_hv_voltage_raw_to_conversion_struct(
    primary_hv_voltage_converted_t *conversion, 
    const primary_hv_voltage_t *raw);


void primary_hv_voltage_conversion_to_raw_struct(
    primary_hv_voltage_t *raw,
    const primary_hv_voltage_converted_t *conversion);


int primary_hv_voltage_converted_to_string(primary_hv_voltage_converted_t *message, char *buffer);

int primary_hv_voltage_converted_to_string_file(primary_hv_voltage_converted_t *message, FILE *buffer);

int primary_hv_voltage_fields(char *buffer);

int primary_hv_voltage_fields_file(FILE *buffer);

/**
 * Pack message HV_VOLTAGE.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_hv_voltage_pack(
    uint8_t *dst_p,
    const primary_hv_voltage_t *src_p,
    size_t byte_size);

/**
 * Unpack message HV_VOLTAGE.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_hv_voltage_unpack(
    primary_hv_voltage_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_hv_voltage_pack_voltage_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_hv_voltage_pack_voltage_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_voltage_pack_voltage_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_hv_voltage_bus_voltage_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_hv_voltage_bus_voltage_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_voltage_bus_voltage_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_hv_voltage_max_cell_voltage_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_hv_voltage_max_cell_voltage_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_voltage_max_cell_voltage_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_hv_voltage_min_cell_voltage_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_hv_voltage_min_cell_voltage_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_voltage_min_cell_voltage_is_in_range(uint16_t value);


void primary_hv_current_raw_to_conversion(
    primary_hv_current_converted_t *conversion,
    float current,
    float power,
    float energy,
    float soc
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_hv_current_conversion_to_raw(
    primary_hv_current_t *raw,
    float current,
    float power,
    float energy,
    float soc
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_hv_current_raw_to_conversion_struct(
    primary_hv_current_converted_t *conversion, 
    const primary_hv_current_t *raw);


void primary_hv_current_conversion_to_raw_struct(
    primary_hv_current_t *raw,
    const primary_hv_current_converted_t *conversion);


int primary_hv_current_converted_to_string(primary_hv_current_converted_t *message, char *buffer);

int primary_hv_current_converted_to_string_file(primary_hv_current_converted_t *message, FILE *buffer);

int primary_hv_current_fields(char *buffer);

int primary_hv_current_fields_file(FILE *buffer);

/**
 * Pack message HV_CURRENT.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_hv_current_pack(
    uint8_t *dst_p,
    const primary_hv_current_t *src_p,
    size_t byte_size);

/**
 * Unpack message HV_CURRENT.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_hv_current_unpack(
    primary_hv_current_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_hv_current_current_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_hv_current_current_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_current_current_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_hv_current_power_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_hv_current_power_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_current_power_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_hv_current_energy_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_hv_current_energy_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_current_energy_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t primary_hv_current_soc_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_hv_current_soc_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_current_soc_is_in_range(uint8_t value);


void primary_hv_temp_raw_to_conversion(
    primary_hv_temp_converted_t *conversion,
    float average_temp,
    float max_temp,
    float min_temp
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_hv_temp_conversion_to_raw(
    primary_hv_temp_t *raw,
    float average_temp,
    float max_temp,
    float min_temp
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_hv_temp_raw_to_conversion_struct(
    primary_hv_temp_converted_t *conversion, 
    const primary_hv_temp_t *raw);


void primary_hv_temp_conversion_to_raw_struct(
    primary_hv_temp_t *raw,
    const primary_hv_temp_converted_t *conversion);


int primary_hv_temp_converted_to_string(primary_hv_temp_converted_t *message, char *buffer);

int primary_hv_temp_converted_to_string_file(primary_hv_temp_converted_t *message, FILE *buffer);

int primary_hv_temp_fields(char *buffer);

int primary_hv_temp_fields_file(FILE *buffer);

/**
 * Pack message HV_TEMP.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_hv_temp_pack(
    uint8_t *dst_p,
    const primary_hv_temp_t *src_p,
    size_t byte_size);

/**
 * Unpack message HV_TEMP.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_hv_temp_unpack(
    primary_hv_temp_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t primary_hv_temp_average_temp_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_hv_temp_average_temp_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_temp_average_temp_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t primary_hv_temp_max_temp_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_hv_temp_max_temp_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_temp_max_temp_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t primary_hv_temp_min_temp_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_hv_temp_min_temp_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_temp_min_temp_is_in_range(uint8_t value);


void primary_hv_errors_raw_to_conversion(
    primary_hv_errors_converted_t *conversion,
    uint8_t warnings_cell_low_voltage,
    uint8_t warnings_cell_under_voltage,
    uint8_t warnings_cell_over_voltage,
    uint8_t warnings_cell_high_temperature,
    uint8_t warnings_cell_over_temperature,
    uint8_t warnings_over_current,
    uint8_t warnings_can,
    uint8_t warnings_int_voltage_mismatch,
    uint8_t warnings_cellboard_comm,
    uint8_t warnings_cellboard_internal,
    uint8_t warnings_connector_disconnected,
    uint8_t warnings_fans_disconnected,
    uint8_t warnings_feedback,
    uint8_t warnings_feedback_circuitry,
    uint8_t warnings_eeprom_comm,
    uint8_t warnings_eeprom_write,
    uint8_t errors_cell_low_voltage,
    uint8_t errors_cell_under_voltage,
    uint8_t errors_cell_over_voltage,
    uint8_t errors_cell_high_temperature,
    uint8_t errors_cell_over_temperature,
    uint8_t errors_over_current,
    uint8_t errors_can,
    uint8_t errors_int_voltage_mismatch,
    uint8_t errors_cellboard_comm,
    uint8_t errors_cellboard_internal,
    uint8_t errors_connector_disconnected,
    uint8_t errors_fans_disconnected,
    uint8_t errors_feedback,
    uint8_t errors_feedback_circuitry,
    uint8_t errors_eeprom_comm,
    uint8_t errors_eeprom_write
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_hv_errors_conversion_to_raw(
    primary_hv_errors_t *raw,
    uint8_t warnings_cell_low_voltage,
    uint8_t warnings_cell_under_voltage,
    uint8_t warnings_cell_over_voltage,
    uint8_t warnings_cell_high_temperature,
    uint8_t warnings_cell_over_temperature,
    uint8_t warnings_over_current,
    uint8_t warnings_can,
    uint8_t warnings_int_voltage_mismatch,
    uint8_t warnings_cellboard_comm,
    uint8_t warnings_cellboard_internal,
    uint8_t warnings_connector_disconnected,
    uint8_t warnings_fans_disconnected,
    uint8_t warnings_feedback,
    uint8_t warnings_feedback_circuitry,
    uint8_t warnings_eeprom_comm,
    uint8_t warnings_eeprom_write,
    uint8_t errors_cell_low_voltage,
    uint8_t errors_cell_under_voltage,
    uint8_t errors_cell_over_voltage,
    uint8_t errors_cell_high_temperature,
    uint8_t errors_cell_over_temperature,
    uint8_t errors_over_current,
    uint8_t errors_can,
    uint8_t errors_int_voltage_mismatch,
    uint8_t errors_cellboard_comm,
    uint8_t errors_cellboard_internal,
    uint8_t errors_connector_disconnected,
    uint8_t errors_fans_disconnected,
    uint8_t errors_feedback,
    uint8_t errors_feedback_circuitry,
    uint8_t errors_eeprom_comm,
    uint8_t errors_eeprom_write
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_hv_errors_raw_to_conversion_struct(
    primary_hv_errors_converted_t *conversion, 
    const primary_hv_errors_t *raw);


void primary_hv_errors_conversion_to_raw_struct(
    primary_hv_errors_t *raw,
    const primary_hv_errors_converted_t *conversion);


int primary_hv_errors_to_string(primary_hv_errors_t *message, char *buffer);

int primary_hv_errors_to_string_file(primary_hv_errors_t *message, FILE *buffer);

int primary_hv_errors_fields(char *buffer);

int primary_hv_errors_fields_file(FILE *buffer);

/**
 * Pack message HV_ERRORS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_hv_errors_pack(
    uint8_t *dst_p,
    const primary_hv_errors_t *src_p,
    size_t byte_size);

/**
 * Unpack message HV_ERRORS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_hv_errors_unpack(
    primary_hv_errors_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_errors_warnings_cell_low_voltage_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_errors_warnings_cell_under_voltage_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_errors_warnings_cell_over_voltage_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_errors_warnings_cell_high_temperature_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_errors_warnings_cell_over_temperature_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_errors_warnings_over_current_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_errors_warnings_can_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_errors_warnings_int_voltage_mismatch_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_errors_warnings_cellboard_comm_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_errors_warnings_cellboard_internal_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_errors_warnings_connector_disconnected_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_errors_warnings_fans_disconnected_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_errors_warnings_feedback_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_errors_warnings_feedback_circuitry_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_errors_warnings_eeprom_comm_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_errors_warnings_eeprom_write_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_errors_errors_cell_low_voltage_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_errors_errors_cell_under_voltage_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_errors_errors_cell_over_voltage_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_errors_errors_cell_high_temperature_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_errors_errors_cell_over_temperature_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_errors_errors_over_current_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_errors_errors_can_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_errors_errors_int_voltage_mismatch_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_errors_errors_cellboard_comm_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_errors_errors_cellboard_internal_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_errors_errors_connector_disconnected_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_errors_errors_fans_disconnected_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_errors_errors_feedback_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_errors_errors_feedback_circuitry_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_errors_errors_eeprom_comm_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_errors_errors_eeprom_write_is_in_range(uint8_t value);


void primary_hv_fans_override_raw_to_conversion(
    primary_hv_fans_override_converted_t *conversion,
    primary_hv_fans_override_fans_override fans_override,
    float fans_speed
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_hv_fans_override_conversion_to_raw(
    primary_hv_fans_override_t *raw,
    primary_hv_fans_override_fans_override fans_override,
    float fans_speed
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_hv_fans_override_raw_to_conversion_struct(
    primary_hv_fans_override_converted_t *conversion, 
    const primary_hv_fans_override_t *raw);


void primary_hv_fans_override_conversion_to_raw_struct(
    primary_hv_fans_override_t *raw,
    const primary_hv_fans_override_converted_t *conversion);

int primary_hv_fans_override_fans_override_enum_to_string(primary_hv_fans_override_fans_override value, char *buffer);

int primary_hv_fans_override_converted_to_string(primary_hv_fans_override_converted_t *message, char *buffer);

int primary_hv_fans_override_converted_to_string_file(primary_hv_fans_override_converted_t *message, FILE *buffer);

int primary_hv_fans_override_fields(char *buffer);

int primary_hv_fans_override_fields_file(FILE *buffer);

/**
 * Pack message HV_FANS_OVERRIDE.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_hv_fans_override_pack(
    uint8_t *dst_p,
    const primary_hv_fans_override_t *src_p,
    size_t byte_size);

/**
 * Unpack message HV_FANS_OVERRIDE.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_hv_fans_override_unpack(
    primary_hv_fans_override_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_fans_override_fans_override_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_hv_fans_override_fans_speed_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_hv_fans_override_fans_speed_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_fans_override_fans_speed_is_in_range(uint16_t value);


void primary_hv_can_forward_status_raw_to_conversion(
    primary_hv_can_forward_status_converted_t *conversion,
    primary_hv_can_forward_status_can_forward_status can_forward_status
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_hv_can_forward_status_conversion_to_raw(
    primary_hv_can_forward_status_t *raw,
    primary_hv_can_forward_status_can_forward_status can_forward_status
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_hv_can_forward_status_raw_to_conversion_struct(
    primary_hv_can_forward_status_converted_t *conversion, 
    const primary_hv_can_forward_status_t *raw);


void primary_hv_can_forward_status_conversion_to_raw_struct(
    primary_hv_can_forward_status_t *raw,
    const primary_hv_can_forward_status_converted_t *conversion);

int primary_hv_can_forward_status_can_forward_status_enum_to_string(primary_hv_can_forward_status_can_forward_status value, char *buffer);

int primary_hv_can_forward_status_to_string(primary_hv_can_forward_status_t *message, char *buffer);

int primary_hv_can_forward_status_to_string_file(primary_hv_can_forward_status_t *message, FILE *buffer);

int primary_hv_can_forward_status_fields(char *buffer);

int primary_hv_can_forward_status_fields_file(FILE *buffer);

/**
 * Pack message HV_CAN_FORWARD_STATUS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_hv_can_forward_status_pack(
    uint8_t *dst_p,
    const primary_hv_can_forward_status_t *src_p,
    size_t byte_size);

/**
 * Unpack message HV_CAN_FORWARD_STATUS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_hv_can_forward_status_unpack(
    primary_hv_can_forward_status_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_can_forward_status_can_forward_status_is_in_range(uint8_t value);


void primary_hv_fans_override_status_raw_to_conversion(
    primary_hv_fans_override_status_converted_t *conversion,
    primary_hv_fans_override_status_fans_override fans_override,
    float fans_speed
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_hv_fans_override_status_conversion_to_raw(
    primary_hv_fans_override_status_t *raw,
    primary_hv_fans_override_status_fans_override fans_override,
    float fans_speed
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_hv_fans_override_status_raw_to_conversion_struct(
    primary_hv_fans_override_status_converted_t *conversion, 
    const primary_hv_fans_override_status_t *raw);


void primary_hv_fans_override_status_conversion_to_raw_struct(
    primary_hv_fans_override_status_t *raw,
    const primary_hv_fans_override_status_converted_t *conversion);

int primary_hv_fans_override_status_fans_override_enum_to_string(primary_hv_fans_override_status_fans_override value, char *buffer);

int primary_hv_fans_override_status_converted_to_string(primary_hv_fans_override_status_converted_t *message, char *buffer);

int primary_hv_fans_override_status_converted_to_string_file(primary_hv_fans_override_status_converted_t *message, FILE *buffer);

int primary_hv_fans_override_status_fields(char *buffer);

int primary_hv_fans_override_status_fields_file(FILE *buffer);

/**
 * Pack message HV_FANS_OVERRIDE_STATUS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_hv_fans_override_status_pack(
    uint8_t *dst_p,
    const primary_hv_fans_override_status_t *src_p,
    size_t byte_size);

/**
 * Unpack message HV_FANS_OVERRIDE_STATUS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_hv_fans_override_status_unpack(
    primary_hv_fans_override_status_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_fans_override_status_fans_override_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_hv_fans_override_status_fans_speed_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_hv_fans_override_status_fans_speed_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_fans_override_status_fans_speed_is_in_range(uint16_t value);


void primary_hv_feedbacks_status_raw_to_conversion(
    primary_hv_feedbacks_status_converted_t *conversion,
    uint8_t feedbacks_status_feedback_implausibility_detected,
    uint8_t feedbacks_status_feedback_imd_cockpit,
    uint8_t feedbacks_status_feedback_tsal_green_fault_latched,
    uint8_t feedbacks_status_feedback_bms_cockpit,
    uint8_t feedbacks_status_feedback_ext_latched,
    uint8_t feedbacks_status_feedback_tsal_green,
    uint8_t feedbacks_status_feedback_ts_over_60v_status,
    uint8_t feedbacks_status_feedback_airn_status,
    uint8_t feedbacks_status_feedback_airp_status,
    uint8_t feedbacks_status_feedback_airp_gate,
    uint8_t feedbacks_status_feedback_airn_gate,
    uint8_t feedbacks_status_feedback_precharge_status,
    uint8_t feedbacks_status_feedback_tsp_over_60v_status,
    uint8_t feedbacks_status_feedback_imd_fault,
    uint8_t feedbacks_status_feedback_check_mux,
    uint8_t feedbacks_status_feedback_sd_end,
    uint8_t feedbacks_status_feedback_sd_out,
    uint8_t feedbacks_status_feedback_sd_in,
    uint8_t feedbacks_status_feedback_sd_bms,
    uint8_t feedbacks_status_feedback_sd_imd,
    uint8_t is_circuitry_error_feedback_implausibility_detected,
    uint8_t is_circuitry_error_feedback_imd_cockpit,
    uint8_t is_circuitry_error_feedback_tsal_green_fault_latched,
    uint8_t is_circuitry_error_feedback_bms_cockpit,
    uint8_t is_circuitry_error_feedback_ext_latched,
    uint8_t is_circuitry_error_feedback_tsal_green,
    uint8_t is_circuitry_error_feedback_ts_over_60v_status,
    uint8_t is_circuitry_error_feedback_airn_status,
    uint8_t is_circuitry_error_feedback_airp_status,
    uint8_t is_circuitry_error_feedback_airp_gate,
    uint8_t is_circuitry_error_feedback_airn_gate,
    uint8_t is_circuitry_error_feedback_precharge_status,
    uint8_t is_circuitry_error_feedback_tsp_over_60v_status,
    uint8_t is_circuitry_error_feedback_imd_fault,
    uint8_t is_circuitry_error_feedback_check_mux,
    uint8_t is_circuitry_error_feedback_sd_end,
    uint8_t is_circuitry_error_feedback_sd_out,
    uint8_t is_circuitry_error_feedback_sd_in,
    uint8_t is_circuitry_error_feedback_sd_bms,
    uint8_t is_circuitry_error_feedback_sd_imd
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_hv_feedbacks_status_conversion_to_raw(
    primary_hv_feedbacks_status_t *raw,
    uint8_t feedbacks_status_feedback_implausibility_detected,
    uint8_t feedbacks_status_feedback_imd_cockpit,
    uint8_t feedbacks_status_feedback_tsal_green_fault_latched,
    uint8_t feedbacks_status_feedback_bms_cockpit,
    uint8_t feedbacks_status_feedback_ext_latched,
    uint8_t feedbacks_status_feedback_tsal_green,
    uint8_t feedbacks_status_feedback_ts_over_60v_status,
    uint8_t feedbacks_status_feedback_airn_status,
    uint8_t feedbacks_status_feedback_airp_status,
    uint8_t feedbacks_status_feedback_airp_gate,
    uint8_t feedbacks_status_feedback_airn_gate,
    uint8_t feedbacks_status_feedback_precharge_status,
    uint8_t feedbacks_status_feedback_tsp_over_60v_status,
    uint8_t feedbacks_status_feedback_imd_fault,
    uint8_t feedbacks_status_feedback_check_mux,
    uint8_t feedbacks_status_feedback_sd_end,
    uint8_t feedbacks_status_feedback_sd_out,
    uint8_t feedbacks_status_feedback_sd_in,
    uint8_t feedbacks_status_feedback_sd_bms,
    uint8_t feedbacks_status_feedback_sd_imd,
    uint8_t is_circuitry_error_feedback_implausibility_detected,
    uint8_t is_circuitry_error_feedback_imd_cockpit,
    uint8_t is_circuitry_error_feedback_tsal_green_fault_latched,
    uint8_t is_circuitry_error_feedback_bms_cockpit,
    uint8_t is_circuitry_error_feedback_ext_latched,
    uint8_t is_circuitry_error_feedback_tsal_green,
    uint8_t is_circuitry_error_feedback_ts_over_60v_status,
    uint8_t is_circuitry_error_feedback_airn_status,
    uint8_t is_circuitry_error_feedback_airp_status,
    uint8_t is_circuitry_error_feedback_airp_gate,
    uint8_t is_circuitry_error_feedback_airn_gate,
    uint8_t is_circuitry_error_feedback_precharge_status,
    uint8_t is_circuitry_error_feedback_tsp_over_60v_status,
    uint8_t is_circuitry_error_feedback_imd_fault,
    uint8_t is_circuitry_error_feedback_check_mux,
    uint8_t is_circuitry_error_feedback_sd_end,
    uint8_t is_circuitry_error_feedback_sd_out,
    uint8_t is_circuitry_error_feedback_sd_in,
    uint8_t is_circuitry_error_feedback_sd_bms,
    uint8_t is_circuitry_error_feedback_sd_imd
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_hv_feedbacks_status_raw_to_conversion_struct(
    primary_hv_feedbacks_status_converted_t *conversion, 
    const primary_hv_feedbacks_status_t *raw);


void primary_hv_feedbacks_status_conversion_to_raw_struct(
    primary_hv_feedbacks_status_t *raw,
    const primary_hv_feedbacks_status_converted_t *conversion);


int primary_hv_feedbacks_status_to_string(primary_hv_feedbacks_status_t *message, char *buffer);

int primary_hv_feedbacks_status_to_string_file(primary_hv_feedbacks_status_t *message, FILE *buffer);

int primary_hv_feedbacks_status_fields(char *buffer);

int primary_hv_feedbacks_status_fields_file(FILE *buffer);

/**
 * Pack message HV_FEEDBACKS_STATUS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_hv_feedbacks_status_pack(
    uint8_t *dst_p,
    const primary_hv_feedbacks_status_t *src_p,
    size_t byte_size);

/**
 * Unpack message HV_FEEDBACKS_STATUS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_hv_feedbacks_status_unpack(
    primary_hv_feedbacks_status_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedbacks_status_feedbacks_status_feedback_implausibility_detected_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedbacks_status_feedbacks_status_feedback_imd_cockpit_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedbacks_status_feedbacks_status_feedback_tsal_green_fault_latched_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedbacks_status_feedbacks_status_feedback_bms_cockpit_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedbacks_status_feedbacks_status_feedback_ext_latched_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedbacks_status_feedbacks_status_feedback_tsal_green_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedbacks_status_feedbacks_status_feedback_ts_over_60v_status_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedbacks_status_feedbacks_status_feedback_airn_status_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedbacks_status_feedbacks_status_feedback_airp_status_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedbacks_status_feedbacks_status_feedback_airp_gate_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedbacks_status_feedbacks_status_feedback_airn_gate_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedbacks_status_feedbacks_status_feedback_precharge_status_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedbacks_status_feedbacks_status_feedback_tsp_over_60v_status_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedbacks_status_feedbacks_status_feedback_imd_fault_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedbacks_status_feedbacks_status_feedback_check_mux_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedbacks_status_feedbacks_status_feedback_sd_end_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedbacks_status_feedbacks_status_feedback_sd_out_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedbacks_status_feedbacks_status_feedback_sd_in_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedbacks_status_feedbacks_status_feedback_sd_bms_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedbacks_status_feedbacks_status_feedback_sd_imd_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedbacks_status_is_circuitry_error_feedback_implausibility_detected_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedbacks_status_is_circuitry_error_feedback_imd_cockpit_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedbacks_status_is_circuitry_error_feedback_tsal_green_fault_latched_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedbacks_status_is_circuitry_error_feedback_bms_cockpit_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedbacks_status_is_circuitry_error_feedback_ext_latched_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedbacks_status_is_circuitry_error_feedback_tsal_green_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedbacks_status_is_circuitry_error_feedback_ts_over_60v_status_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedbacks_status_is_circuitry_error_feedback_airn_status_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedbacks_status_is_circuitry_error_feedback_airp_status_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedbacks_status_is_circuitry_error_feedback_airp_gate_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedbacks_status_is_circuitry_error_feedback_airn_gate_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedbacks_status_is_circuitry_error_feedback_precharge_status_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedbacks_status_is_circuitry_error_feedback_tsp_over_60v_status_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedbacks_status_is_circuitry_error_feedback_imd_fault_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedbacks_status_is_circuitry_error_feedback_check_mux_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedbacks_status_is_circuitry_error_feedback_sd_end_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedbacks_status_is_circuitry_error_feedback_sd_out_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedbacks_status_is_circuitry_error_feedback_sd_in_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedbacks_status_is_circuitry_error_feedback_sd_bms_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedbacks_status_is_circuitry_error_feedback_sd_imd_is_in_range(uint8_t value);


void primary_hv_imd_status_raw_to_conversion(
    primary_hv_imd_status_converted_t *conversion,
    uint8_t imd_fault,
    primary_hv_imd_status_imd_status imd_status,
    int32_t imd_info
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_hv_imd_status_conversion_to_raw(
    primary_hv_imd_status_t *raw,
    uint8_t imd_fault,
    primary_hv_imd_status_imd_status imd_status,
    int32_t imd_info
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_hv_imd_status_raw_to_conversion_struct(
    primary_hv_imd_status_converted_t *conversion, 
    const primary_hv_imd_status_t *raw);


void primary_hv_imd_status_conversion_to_raw_struct(
    primary_hv_imd_status_t *raw,
    const primary_hv_imd_status_converted_t *conversion);

int primary_hv_imd_status_imd_status_enum_to_string(primary_hv_imd_status_imd_status value, char *buffer);

int primary_hv_imd_status_to_string(primary_hv_imd_status_t *message, char *buffer);

int primary_hv_imd_status_to_string_file(primary_hv_imd_status_t *message, FILE *buffer);

int primary_hv_imd_status_fields(char *buffer);

int primary_hv_imd_status_fields_file(FILE *buffer);

/**
 * Pack message HV_IMD_STATUS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_hv_imd_status_pack(
    uint8_t *dst_p,
    const primary_hv_imd_status_t *src_p,
    size_t byte_size);

/**
 * Unpack message HV_IMD_STATUS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_hv_imd_status_unpack(
    primary_hv_imd_status_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_imd_status_imd_fault_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_imd_status_imd_status_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_imd_status_imd_info_is_in_range(int32_t value);


void primary_ts_status_raw_to_conversion(
    primary_ts_status_converted_t *conversion,
    primary_ts_status_ts_status ts_status
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_ts_status_conversion_to_raw(
    primary_ts_status_t *raw,
    primary_ts_status_ts_status ts_status
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_ts_status_raw_to_conversion_struct(
    primary_ts_status_converted_t *conversion, 
    const primary_ts_status_t *raw);


void primary_ts_status_conversion_to_raw_struct(
    primary_ts_status_t *raw,
    const primary_ts_status_converted_t *conversion);

int primary_ts_status_ts_status_enum_to_string(primary_ts_status_ts_status value, char *buffer);

int primary_ts_status_to_string(primary_ts_status_t *message, char *buffer);

int primary_ts_status_to_string_file(primary_ts_status_t *message, FILE *buffer);

int primary_ts_status_fields(char *buffer);

int primary_ts_status_fields_file(FILE *buffer);

/**
 * Pack message TS_STATUS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_ts_status_pack(
    uint8_t *dst_p,
    const primary_ts_status_t *src_p,
    size_t byte_size);

/**
 * Unpack message TS_STATUS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_ts_status_unpack(
    primary_ts_status_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_ts_status_ts_status_is_in_range(uint8_t value);


void primary_set_ts_status_das_raw_to_conversion(
    primary_set_ts_status_das_converted_t *conversion,
    primary_set_ts_status_das_ts_status_set ts_status_set
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_set_ts_status_das_conversion_to_raw(
    primary_set_ts_status_das_t *raw,
    primary_set_ts_status_das_ts_status_set ts_status_set
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_set_ts_status_das_raw_to_conversion_struct(
    primary_set_ts_status_das_converted_t *conversion, 
    const primary_set_ts_status_das_t *raw);


void primary_set_ts_status_das_conversion_to_raw_struct(
    primary_set_ts_status_das_t *raw,
    const primary_set_ts_status_das_converted_t *conversion);

int primary_set_ts_status_das_ts_status_set_enum_to_string(primary_set_ts_status_das_ts_status_set value, char *buffer);

int primary_set_ts_status_das_to_string(primary_set_ts_status_das_t *message, char *buffer);

int primary_set_ts_status_das_to_string_file(primary_set_ts_status_das_t *message, FILE *buffer);

int primary_set_ts_status_das_fields(char *buffer);

int primary_set_ts_status_das_fields_file(FILE *buffer);

/**
 * Pack message SET_TS_STATUS_DAS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_set_ts_status_das_pack(
    uint8_t *dst_p,
    const primary_set_ts_status_das_t *src_p,
    size_t byte_size);

/**
 * Unpack message SET_TS_STATUS_DAS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_set_ts_status_das_unpack(
    primary_set_ts_status_das_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_set_ts_status_das_ts_status_set_is_in_range(uint8_t value);


void primary_set_ts_status_handcart_raw_to_conversion(
    primary_set_ts_status_handcart_converted_t *conversion,
    primary_set_ts_status_handcart_ts_status_set ts_status_set
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_set_ts_status_handcart_conversion_to_raw(
    primary_set_ts_status_handcart_t *raw,
    primary_set_ts_status_handcart_ts_status_set ts_status_set
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_set_ts_status_handcart_raw_to_conversion_struct(
    primary_set_ts_status_handcart_converted_t *conversion, 
    const primary_set_ts_status_handcart_t *raw);


void primary_set_ts_status_handcart_conversion_to_raw_struct(
    primary_set_ts_status_handcart_t *raw,
    const primary_set_ts_status_handcart_converted_t *conversion);

int primary_set_ts_status_handcart_ts_status_set_enum_to_string(primary_set_ts_status_handcart_ts_status_set value, char *buffer);

int primary_set_ts_status_handcart_to_string(primary_set_ts_status_handcart_t *message, char *buffer);

int primary_set_ts_status_handcart_to_string_file(primary_set_ts_status_handcart_t *message, FILE *buffer);

int primary_set_ts_status_handcart_fields(char *buffer);

int primary_set_ts_status_handcart_fields_file(FILE *buffer);

/**
 * Pack message SET_TS_STATUS_HANDCART.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_set_ts_status_handcart_pack(
    uint8_t *dst_p,
    const primary_set_ts_status_handcart_t *src_p,
    size_t byte_size);

/**
 * Unpack message SET_TS_STATUS_HANDCART.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_set_ts_status_handcart_unpack(
    primary_set_ts_status_handcart_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_set_ts_status_handcart_ts_status_set_is_in_range(uint8_t value);


void primary_steer_status_raw_to_conversion(
    primary_steer_status_converted_t *conversion,
    float map_pw,
    float map_sc,
    float map_tv
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_steer_status_conversion_to_raw(
    primary_steer_status_t *raw,
    float map_pw,
    float map_sc,
    float map_tv
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_steer_status_raw_to_conversion_struct(
    primary_steer_status_converted_t *conversion, 
    const primary_steer_status_t *raw);


void primary_steer_status_conversion_to_raw_struct(
    primary_steer_status_t *raw,
    const primary_steer_status_converted_t *conversion);


int primary_steer_status_converted_to_string(primary_steer_status_converted_t *message, char *buffer);

int primary_steer_status_converted_to_string_file(primary_steer_status_converted_t *message, FILE *buffer);

int primary_steer_status_fields(char *buffer);

int primary_steer_status_fields_file(FILE *buffer);

/**
 * Pack message STEER_STATUS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_steer_status_pack(
    uint8_t *dst_p,
    const primary_steer_status_t *src_p,
    size_t byte_size);

/**
 * Unpack message STEER_STATUS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_steer_status_unpack(
    primary_steer_status_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t primary_steer_status_map_pw_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_steer_status_map_pw_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_steer_status_map_pw_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t primary_steer_status_map_sc_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_steer_status_map_sc_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_steer_status_map_sc_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t primary_steer_status_map_tv_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_steer_status_map_tv_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_steer_status_map_tv_is_in_range(uint8_t value);


void primary_set_car_status_raw_to_conversion(
    primary_set_car_status_converted_t *conversion,
    primary_set_car_status_car_status_set car_status_set
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_set_car_status_conversion_to_raw(
    primary_set_car_status_t *raw,
    primary_set_car_status_car_status_set car_status_set
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_set_car_status_raw_to_conversion_struct(
    primary_set_car_status_converted_t *conversion, 
    const primary_set_car_status_t *raw);


void primary_set_car_status_conversion_to_raw_struct(
    primary_set_car_status_t *raw,
    const primary_set_car_status_converted_t *conversion);

int primary_set_car_status_car_status_set_enum_to_string(primary_set_car_status_car_status_set value, char *buffer);

int primary_set_car_status_to_string(primary_set_car_status_t *message, char *buffer);

int primary_set_car_status_to_string_file(primary_set_car_status_t *message, FILE *buffer);

int primary_set_car_status_fields(char *buffer);

int primary_set_car_status_fields_file(FILE *buffer);

/**
 * Pack message SET_CAR_STATUS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_set_car_status_pack(
    uint8_t *dst_p,
    const primary_set_car_status_t *src_p,
    size_t byte_size);

/**
 * Unpack message SET_CAR_STATUS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_set_car_status_unpack(
    primary_set_car_status_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_set_car_status_car_status_set_is_in_range(uint8_t value);


void primary_set_pedal_calibration_raw_to_conversion(
    primary_set_pedal_calibration_converted_t *conversion,
    primary_set_pedal_calibration_pedal pedal,
    primary_set_pedal_calibration_bound bound
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_set_pedal_calibration_conversion_to_raw(
    primary_set_pedal_calibration_t *raw,
    primary_set_pedal_calibration_pedal pedal,
    primary_set_pedal_calibration_bound bound
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_set_pedal_calibration_raw_to_conversion_struct(
    primary_set_pedal_calibration_converted_t *conversion, 
    const primary_set_pedal_calibration_t *raw);


void primary_set_pedal_calibration_conversion_to_raw_struct(
    primary_set_pedal_calibration_t *raw,
    const primary_set_pedal_calibration_converted_t *conversion);

int primary_set_pedal_calibration_pedal_enum_to_string(primary_set_pedal_calibration_pedal value, char *buffer);
int primary_set_pedal_calibration_bound_enum_to_string(primary_set_pedal_calibration_bound value, char *buffer);

int primary_set_pedal_calibration_to_string(primary_set_pedal_calibration_t *message, char *buffer);

int primary_set_pedal_calibration_to_string_file(primary_set_pedal_calibration_t *message, FILE *buffer);

int primary_set_pedal_calibration_fields(char *buffer);

int primary_set_pedal_calibration_fields_file(FILE *buffer);

/**
 * Pack message SET_PEDAL_CALIBRATION.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_set_pedal_calibration_pack(
    uint8_t *dst_p,
    const primary_set_pedal_calibration_t *src_p,
    size_t byte_size);

/**
 * Unpack message SET_PEDAL_CALIBRATION.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_set_pedal_calibration_unpack(
    primary_set_pedal_calibration_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_set_pedal_calibration_pedal_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_set_pedal_calibration_bound_is_in_range(uint8_t value);


void primary_pedal_calibration_ack_raw_to_conversion(
    primary_pedal_calibration_ack_converted_t *conversion,
    primary_pedal_calibration_ack_pedal pedal,
    primary_pedal_calibration_ack_bound bound
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_pedal_calibration_ack_conversion_to_raw(
    primary_pedal_calibration_ack_t *raw,
    primary_pedal_calibration_ack_pedal pedal,
    primary_pedal_calibration_ack_bound bound
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_pedal_calibration_ack_raw_to_conversion_struct(
    primary_pedal_calibration_ack_converted_t *conversion, 
    const primary_pedal_calibration_ack_t *raw);


void primary_pedal_calibration_ack_conversion_to_raw_struct(
    primary_pedal_calibration_ack_t *raw,
    const primary_pedal_calibration_ack_converted_t *conversion);

int primary_pedal_calibration_ack_pedal_enum_to_string(primary_pedal_calibration_ack_pedal value, char *buffer);
int primary_pedal_calibration_ack_bound_enum_to_string(primary_pedal_calibration_ack_bound value, char *buffer);

int primary_pedal_calibration_ack_to_string(primary_pedal_calibration_ack_t *message, char *buffer);

int primary_pedal_calibration_ack_to_string_file(primary_pedal_calibration_ack_t *message, FILE *buffer);

int primary_pedal_calibration_ack_fields(char *buffer);

int primary_pedal_calibration_ack_fields_file(FILE *buffer);

/**
 * Pack message PEDAL_CALIBRATION_ACK.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_pedal_calibration_ack_pack(
    uint8_t *dst_p,
    const primary_pedal_calibration_ack_t *src_p,
    size_t byte_size);

/**
 * Unpack message PEDAL_CALIBRATION_ACK.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_pedal_calibration_ack_unpack(
    primary_pedal_calibration_ack_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_pedal_calibration_ack_pedal_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_pedal_calibration_ack_bound_is_in_range(uint8_t value);


void primary_car_status_raw_to_conversion(
    primary_car_status_converted_t *conversion,
    primary_car_status_inverter_l inverter_l,
    primary_car_status_inverter_r inverter_r,
    primary_car_status_car_status car_status
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_car_status_conversion_to_raw(
    primary_car_status_t *raw,
    primary_car_status_inverter_l inverter_l,
    primary_car_status_inverter_r inverter_r,
    primary_car_status_car_status car_status
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_car_status_raw_to_conversion_struct(
    primary_car_status_converted_t *conversion, 
    const primary_car_status_t *raw);


void primary_car_status_conversion_to_raw_struct(
    primary_car_status_t *raw,
    const primary_car_status_converted_t *conversion);

int primary_car_status_inverter_l_enum_to_string(primary_car_status_inverter_l value, char *buffer);
int primary_car_status_inverter_r_enum_to_string(primary_car_status_inverter_r value, char *buffer);
int primary_car_status_car_status_enum_to_string(primary_car_status_car_status value, char *buffer);

int primary_car_status_to_string(primary_car_status_t *message, char *buffer);

int primary_car_status_to_string_file(primary_car_status_t *message, FILE *buffer);

int primary_car_status_fields(char *buffer);

int primary_car_status_fields_file(FILE *buffer);

/**
 * Pack message CAR_STATUS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_car_status_pack(
    uint8_t *dst_p,
    const primary_car_status_t *src_p,
    size_t byte_size);

/**
 * Unpack message CAR_STATUS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_car_status_unpack(
    primary_car_status_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_car_status_inverter_l_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_car_status_inverter_r_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_car_status_car_status_is_in_range(uint8_t value);


void primary_das_errors_raw_to_conversion(
    primary_das_errors_converted_t *conversion,
    uint8_t das_error_pedal_adc,
    uint8_t das_error_pedal_implausibility,
    uint8_t das_error_imu_tout,
    uint8_t das_error_irts_tout,
    uint8_t das_error_ts_tout,
    uint8_t das_error_invl_tout,
    uint8_t das_error_invr_tout,
    uint8_t das_error_steer_tout,
    uint8_t das_error_fsm
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_das_errors_conversion_to_raw(
    primary_das_errors_t *raw,
    uint8_t das_error_pedal_adc,
    uint8_t das_error_pedal_implausibility,
    uint8_t das_error_imu_tout,
    uint8_t das_error_irts_tout,
    uint8_t das_error_ts_tout,
    uint8_t das_error_invl_tout,
    uint8_t das_error_invr_tout,
    uint8_t das_error_steer_tout,
    uint8_t das_error_fsm
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_das_errors_raw_to_conversion_struct(
    primary_das_errors_converted_t *conversion, 
    const primary_das_errors_t *raw);


void primary_das_errors_conversion_to_raw_struct(
    primary_das_errors_t *raw,
    const primary_das_errors_converted_t *conversion);


int primary_das_errors_to_string(primary_das_errors_t *message, char *buffer);

int primary_das_errors_to_string_file(primary_das_errors_t *message, FILE *buffer);

int primary_das_errors_fields(char *buffer);

int primary_das_errors_fields_file(FILE *buffer);

/**
 * Pack message DAS_ERRORS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_das_errors_pack(
    uint8_t *dst_p,
    const primary_das_errors_t *src_p,
    size_t byte_size);

/**
 * Unpack message DAS_ERRORS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_das_errors_unpack(
    primary_das_errors_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_das_errors_das_error_pedal_adc_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_das_errors_das_error_pedal_implausibility_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_das_errors_das_error_imu_tout_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_das_errors_das_error_irts_tout_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_das_errors_das_error_ts_tout_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_das_errors_das_error_invl_tout_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_das_errors_das_error_invr_tout_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_das_errors_das_error_steer_tout_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_das_errors_das_error_fsm_is_in_range(uint8_t value);


void primary_ecu_feedbacks_raw_to_conversion(
    primary_ecu_feedbacks_converted_t *conversion,
    uint8_t ecu_feedbacks_sd_cock_fb,
    uint8_t ecu_feedbacks_sd_fb1,
    uint8_t ecu_feedbacks_sd_bots_fb,
    uint8_t ecu_feedbacks_sd_interial_fb,
    uint8_t ecu_feedbacks_sd_fb3,
    uint8_t ecu_feedbacks_sd_in,
    uint8_t ecu_feedbacks_sd_our,
    uint8_t ecu_feedbacks_sd_ctrl_pin
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_ecu_feedbacks_conversion_to_raw(
    primary_ecu_feedbacks_t *raw,
    uint8_t ecu_feedbacks_sd_cock_fb,
    uint8_t ecu_feedbacks_sd_fb1,
    uint8_t ecu_feedbacks_sd_bots_fb,
    uint8_t ecu_feedbacks_sd_interial_fb,
    uint8_t ecu_feedbacks_sd_fb3,
    uint8_t ecu_feedbacks_sd_in,
    uint8_t ecu_feedbacks_sd_our,
    uint8_t ecu_feedbacks_sd_ctrl_pin
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_ecu_feedbacks_raw_to_conversion_struct(
    primary_ecu_feedbacks_converted_t *conversion, 
    const primary_ecu_feedbacks_t *raw);


void primary_ecu_feedbacks_conversion_to_raw_struct(
    primary_ecu_feedbacks_t *raw,
    const primary_ecu_feedbacks_converted_t *conversion);


int primary_ecu_feedbacks_to_string(primary_ecu_feedbacks_t *message, char *buffer);

int primary_ecu_feedbacks_to_string_file(primary_ecu_feedbacks_t *message, FILE *buffer);

int primary_ecu_feedbacks_fields(char *buffer);

int primary_ecu_feedbacks_fields_file(FILE *buffer);

/**
 * Pack message ECU_FEEDBACKS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_ecu_feedbacks_pack(
    uint8_t *dst_p,
    const primary_ecu_feedbacks_t *src_p,
    size_t byte_size);

/**
 * Unpack message ECU_FEEDBACKS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_ecu_feedbacks_unpack(
    primary_ecu_feedbacks_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_ecu_feedbacks_ecu_feedbacks_sd_cock_fb_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_ecu_feedbacks_ecu_feedbacks_sd_fb1_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_ecu_feedbacks_ecu_feedbacks_sd_bots_fb_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_ecu_feedbacks_ecu_feedbacks_sd_interial_fb_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_ecu_feedbacks_ecu_feedbacks_sd_fb3_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_ecu_feedbacks_ecu_feedbacks_sd_in_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_ecu_feedbacks_ecu_feedbacks_sd_our_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_ecu_feedbacks_ecu_feedbacks_sd_ctrl_pin_is_in_range(uint8_t value);


void primary_lv_status_raw_to_conversion(
    primary_lv_status_converted_t *conversion,
    primary_lv_status_status status
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_lv_status_conversion_to_raw(
    primary_lv_status_t *raw,
    primary_lv_status_status status
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_lv_status_raw_to_conversion_struct(
    primary_lv_status_converted_t *conversion, 
    const primary_lv_status_t *raw);


void primary_lv_status_conversion_to_raw_struct(
    primary_lv_status_t *raw,
    const primary_lv_status_converted_t *conversion);

int primary_lv_status_status_enum_to_string(primary_lv_status_status value, char *buffer);

int primary_lv_status_to_string(primary_lv_status_t *message, char *buffer);

int primary_lv_status_to_string_file(primary_lv_status_t *message, FILE *buffer);

int primary_lv_status_fields(char *buffer);

int primary_lv_status_fields_file(FILE *buffer);

/**
 * Pack message LV_STATUS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_lv_status_pack(
    uint8_t *dst_p,
    const primary_lv_status_t *src_p,
    size_t byte_size);

/**
 * Unpack message LV_STATUS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_lv_status_unpack(
    primary_lv_status_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_status_status_is_in_range(uint8_t value);


void primary_lv_currents_raw_to_conversion(
    primary_lv_currents_converted_t *conversion,
    float current_as_battery,
    float current_lv_battery,
    float current_charger
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_lv_currents_conversion_to_raw(
    primary_lv_currents_t *raw,
    float current_as_battery,
    float current_lv_battery,
    float current_charger
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_lv_currents_raw_to_conversion_struct(
    primary_lv_currents_converted_t *conversion, 
    const primary_lv_currents_t *raw);


void primary_lv_currents_conversion_to_raw_struct(
    primary_lv_currents_t *raw,
    const primary_lv_currents_converted_t *conversion);


int primary_lv_currents_converted_to_string(primary_lv_currents_converted_t *message, char *buffer);

int primary_lv_currents_converted_to_string_file(primary_lv_currents_converted_t *message, FILE *buffer);

int primary_lv_currents_fields(char *buffer);

int primary_lv_currents_fields_file(FILE *buffer);

/**
 * Pack message LV_CURRENTS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_lv_currents_pack(
    uint8_t *dst_p,
    const primary_lv_currents_t *src_p,
    size_t byte_size);

/**
 * Unpack message LV_CURRENTS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_lv_currents_unpack(
    primary_lv_currents_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_lv_currents_current_as_battery_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_lv_currents_current_as_battery_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_currents_current_as_battery_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_lv_currents_current_lv_battery_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_lv_currents_current_lv_battery_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_currents_current_lv_battery_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_lv_currents_current_charger_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_lv_currents_current_charger_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_currents_current_charger_is_in_range(uint16_t value);


void primary_lv_cells_voltage_raw_to_conversion(
    primary_lv_cells_voltage_converted_t *conversion,
    uint8_t start_index,
    float voltage_0,
    float voltage_1,
    float voltage_2
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_lv_cells_voltage_conversion_to_raw(
    primary_lv_cells_voltage_t *raw,
    uint8_t start_index,
    float voltage_0,
    float voltage_1,
    float voltage_2
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_lv_cells_voltage_raw_to_conversion_struct(
    primary_lv_cells_voltage_converted_t *conversion, 
    const primary_lv_cells_voltage_t *raw);


void primary_lv_cells_voltage_conversion_to_raw_struct(
    primary_lv_cells_voltage_t *raw,
    const primary_lv_cells_voltage_converted_t *conversion);


int primary_lv_cells_voltage_converted_to_string(primary_lv_cells_voltage_converted_t *message, char *buffer);

int primary_lv_cells_voltage_converted_to_string_file(primary_lv_cells_voltage_converted_t *message, FILE *buffer);

int primary_lv_cells_voltage_fields(char *buffer);

int primary_lv_cells_voltage_fields_file(FILE *buffer);

/**
 * Pack message LV_CELLS_VOLTAGE.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_lv_cells_voltage_pack(
    uint8_t *dst_p,
    const primary_lv_cells_voltage_t *src_p,
    size_t byte_size);

/**
 * Unpack message LV_CELLS_VOLTAGE.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_lv_cells_voltage_unpack(
    primary_lv_cells_voltage_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_cells_voltage_start_index_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_lv_cells_voltage_voltage_0_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_lv_cells_voltage_voltage_0_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_cells_voltage_voltage_0_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_lv_cells_voltage_voltage_1_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_lv_cells_voltage_voltage_1_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_cells_voltage_voltage_1_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_lv_cells_voltage_voltage_2_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_lv_cells_voltage_voltage_2_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_cells_voltage_voltage_2_is_in_range(uint16_t value);


void primary_lv_total_voltage_raw_to_conversion(
    primary_lv_total_voltage_converted_t *conversion,
    float total_voltage
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_lv_total_voltage_conversion_to_raw(
    primary_lv_total_voltage_t *raw,
    float total_voltage
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_lv_total_voltage_raw_to_conversion_struct(
    primary_lv_total_voltage_converted_t *conversion, 
    const primary_lv_total_voltage_t *raw);


void primary_lv_total_voltage_conversion_to_raw_struct(
    primary_lv_total_voltage_t *raw,
    const primary_lv_total_voltage_converted_t *conversion);


int primary_lv_total_voltage_converted_to_string(primary_lv_total_voltage_converted_t *message, char *buffer);

int primary_lv_total_voltage_converted_to_string_file(primary_lv_total_voltage_converted_t *message, FILE *buffer);

int primary_lv_total_voltage_fields(char *buffer);

int primary_lv_total_voltage_fields_file(FILE *buffer);

/**
 * Pack message LV_TOTAL_VOLTAGE.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_lv_total_voltage_pack(
    uint8_t *dst_p,
    const primary_lv_total_voltage_t *src_p,
    size_t byte_size);

/**
 * Unpack message LV_TOTAL_VOLTAGE.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_lv_total_voltage_unpack(
    primary_lv_total_voltage_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t primary_lv_total_voltage_total_voltage_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_lv_total_voltage_total_voltage_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_total_voltage_total_voltage_is_in_range(uint32_t value);


void primary_lv_cells_temp_raw_to_conversion(
    primary_lv_cells_temp_converted_t *conversion,
    uint8_t start_index,
    float temp_0,
    float temp_1,
    float temp_2
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_lv_cells_temp_conversion_to_raw(
    primary_lv_cells_temp_t *raw,
    uint8_t start_index,
    float temp_0,
    float temp_1,
    float temp_2
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_lv_cells_temp_raw_to_conversion_struct(
    primary_lv_cells_temp_converted_t *conversion, 
    const primary_lv_cells_temp_t *raw);


void primary_lv_cells_temp_conversion_to_raw_struct(
    primary_lv_cells_temp_t *raw,
    const primary_lv_cells_temp_converted_t *conversion);


int primary_lv_cells_temp_converted_to_string(primary_lv_cells_temp_converted_t *message, char *buffer);

int primary_lv_cells_temp_converted_to_string_file(primary_lv_cells_temp_converted_t *message, FILE *buffer);

int primary_lv_cells_temp_fields(char *buffer);

int primary_lv_cells_temp_fields_file(FILE *buffer);

/**
 * Pack message LV_CELLS_TEMP.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_lv_cells_temp_pack(
    uint8_t *dst_p,
    const primary_lv_cells_temp_t *src_p,
    size_t byte_size);

/**
 * Unpack message LV_CELLS_TEMP.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_lv_cells_temp_unpack(
    primary_lv_cells_temp_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_cells_temp_start_index_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_lv_cells_temp_temp_0_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_lv_cells_temp_temp_0_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_cells_temp_temp_0_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_lv_cells_temp_temp_1_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_lv_cells_temp_temp_1_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_cells_temp_temp_1_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_lv_cells_temp_temp_2_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_lv_cells_temp_temp_2_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_cells_temp_temp_2_is_in_range(uint16_t value);


void primary_cooling_status_raw_to_conversion(
    primary_cooling_status_converted_t *conversion,
    float radiators_speed,
    float pumps_speed
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_cooling_status_conversion_to_raw(
    primary_cooling_status_t *raw,
    float radiators_speed,
    float pumps_speed
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_cooling_status_raw_to_conversion_struct(
    primary_cooling_status_converted_t *conversion, 
    const primary_cooling_status_t *raw);


void primary_cooling_status_conversion_to_raw_struct(
    primary_cooling_status_t *raw,
    const primary_cooling_status_converted_t *conversion);


int primary_cooling_status_converted_to_string(primary_cooling_status_converted_t *message, char *buffer);

int primary_cooling_status_converted_to_string_file(primary_cooling_status_converted_t *message, FILE *buffer);

int primary_cooling_status_fields(char *buffer);

int primary_cooling_status_fields_file(FILE *buffer);

/**
 * Pack message COOLING_STATUS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_cooling_status_pack(
    uint8_t *dst_p,
    const primary_cooling_status_t *src_p,
    size_t byte_size);

/**
 * Unpack message COOLING_STATUS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_cooling_status_unpack(
    primary_cooling_status_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_cooling_status_radiators_speed_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_cooling_status_radiators_speed_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_cooling_status_radiators_speed_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_cooling_status_pumps_speed_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_cooling_status_pumps_speed_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_cooling_status_pumps_speed_is_in_range(uint16_t value);


void primary_set_radiator_speed_raw_to_conversion(
    primary_set_radiator_speed_converted_t *conversion,
    float radiators_speed
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_set_radiator_speed_conversion_to_raw(
    primary_set_radiator_speed_t *raw,
    float radiators_speed
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_set_radiator_speed_raw_to_conversion_struct(
    primary_set_radiator_speed_converted_t *conversion, 
    const primary_set_radiator_speed_t *raw);


void primary_set_radiator_speed_conversion_to_raw_struct(
    primary_set_radiator_speed_t *raw,
    const primary_set_radiator_speed_converted_t *conversion);


int primary_set_radiator_speed_converted_to_string(primary_set_radiator_speed_converted_t *message, char *buffer);

int primary_set_radiator_speed_converted_to_string_file(primary_set_radiator_speed_converted_t *message, FILE *buffer);

int primary_set_radiator_speed_fields(char *buffer);

int primary_set_radiator_speed_fields_file(FILE *buffer);

/**
 * Pack message SET_RADIATOR_SPEED.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_set_radiator_speed_pack(
    uint8_t *dst_p,
    const primary_set_radiator_speed_t *src_p,
    size_t byte_size);

/**
 * Unpack message SET_RADIATOR_SPEED.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_set_radiator_speed_unpack(
    primary_set_radiator_speed_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_set_radiator_speed_radiators_speed_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_set_radiator_speed_radiators_speed_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_set_radiator_speed_radiators_speed_is_in_range(uint16_t value);


void primary_set_pumps_speed_raw_to_conversion(
    primary_set_pumps_speed_converted_t *conversion,
    float pumps_speed
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_set_pumps_speed_conversion_to_raw(
    primary_set_pumps_speed_t *raw,
    float pumps_speed
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_set_pumps_speed_raw_to_conversion_struct(
    primary_set_pumps_speed_converted_t *conversion, 
    const primary_set_pumps_speed_t *raw);


void primary_set_pumps_speed_conversion_to_raw_struct(
    primary_set_pumps_speed_t *raw,
    const primary_set_pumps_speed_converted_t *conversion);


int primary_set_pumps_speed_converted_to_string(primary_set_pumps_speed_converted_t *message, char *buffer);

int primary_set_pumps_speed_converted_to_string_file(primary_set_pumps_speed_converted_t *message, FILE *buffer);

int primary_set_pumps_speed_fields(char *buffer);

int primary_set_pumps_speed_fields_file(FILE *buffer);

/**
 * Pack message SET_PUMPS_SPEED.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_set_pumps_speed_pack(
    uint8_t *dst_p,
    const primary_set_pumps_speed_t *src_p,
    size_t byte_size);

/**
 * Unpack message SET_PUMPS_SPEED.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_set_pumps_speed_unpack(
    primary_set_pumps_speed_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_set_pumps_speed_pumps_speed_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_set_pumps_speed_pumps_speed_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_set_pumps_speed_pumps_speed_is_in_range(uint16_t value);


void primary_set_inverter_connection_status_raw_to_conversion(
    primary_set_inverter_connection_status_converted_t *conversion,
    primary_set_inverter_connection_status_status status
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_set_inverter_connection_status_conversion_to_raw(
    primary_set_inverter_connection_status_t *raw,
    primary_set_inverter_connection_status_status status
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_set_inverter_connection_status_raw_to_conversion_struct(
    primary_set_inverter_connection_status_converted_t *conversion, 
    const primary_set_inverter_connection_status_t *raw);


void primary_set_inverter_connection_status_conversion_to_raw_struct(
    primary_set_inverter_connection_status_t *raw,
    const primary_set_inverter_connection_status_converted_t *conversion);

int primary_set_inverter_connection_status_status_enum_to_string(primary_set_inverter_connection_status_status value, char *buffer);

int primary_set_inverter_connection_status_to_string(primary_set_inverter_connection_status_t *message, char *buffer);

int primary_set_inverter_connection_status_to_string_file(primary_set_inverter_connection_status_t *message, FILE *buffer);

int primary_set_inverter_connection_status_fields(char *buffer);

int primary_set_inverter_connection_status_fields_file(FILE *buffer);

/**
 * Pack message SET_INVERTER_CONNECTION_STATUS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_set_inverter_connection_status_pack(
    uint8_t *dst_p,
    const primary_set_inverter_connection_status_t *src_p,
    size_t byte_size);

/**
 * Unpack message SET_INVERTER_CONNECTION_STATUS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_set_inverter_connection_status_unpack(
    primary_set_inverter_connection_status_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_set_inverter_connection_status_status_is_in_range(uint8_t value);


void primary_inverter_connection_status_raw_to_conversion(
    primary_inverter_connection_status_converted_t *conversion,
    primary_inverter_connection_status_status status
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_inverter_connection_status_conversion_to_raw(
    primary_inverter_connection_status_t *raw,
    primary_inverter_connection_status_status status
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_inverter_connection_status_raw_to_conversion_struct(
    primary_inverter_connection_status_converted_t *conversion, 
    const primary_inverter_connection_status_t *raw);


void primary_inverter_connection_status_conversion_to_raw_struct(
    primary_inverter_connection_status_t *raw,
    const primary_inverter_connection_status_converted_t *conversion);

int primary_inverter_connection_status_status_enum_to_string(primary_inverter_connection_status_status value, char *buffer);

int primary_inverter_connection_status_to_string(primary_inverter_connection_status_t *message, char *buffer);

int primary_inverter_connection_status_to_string_file(primary_inverter_connection_status_t *message, FILE *buffer);

int primary_inverter_connection_status_fields(char *buffer);

int primary_inverter_connection_status_fields_file(FILE *buffer);

/**
 * Pack message INVERTER_CONNECTION_STATUS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_inverter_connection_status_pack(
    uint8_t *dst_p,
    const primary_inverter_connection_status_t *src_p,
    size_t byte_size);

/**
 * Unpack message INVERTER_CONNECTION_STATUS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_inverter_connection_status_unpack(
    primary_inverter_connection_status_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_connection_status_status_is_in_range(uint8_t value);


void primary_lv_errors_raw_to_conversion(
    primary_lv_errors_converted_t *conversion,
    uint8_t warnings_cell_undervoltage,
    uint8_t warnings_cell_overvoltage,
    uint8_t warnings_battery_open_wire,
    uint8_t warnings_can,
    uint8_t warnings_spi,
    uint8_t warnings_over_current,
    uint8_t warnings_cell_under_temperature,
    uint8_t warnings_cell_over_temperature,
    uint8_t warnings_relay,
    uint8_t warnings_bms_monitor,
    uint8_t warnings_voltages_not_ready,
    uint8_t warnings_mcp23017,
    uint8_t warnings_radiator,
    uint8_t warnings_fan,
    uint8_t warnings_pump,
    uint8_t warnings_adc_init,
    uint8_t warnings_mux,
    uint8_t errors_cell_undervoltage,
    uint8_t errors_cell_overvoltage,
    uint8_t errors_battery_open_wire,
    uint8_t errors_can,
    uint8_t errors_spi,
    uint8_t errors_over_current,
    uint8_t errors_cell_under_temperature,
    uint8_t errors_cell_over_temperature,
    uint8_t errors_relay,
    uint8_t errors_bms_monitor,
    uint8_t errors_voltages_not_ready,
    uint8_t errors_mcp23017,
    uint8_t errors_radiator,
    uint8_t errors_fan,
    uint8_t errors_pump,
    uint8_t errors_adc_init,
    uint8_t errors_mux
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_lv_errors_conversion_to_raw(
    primary_lv_errors_t *raw,
    uint8_t warnings_cell_undervoltage,
    uint8_t warnings_cell_overvoltage,
    uint8_t warnings_battery_open_wire,
    uint8_t warnings_can,
    uint8_t warnings_spi,
    uint8_t warnings_over_current,
    uint8_t warnings_cell_under_temperature,
    uint8_t warnings_cell_over_temperature,
    uint8_t warnings_relay,
    uint8_t warnings_bms_monitor,
    uint8_t warnings_voltages_not_ready,
    uint8_t warnings_mcp23017,
    uint8_t warnings_radiator,
    uint8_t warnings_fan,
    uint8_t warnings_pump,
    uint8_t warnings_adc_init,
    uint8_t warnings_mux,
    uint8_t errors_cell_undervoltage,
    uint8_t errors_cell_overvoltage,
    uint8_t errors_battery_open_wire,
    uint8_t errors_can,
    uint8_t errors_spi,
    uint8_t errors_over_current,
    uint8_t errors_cell_under_temperature,
    uint8_t errors_cell_over_temperature,
    uint8_t errors_relay,
    uint8_t errors_bms_monitor,
    uint8_t errors_voltages_not_ready,
    uint8_t errors_mcp23017,
    uint8_t errors_radiator,
    uint8_t errors_fan,
    uint8_t errors_pump,
    uint8_t errors_adc_init,
    uint8_t errors_mux
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_lv_errors_raw_to_conversion_struct(
    primary_lv_errors_converted_t *conversion, 
    const primary_lv_errors_t *raw);


void primary_lv_errors_conversion_to_raw_struct(
    primary_lv_errors_t *raw,
    const primary_lv_errors_converted_t *conversion);


int primary_lv_errors_to_string(primary_lv_errors_t *message, char *buffer);

int primary_lv_errors_to_string_file(primary_lv_errors_t *message, FILE *buffer);

int primary_lv_errors_fields(char *buffer);

int primary_lv_errors_fields_file(FILE *buffer);

/**
 * Pack message LV_ERRORS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_lv_errors_pack(
    uint8_t *dst_p,
    const primary_lv_errors_t *src_p,
    size_t byte_size);

/**
 * Unpack message LV_ERRORS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_lv_errors_unpack(
    primary_lv_errors_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_errors_warnings_cell_undervoltage_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_errors_warnings_cell_overvoltage_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_errors_warnings_battery_open_wire_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_errors_warnings_can_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_errors_warnings_spi_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_errors_warnings_over_current_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_errors_warnings_cell_under_temperature_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_errors_warnings_cell_over_temperature_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_errors_warnings_relay_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_errors_warnings_bms_monitor_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_errors_warnings_voltages_not_ready_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_errors_warnings_mcp23017_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_errors_warnings_radiator_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_errors_warnings_fan_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_errors_warnings_pump_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_errors_warnings_adc_init_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_errors_warnings_mux_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_errors_errors_cell_undervoltage_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_errors_errors_cell_overvoltage_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_errors_errors_battery_open_wire_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_errors_errors_can_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_errors_errors_spi_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_errors_errors_over_current_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_errors_errors_cell_under_temperature_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_errors_errors_cell_over_temperature_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_errors_errors_relay_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_errors_errors_bms_monitor_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_errors_errors_voltages_not_ready_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_errors_errors_mcp23017_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_errors_errors_radiator_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_errors_errors_fan_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_errors_errors_pump_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_errors_errors_adc_init_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_errors_errors_mux_is_in_range(uint8_t value);


void primary_lv_health_signals_raw_to_conversion(
    primary_lv_health_signals_converted_t *conversion,
    uint8_t health_signals_lvms_out,
    uint8_t health_signals_relay_out,
    uint8_t health_signals_battery_voltage_out,
    uint8_t health_signals_charger_current,
    uint8_t health_signals_battery_current,
    uint8_t health_signals_sign_battery_current,
    uint8_t health_code
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_lv_health_signals_conversion_to_raw(
    primary_lv_health_signals_t *raw,
    uint8_t health_signals_lvms_out,
    uint8_t health_signals_relay_out,
    uint8_t health_signals_battery_voltage_out,
    uint8_t health_signals_charger_current,
    uint8_t health_signals_battery_current,
    uint8_t health_signals_sign_battery_current,
    uint8_t health_code
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_lv_health_signals_raw_to_conversion_struct(
    primary_lv_health_signals_converted_t *conversion, 
    const primary_lv_health_signals_t *raw);


void primary_lv_health_signals_conversion_to_raw_struct(
    primary_lv_health_signals_t *raw,
    const primary_lv_health_signals_converted_t *conversion);


int primary_lv_health_signals_to_string(primary_lv_health_signals_t *message, char *buffer);

int primary_lv_health_signals_to_string_file(primary_lv_health_signals_t *message, FILE *buffer);

int primary_lv_health_signals_fields(char *buffer);

int primary_lv_health_signals_fields_file(FILE *buffer);

/**
 * Pack message LV_HEALTH_SIGNALS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_lv_health_signals_pack(
    uint8_t *dst_p,
    const primary_lv_health_signals_t *src_p,
    size_t byte_size);

/**
 * Unpack message LV_HEALTH_SIGNALS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_lv_health_signals_unpack(
    primary_lv_health_signals_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_health_signals_health_signals_lvms_out_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_health_signals_health_signals_relay_out_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_health_signals_health_signals_battery_voltage_out_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_health_signals_health_signals_charger_current_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_health_signals_health_signals_battery_current_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_health_signals_health_signals_sign_battery_current_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_health_signals_health_code_is_in_range(uint8_t value);


void primary_lv_feedbacks_raw_to_conversion(
    primary_lv_feedbacks_converted_t *conversion,
    uint8_t feedbacks_bspd_fb,
    uint8_t feedbacks_hvd_fb,
    uint8_t feedbacks_lvms_fb,
    uint8_t feedbacks_res_fb,
    uint8_t feedbacks_lv_encl,
    uint8_t feedbacks_invc_lid_fb,
    uint8_t feedbacks_hv_encl_2_fb,
    uint8_t feedbacks_back_plate_fb,
    uint8_t feedbacks_invc_interlock_fb,
    uint8_t feedbacks_ams_fb,
    uint8_t feedbacks_asms_fb,
    uint8_t feedbacks_interlock_fb,
    uint8_t feedbacks_inverters_fb,
    uint8_t feedbacks_pcbs_fb,
    uint8_t feedbacks_pumps_fb,
    uint8_t feedbacks_shutdown_fb,
    uint8_t feedbacks_radiators_fb,
    uint8_t feedbacks_fan_fb,
    uint8_t feedbacks_as_actuation_fb,
    float sd_start,
    float sd_end
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_lv_feedbacks_conversion_to_raw(
    primary_lv_feedbacks_t *raw,
    uint8_t feedbacks_bspd_fb,
    uint8_t feedbacks_hvd_fb,
    uint8_t feedbacks_lvms_fb,
    uint8_t feedbacks_res_fb,
    uint8_t feedbacks_lv_encl,
    uint8_t feedbacks_invc_lid_fb,
    uint8_t feedbacks_hv_encl_2_fb,
    uint8_t feedbacks_back_plate_fb,
    uint8_t feedbacks_invc_interlock_fb,
    uint8_t feedbacks_ams_fb,
    uint8_t feedbacks_asms_fb,
    uint8_t feedbacks_interlock_fb,
    uint8_t feedbacks_inverters_fb,
    uint8_t feedbacks_pcbs_fb,
    uint8_t feedbacks_pumps_fb,
    uint8_t feedbacks_shutdown_fb,
    uint8_t feedbacks_radiators_fb,
    uint8_t feedbacks_fan_fb,
    uint8_t feedbacks_as_actuation_fb,
    float sd_start,
    float sd_end
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_lv_feedbacks_raw_to_conversion_struct(
    primary_lv_feedbacks_converted_t *conversion, 
    const primary_lv_feedbacks_t *raw);


void primary_lv_feedbacks_conversion_to_raw_struct(
    primary_lv_feedbacks_t *raw,
    const primary_lv_feedbacks_converted_t *conversion);


int primary_lv_feedbacks_converted_to_string(primary_lv_feedbacks_converted_t *message, char *buffer);

int primary_lv_feedbacks_converted_to_string_file(primary_lv_feedbacks_converted_t *message, FILE *buffer);

int primary_lv_feedbacks_fields(char *buffer);

int primary_lv_feedbacks_fields_file(FILE *buffer);

/**
 * Pack message LV_FEEDBACKS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_lv_feedbacks_pack(
    uint8_t *dst_p,
    const primary_lv_feedbacks_t *src_p,
    size_t byte_size);

/**
 * Unpack message LV_FEEDBACKS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_lv_feedbacks_unpack(
    primary_lv_feedbacks_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_feedbacks_feedbacks_bspd_fb_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_feedbacks_feedbacks_hvd_fb_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_feedbacks_feedbacks_lvms_fb_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_feedbacks_feedbacks_res_fb_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_feedbacks_feedbacks_lv_encl_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_feedbacks_feedbacks_invc_lid_fb_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_feedbacks_feedbacks_hv_encl_2_fb_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_feedbacks_feedbacks_back_plate_fb_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_feedbacks_feedbacks_invc_interlock_fb_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_feedbacks_feedbacks_ams_fb_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_feedbacks_feedbacks_asms_fb_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_feedbacks_feedbacks_interlock_fb_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_feedbacks_feedbacks_inverters_fb_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_feedbacks_feedbacks_pcbs_fb_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_feedbacks_feedbacks_pumps_fb_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_feedbacks_feedbacks_shutdown_fb_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_feedbacks_feedbacks_radiators_fb_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_feedbacks_feedbacks_fan_fb_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_feedbacks_feedbacks_as_actuation_fb_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_lv_feedbacks_sd_start_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_lv_feedbacks_sd_start_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_feedbacks_sd_start_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_lv_feedbacks_sd_end_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_lv_feedbacks_sd_end_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_feedbacks_sd_end_is_in_range(uint16_t value);


void primary_shutdown_status_raw_to_conversion(
    primary_shutdown_status_converted_t *conversion,
    uint8_t input,
    uint8_t output
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_shutdown_status_conversion_to_raw(
    primary_shutdown_status_t *raw,
    uint8_t input,
    uint8_t output
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_shutdown_status_raw_to_conversion_struct(
    primary_shutdown_status_converted_t *conversion, 
    const primary_shutdown_status_t *raw);


void primary_shutdown_status_conversion_to_raw_struct(
    primary_shutdown_status_t *raw,
    const primary_shutdown_status_converted_t *conversion);


int primary_shutdown_status_to_string(primary_shutdown_status_t *message, char *buffer);

int primary_shutdown_status_to_string_file(primary_shutdown_status_t *message, FILE *buffer);

int primary_shutdown_status_fields(char *buffer);

int primary_shutdown_status_fields_file(FILE *buffer);

/**
 * Pack message SHUTDOWN_STATUS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_shutdown_status_pack(
    uint8_t *dst_p,
    const primary_shutdown_status_t *src_p,
    size_t byte_size);

/**
 * Unpack message SHUTDOWN_STATUS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_shutdown_status_unpack(
    primary_shutdown_status_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_shutdown_status_input_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_shutdown_status_output_is_in_range(uint8_t value);


;


;


void primary_lv_can_flash_req_raw_to_conversion_struct(
    primary_lv_can_flash_req_converted_t *conversion, 
    const primary_lv_can_flash_req_t *raw);


void primary_lv_can_flash_req_conversion_to_raw_struct(
    primary_lv_can_flash_req_t *raw,
    const primary_lv_can_flash_req_converted_t *conversion);


int primary_lv_can_flash_req_to_string(primary_lv_can_flash_req_t *message, char *buffer);

int primary_lv_can_flash_req_to_string_file(primary_lv_can_flash_req_t *message, FILE *buffer);

int primary_lv_can_flash_req_fields(char *buffer);

int primary_lv_can_flash_req_fields_file(FILE *buffer);

/**
 * Pack message LV_CAN_FLASH_REQ.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_lv_can_flash_req_pack(
    uint8_t *dst_p,
    const primary_lv_can_flash_req_t *src_p,
    size_t byte_size);

/**
 * Unpack message LV_CAN_FLASH_REQ.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_lv_can_flash_req_unpack(
    primary_lv_can_flash_req_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


void primary_lv_can_flash_ack_raw_to_conversion(
    primary_lv_can_flash_ack_converted_t *conversion,
    primary_lv_can_flash_ack_response response
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_lv_can_flash_ack_conversion_to_raw(
    primary_lv_can_flash_ack_t *raw,
    primary_lv_can_flash_ack_response response
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_lv_can_flash_ack_raw_to_conversion_struct(
    primary_lv_can_flash_ack_converted_t *conversion, 
    const primary_lv_can_flash_ack_t *raw);


void primary_lv_can_flash_ack_conversion_to_raw_struct(
    primary_lv_can_flash_ack_t *raw,
    const primary_lv_can_flash_ack_converted_t *conversion);

int primary_lv_can_flash_ack_response_enum_to_string(primary_lv_can_flash_ack_response value, char *buffer);

int primary_lv_can_flash_ack_to_string(primary_lv_can_flash_ack_t *message, char *buffer);

int primary_lv_can_flash_ack_to_string_file(primary_lv_can_flash_ack_t *message, FILE *buffer);

int primary_lv_can_flash_ack_fields(char *buffer);

int primary_lv_can_flash_ack_fields_file(FILE *buffer);

/**
 * Pack message LV_CAN_FLASH_ACK.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_lv_can_flash_ack_pack(
    uint8_t *dst_p,
    const primary_lv_can_flash_ack_t *src_p,
    size_t byte_size);

/**
 * Unpack message LV_CAN_FLASH_ACK.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_lv_can_flash_ack_unpack(
    primary_lv_can_flash_ack_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_can_flash_ack_response_is_in_range(uint8_t value);


;


;


void primary_marker_raw_to_conversion_struct(
    primary_marker_converted_t *conversion, 
    const primary_marker_t *raw);


void primary_marker_conversion_to_raw_struct(
    primary_marker_t *raw,
    const primary_marker_converted_t *conversion);


int primary_marker_to_string(primary_marker_t *message, char *buffer);

int primary_marker_to_string_file(primary_marker_t *message, FILE *buffer);

int primary_marker_fields(char *buffer);

int primary_marker_fields_file(FILE *buffer);

/**
 * Pack message MARKER.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_marker_pack(
    uint8_t *dst_p,
    const primary_marker_t *src_p,
    size_t byte_size);

/**
 * Unpack message MARKER.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_marker_unpack(
    primary_marker_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


void primary_hv_cells_voltage_raw_to_conversion(
    primary_hv_cells_voltage_converted_t *conversion,
    uint8_t start_index,
    float voltage_0,
    float voltage_1,
    float voltage_2
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_hv_cells_voltage_conversion_to_raw(
    primary_hv_cells_voltage_t *raw,
    uint8_t start_index,
    float voltage_0,
    float voltage_1,
    float voltage_2
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_hv_cells_voltage_raw_to_conversion_struct(
    primary_hv_cells_voltage_converted_t *conversion, 
    const primary_hv_cells_voltage_t *raw);


void primary_hv_cells_voltage_conversion_to_raw_struct(
    primary_hv_cells_voltage_t *raw,
    const primary_hv_cells_voltage_converted_t *conversion);


int primary_hv_cells_voltage_converted_to_string(primary_hv_cells_voltage_converted_t *message, char *buffer);

int primary_hv_cells_voltage_converted_to_string_file(primary_hv_cells_voltage_converted_t *message, FILE *buffer);

int primary_hv_cells_voltage_fields(char *buffer);

int primary_hv_cells_voltage_fields_file(FILE *buffer);

/**
 * Pack message HV_CELLS_VOLTAGE.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_hv_cells_voltage_pack(
    uint8_t *dst_p,
    const primary_hv_cells_voltage_t *src_p,
    size_t byte_size);

/**
 * Unpack message HV_CELLS_VOLTAGE.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_hv_cells_voltage_unpack(
    primary_hv_cells_voltage_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_cells_voltage_start_index_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_hv_cells_voltage_voltage_0_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_hv_cells_voltage_voltage_0_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_cells_voltage_voltage_0_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_hv_cells_voltage_voltage_1_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_hv_cells_voltage_voltage_1_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_cells_voltage_voltage_1_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_hv_cells_voltage_voltage_2_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_hv_cells_voltage_voltage_2_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_cells_voltage_voltage_2_is_in_range(uint16_t value);


void primary_hv_cells_temp_raw_to_conversion(
    primary_hv_cells_temp_converted_t *conversion,
    uint8_t start_index,
    float temp_0,
    float temp_1,
    float temp_2,
    float temp_3
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_hv_cells_temp_conversion_to_raw(
    primary_hv_cells_temp_t *raw,
    uint8_t start_index,
    float temp_0,
    float temp_1,
    float temp_2,
    float temp_3
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_hv_cells_temp_raw_to_conversion_struct(
    primary_hv_cells_temp_converted_t *conversion, 
    const primary_hv_cells_temp_t *raw);


void primary_hv_cells_temp_conversion_to_raw_struct(
    primary_hv_cells_temp_t *raw,
    const primary_hv_cells_temp_converted_t *conversion);


int primary_hv_cells_temp_converted_to_string(primary_hv_cells_temp_converted_t *message, char *buffer);

int primary_hv_cells_temp_converted_to_string_file(primary_hv_cells_temp_converted_t *message, FILE *buffer);

int primary_hv_cells_temp_fields(char *buffer);

int primary_hv_cells_temp_fields_file(FILE *buffer);

/**
 * Pack message HV_CELLS_TEMP.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_hv_cells_temp_pack(
    uint8_t *dst_p,
    const primary_hv_cells_temp_t *src_p,
    size_t byte_size);

/**
 * Unpack message HV_CELLS_TEMP.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_hv_cells_temp_unpack(
    primary_hv_cells_temp_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_cells_temp_start_index_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t primary_hv_cells_temp_temp_0_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_hv_cells_temp_temp_0_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_cells_temp_temp_0_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t primary_hv_cells_temp_temp_1_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_hv_cells_temp_temp_1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_cells_temp_temp_1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t primary_hv_cells_temp_temp_2_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_hv_cells_temp_temp_2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_cells_temp_temp_2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t primary_hv_cells_temp_temp_3_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_hv_cells_temp_temp_3_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_cells_temp_temp_3_is_in_range(uint8_t value);


void primary_hv_cell_balancing_status_raw_to_conversion(
    primary_hv_cell_balancing_status_converted_t *conversion,
    primary_hv_cell_balancing_status_cellboard_id cellboard_id,
    primary_hv_cell_balancing_status_balancing_status balancing_status,
    uint8_t errors_can_comm,
    uint8_t errors_ltc_comm,
    uint8_t errors_temp_comm_0,
    uint8_t errors_temp_comm_1,
    uint8_t errors_temp_comm_2,
    uint8_t errors_temp_comm_3,
    uint8_t errors_temp_comm_4,
    uint8_t errors_temp_comm_5,
    uint8_t errors_open_wire,
    uint8_t balancing_cells_cell0,
    uint8_t balancing_cells_cell1,
    uint8_t balancing_cells_cell2,
    uint8_t balancing_cells_cell3,
    uint8_t balancing_cells_cell4,
    uint8_t balancing_cells_cell5,
    uint8_t balancing_cells_cell6,
    uint8_t balancing_cells_cell7,
    uint8_t balancing_cells_cell8,
    uint8_t balancing_cells_cell9,
    uint8_t balancing_cells_cell10,
    uint8_t balancing_cells_cell11,
    uint8_t balancing_cells_cell12,
    uint8_t balancing_cells_cell13,
    uint8_t balancing_cells_cell14,
    uint8_t balancing_cells_cell15,
    uint8_t balancing_cells_cell16,
    uint8_t balancing_cells_cell17
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_hv_cell_balancing_status_conversion_to_raw(
    primary_hv_cell_balancing_status_t *raw,
    primary_hv_cell_balancing_status_cellboard_id cellboard_id,
    primary_hv_cell_balancing_status_balancing_status balancing_status,
    uint8_t errors_can_comm,
    uint8_t errors_ltc_comm,
    uint8_t errors_temp_comm_0,
    uint8_t errors_temp_comm_1,
    uint8_t errors_temp_comm_2,
    uint8_t errors_temp_comm_3,
    uint8_t errors_temp_comm_4,
    uint8_t errors_temp_comm_5,
    uint8_t errors_open_wire,
    uint8_t balancing_cells_cell0,
    uint8_t balancing_cells_cell1,
    uint8_t balancing_cells_cell2,
    uint8_t balancing_cells_cell3,
    uint8_t balancing_cells_cell4,
    uint8_t balancing_cells_cell5,
    uint8_t balancing_cells_cell6,
    uint8_t balancing_cells_cell7,
    uint8_t balancing_cells_cell8,
    uint8_t balancing_cells_cell9,
    uint8_t balancing_cells_cell10,
    uint8_t balancing_cells_cell11,
    uint8_t balancing_cells_cell12,
    uint8_t balancing_cells_cell13,
    uint8_t balancing_cells_cell14,
    uint8_t balancing_cells_cell15,
    uint8_t balancing_cells_cell16,
    uint8_t balancing_cells_cell17
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_hv_cell_balancing_status_raw_to_conversion_struct(
    primary_hv_cell_balancing_status_converted_t *conversion, 
    const primary_hv_cell_balancing_status_t *raw);


void primary_hv_cell_balancing_status_conversion_to_raw_struct(
    primary_hv_cell_balancing_status_t *raw,
    const primary_hv_cell_balancing_status_converted_t *conversion);

int primary_hv_cell_balancing_status_cellboard_id_enum_to_string(primary_hv_cell_balancing_status_cellboard_id value, char *buffer);
int primary_hv_cell_balancing_status_balancing_status_enum_to_string(primary_hv_cell_balancing_status_balancing_status value, char *buffer);

int primary_hv_cell_balancing_status_to_string(primary_hv_cell_balancing_status_t *message, char *buffer);

int primary_hv_cell_balancing_status_to_string_file(primary_hv_cell_balancing_status_t *message, FILE *buffer);

int primary_hv_cell_balancing_status_fields(char *buffer);

int primary_hv_cell_balancing_status_fields_file(FILE *buffer);

/**
 * Pack message HV_CELL_BALANCING_STATUS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_hv_cell_balancing_status_pack(
    uint8_t *dst_p,
    const primary_hv_cell_balancing_status_t *src_p,
    size_t byte_size);

/**
 * Unpack message HV_CELL_BALANCING_STATUS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_hv_cell_balancing_status_unpack(
    primary_hv_cell_balancing_status_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_cell_balancing_status_cellboard_id_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_cell_balancing_status_balancing_status_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_cell_balancing_status_errors_can_comm_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_cell_balancing_status_errors_ltc_comm_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_cell_balancing_status_errors_temp_comm_0_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_cell_balancing_status_errors_temp_comm_1_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_cell_balancing_status_errors_temp_comm_2_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_cell_balancing_status_errors_temp_comm_3_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_cell_balancing_status_errors_temp_comm_4_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_cell_balancing_status_errors_temp_comm_5_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_cell_balancing_status_errors_open_wire_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_cell_balancing_status_balancing_cells_cell0_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_cell_balancing_status_balancing_cells_cell1_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_cell_balancing_status_balancing_cells_cell2_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_cell_balancing_status_balancing_cells_cell3_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_cell_balancing_status_balancing_cells_cell4_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_cell_balancing_status_balancing_cells_cell5_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_cell_balancing_status_balancing_cells_cell6_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_cell_balancing_status_balancing_cells_cell7_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_cell_balancing_status_balancing_cells_cell8_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_cell_balancing_status_balancing_cells_cell9_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_cell_balancing_status_balancing_cells_cell10_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_cell_balancing_status_balancing_cells_cell11_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_cell_balancing_status_balancing_cells_cell12_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_cell_balancing_status_balancing_cells_cell13_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_cell_balancing_status_balancing_cells_cell14_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_cell_balancing_status_balancing_cells_cell15_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_cell_balancing_status_balancing_cells_cell16_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_cell_balancing_status_balancing_cells_cell17_is_in_range(uint8_t value);


void primary_set_cell_balancing_status_raw_to_conversion(
    primary_set_cell_balancing_status_converted_t *conversion,
    primary_set_cell_balancing_status_set_balancing_status set_balancing_status
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_set_cell_balancing_status_conversion_to_raw(
    primary_set_cell_balancing_status_t *raw,
    primary_set_cell_balancing_status_set_balancing_status set_balancing_status
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_set_cell_balancing_status_raw_to_conversion_struct(
    primary_set_cell_balancing_status_converted_t *conversion, 
    const primary_set_cell_balancing_status_t *raw);


void primary_set_cell_balancing_status_conversion_to_raw_struct(
    primary_set_cell_balancing_status_t *raw,
    const primary_set_cell_balancing_status_converted_t *conversion);

int primary_set_cell_balancing_status_set_balancing_status_enum_to_string(primary_set_cell_balancing_status_set_balancing_status value, char *buffer);

int primary_set_cell_balancing_status_to_string(primary_set_cell_balancing_status_t *message, char *buffer);

int primary_set_cell_balancing_status_to_string_file(primary_set_cell_balancing_status_t *message, FILE *buffer);

int primary_set_cell_balancing_status_fields(char *buffer);

int primary_set_cell_balancing_status_fields_file(FILE *buffer);

/**
 * Pack message SET_CELL_BALANCING_STATUS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_set_cell_balancing_status_pack(
    uint8_t *dst_p,
    const primary_set_cell_balancing_status_t *src_p,
    size_t byte_size);

/**
 * Unpack message SET_CELL_BALANCING_STATUS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_set_cell_balancing_status_unpack(
    primary_set_cell_balancing_status_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_set_cell_balancing_status_set_balancing_status_is_in_range(uint8_t value);


void primary_speed_raw_to_conversion(
    primary_speed_converted_t *conversion,
    float encoder_r,
    float encoder_l,
    float inverter_r,
    float inverter_l
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_speed_conversion_to_raw(
    primary_speed_t *raw,
    float encoder_r,
    float encoder_l,
    float inverter_r,
    float inverter_l
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_speed_raw_to_conversion_struct(
    primary_speed_converted_t *conversion, 
    const primary_speed_t *raw);


void primary_speed_conversion_to_raw_struct(
    primary_speed_t *raw,
    const primary_speed_converted_t *conversion);


int primary_speed_converted_to_string(primary_speed_converted_t *message, char *buffer);

int primary_speed_converted_to_string_file(primary_speed_converted_t *message, FILE *buffer);

int primary_speed_fields(char *buffer);

int primary_speed_fields_file(FILE *buffer);

/**
 * Pack message SPEED.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_speed_pack(
    uint8_t *dst_p,
    const primary_speed_t *src_p,
    size_t byte_size);

/**
 * Unpack message SPEED.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_speed_unpack(
    primary_speed_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_speed_encoder_r_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_speed_encoder_r_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_speed_encoder_r_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_speed_encoder_l_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_speed_encoder_l_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_speed_encoder_l_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_speed_inverter_r_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_speed_inverter_r_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_speed_inverter_r_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_speed_inverter_l_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_speed_inverter_l_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_speed_inverter_l_is_in_range(uint16_t value);


void primary_inv_l_request_raw_to_conversion(
    primary_inv_l_request_converted_t *conversion,
    uint8_t data_0,
    uint8_t data_1,
    uint8_t data_2,
    uint8_t data_3,
    uint8_t data_4,
    uint8_t data_5,
    uint8_t data_6,
    uint8_t data_7
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_inv_l_request_conversion_to_raw(
    primary_inv_l_request_t *raw,
    uint8_t data_0,
    uint8_t data_1,
    uint8_t data_2,
    uint8_t data_3,
    uint8_t data_4,
    uint8_t data_5,
    uint8_t data_6,
    uint8_t data_7
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_inv_l_request_raw_to_conversion_struct(
    primary_inv_l_request_converted_t *conversion, 
    const primary_inv_l_request_t *raw);


void primary_inv_l_request_conversion_to_raw_struct(
    primary_inv_l_request_t *raw,
    const primary_inv_l_request_converted_t *conversion);


int primary_inv_l_request_to_string(primary_inv_l_request_t *message, char *buffer);

int primary_inv_l_request_to_string_file(primary_inv_l_request_t *message, FILE *buffer);

int primary_inv_l_request_fields(char *buffer);

int primary_inv_l_request_fields_file(FILE *buffer);

/**
 * Pack message INV_L_REQUEST.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_inv_l_request_pack(
    uint8_t *dst_p,
    const primary_inv_l_request_t *src_p,
    size_t byte_size);

/**
 * Unpack message INV_L_REQUEST.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_inv_l_request_unpack(
    primary_inv_l_request_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inv_l_request_data_0_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inv_l_request_data_1_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inv_l_request_data_2_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inv_l_request_data_3_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inv_l_request_data_4_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inv_l_request_data_5_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inv_l_request_data_6_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inv_l_request_data_7_is_in_range(uint8_t value);


void primary_inv_r_request_raw_to_conversion(
    primary_inv_r_request_converted_t *conversion,
    uint8_t data_0,
    uint8_t data_1,
    uint8_t data_2,
    uint8_t data_3,
    uint8_t data_4,
    uint8_t data_5,
    uint8_t data_6,
    uint8_t data_7
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_inv_r_request_conversion_to_raw(
    primary_inv_r_request_t *raw,
    uint8_t data_0,
    uint8_t data_1,
    uint8_t data_2,
    uint8_t data_3,
    uint8_t data_4,
    uint8_t data_5,
    uint8_t data_6,
    uint8_t data_7
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_inv_r_request_raw_to_conversion_struct(
    primary_inv_r_request_converted_t *conversion, 
    const primary_inv_r_request_t *raw);


void primary_inv_r_request_conversion_to_raw_struct(
    primary_inv_r_request_t *raw,
    const primary_inv_r_request_converted_t *conversion);


int primary_inv_r_request_to_string(primary_inv_r_request_t *message, char *buffer);

int primary_inv_r_request_to_string_file(primary_inv_r_request_t *message, FILE *buffer);

int primary_inv_r_request_fields(char *buffer);

int primary_inv_r_request_fields_file(FILE *buffer);

/**
 * Pack message INV_R_REQUEST.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_inv_r_request_pack(
    uint8_t *dst_p,
    const primary_inv_r_request_t *src_p,
    size_t byte_size);

/**
 * Unpack message INV_R_REQUEST.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_inv_r_request_unpack(
    primary_inv_r_request_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inv_r_request_data_0_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inv_r_request_data_1_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inv_r_request_data_2_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inv_r_request_data_3_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inv_r_request_data_4_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inv_r_request_data_5_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inv_r_request_data_6_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inv_r_request_data_7_is_in_range(uint8_t value);


void primary_inv_l_response_raw_to_conversion(
    primary_inv_l_response_converted_t *conversion,
    uint8_t reg_id,
    uint8_t data_0,
    uint8_t data_1,
    uint8_t data_2,
    uint8_t data_3,
    uint8_t data_4,
    uint8_t data_5,
    uint8_t data_6
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_inv_l_response_conversion_to_raw(
    primary_inv_l_response_t *raw,
    uint8_t reg_id,
    uint8_t data_0,
    uint8_t data_1,
    uint8_t data_2,
    uint8_t data_3,
    uint8_t data_4,
    uint8_t data_5,
    uint8_t data_6
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_inv_l_response_raw_to_conversion_struct(
    primary_inv_l_response_converted_t *conversion, 
    const primary_inv_l_response_t *raw);


void primary_inv_l_response_conversion_to_raw_struct(
    primary_inv_l_response_t *raw,
    const primary_inv_l_response_converted_t *conversion);


int primary_inv_l_response_to_string(primary_inv_l_response_t *message, char *buffer);

int primary_inv_l_response_to_string_file(primary_inv_l_response_t *message, FILE *buffer);

int primary_inv_l_response_fields(char *buffer);

int primary_inv_l_response_fields_file(FILE *buffer);

/**
 * Pack message INV_L_RESPONSE.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_inv_l_response_pack(
    uint8_t *dst_p,
    const primary_inv_l_response_t *src_p,
    size_t byte_size);

/**
 * Unpack message INV_L_RESPONSE.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_inv_l_response_unpack(
    primary_inv_l_response_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inv_l_response_reg_id_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inv_l_response_data_0_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inv_l_response_data_1_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inv_l_response_data_2_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inv_l_response_data_3_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inv_l_response_data_4_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inv_l_response_data_5_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inv_l_response_data_6_is_in_range(uint8_t value);


void primary_inv_r_response_raw_to_conversion(
    primary_inv_r_response_converted_t *conversion,
    uint8_t reg_id,
    uint8_t data_0,
    uint8_t data_1,
    uint8_t data_2,
    uint8_t data_3,
    uint8_t data_4,
    uint8_t data_5,
    uint8_t data_6
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_inv_r_response_conversion_to_raw(
    primary_inv_r_response_t *raw,
    uint8_t reg_id,
    uint8_t data_0,
    uint8_t data_1,
    uint8_t data_2,
    uint8_t data_3,
    uint8_t data_4,
    uint8_t data_5,
    uint8_t data_6
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_inv_r_response_raw_to_conversion_struct(
    primary_inv_r_response_converted_t *conversion, 
    const primary_inv_r_response_t *raw);


void primary_inv_r_response_conversion_to_raw_struct(
    primary_inv_r_response_t *raw,
    const primary_inv_r_response_converted_t *conversion);


int primary_inv_r_response_to_string(primary_inv_r_response_t *message, char *buffer);

int primary_inv_r_response_to_string_file(primary_inv_r_response_t *message, FILE *buffer);

int primary_inv_r_response_fields(char *buffer);

int primary_inv_r_response_fields_file(FILE *buffer);

/**
 * Pack message INV_R_RESPONSE.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_inv_r_response_pack(
    uint8_t *dst_p,
    const primary_inv_r_response_t *src_p,
    size_t byte_size);

/**
 * Unpack message INV_R_RESPONSE.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_inv_r_response_unpack(
    primary_inv_r_response_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inv_r_response_reg_id_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inv_r_response_data_0_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inv_r_response_data_1_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inv_r_response_data_2_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inv_r_response_data_3_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inv_r_response_data_4_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inv_r_response_data_5_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inv_r_response_data_6_is_in_range(uint8_t value);


void primary_control_output_raw_to_conversion(
    primary_control_output_converted_t *conversion,
    float estimated_velocity,
    float tmax_r,
    float tmax_l,
    float torque_l,
    float torque_r
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_control_output_conversion_to_raw(
    primary_control_output_t *raw,
    float estimated_velocity,
    float tmax_r,
    float tmax_l,
    float torque_l,
    float torque_r
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_control_output_raw_to_conversion_struct(
    primary_control_output_converted_t *conversion, 
    const primary_control_output_t *raw);


void primary_control_output_conversion_to_raw_struct(
    primary_control_output_t *raw,
    const primary_control_output_converted_t *conversion);


int primary_control_output_converted_to_string(primary_control_output_converted_t *message, char *buffer);

int primary_control_output_converted_to_string_file(primary_control_output_converted_t *message, FILE *buffer);

int primary_control_output_fields(char *buffer);

int primary_control_output_fields_file(FILE *buffer);

/**
 * Pack message CONTROL_OUTPUT.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_control_output_pack(
    uint8_t *dst_p,
    const primary_control_output_t *src_p,
    size_t byte_size);

/**
 * Unpack message CONTROL_OUTPUT.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_control_output_unpack(
    primary_control_output_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_control_output_estimated_velocity_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_control_output_estimated_velocity_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_control_output_estimated_velocity_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t primary_control_output_tmax_r_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_control_output_tmax_r_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_control_output_tmax_r_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t primary_control_output_tmax_l_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_control_output_tmax_l_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_control_output_tmax_l_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_control_output_torque_l_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_control_output_torque_l_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_control_output_torque_l_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_control_output_torque_r_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_control_output_torque_r_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_control_output_torque_r_is_in_range(uint16_t value);


;


;


void primary_lc_reset_raw_to_conversion_struct(
    primary_lc_reset_converted_t *conversion, 
    const primary_lc_reset_t *raw);


void primary_lc_reset_conversion_to_raw_struct(
    primary_lc_reset_t *raw,
    const primary_lc_reset_converted_t *conversion);


int primary_lc_reset_to_string(primary_lc_reset_t *message, char *buffer);

int primary_lc_reset_to_string_file(primary_lc_reset_t *message, FILE *buffer);

int primary_lc_reset_fields(char *buffer);

int primary_lc_reset_fields_file(FILE *buffer);

/**
 * Pack message LC_RESET.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_lc_reset_pack(
    uint8_t *dst_p,
    const primary_lc_reset_t *src_p,
    size_t byte_size);

/**
 * Unpack message LC_RESET.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_lc_reset_unpack(
    primary_lc_reset_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


void primary_handcart_status_raw_to_conversion(
    primary_handcart_status_converted_t *conversion,
    uint8_t connected
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_handcart_status_conversion_to_raw(
    primary_handcart_status_t *raw,
    uint8_t connected
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_handcart_status_raw_to_conversion_struct(
    primary_handcart_status_converted_t *conversion, 
    const primary_handcart_status_t *raw);


void primary_handcart_status_conversion_to_raw_struct(
    primary_handcart_status_t *raw,
    const primary_handcart_status_converted_t *conversion);


int primary_handcart_status_to_string(primary_handcart_status_t *message, char *buffer);

int primary_handcart_status_to_string_file(primary_handcart_status_t *message, FILE *buffer);

int primary_handcart_status_fields(char *buffer);

int primary_handcart_status_fields_file(FILE *buffer);

/**
 * Pack message HANDCART_STATUS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_handcart_status_pack(
    uint8_t *dst_p,
    const primary_handcart_status_t *src_p,
    size_t byte_size);

/**
 * Unpack message HANDCART_STATUS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_handcart_status_unpack(
    primary_handcart_status_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_handcart_status_connected_is_in_range(uint8_t value);


void primary_handcart_settings_raw_to_conversion(
    primary_handcart_settings_converted_t *conversion,
    float target_voltage,
    primary_handcart_settings_fans_override fans_override,
    float fans_speed,
    float acc_charge_current,
    float grid_max_current,
    primary_handcart_settings_status status
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_handcart_settings_conversion_to_raw(
    primary_handcart_settings_t *raw,
    float target_voltage,
    primary_handcart_settings_fans_override fans_override,
    float fans_speed,
    float acc_charge_current,
    float grid_max_current,
    primary_handcart_settings_status status
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_handcart_settings_raw_to_conversion_struct(
    primary_handcart_settings_converted_t *conversion, 
    const primary_handcart_settings_t *raw);


void primary_handcart_settings_conversion_to_raw_struct(
    primary_handcart_settings_t *raw,
    const primary_handcart_settings_converted_t *conversion);

int primary_handcart_settings_fans_override_enum_to_string(primary_handcart_settings_fans_override value, char *buffer);
int primary_handcart_settings_status_enum_to_string(primary_handcart_settings_status value, char *buffer);

int primary_handcart_settings_converted_to_string(primary_handcart_settings_converted_t *message, char *buffer);

int primary_handcart_settings_converted_to_string_file(primary_handcart_settings_converted_t *message, FILE *buffer);

int primary_handcart_settings_fields(char *buffer);

int primary_handcart_settings_fields_file(FILE *buffer);

/**
 * Pack message HANDCART_SETTINGS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_handcart_settings_pack(
    uint8_t *dst_p,
    const primary_handcart_settings_t *src_p,
    size_t byte_size);

/**
 * Unpack message HANDCART_SETTINGS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_handcart_settings_unpack(
    primary_handcart_settings_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t primary_handcart_settings_target_voltage_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_handcart_settings_target_voltage_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_handcart_settings_target_voltage_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_handcart_settings_fans_override_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t primary_handcart_settings_fans_speed_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_handcart_settings_fans_speed_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_handcart_settings_fans_speed_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t primary_handcart_settings_acc_charge_current_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_handcart_settings_acc_charge_current_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_handcart_settings_acc_charge_current_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t primary_handcart_settings_grid_max_current_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_handcart_settings_grid_max_current_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_handcart_settings_grid_max_current_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_handcart_settings_status_is_in_range(uint8_t value);


void primary_handcart_settings_set_raw_to_conversion(
    primary_handcart_settings_set_converted_t *conversion,
    float target_voltage,
    primary_handcart_settings_set_fans_override fans_override,
    float fans_speed,
    float acc_charge_current,
    float grid_max_current,
    primary_handcart_settings_set_status status
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_handcart_settings_set_conversion_to_raw(
    primary_handcart_settings_set_t *raw,
    float target_voltage,
    primary_handcart_settings_set_fans_override fans_override,
    float fans_speed,
    float acc_charge_current,
    float grid_max_current,
    primary_handcart_settings_set_status status
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_handcart_settings_set_raw_to_conversion_struct(
    primary_handcart_settings_set_converted_t *conversion, 
    const primary_handcart_settings_set_t *raw);


void primary_handcart_settings_set_conversion_to_raw_struct(
    primary_handcart_settings_set_t *raw,
    const primary_handcart_settings_set_converted_t *conversion);

int primary_handcart_settings_set_fans_override_enum_to_string(primary_handcart_settings_set_fans_override value, char *buffer);
int primary_handcart_settings_set_status_enum_to_string(primary_handcart_settings_set_status value, char *buffer);

int primary_handcart_settings_set_converted_to_string(primary_handcart_settings_set_converted_t *message, char *buffer);

int primary_handcart_settings_set_converted_to_string_file(primary_handcart_settings_set_converted_t *message, FILE *buffer);

int primary_handcart_settings_set_fields(char *buffer);

int primary_handcart_settings_set_fields_file(FILE *buffer);

/**
 * Pack message HANDCART_SETTINGS_SET.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_handcart_settings_set_pack(
    uint8_t *dst_p,
    const primary_handcart_settings_set_t *src_p,
    size_t byte_size);

/**
 * Unpack message HANDCART_SETTINGS_SET.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_handcart_settings_set_unpack(
    primary_handcart_settings_set_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t primary_handcart_settings_set_target_voltage_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_handcart_settings_set_target_voltage_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_handcart_settings_set_target_voltage_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_handcart_settings_set_fans_override_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t primary_handcart_settings_set_fans_speed_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_handcart_settings_set_fans_speed_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_handcart_settings_set_fans_speed_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t primary_handcart_settings_set_acc_charge_current_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_handcart_settings_set_acc_charge_current_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_handcart_settings_set_acc_charge_current_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t primary_handcart_settings_set_grid_max_current_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_handcart_settings_set_grid_max_current_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_handcart_settings_set_grid_max_current_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_handcart_settings_set_status_is_in_range(uint8_t value);


void primary_set_ptt_status_raw_to_conversion(
    primary_set_ptt_status_converted_t *conversion,
    primary_set_ptt_status_status status
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_set_ptt_status_conversion_to_raw(
    primary_set_ptt_status_t *raw,
    primary_set_ptt_status_status status
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_set_ptt_status_raw_to_conversion_struct(
    primary_set_ptt_status_converted_t *conversion, 
    const primary_set_ptt_status_t *raw);


void primary_set_ptt_status_conversion_to_raw_struct(
    primary_set_ptt_status_t *raw,
    const primary_set_ptt_status_converted_t *conversion);

int primary_set_ptt_status_status_enum_to_string(primary_set_ptt_status_status value, char *buffer);

int primary_set_ptt_status_to_string(primary_set_ptt_status_t *message, char *buffer);

int primary_set_ptt_status_to_string_file(primary_set_ptt_status_t *message, FILE *buffer);

int primary_set_ptt_status_fields(char *buffer);

int primary_set_ptt_status_fields_file(FILE *buffer);

/**
 * Pack message SET_PTT_STATUS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_set_ptt_status_pack(
    uint8_t *dst_p,
    const primary_set_ptt_status_t *src_p,
    size_t byte_size);

/**
 * Unpack message SET_PTT_STATUS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_set_ptt_status_unpack(
    primary_set_ptt_status_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_set_ptt_status_status_is_in_range(uint8_t value);


void primary_ptt_status_raw_to_conversion(
    primary_ptt_status_converted_t *conversion,
    primary_ptt_status_status status
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_ptt_status_conversion_to_raw(
    primary_ptt_status_t *raw,
    primary_ptt_status_status status
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_ptt_status_raw_to_conversion_struct(
    primary_ptt_status_converted_t *conversion, 
    const primary_ptt_status_t *raw);


void primary_ptt_status_conversion_to_raw_struct(
    primary_ptt_status_t *raw,
    const primary_ptt_status_converted_t *conversion);

int primary_ptt_status_status_enum_to_string(primary_ptt_status_status value, char *buffer);

int primary_ptt_status_to_string(primary_ptt_status_t *message, char *buffer);

int primary_ptt_status_to_string_file(primary_ptt_status_t *message, FILE *buffer);

int primary_ptt_status_fields(char *buffer);

int primary_ptt_status_fields_file(FILE *buffer);

/**
 * Pack message PTT_STATUS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_ptt_status_pack(
    uint8_t *dst_p,
    const primary_ptt_status_t *src_p,
    size_t byte_size);

/**
 * Unpack message PTT_STATUS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_ptt_status_unpack(
    primary_ptt_status_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_ptt_status_status_is_in_range(uint8_t value);

bool primary_id_is_message(uint16_t id);

int primary_to_string_from_id(uint16_t message_id, void* message, char* buffer);
int primary_fields_from_id(uint16_t message_id, char* buffer);
int primary_to_string_file_from_id(uint16_t message_id, void* message, FILE* buffer);
int primary_fields_file_from_id(uint16_t message_id, FILE* buffer);


typedef union CANLIB_PARKING {
    primary_nlg5_diag_tx_t _nlg5_diag_tx;
    primary_nlg5_diag_rx_t _nlg5_diag_rx;
    primary_nlg5_err_t _nlg5_err;
    primary_nlg5_temp_t _nlg5_temp;
    primary_nlg5_act_ii_t _nlg5_act_ii;
    primary_nlg5_act_i_t _nlg5_act_i;
    primary_nlg5_st_t _nlg5_st;
    primary_nlg5_ctl_t _nlg5_ctl;
    primary_bms_hv_jmp_to_blt_t _bms_hv_jmp_to_blt;
    primary_flash_bms_hv_tx_t _flash_bms_hv_tx;
    primary_flash_bms_hv_rx_t _flash_bms_hv_rx;
    primary_hv_can_forward_t _hv_can_forward;
    primary_flash_cellboard_0_tx_t _flash_cellboard_0_tx;
    primary_flash_cellboard_0_rx_t _flash_cellboard_0_rx;
    primary_flash_cellboard_1_tx_t _flash_cellboard_1_tx;
    primary_flash_cellboard_1_rx_t _flash_cellboard_1_rx;
    primary_flash_cellboard_2_tx_t _flash_cellboard_2_tx;
    primary_flash_cellboard_2_rx_t _flash_cellboard_2_rx;
    primary_flash_cellboard_3_tx_t _flash_cellboard_3_tx;
    primary_flash_cellboard_3_rx_t _flash_cellboard_3_rx;
    primary_flash_cellboard_4_tx_t _flash_cellboard_4_tx;
    primary_flash_cellboard_4_rx_t _flash_cellboard_4_rx;
    primary_flash_cellboard_5_tx_t _flash_cellboard_5_tx;
    primary_flash_cellboard_5_rx_t _flash_cellboard_5_rx;
    primary_bms_lv_jmp_to_blt_t _bms_lv_jmp_to_blt;
    primary_flash_bms_lv_tx_t _flash_bms_lv_tx;
    primary_flash_bms_lv_rx_t _flash_bms_lv_rx;
    primary_ecu_jmp_to_blt_t _ecu_jmp_to_blt;
    primary_flash_ecu_tx_t _flash_ecu_tx;
    primary_flash_ecu_rx_t _flash_ecu_rx;
    primary_steering_jmp_to_blt_t _steering_jmp_to_blt;
    primary_flash_steering_tx_t _flash_steering_tx;
    primary_flash_steering_rx_t _flash_steering_rx;
    primary_steer_version_t _steer_version;
    primary_das_version_t _das_version;
    primary_hv_version_t _hv_version;
    primary_lv_version_t _lv_version;
    primary_tlm_version_t _tlm_version;
    primary_timestamp_t _timestamp;
    primary_ambient_temperature_t _ambient_temperature;
    primary_data_logger_t _data_logger;
    primary_set_tlm_status_t _set_tlm_status;
    primary_tlm_status_t _tlm_status;
    primary_steer_system_status_t _steer_system_status;
    primary_hv_voltage_t _hv_voltage;
    primary_hv_current_t _hv_current;
    primary_hv_temp_t _hv_temp;
    primary_hv_errors_t _hv_errors;
    primary_hv_fans_override_t _hv_fans_override;
    primary_hv_can_forward_status_t _hv_can_forward_status;
    primary_hv_fans_override_status_t _hv_fans_override_status;
    primary_hv_feedbacks_status_t _hv_feedbacks_status;
    primary_hv_imd_status_t _hv_imd_status;
    primary_ts_status_t _ts_status;
    primary_set_ts_status_das_t _set_ts_status_das;
    primary_set_ts_status_handcart_t _set_ts_status_handcart;
    primary_steer_status_t _steer_status;
    primary_set_car_status_t _set_car_status;
    primary_set_pedal_calibration_t _set_pedal_calibration;
    primary_pedal_calibration_ack_t _pedal_calibration_ack;
    primary_car_status_t _car_status;
    primary_das_errors_t _das_errors;
    primary_ecu_feedbacks_t _ecu_feedbacks;
    primary_lv_status_t _lv_status;
    primary_lv_currents_t _lv_currents;
    primary_lv_cells_voltage_t _lv_cells_voltage;
    primary_lv_total_voltage_t _lv_total_voltage;
    primary_lv_cells_temp_t _lv_cells_temp;
    primary_cooling_status_t _cooling_status;
    primary_set_radiator_speed_t _set_radiator_speed;
    primary_set_pumps_speed_t _set_pumps_speed;
    primary_set_inverter_connection_status_t _set_inverter_connection_status;
    primary_inverter_connection_status_t _inverter_connection_status;
    primary_lv_errors_t _lv_errors;
    primary_lv_health_signals_t _lv_health_signals;
    primary_lv_feedbacks_t _lv_feedbacks;
    primary_shutdown_status_t _shutdown_status;
    primary_lv_can_flash_req_t _lv_can_flash_req;
    primary_lv_can_flash_ack_t _lv_can_flash_ack;
    primary_marker_t _marker;
    primary_hv_cells_voltage_t _hv_cells_voltage;
    primary_hv_cells_temp_t _hv_cells_temp;
    primary_hv_cell_balancing_status_t _hv_cell_balancing_status;
    primary_set_cell_balancing_status_t _set_cell_balancing_status;
    primary_speed_t _speed;
    primary_inv_l_request_t _inv_l_request;
    primary_inv_r_request_t _inv_r_request;
    primary_inv_l_response_t _inv_l_response;
    primary_inv_r_response_t _inv_r_response;
    primary_control_output_t _control_output;
    primary_lc_reset_t _lc_reset;
    primary_handcart_status_t _handcart_status;
    primary_handcart_settings_t _handcart_settings;
    primary_handcart_settings_set_t _handcart_settings_set;
    primary_set_ptt_status_t _set_ptt_status;
    primary_ptt_status_t _ptt_status;

} _primary_all_struct_raw;

typedef union CANLIB_PARKING {
    primary_nlg5_diag_tx_converted_t _nlg5_diag_tx;
    primary_nlg5_diag_rx_converted_t _nlg5_diag_rx;
    primary_nlg5_err_converted_t _nlg5_err;
    primary_nlg5_temp_converted_t _nlg5_temp;
    primary_nlg5_act_ii_converted_t _nlg5_act_ii;
    primary_nlg5_act_i_converted_t _nlg5_act_i;
    primary_nlg5_st_converted_t _nlg5_st;
    primary_nlg5_ctl_converted_t _nlg5_ctl;
    primary_bms_hv_jmp_to_blt_converted_t _bms_hv_jmp_to_blt;
    primary_flash_bms_hv_tx_converted_t _flash_bms_hv_tx;
    primary_flash_bms_hv_rx_converted_t _flash_bms_hv_rx;
    primary_hv_can_forward_converted_t _hv_can_forward;
    primary_flash_cellboard_0_tx_converted_t _flash_cellboard_0_tx;
    primary_flash_cellboard_0_rx_converted_t _flash_cellboard_0_rx;
    primary_flash_cellboard_1_tx_converted_t _flash_cellboard_1_tx;
    primary_flash_cellboard_1_rx_converted_t _flash_cellboard_1_rx;
    primary_flash_cellboard_2_tx_converted_t _flash_cellboard_2_tx;
    primary_flash_cellboard_2_rx_converted_t _flash_cellboard_2_rx;
    primary_flash_cellboard_3_tx_converted_t _flash_cellboard_3_tx;
    primary_flash_cellboard_3_rx_converted_t _flash_cellboard_3_rx;
    primary_flash_cellboard_4_tx_converted_t _flash_cellboard_4_tx;
    primary_flash_cellboard_4_rx_converted_t _flash_cellboard_4_rx;
    primary_flash_cellboard_5_tx_converted_t _flash_cellboard_5_tx;
    primary_flash_cellboard_5_rx_converted_t _flash_cellboard_5_rx;
    primary_bms_lv_jmp_to_blt_converted_t _bms_lv_jmp_to_blt;
    primary_flash_bms_lv_tx_converted_t _flash_bms_lv_tx;
    primary_flash_bms_lv_rx_converted_t _flash_bms_lv_rx;
    primary_ecu_jmp_to_blt_converted_t _ecu_jmp_to_blt;
    primary_flash_ecu_tx_converted_t _flash_ecu_tx;
    primary_flash_ecu_rx_converted_t _flash_ecu_rx;
    primary_steering_jmp_to_blt_converted_t _steering_jmp_to_blt;
    primary_flash_steering_tx_converted_t _flash_steering_tx;
    primary_flash_steering_rx_converted_t _flash_steering_rx;
    primary_steer_version_converted_t _steer_version;
    primary_das_version_converted_t _das_version;
    primary_hv_version_converted_t _hv_version;
    primary_lv_version_converted_t _lv_version;
    primary_tlm_version_converted_t _tlm_version;
    primary_timestamp_converted_t _timestamp;
    primary_ambient_temperature_converted_t _ambient_temperature;
    primary_data_logger_converted_t _data_logger;
    primary_set_tlm_status_converted_t _set_tlm_status;
    primary_tlm_status_converted_t _tlm_status;
    primary_steer_system_status_converted_t _steer_system_status;
    primary_hv_voltage_converted_t _hv_voltage;
    primary_hv_current_converted_t _hv_current;
    primary_hv_temp_converted_t _hv_temp;
    primary_hv_errors_converted_t _hv_errors;
    primary_hv_fans_override_converted_t _hv_fans_override;
    primary_hv_can_forward_status_converted_t _hv_can_forward_status;
    primary_hv_fans_override_status_converted_t _hv_fans_override_status;
    primary_hv_feedbacks_status_converted_t _hv_feedbacks_status;
    primary_hv_imd_status_converted_t _hv_imd_status;
    primary_ts_status_converted_t _ts_status;
    primary_set_ts_status_das_converted_t _set_ts_status_das;
    primary_set_ts_status_handcart_converted_t _set_ts_status_handcart;
    primary_steer_status_converted_t _steer_status;
    primary_set_car_status_converted_t _set_car_status;
    primary_set_pedal_calibration_converted_t _set_pedal_calibration;
    primary_pedal_calibration_ack_converted_t _pedal_calibration_ack;
    primary_car_status_converted_t _car_status;
    primary_das_errors_converted_t _das_errors;
    primary_ecu_feedbacks_converted_t _ecu_feedbacks;
    primary_lv_status_converted_t _lv_status;
    primary_lv_currents_converted_t _lv_currents;
    primary_lv_cells_voltage_converted_t _lv_cells_voltage;
    primary_lv_total_voltage_converted_t _lv_total_voltage;
    primary_lv_cells_temp_converted_t _lv_cells_temp;
    primary_cooling_status_converted_t _cooling_status;
    primary_set_radiator_speed_converted_t _set_radiator_speed;
    primary_set_pumps_speed_converted_t _set_pumps_speed;
    primary_set_inverter_connection_status_converted_t _set_inverter_connection_status;
    primary_inverter_connection_status_converted_t _inverter_connection_status;
    primary_lv_errors_converted_t _lv_errors;
    primary_lv_health_signals_converted_t _lv_health_signals;
    primary_lv_feedbacks_converted_t _lv_feedbacks;
    primary_shutdown_status_converted_t _shutdown_status;
    primary_lv_can_flash_req_converted_t _lv_can_flash_req;
    primary_lv_can_flash_ack_converted_t _lv_can_flash_ack;
    primary_marker_converted_t _marker;
    primary_hv_cells_voltage_converted_t _hv_cells_voltage;
    primary_hv_cells_temp_converted_t _hv_cells_temp;
    primary_hv_cell_balancing_status_converted_t _hv_cell_balancing_status;
    primary_set_cell_balancing_status_converted_t _set_cell_balancing_status;
    primary_speed_converted_t _speed;
    primary_inv_l_request_converted_t _inv_l_request;
    primary_inv_r_request_converted_t _inv_r_request;
    primary_inv_l_response_converted_t _inv_l_response;
    primary_inv_r_response_converted_t _inv_r_response;
    primary_control_output_converted_t _control_output;
    primary_lc_reset_converted_t _lc_reset;
    primary_handcart_status_converted_t _handcart_status;
    primary_handcart_settings_converted_t _handcart_settings;
    primary_handcart_settings_set_converted_t _handcart_settings_set;
    primary_set_ptt_status_converted_t _set_ptt_status;
    primary_ptt_status_converted_t _ptt_status;

} _primary_all_struct_converted;



#define primary_MAX_STRUCT_SIZE_RAW sizeof(_primary_all_struct_raw)
#define primary_MAX_STRUCT_SIZE_CONVERSION sizeof(_primary_all_struct_converted)

#ifdef __cplusplus
}
#endif

#endif
