/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2018-2019 Erik Moqvist
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/**
 * This file was generated by cantools version 38.0.2 Tue Apr  9 11:16:17 2024.
 */

#ifndef PRIMARY_H
#define PRIMARY_H

#include <stdio.h>
#include <stdlib.h>
#include <inttypes.h>

#ifdef __cplusplus
extern "C" {
#endif

#include <stdint.h>
#include <stdbool.h>
#include <stddef.h>

#ifndef CANLIB_BUILD
#define CANLIB_BUILD
#define CANLIB_BUILD_TIME 1712661377
#endif // CANLIB_BUILD

#define canlib_min(a,b) (((a) < (b)) ? (a) : (b))
#define canlib_max(a,b) (((a) > (b)) ? (a) : (b))

#ifndef CANLIB_PARKING
/* We know it's PACKING but PARKING sounds a bit better ;) */
#if defined(__MINGW32__)
#define CANLIB_PARKING                                                           __attribute__((__gcc_struct__, __packed__)) // , __aligned__(1)))
#else
#define CANLIB_PARKING __attribute__((__packed__)) // , __aligned__(1)))
#endif                                             // defined(__MINGW32__)
#endif                                             // CANLIB_PARKING

#ifndef EINVAL
#    define EINVAL 22
#endif

/* General defines */
#define PRIMARY_ONESHOT (-1)

/* Frame ids. */
#define PRIMARY_NLG5_DIAG_TX_FRAME_ID (0x71au)
#define PRIMARY_NLG5_DIAG_RX_FRAME_ID (0x718u)
#define PRIMARY_NLG5_ERR_FRAME_ID (0x614u)
#define PRIMARY_NLG5_TEMP_FRAME_ID (0x613u)
#define PRIMARY_NLG5_ACT_II_FRAME_ID (0x612u)
#define PRIMARY_NLG5_ACT_I_FRAME_ID (0x611u)
#define PRIMARY_NLG5_ST_FRAME_ID (0x610u)
#define PRIMARY_NLG5_CTL_FRAME_ID (0x618u)
#define PRIMARY_HV_JMP_TO_BLT_FRAME_ID (0x00u)
#define PRIMARY_HV_FLASH_MAINBOARD_TX_FRAME_ID (0x01u)
#define PRIMARY_HV_FLASH_MAINBOARD_RX_FRAME_ID (0x02u)
#define PRIMARY_HV_FLASH_CELLBOARD_0_TX_FRAME_ID (0x04u)
#define PRIMARY_HV_FLASH_CELLBOARD_0_RX_FRAME_ID (0x05u)
#define PRIMARY_HV_FLASH_CELLBOARD_1_TX_FRAME_ID (0x06u)
#define PRIMARY_HV_FLASH_CELLBOARD_1_RX_FRAME_ID (0x07u)
#define PRIMARY_HV_FLASH_CELLBOARD_2_TX_FRAME_ID (0x08u)
#define PRIMARY_HV_FLASH_CELLBOARD_2_RX_FRAME_ID (0x09u)
#define PRIMARY_HV_FLASH_CELLBOARD_3_TX_FRAME_ID (0x0au)
#define PRIMARY_HV_FLASH_CELLBOARD_3_RX_FRAME_ID (0x0bu)
#define PRIMARY_HV_FLASH_CELLBOARD_4_TX_FRAME_ID (0x0cu)
#define PRIMARY_HV_FLASH_CELLBOARD_4_RX_FRAME_ID (0x0du)
#define PRIMARY_HV_FLASH_CELLBOARD_5_TX_FRAME_ID (0x0eu)
#define PRIMARY_HV_FLASH_CELLBOARD_5_RX_FRAME_ID (0x0fu)
#define PRIMARY_LV_JMP_TO_BLT_FRAME_ID (0x10u)
#define PRIMARY_LV_FLASH_TX_FRAME_ID (0x11u)
#define PRIMARY_LV_FLASH_RX_FRAME_ID (0x12u)
#define PRIMARY_ECU_JMP_TO_BLT_FRAME_ID (0x13u)
#define PRIMARY_ECU_FLASH_TX_FRAME_ID (0x14u)
#define PRIMARY_ECU_FLASH_RX_FRAME_ID (0x15u)
#define PRIMARY_STEERING_WHEEL_JMP_TO_BLT_FRAME_ID (0x16u)
#define PRIMARY_STEERING_WHEEL_FLASH_TX_FRAME_ID (0x17u)
#define PRIMARY_STEERING_WHEEL_FLASH_RX_FRAME_ID (0x18u)
#define PRIMARY_STEERING_WHEEL_VERSION_FRAME_ID (0x2bcu)
#define PRIMARY_ECU_VERSION_FRAME_ID (0x2bdu)
#define PRIMARY_LV_VERSION_FRAME_ID (0x2bfu)
#define PRIMARY_TLM_VERSION_FRAME_ID (0x2c0u)
#define PRIMARY_HV_MAINBOARD_VERSION_FRAME_ID (0x2beu)
#define PRIMARY_HV_CELLBOARD_VERSION_FRAME_ID (0x2c1u)
#define PRIMARY_HV_ERRORS_FRAME_ID (0x20u)
#define PRIMARY_HV_DEBUG_SIGNALS_FRAME_ID (0x200u)
#define PRIMARY_HV_FANS_STATUS_FRAME_ID (0x600u)
#define PRIMARY_HV_SET_FANS_STATUS_FRAME_ID (0x400u)
#define PRIMARY_HV_FEEDBACK_STATUS_FRAME_ID (0x208u)
#define PRIMARY_HV_FEEDBACK_TS_VOLTAGE_FRAME_ID (0x210u)
#define PRIMARY_HV_FEEDBACK_MISC_VOLTAGE_FRAME_ID (0x218u)
#define PRIMARY_HV_FEEDBACK_SD_VOLTAGE_FRAME_ID (0x220u)
#define PRIMARY_HV_IMD_STATUS_FRAME_ID (0x228u)
#define PRIMARY_HV_STATUS_FRAME_ID (0x230u)
#define PRIMARY_HV_SET_STATUS_ECU_FRAME_ID (0x28u)
#define PRIMARY_HV_SET_STATUS_HANDCART_FRAME_ID (0x30u)
#define PRIMARY_HV_BALANCING_STATUS_FRAME_ID (0x608u)
#define PRIMARY_HV_SET_BALANCING_STATUS_HANDCART_FRAME_ID (0x408u)
#define PRIMARY_HV_SET_BALANCING_STATUS_STEERING_WHEEL_FRAME_ID (0x410u)
#define PRIMARY_LV_STATUS_FRAME_ID (0x238u)
#define PRIMARY_LV_RADIATOR_SPEED_FRAME_ID (0x620u)
#define PRIMARY_LV_PUMPS_SPEED_FRAME_ID (0x628u)
#define PRIMARY_LV_SET_RADIATOR_SPEED_FRAME_ID (0x418u)
#define PRIMARY_LV_SET_PUMPS_SPEED_FRAME_ID (0x420u)
#define PRIMARY_LV_ERRORS_FRAME_ID (0x240u)
#define PRIMARY_LV_FEEDBACK_TS_VOLTAGE_FRAME_ID (0x248u)
#define PRIMARY_LV_FEEDBACK_SD_VOLTAGE_FRAME_ID (0x250u)
#define PRIMARY_LV_FEEDBACK_ENCLOSURE_VOLTAGE_FRAME_ID (0x258u)
#define PRIMARY_LV_FEEDBACK_GPIO_EXTENDER_FRAME_ID (0x260u)
#define PRIMARY_LV_CAN_FLASH_REQ_TLM_FRAME_ID (0x38u)
#define PRIMARY_LV_CAN_FLASH_REQ_STEERING_WHEEL_FRAME_ID (0x40u)
#define PRIMARY_LV_CAN_FLASH_ACK_FRAME_ID (0x48u)
#define PRIMARY_LV_INVERTER_CONNECTION_STATUS_FRAME_ID (0x268u)
#define PRIMARY_LV_SET_INVERTER_CONNECTION_STATUS_FRAME_ID (0x50u)
#define PRIMARY_TLM_STATUS_FRAME_ID (0x630u)
#define PRIMARY_TLM_SET_STATUS_FRAME_ID (0x428u)
#define PRIMARY_HANDCART_STATUS_FRAME_ID (0x270u)
#define PRIMARY_HANDCART_SETTINGS_FRAME_ID (0x638u)
#define PRIMARY_HANDCART_SET_SETTINGS_FRAME_ID (0x430u)
#define PRIMARY_ECU_STATUS_FRAME_ID (0x278u)
#define PRIMARY_ECU_SET_STATUS_FRAME_ID (0x58u)
#define PRIMARY_ECU_INVERTER_STATUS_FRAME_ID (0x438u)
#define PRIMARY_ECU_CONTROL_STATUS_FRAME_ID (0x280u)
#define PRIMARY_ECU_ERRORS_FRAME_ID (0x288u)
#define PRIMARY_ECU_FEEDBACKS_FRAME_ID (0x290u)
#define PRIMARY_ECU_POWER_MAPS_FRAME_ID (0x298u)
#define PRIMARY_ECU_SET_POWER_MAPS_FRAME_ID (0x60u)
#define PRIMARY_ECU_PTT_STATUS_FRAME_ID (0x640u)
#define PRIMARY_ECU_SET_PTT_STATUS_FRAME_ID (0x440u)
#define PRIMARY_INV_L_REQUEST_FRAME_ID (0x201u)
#define PRIMARY_CONTROL_OUTPUT_FRAME_ID (0x2a0u)
#define PRIMARY_CONTROL_STATUS_FRAME_ID (0x2a8u)
#define PRIMARY_INV_R_REQUEST_FRAME_ID (0x202u)
#define PRIMARY_INV_L_RESPONSE_FRAME_ID (0x181u)
#define PRIMARY_INV_R_RESPONSE_FRAME_ID (0x182u)
#define PRIMARY_LV_CURRENT_BATTERY_FRAME_ID (0x648u)
#define PRIMARY_LV_CURRENT_CHARGER_FRAME_ID (0x650u)
#define PRIMARY_LV_TOTAL_VOLTAGE_FRAME_ID (0x658u)
#define PRIMARY_LV_CELLS_VOLTAGE_FRAME_ID (0x660u)
#define PRIMARY_LV_CELLS_VOLTAGE_STATS_FRAME_ID (0x668u)
#define PRIMARY_LV_CELLS_TEMP_FRAME_ID (0x670u)
#define PRIMARY_LV_CELLS_TEMP_STATS_FRAME_ID (0x678u)
#define PRIMARY_HV_CURRENT_FRAME_ID (0x680u)
#define PRIMARY_HV_POWER_FRAME_ID (0x688u)
#define PRIMARY_HV_ENERGY_FRAME_ID (0x690u)
#define PRIMARY_HV_SOC_FRAME_ID (0x698u)
#define PRIMARY_HV_TOTAL_VOLTAGE_FRAME_ID (0x6a0u)
#define PRIMARY_HV_CELLS_VOLTAGE_FRAME_ID (0x6a8u)
#define PRIMARY_HV_CELLS_VOLTAGE_STATS_FRAME_ID (0x6b0u)
#define PRIMARY_HV_CELLS_TEMP_FRAME_ID (0x6b8u)
#define PRIMARY_HV_CELLS_TEMP_STATS_FRAME_ID (0x6c0u)
#define PRIMARY_ECU_STEER_ACTUATOR_STATUS_FRAME_ID (0x6c8u)
#define PRIMARY_ECU_SET_STEER_ACTUATOR_STATUS_STEERING_WHEEL_FRAME_ID (0x448u)
#define PRIMARY_ECU_SET_STEER_ACTUATOR_STATUS_TLM_FRAME_ID (0x450u)
#define PRIMARY_ECU_STEER_ACTUATOR_CURRENT_FRAME_ID (0x6d0u)
#define PRIMARY_DEBUG_SIGNAL_CRASH_DEBUG_FRAME_ID (0x6d8u)
#define PRIMARY_DEBUG_SIGNAL_CRASH_DEBUG_ACK_FRAME_ID (0x6e0u)
#define PRIMARY_DEBUG_SIGNAL_1_FRAME_ID (0x6e8u)
#define PRIMARY_DEBUG_SIGNAL_2_FRAME_ID (0x6f0u)

/* Frame lengths in bytes. */
#define PRIMARY_NLG5_DIAG_TX_BYTE_SIZE (8u)
#define PRIMARY_NLG5_DIAG_RX_BYTE_SIZE (8u)
#define PRIMARY_NLG5_ERR_BYTE_SIZE (5u)
#define PRIMARY_NLG5_TEMP_BYTE_SIZE (8u)
#define PRIMARY_NLG5_ACT_II_BYTE_SIZE (8u)
#define PRIMARY_NLG5_ACT_I_BYTE_SIZE (8u)
#define PRIMARY_NLG5_ST_BYTE_SIZE (4u)
#define PRIMARY_NLG5_CTL_BYTE_SIZE (7u)
#define PRIMARY_HV_JMP_TO_BLT_BYTE_SIZE (1u)
#define PRIMARY_HV_FLASH_MAINBOARD_TX_BYTE_SIZE (0u)
#define PRIMARY_HV_FLASH_MAINBOARD_RX_BYTE_SIZE (0u)
#define PRIMARY_HV_FLASH_CELLBOARD_0_TX_BYTE_SIZE (0u)
#define PRIMARY_HV_FLASH_CELLBOARD_0_RX_BYTE_SIZE (0u)
#define PRIMARY_HV_FLASH_CELLBOARD_1_TX_BYTE_SIZE (0u)
#define PRIMARY_HV_FLASH_CELLBOARD_1_RX_BYTE_SIZE (0u)
#define PRIMARY_HV_FLASH_CELLBOARD_2_TX_BYTE_SIZE (0u)
#define PRIMARY_HV_FLASH_CELLBOARD_2_RX_BYTE_SIZE (0u)
#define PRIMARY_HV_FLASH_CELLBOARD_3_TX_BYTE_SIZE (0u)
#define PRIMARY_HV_FLASH_CELLBOARD_3_RX_BYTE_SIZE (0u)
#define PRIMARY_HV_FLASH_CELLBOARD_4_TX_BYTE_SIZE (0u)
#define PRIMARY_HV_FLASH_CELLBOARD_4_RX_BYTE_SIZE (0u)
#define PRIMARY_HV_FLASH_CELLBOARD_5_TX_BYTE_SIZE (0u)
#define PRIMARY_HV_FLASH_CELLBOARD_5_RX_BYTE_SIZE (0u)
#define PRIMARY_LV_JMP_TO_BLT_BYTE_SIZE (0u)
#define PRIMARY_LV_FLASH_TX_BYTE_SIZE (0u)
#define PRIMARY_LV_FLASH_RX_BYTE_SIZE (0u)
#define PRIMARY_ECU_JMP_TO_BLT_BYTE_SIZE (0u)
#define PRIMARY_ECU_FLASH_TX_BYTE_SIZE (0u)
#define PRIMARY_ECU_FLASH_RX_BYTE_SIZE (0u)
#define PRIMARY_STEERING_WHEEL_JMP_TO_BLT_BYTE_SIZE (0u)
#define PRIMARY_STEERING_WHEEL_FLASH_TX_BYTE_SIZE (0u)
#define PRIMARY_STEERING_WHEEL_FLASH_RX_BYTE_SIZE (0u)
#define PRIMARY_STEERING_WHEEL_VERSION_BYTE_SIZE (8u)
#define PRIMARY_ECU_VERSION_BYTE_SIZE (8u)
#define PRIMARY_LV_VERSION_BYTE_SIZE (8u)
#define PRIMARY_TLM_VERSION_BYTE_SIZE (8u)
#define PRIMARY_HV_MAINBOARD_VERSION_BYTE_SIZE (8u)
#define PRIMARY_HV_CELLBOARD_VERSION_BYTE_SIZE (7u)
#define PRIMARY_HV_ERRORS_BYTE_SIZE (2u)
#define PRIMARY_HV_DEBUG_SIGNALS_BYTE_SIZE (5u)
#define PRIMARY_HV_FANS_STATUS_BYTE_SIZE (3u)
#define PRIMARY_HV_SET_FANS_STATUS_BYTE_SIZE (3u)
#define PRIMARY_HV_FEEDBACK_STATUS_BYTE_SIZE (5u)
#define PRIMARY_HV_FEEDBACK_TS_VOLTAGE_BYTE_SIZE (7u)
#define PRIMARY_HV_FEEDBACK_MISC_VOLTAGE_BYTE_SIZE (8u)
#define PRIMARY_HV_FEEDBACK_SD_VOLTAGE_BYTE_SIZE (5u)
#define PRIMARY_HV_IMD_STATUS_BYTE_SIZE (6u)
#define PRIMARY_HV_STATUS_BYTE_SIZE (1u)
#define PRIMARY_HV_SET_STATUS_ECU_BYTE_SIZE (1u)
#define PRIMARY_HV_SET_STATUS_HANDCART_BYTE_SIZE (1u)
#define PRIMARY_HV_BALANCING_STATUS_BYTE_SIZE (4u)
#define PRIMARY_HV_SET_BALANCING_STATUS_HANDCART_BYTE_SIZE (2u)
#define PRIMARY_HV_SET_BALANCING_STATUS_STEERING_WHEEL_BYTE_SIZE (2u)
#define PRIMARY_LV_STATUS_BYTE_SIZE (1u)
#define PRIMARY_LV_RADIATOR_SPEED_BYTE_SIZE (2u)
#define PRIMARY_LV_PUMPS_SPEED_BYTE_SIZE (2u)
#define PRIMARY_LV_SET_RADIATOR_SPEED_BYTE_SIZE (2u)
#define PRIMARY_LV_SET_PUMPS_SPEED_BYTE_SIZE (2u)
#define PRIMARY_LV_ERRORS_BYTE_SIZE (3u)
#define PRIMARY_LV_FEEDBACK_TS_VOLTAGE_BYTE_SIZE (8u)
#define PRIMARY_LV_FEEDBACK_SD_VOLTAGE_BYTE_SIZE (8u)
#define PRIMARY_LV_FEEDBACK_ENCLOSURE_VOLTAGE_BYTE_SIZE (8u)
#define PRIMARY_LV_FEEDBACK_GPIO_EXTENDER_BYTE_SIZE (2u)
#define PRIMARY_LV_CAN_FLASH_REQ_TLM_BYTE_SIZE (0u)
#define PRIMARY_LV_CAN_FLASH_REQ_STEERING_WHEEL_BYTE_SIZE (0u)
#define PRIMARY_LV_CAN_FLASH_ACK_BYTE_SIZE (0u)
#define PRIMARY_LV_INVERTER_CONNECTION_STATUS_BYTE_SIZE (1u)
#define PRIMARY_LV_SET_INVERTER_CONNECTION_STATUS_BYTE_SIZE (1u)
#define PRIMARY_TLM_STATUS_BYTE_SIZE (1u)
#define PRIMARY_TLM_SET_STATUS_BYTE_SIZE (1u)
#define PRIMARY_HANDCART_STATUS_BYTE_SIZE (1u)
#define PRIMARY_HANDCART_SETTINGS_BYTE_SIZE (5u)
#define PRIMARY_HANDCART_SET_SETTINGS_BYTE_SIZE (5u)
#define PRIMARY_ECU_STATUS_BYTE_SIZE (1u)
#define PRIMARY_ECU_SET_STATUS_BYTE_SIZE (1u)
#define PRIMARY_ECU_INVERTER_STATUS_BYTE_SIZE (1u)
#define PRIMARY_ECU_CONTROL_STATUS_BYTE_SIZE (1u)
#define PRIMARY_ECU_ERRORS_BYTE_SIZE (2u)
#define PRIMARY_ECU_FEEDBACKS_BYTE_SIZE (1u)
#define PRIMARY_ECU_POWER_MAPS_BYTE_SIZE (3u)
#define PRIMARY_ECU_SET_POWER_MAPS_BYTE_SIZE (3u)
#define PRIMARY_ECU_PTT_STATUS_BYTE_SIZE (1u)
#define PRIMARY_ECU_SET_PTT_STATUS_BYTE_SIZE (1u)
#define PRIMARY_INV_L_REQUEST_BYTE_SIZE (8u)
#define PRIMARY_CONTROL_OUTPUT_BYTE_SIZE (8u)
#define PRIMARY_CONTROL_STATUS_BYTE_SIZE (3u)
#define PRIMARY_INV_R_REQUEST_BYTE_SIZE (8u)
#define PRIMARY_INV_L_RESPONSE_BYTE_SIZE (8u)
#define PRIMARY_INV_R_RESPONSE_BYTE_SIZE (8u)
#define PRIMARY_LV_CURRENT_BATTERY_BYTE_SIZE (2u)
#define PRIMARY_LV_CURRENT_CHARGER_BYTE_SIZE (2u)
#define PRIMARY_LV_TOTAL_VOLTAGE_BYTE_SIZE (4u)
#define PRIMARY_LV_CELLS_VOLTAGE_BYTE_SIZE (7u)
#define PRIMARY_LV_CELLS_VOLTAGE_STATS_BYTE_SIZE (8u)
#define PRIMARY_LV_CELLS_TEMP_BYTE_SIZE (7u)
#define PRIMARY_LV_CELLS_TEMP_STATS_BYTE_SIZE (6u)
#define PRIMARY_HV_CURRENT_BYTE_SIZE (2u)
#define PRIMARY_HV_POWER_BYTE_SIZE (2u)
#define PRIMARY_HV_ENERGY_BYTE_SIZE (2u)
#define PRIMARY_HV_SOC_BYTE_SIZE (1u)
#define PRIMARY_HV_TOTAL_VOLTAGE_BYTE_SIZE (6u)
#define PRIMARY_HV_CELLS_VOLTAGE_BYTE_SIZE (7u)
#define PRIMARY_HV_CELLS_VOLTAGE_STATS_BYTE_SIZE (8u)
#define PRIMARY_HV_CELLS_TEMP_BYTE_SIZE (5u)
#define PRIMARY_HV_CELLS_TEMP_STATS_BYTE_SIZE (6u)
#define PRIMARY_ECU_STEER_ACTUATOR_STATUS_BYTE_SIZE (1u)
#define PRIMARY_ECU_SET_STEER_ACTUATOR_STATUS_STEERING_WHEEL_BYTE_SIZE (2u)
#define PRIMARY_ECU_SET_STEER_ACTUATOR_STATUS_TLM_BYTE_SIZE (2u)
#define PRIMARY_ECU_STEER_ACTUATOR_CURRENT_BYTE_SIZE (1u)
#define PRIMARY_DEBUG_SIGNAL_CRASH_DEBUG_BYTE_SIZE (8u)
#define PRIMARY_DEBUG_SIGNAL_CRASH_DEBUG_ACK_BYTE_SIZE (1u)
#define PRIMARY_DEBUG_SIGNAL_1_BYTE_SIZE (8u)
#define PRIMARY_DEBUG_SIGNAL_2_BYTE_SIZE (8u)

/* Extended or standard frame types. */
#define PRIMARY_NLG5_DIAG_TX_IS_EXTENDED (0)
#define PRIMARY_NLG5_DIAG_RX_IS_EXTENDED (0)
#define PRIMARY_NLG5_ERR_IS_EXTENDED (0)
#define PRIMARY_NLG5_TEMP_IS_EXTENDED (0)
#define PRIMARY_NLG5_ACT_II_IS_EXTENDED (0)
#define PRIMARY_NLG5_ACT_I_IS_EXTENDED (0)
#define PRIMARY_NLG5_ST_IS_EXTENDED (0)
#define PRIMARY_NLG5_CTL_IS_EXTENDED (0)
#define PRIMARY_HV_JMP_TO_BLT_IS_EXTENDED (0)
#define PRIMARY_HV_FLASH_MAINBOARD_TX_IS_EXTENDED (0)
#define PRIMARY_HV_FLASH_MAINBOARD_RX_IS_EXTENDED (0)
#define PRIMARY_HV_FLASH_CELLBOARD_0_TX_IS_EXTENDED (0)
#define PRIMARY_HV_FLASH_CELLBOARD_0_RX_IS_EXTENDED (0)
#define PRIMARY_HV_FLASH_CELLBOARD_1_TX_IS_EXTENDED (0)
#define PRIMARY_HV_FLASH_CELLBOARD_1_RX_IS_EXTENDED (0)
#define PRIMARY_HV_FLASH_CELLBOARD_2_TX_IS_EXTENDED (0)
#define PRIMARY_HV_FLASH_CELLBOARD_2_RX_IS_EXTENDED (0)
#define PRIMARY_HV_FLASH_CELLBOARD_3_TX_IS_EXTENDED (0)
#define PRIMARY_HV_FLASH_CELLBOARD_3_RX_IS_EXTENDED (0)
#define PRIMARY_HV_FLASH_CELLBOARD_4_TX_IS_EXTENDED (0)
#define PRIMARY_HV_FLASH_CELLBOARD_4_RX_IS_EXTENDED (0)
#define PRIMARY_HV_FLASH_CELLBOARD_5_TX_IS_EXTENDED (0)
#define PRIMARY_HV_FLASH_CELLBOARD_5_RX_IS_EXTENDED (0)
#define PRIMARY_LV_JMP_TO_BLT_IS_EXTENDED (0)
#define PRIMARY_LV_FLASH_TX_IS_EXTENDED (0)
#define PRIMARY_LV_FLASH_RX_IS_EXTENDED (0)
#define PRIMARY_ECU_JMP_TO_BLT_IS_EXTENDED (0)
#define PRIMARY_ECU_FLASH_TX_IS_EXTENDED (0)
#define PRIMARY_ECU_FLASH_RX_IS_EXTENDED (0)
#define PRIMARY_STEERING_WHEEL_JMP_TO_BLT_IS_EXTENDED (0)
#define PRIMARY_STEERING_WHEEL_FLASH_TX_IS_EXTENDED (0)
#define PRIMARY_STEERING_WHEEL_FLASH_RX_IS_EXTENDED (0)
#define PRIMARY_STEERING_WHEEL_VERSION_IS_EXTENDED (0)
#define PRIMARY_ECU_VERSION_IS_EXTENDED (0)
#define PRIMARY_LV_VERSION_IS_EXTENDED (0)
#define PRIMARY_TLM_VERSION_IS_EXTENDED (0)
#define PRIMARY_HV_MAINBOARD_VERSION_IS_EXTENDED (0)
#define PRIMARY_HV_CELLBOARD_VERSION_IS_EXTENDED (0)
#define PRIMARY_HV_ERRORS_IS_EXTENDED (0)
#define PRIMARY_HV_DEBUG_SIGNALS_IS_EXTENDED (0)
#define PRIMARY_HV_FANS_STATUS_IS_EXTENDED (0)
#define PRIMARY_HV_SET_FANS_STATUS_IS_EXTENDED (0)
#define PRIMARY_HV_FEEDBACK_STATUS_IS_EXTENDED (0)
#define PRIMARY_HV_FEEDBACK_TS_VOLTAGE_IS_EXTENDED (0)
#define PRIMARY_HV_FEEDBACK_MISC_VOLTAGE_IS_EXTENDED (0)
#define PRIMARY_HV_FEEDBACK_SD_VOLTAGE_IS_EXTENDED (0)
#define PRIMARY_HV_IMD_STATUS_IS_EXTENDED (0)
#define PRIMARY_HV_STATUS_IS_EXTENDED (0)
#define PRIMARY_HV_SET_STATUS_ECU_IS_EXTENDED (0)
#define PRIMARY_HV_SET_STATUS_HANDCART_IS_EXTENDED (0)
#define PRIMARY_HV_BALANCING_STATUS_IS_EXTENDED (0)
#define PRIMARY_HV_SET_BALANCING_STATUS_HANDCART_IS_EXTENDED (0)
#define PRIMARY_HV_SET_BALANCING_STATUS_STEERING_WHEEL_IS_EXTENDED (0)
#define PRIMARY_LV_STATUS_IS_EXTENDED (0)
#define PRIMARY_LV_RADIATOR_SPEED_IS_EXTENDED (0)
#define PRIMARY_LV_PUMPS_SPEED_IS_EXTENDED (0)
#define PRIMARY_LV_SET_RADIATOR_SPEED_IS_EXTENDED (0)
#define PRIMARY_LV_SET_PUMPS_SPEED_IS_EXTENDED (0)
#define PRIMARY_LV_ERRORS_IS_EXTENDED (0)
#define PRIMARY_LV_FEEDBACK_TS_VOLTAGE_IS_EXTENDED (0)
#define PRIMARY_LV_FEEDBACK_SD_VOLTAGE_IS_EXTENDED (0)
#define PRIMARY_LV_FEEDBACK_ENCLOSURE_VOLTAGE_IS_EXTENDED (0)
#define PRIMARY_LV_FEEDBACK_GPIO_EXTENDER_IS_EXTENDED (0)
#define PRIMARY_LV_CAN_FLASH_REQ_TLM_IS_EXTENDED (0)
#define PRIMARY_LV_CAN_FLASH_REQ_STEERING_WHEEL_IS_EXTENDED (0)
#define PRIMARY_LV_CAN_FLASH_ACK_IS_EXTENDED (0)
#define PRIMARY_LV_INVERTER_CONNECTION_STATUS_IS_EXTENDED (0)
#define PRIMARY_LV_SET_INVERTER_CONNECTION_STATUS_IS_EXTENDED (0)
#define PRIMARY_TLM_STATUS_IS_EXTENDED (0)
#define PRIMARY_TLM_SET_STATUS_IS_EXTENDED (0)
#define PRIMARY_HANDCART_STATUS_IS_EXTENDED (0)
#define PRIMARY_HANDCART_SETTINGS_IS_EXTENDED (0)
#define PRIMARY_HANDCART_SET_SETTINGS_IS_EXTENDED (0)
#define PRIMARY_ECU_STATUS_IS_EXTENDED (0)
#define PRIMARY_ECU_SET_STATUS_IS_EXTENDED (0)
#define PRIMARY_ECU_INVERTER_STATUS_IS_EXTENDED (0)
#define PRIMARY_ECU_CONTROL_STATUS_IS_EXTENDED (0)
#define PRIMARY_ECU_ERRORS_IS_EXTENDED (0)
#define PRIMARY_ECU_FEEDBACKS_IS_EXTENDED (0)
#define PRIMARY_ECU_POWER_MAPS_IS_EXTENDED (0)
#define PRIMARY_ECU_SET_POWER_MAPS_IS_EXTENDED (0)
#define PRIMARY_ECU_PTT_STATUS_IS_EXTENDED (0)
#define PRIMARY_ECU_SET_PTT_STATUS_IS_EXTENDED (0)
#define PRIMARY_INV_L_REQUEST_IS_EXTENDED (0)
#define PRIMARY_CONTROL_OUTPUT_IS_EXTENDED (0)
#define PRIMARY_CONTROL_STATUS_IS_EXTENDED (0)
#define PRIMARY_INV_R_REQUEST_IS_EXTENDED (0)
#define PRIMARY_INV_L_RESPONSE_IS_EXTENDED (0)
#define PRIMARY_INV_R_RESPONSE_IS_EXTENDED (0)
#define PRIMARY_LV_CURRENT_BATTERY_IS_EXTENDED (0)
#define PRIMARY_LV_CURRENT_CHARGER_IS_EXTENDED (0)
#define PRIMARY_LV_TOTAL_VOLTAGE_IS_EXTENDED (0)
#define PRIMARY_LV_CELLS_VOLTAGE_IS_EXTENDED (0)
#define PRIMARY_LV_CELLS_VOLTAGE_STATS_IS_EXTENDED (0)
#define PRIMARY_LV_CELLS_TEMP_IS_EXTENDED (0)
#define PRIMARY_LV_CELLS_TEMP_STATS_IS_EXTENDED (0)
#define PRIMARY_HV_CURRENT_IS_EXTENDED (0)
#define PRIMARY_HV_POWER_IS_EXTENDED (0)
#define PRIMARY_HV_ENERGY_IS_EXTENDED (0)
#define PRIMARY_HV_SOC_IS_EXTENDED (0)
#define PRIMARY_HV_TOTAL_VOLTAGE_IS_EXTENDED (0)
#define PRIMARY_HV_CELLS_VOLTAGE_IS_EXTENDED (0)
#define PRIMARY_HV_CELLS_VOLTAGE_STATS_IS_EXTENDED (0)
#define PRIMARY_HV_CELLS_TEMP_IS_EXTENDED (0)
#define PRIMARY_HV_CELLS_TEMP_STATS_IS_EXTENDED (0)
#define PRIMARY_ECU_STEER_ACTUATOR_STATUS_IS_EXTENDED (0)
#define PRIMARY_ECU_SET_STEER_ACTUATOR_STATUS_STEERING_WHEEL_IS_EXTENDED (0)
#define PRIMARY_ECU_SET_STEER_ACTUATOR_STATUS_TLM_IS_EXTENDED (0)
#define PRIMARY_ECU_STEER_ACTUATOR_CURRENT_IS_EXTENDED (0)
#define PRIMARY_DEBUG_SIGNAL_CRASH_DEBUG_IS_EXTENDED (0)
#define PRIMARY_DEBUG_SIGNAL_CRASH_DEBUG_ACK_IS_EXTENDED (0)
#define PRIMARY_DEBUG_SIGNAL_1_IS_EXTENDED (0)
#define PRIMARY_DEBUG_SIGNAL_2_IS_EXTENDED (0)

/* Frame cycle times in milliseconds. */
#define PRIMARY_STEERING_WHEEL_VERSION_CYCLE_TIME_MS (1000u)
#define PRIMARY_ECU_VERSION_CYCLE_TIME_MS (1000u)
#define PRIMARY_LV_VERSION_CYCLE_TIME_MS (1000u)
#define PRIMARY_TLM_VERSION_CYCLE_TIME_MS (1000u)
#define PRIMARY_HV_MAINBOARD_VERSION_CYCLE_TIME_MS (1000u)
#define PRIMARY_HV_CELLBOARD_VERSION_CYCLE_TIME_MS (1000u)
#define PRIMARY_HV_ERRORS_CYCLE_TIME_MS (20u)
#define PRIMARY_HV_DEBUG_SIGNALS_CYCLE_TIME_MS (500u)
#define PRIMARY_HV_FANS_STATUS_CYCLE_TIME_MS (200u)
#define PRIMARY_HV_SET_FANS_STATUS_CYCLE_TIME_MS (200u)
#define PRIMARY_HV_FEEDBACK_STATUS_CYCLE_TIME_MS (50u)
#define PRIMARY_HV_FEEDBACK_TS_VOLTAGE_CYCLE_TIME_MS (50u)
#define PRIMARY_HV_FEEDBACK_MISC_VOLTAGE_CYCLE_TIME_MS (50u)
#define PRIMARY_HV_FEEDBACK_SD_VOLTAGE_CYCLE_TIME_MS (50u)
#define PRIMARY_HV_IMD_STATUS_CYCLE_TIME_MS (20u)
#define PRIMARY_HV_STATUS_CYCLE_TIME_MS (20u)
#define PRIMARY_HV_SET_STATUS_ECU_CYCLE_TIME_MS (50u)
#define PRIMARY_HV_SET_STATUS_HANDCART_CYCLE_TIME_MS (50u)
#define PRIMARY_HV_BALANCING_STATUS_CYCLE_TIME_MS (50u)
#define PRIMARY_HV_SET_BALANCING_STATUS_HANDCART_CYCLE_TIME_MS (200u)
#define PRIMARY_HV_SET_BALANCING_STATUS_STEERING_WHEEL_CYCLE_TIME_MS (200u)
#define PRIMARY_LV_STATUS_CYCLE_TIME_MS (20u)
#define PRIMARY_LV_RADIATOR_SPEED_CYCLE_TIME_MS (200u)
#define PRIMARY_LV_PUMPS_SPEED_CYCLE_TIME_MS (200u)
#define PRIMARY_LV_SET_RADIATOR_SPEED_CYCLE_TIME_MS (200u)
#define PRIMARY_LV_SET_PUMPS_SPEED_CYCLE_TIME_MS (200u)
#define PRIMARY_LV_ERRORS_CYCLE_TIME_MS (20u)
#define PRIMARY_LV_FEEDBACK_TS_VOLTAGE_CYCLE_TIME_MS (50u)
#define PRIMARY_LV_FEEDBACK_SD_VOLTAGE_CYCLE_TIME_MS (50u)
#define PRIMARY_LV_FEEDBACK_ENCLOSURE_VOLTAGE_CYCLE_TIME_MS (50u)
#define PRIMARY_LV_FEEDBACK_GPIO_EXTENDER_CYCLE_TIME_MS (50u)
#define PRIMARY_LV_INVERTER_CONNECTION_STATUS_CYCLE_TIME_MS (20u)
#define PRIMARY_LV_SET_INVERTER_CONNECTION_STATUS_CYCLE_TIME_MS (50u)
#define PRIMARY_TLM_STATUS_CYCLE_TIME_MS (200u)
#define PRIMARY_TLM_SET_STATUS_CYCLE_TIME_MS (200u)
#define PRIMARY_HANDCART_STATUS_CYCLE_TIME_MS (20u)
#define PRIMARY_HANDCART_SETTINGS_CYCLE_TIME_MS (200u)
#define PRIMARY_HANDCART_SET_SETTINGS_CYCLE_TIME_MS (200u)
#define PRIMARY_ECU_STATUS_CYCLE_TIME_MS (20u)
#define PRIMARY_ECU_SET_STATUS_CYCLE_TIME_MS (50u)
#define PRIMARY_ECU_INVERTER_STATUS_CYCLE_TIME_MS (50u)
#define PRIMARY_ECU_CONTROL_STATUS_CYCLE_TIME_MS (50u)
#define PRIMARY_ECU_ERRORS_CYCLE_TIME_MS (20u)
#define PRIMARY_ECU_FEEDBACKS_CYCLE_TIME_MS (50u)
#define PRIMARY_ECU_POWER_MAPS_CYCLE_TIME_MS (200u)
#define PRIMARY_ECU_SET_POWER_MAPS_CYCLE_TIME_MS (200u)
#define PRIMARY_ECU_PTT_STATUS_CYCLE_TIME_MS (200u)
#define PRIMARY_ECU_SET_PTT_STATUS_CYCLE_TIME_MS (200u)
#define PRIMARY_INV_L_REQUEST_CYCLE_TIME_MS (10u)
#define PRIMARY_CONTROL_OUTPUT_CYCLE_TIME_MS (20u)
#define PRIMARY_CONTROL_STATUS_CYCLE_TIME_MS (20u)
#define PRIMARY_INV_R_REQUEST_CYCLE_TIME_MS (10u)
#define PRIMARY_INV_L_RESPONSE_CYCLE_TIME_MS (100u)
#define PRIMARY_INV_R_RESPONSE_CYCLE_TIME_MS (100u)
#define PRIMARY_LV_CURRENT_BATTERY_CYCLE_TIME_MS (50u)
#define PRIMARY_LV_CURRENT_CHARGER_CYCLE_TIME_MS (50u)
#define PRIMARY_LV_TOTAL_VOLTAGE_CYCLE_TIME_MS (50u)
#define PRIMARY_LV_CELLS_VOLTAGE_CYCLE_TIME_MS (50u)
#define PRIMARY_LV_CELLS_VOLTAGE_STATS_CYCLE_TIME_MS (50u)
#define PRIMARY_LV_CELLS_TEMP_CYCLE_TIME_MS (50u)
#define PRIMARY_LV_CELLS_TEMP_STATS_CYCLE_TIME_MS (50u)
#define PRIMARY_HV_CURRENT_CYCLE_TIME_MS (50u)
#define PRIMARY_HV_POWER_CYCLE_TIME_MS (50u)
#define PRIMARY_HV_ENERGY_CYCLE_TIME_MS (50u)
#define PRIMARY_HV_SOC_CYCLE_TIME_MS (50u)
#define PRIMARY_HV_TOTAL_VOLTAGE_CYCLE_TIME_MS (50u)
#define PRIMARY_HV_CELLS_VOLTAGE_CYCLE_TIME_MS (50u)
#define PRIMARY_HV_CELLS_VOLTAGE_STATS_CYCLE_TIME_MS (50u)
#define PRIMARY_HV_CELLS_TEMP_CYCLE_TIME_MS (50u)
#define PRIMARY_HV_CELLS_TEMP_STATS_CYCLE_TIME_MS (50u)
#define PRIMARY_ECU_STEER_ACTUATOR_STATUS_CYCLE_TIME_MS (200u)
#define PRIMARY_ECU_SET_STEER_ACTUATOR_STATUS_STEERING_WHEEL_CYCLE_TIME_MS (200u)
#define PRIMARY_ECU_SET_STEER_ACTUATOR_STATUS_TLM_CYCLE_TIME_MS (200u)
#define PRIMARY_ECU_STEER_ACTUATOR_CURRENT_CYCLE_TIME_MS (200u)
#define PRIMARY_DEBUG_SIGNAL_CRASH_DEBUG_CYCLE_TIME_MS (10u)
#define PRIMARY_DEBUG_SIGNAL_CRASH_DEBUG_ACK_CYCLE_TIME_MS (10u)
#define PRIMARY_DEBUG_SIGNAL_1_CYCLE_TIME_MS (20u)
#define PRIMARY_DEBUG_SIGNAL_2_CYCLE_TIME_MS (20u)
#define PRIMARY_NLG5_DIAG_TX_CYCLE_TIME_MS (PRIMARY_ONESHOT)
#define PRIMARY_NLG5_DIAG_RX_CYCLE_TIME_MS (PRIMARY_ONESHOT)
#define PRIMARY_NLG5_ERR_CYCLE_TIME_MS (PRIMARY_ONESHOT)
#define PRIMARY_NLG5_TEMP_CYCLE_TIME_MS (PRIMARY_ONESHOT)
#define PRIMARY_NLG5_ACT_II_CYCLE_TIME_MS (PRIMARY_ONESHOT)
#define PRIMARY_NLG5_ACT_I_CYCLE_TIME_MS (PRIMARY_ONESHOT)
#define PRIMARY_NLG5_ST_CYCLE_TIME_MS (PRIMARY_ONESHOT)
#define PRIMARY_NLG5_CTL_CYCLE_TIME_MS (PRIMARY_ONESHOT)
#define PRIMARY_HV_JMP_TO_BLT_CYCLE_TIME_MS (PRIMARY_ONESHOT)
#define PRIMARY_HV_FLASH_MAINBOARD_TX_CYCLE_TIME_MS (PRIMARY_ONESHOT)
#define PRIMARY_HV_FLASH_MAINBOARD_RX_CYCLE_TIME_MS (PRIMARY_ONESHOT)
#define PRIMARY_HV_FLASH_CELLBOARD_0_TX_CYCLE_TIME_MS (PRIMARY_ONESHOT)
#define PRIMARY_HV_FLASH_CELLBOARD_0_RX_CYCLE_TIME_MS (PRIMARY_ONESHOT)
#define PRIMARY_HV_FLASH_CELLBOARD_1_TX_CYCLE_TIME_MS (PRIMARY_ONESHOT)
#define PRIMARY_HV_FLASH_CELLBOARD_1_RX_CYCLE_TIME_MS (PRIMARY_ONESHOT)
#define PRIMARY_HV_FLASH_CELLBOARD_2_TX_CYCLE_TIME_MS (PRIMARY_ONESHOT)
#define PRIMARY_HV_FLASH_CELLBOARD_2_RX_CYCLE_TIME_MS (PRIMARY_ONESHOT)
#define PRIMARY_HV_FLASH_CELLBOARD_3_TX_CYCLE_TIME_MS (PRIMARY_ONESHOT)
#define PRIMARY_HV_FLASH_CELLBOARD_3_RX_CYCLE_TIME_MS (PRIMARY_ONESHOT)
#define PRIMARY_HV_FLASH_CELLBOARD_4_TX_CYCLE_TIME_MS (PRIMARY_ONESHOT)
#define PRIMARY_HV_FLASH_CELLBOARD_4_RX_CYCLE_TIME_MS (PRIMARY_ONESHOT)
#define PRIMARY_HV_FLASH_CELLBOARD_5_TX_CYCLE_TIME_MS (PRIMARY_ONESHOT)
#define PRIMARY_HV_FLASH_CELLBOARD_5_RX_CYCLE_TIME_MS (PRIMARY_ONESHOT)
#define PRIMARY_LV_JMP_TO_BLT_CYCLE_TIME_MS (PRIMARY_ONESHOT)
#define PRIMARY_LV_FLASH_TX_CYCLE_TIME_MS (PRIMARY_ONESHOT)
#define PRIMARY_LV_FLASH_RX_CYCLE_TIME_MS (PRIMARY_ONESHOT)
#define PRIMARY_ECU_JMP_TO_BLT_CYCLE_TIME_MS (PRIMARY_ONESHOT)
#define PRIMARY_ECU_FLASH_TX_CYCLE_TIME_MS (PRIMARY_ONESHOT)
#define PRIMARY_ECU_FLASH_RX_CYCLE_TIME_MS (PRIMARY_ONESHOT)
#define PRIMARY_STEERING_WHEEL_JMP_TO_BLT_CYCLE_TIME_MS (PRIMARY_ONESHOT)
#define PRIMARY_STEERING_WHEEL_FLASH_TX_CYCLE_TIME_MS (PRIMARY_ONESHOT)
#define PRIMARY_STEERING_WHEEL_FLASH_RX_CYCLE_TIME_MS (PRIMARY_ONESHOT)
#define PRIMARY_LV_CAN_FLASH_REQ_TLM_CYCLE_TIME_MS (PRIMARY_ONESHOT)
#define PRIMARY_LV_CAN_FLASH_REQ_STEERING_WHEEL_CYCLE_TIME_MS (PRIMARY_ONESHOT)
#define PRIMARY_LV_CAN_FLASH_ACK_CYCLE_TIME_MS (PRIMARY_ONESHOT)

/* Topics masks */
/* TOPIC FIXED_IDS */
#define PRIMARY_TOPIC_MASK_FIXED_IDS 0b00000011111

#define PRIMARY_ID_HV_JMP_TO_BLT 0x0 // dec: 0 bin: 0b00000000000
#define PRIMARY_ID_HV_FLASH_MAINBOARD_TX 0x1 // dec: 1 bin: 0b00000000001
#define PRIMARY_ID_HV_FLASH_MAINBOARD_RX 0x2 // dec: 2 bin: 0b00000000010
#define PRIMARY_ID_HV_FLASH_CELLBOARD_0_TX 0x4 // dec: 4 bin: 0b00000000100
#define PRIMARY_ID_HV_FLASH_CELLBOARD_0_RX 0x5 // dec: 5 bin: 0b00000000101
#define PRIMARY_ID_HV_FLASH_CELLBOARD_1_TX 0x6 // dec: 6 bin: 0b00000000110
#define PRIMARY_ID_HV_FLASH_CELLBOARD_1_RX 0x7 // dec: 7 bin: 0b00000000111
#define PRIMARY_ID_HV_FLASH_CELLBOARD_2_TX 0x8 // dec: 8 bin: 0b00000001000
#define PRIMARY_ID_HV_FLASH_CELLBOARD_2_RX 0x9 // dec: 9 bin: 0b00000001001
#define PRIMARY_ID_HV_FLASH_CELLBOARD_3_TX 0xA // dec: 10 bin: 0b00000001010
#define PRIMARY_ID_HV_FLASH_CELLBOARD_3_RX 0xB // dec: 11 bin: 0b00000001011
#define PRIMARY_ID_HV_FLASH_CELLBOARD_4_TX 0xC // dec: 12 bin: 0b00000001100
#define PRIMARY_ID_HV_FLASH_CELLBOARD_4_RX 0xD // dec: 13 bin: 0b00000001101
#define PRIMARY_ID_HV_FLASH_CELLBOARD_5_TX 0xE // dec: 14 bin: 0b00000001110
#define PRIMARY_ID_HV_FLASH_CELLBOARD_5_RX 0xF // dec: 15 bin: 0b00000001111
#define PRIMARY_ID_LV_JMP_TO_BLT 0x10 // dec: 16 bin: 0b00000010000
#define PRIMARY_ID_LV_FLASH_TX 0x11 // dec: 17 bin: 0b00000010001
#define PRIMARY_ID_LV_FLASH_RX 0x12 // dec: 18 bin: 0b00000010010
#define PRIMARY_ID_ECU_JMP_TO_BLT 0x13 // dec: 19 bin: 0b00000010011
#define PRIMARY_ID_ECU_FLASH_TX 0x14 // dec: 20 bin: 0b00000010100
#define PRIMARY_ID_ECU_FLASH_RX 0x15 // dec: 21 bin: 0b00000010101
#define PRIMARY_ID_STEERING_WHEEL_JMP_TO_BLT 0x16 // dec: 22 bin: 0b00000010110
#define PRIMARY_ID_STEERING_WHEEL_FLASH_TX 0x17 // dec: 23 bin: 0b00000010111
#define PRIMARY_ID_STEERING_WHEEL_FLASH_RX 0x18 // dec: 24 bin: 0b00000011000
#define PRIMARY_ID_STEERING_WHEEL_VERSION 0x2BC // dec: 700 bin: 0b01010111100
#define PRIMARY_ID_ECU_VERSION 0x2BD // dec: 701 bin: 0b01010111101
#define PRIMARY_ID_LV_VERSION 0x2BF // dec: 703 bin: 0b01010111111
#define PRIMARY_ID_TLM_VERSION 0x2C0 // dec: 704 bin: 0b01011000000
#define PRIMARY_ID_HV_MAINBOARD_VERSION 0x2BE // dec: 702 bin: 0b01010111110
#define PRIMARY_ID_HV_CELLBOARD_VERSION 0x2C1 // dec: 705 bin: 0b01011000001
#define PRIMARY_ID_INV_L_REQUEST 0x201 // dec: 513 bin: 0b01000000001
#define PRIMARY_ID_INV_R_REQUEST 0x202 // dec: 514 bin: 0b01000000010
#define PRIMARY_ID_INV_L_RESPONSE 0x181 // dec: 385 bin: 0b00110000001
#define PRIMARY_ID_INV_R_RESPONSE 0x182 // dec: 386 bin: 0b00110000010

/* TOPIC HYDRA */
#define PRIMARY_TOPIC_MASK_HYDRA 0b00000011111

#define PRIMARY_TOPIC_FILTER_HYDRA 0x0 // dec: 0 bin: 0b00000000000

#define PRIMARY_ID_HV_ERRORS 0x20 // dec: 32 bin: 0b00000100000
#define PRIMARY_ID_HV_DEBUG_SIGNALS 0x200 // dec: 512 bin: 0b01000000000
#define PRIMARY_ID_HV_FANS_STATUS 0x600 // dec: 1536 bin: 0b11000000000
#define PRIMARY_ID_HV_SET_FANS_STATUS 0x400 // dec: 1024 bin: 0b10000000000
#define PRIMARY_ID_HV_FEEDBACK_STATUS 0x208 // dec: 520 bin: 0b01000001000
#define PRIMARY_ID_HV_FEEDBACK_TS_VOLTAGE 0x210 // dec: 528 bin: 0b01000010000
#define PRIMARY_ID_HV_FEEDBACK_MISC_VOLTAGE 0x218 // dec: 536 bin: 0b01000011000
#define PRIMARY_ID_HV_FEEDBACK_SD_VOLTAGE 0x220 // dec: 544 bin: 0b01000100000
#define PRIMARY_ID_HV_IMD_STATUS 0x228 // dec: 552 bin: 0b01000101000
#define PRIMARY_ID_HV_STATUS 0x230 // dec: 560 bin: 0b01000110000
#define PRIMARY_ID_HV_SET_STATUS_ECU 0x28 // dec: 40 bin: 0b00000101000
#define PRIMARY_ID_HV_SET_STATUS_HANDCART 0x30 // dec: 48 bin: 0b00000110000
#define PRIMARY_ID_HV_BALANCING_STATUS 0x608 // dec: 1544 bin: 0b11000001000
#define PRIMARY_ID_HV_SET_BALANCING_STATUS_HANDCART 0x408 // dec: 1032 bin: 0b10000001000
#define PRIMARY_ID_HV_SET_BALANCING_STATUS_STEERING_WHEEL 0x410 // dec: 1040 bin: 0b10000010000
#define PRIMARY_ID_LV_STATUS 0x238 // dec: 568 bin: 0b01000111000
#define PRIMARY_ID_LV_RADIATOR_SPEED 0x620 // dec: 1568 bin: 0b11000100000
#define PRIMARY_ID_LV_PUMPS_SPEED 0x628 // dec: 1576 bin: 0b11000101000
#define PRIMARY_ID_LV_SET_RADIATOR_SPEED 0x418 // dec: 1048 bin: 0b10000011000
#define PRIMARY_ID_LV_SET_PUMPS_SPEED 0x420 // dec: 1056 bin: 0b10000100000
#define PRIMARY_ID_LV_ERRORS 0x240 // dec: 576 bin: 0b01001000000
#define PRIMARY_ID_LV_FEEDBACK_TS_VOLTAGE 0x248 // dec: 584 bin: 0b01001001000
#define PRIMARY_ID_LV_FEEDBACK_SD_VOLTAGE 0x250 // dec: 592 bin: 0b01001010000
#define PRIMARY_ID_LV_FEEDBACK_ENCLOSURE_VOLTAGE 0x258 // dec: 600 bin: 0b01001011000
#define PRIMARY_ID_LV_FEEDBACK_GPIO_EXTENDER 0x260 // dec: 608 bin: 0b01001100000
#define PRIMARY_ID_LV_CAN_FLASH_REQ_TLM 0x38 // dec: 56 bin: 0b00000111000
#define PRIMARY_ID_LV_CAN_FLASH_REQ_STEERING_WHEEL 0x40 // dec: 64 bin: 0b00001000000
#define PRIMARY_ID_LV_CAN_FLASH_ACK 0x48 // dec: 72 bin: 0b00001001000
#define PRIMARY_ID_LV_INVERTER_CONNECTION_STATUS 0x268 // dec: 616 bin: 0b01001101000
#define PRIMARY_ID_LV_SET_INVERTER_CONNECTION_STATUS 0x50 // dec: 80 bin: 0b00001010000
#define PRIMARY_ID_TLM_STATUS 0x630 // dec: 1584 bin: 0b11000110000
#define PRIMARY_ID_TLM_SET_STATUS 0x428 // dec: 1064 bin: 0b10000101000
#define PRIMARY_ID_HANDCART_STATUS 0x270 // dec: 624 bin: 0b01001110000
#define PRIMARY_ID_HANDCART_SETTINGS 0x638 // dec: 1592 bin: 0b11000111000
#define PRIMARY_ID_HANDCART_SET_SETTINGS 0x430 // dec: 1072 bin: 0b10000110000
#define PRIMARY_ID_ECU_STATUS 0x278 // dec: 632 bin: 0b01001111000
#define PRIMARY_ID_ECU_SET_STATUS 0x58 // dec: 88 bin: 0b00001011000
#define PRIMARY_ID_ECU_INVERTER_STATUS 0x438 // dec: 1080 bin: 0b10000111000
#define PRIMARY_ID_ECU_CONTROL_STATUS 0x280 // dec: 640 bin: 0b01010000000
#define PRIMARY_ID_ECU_ERRORS 0x288 // dec: 648 bin: 0b01010001000
#define PRIMARY_ID_ECU_FEEDBACKS 0x290 // dec: 656 bin: 0b01010010000
#define PRIMARY_ID_ECU_POWER_MAPS 0x298 // dec: 664 bin: 0b01010011000
#define PRIMARY_ID_ECU_SET_POWER_MAPS 0x60 // dec: 96 bin: 0b00001100000
#define PRIMARY_ID_ECU_PTT_STATUS 0x640 // dec: 1600 bin: 0b11001000000
#define PRIMARY_ID_ECU_SET_PTT_STATUS 0x440 // dec: 1088 bin: 0b10001000000
#define PRIMARY_ID_CONTROL_OUTPUT 0x2A0 // dec: 672 bin: 0b01010100000
#define PRIMARY_ID_CONTROL_STATUS 0x2A8 // dec: 680 bin: 0b01010101000
#define PRIMARY_ID_LV_CURRENT_BATTERY 0x648 // dec: 1608 bin: 0b11001001000
#define PRIMARY_ID_LV_CURRENT_CHARGER 0x650 // dec: 1616 bin: 0b11001010000
#define PRIMARY_ID_LV_TOTAL_VOLTAGE 0x658 // dec: 1624 bin: 0b11001011000
#define PRIMARY_ID_LV_CELLS_VOLTAGE 0x660 // dec: 1632 bin: 0b11001100000
#define PRIMARY_ID_LV_CELLS_VOLTAGE_STATS 0x668 // dec: 1640 bin: 0b11001101000
#define PRIMARY_ID_LV_CELLS_TEMP 0x670 // dec: 1648 bin: 0b11001110000
#define PRIMARY_ID_LV_CELLS_TEMP_STATS 0x678 // dec: 1656 bin: 0b11001111000
#define PRIMARY_ID_HV_CURRENT 0x680 // dec: 1664 bin: 0b11010000000
#define PRIMARY_ID_HV_POWER 0x688 // dec: 1672 bin: 0b11010001000
#define PRIMARY_ID_HV_ENERGY 0x690 // dec: 1680 bin: 0b11010010000
#define PRIMARY_ID_HV_SOC 0x698 // dec: 1688 bin: 0b11010011000
#define PRIMARY_ID_HV_TOTAL_VOLTAGE 0x6A0 // dec: 1696 bin: 0b11010100000
#define PRIMARY_ID_HV_CELLS_VOLTAGE 0x6A8 // dec: 1704 bin: 0b11010101000
#define PRIMARY_ID_HV_CELLS_VOLTAGE_STATS 0x6B0 // dec: 1712 bin: 0b11010110000
#define PRIMARY_ID_HV_CELLS_TEMP 0x6B8 // dec: 1720 bin: 0b11010111000
#define PRIMARY_ID_HV_CELLS_TEMP_STATS 0x6C0 // dec: 1728 bin: 0b11011000000
#define PRIMARY_ID_ECU_STEER_ACTUATOR_STATUS 0x6C8 // dec: 1736 bin: 0b11011001000
#define PRIMARY_ID_ECU_SET_STEER_ACTUATOR_STATUS_STEERING_WHEEL 0x448 // dec: 1096 bin: 0b10001001000
#define PRIMARY_ID_ECU_SET_STEER_ACTUATOR_STATUS_TLM 0x450 // dec: 1104 bin: 0b10001010000
#define PRIMARY_ID_ECU_STEER_ACTUATOR_CURRENT 0x6D0 // dec: 1744 bin: 0b11011010000
#define PRIMARY_ID_DEBUG_SIGNAL_CRASH_DEBUG 0x6D8 // dec: 1752 bin: 0b11011011000
#define PRIMARY_ID_DEBUG_SIGNAL_CRASH_DEBUG_ACK 0x6E0 // dec: 1760 bin: 0b11011100000
#define PRIMARY_ID_DEBUG_SIGNAL_1 0x6E8 // dec: 1768 bin: 0b11011101000
#define PRIMARY_ID_DEBUG_SIGNAL_2 0x6F0 // dec: 1776 bin: 0b11011110000



/* Signal choices. */
#define PRIMARY_HV_JMP_TO_BLT_FORWARD_OFF_CHOICE (0u)
#define PRIMARY_HV_JMP_TO_BLT_FORWARD_ON_CHOICE (1u)

#define PRIMARY_HV_JMP_TO_BLT_CELLBOARD_ID_CELLBOARD_0_CHOICE (0u)
#define PRIMARY_HV_JMP_TO_BLT_CELLBOARD_ID_CELLBOARD_1_CHOICE (1u)
#define PRIMARY_HV_JMP_TO_BLT_CELLBOARD_ID_CELLBOARD_2_CHOICE (2u)
#define PRIMARY_HV_JMP_TO_BLT_CELLBOARD_ID_CELLBOARD_3_CHOICE (3u)
#define PRIMARY_HV_JMP_TO_BLT_CELLBOARD_ID_CELLBOARD_4_CHOICE (4u)
#define PRIMARY_HV_JMP_TO_BLT_CELLBOARD_ID_CELLBOARD_5_CHOICE (5u)

#define PRIMARY_HV_CELLBOARD_VERSION_CELLBOARD_ID_CELLBOARD_0_CHOICE (0u)
#define PRIMARY_HV_CELLBOARD_VERSION_CELLBOARD_ID_CELLBOARD_1_CHOICE (1u)
#define PRIMARY_HV_CELLBOARD_VERSION_CELLBOARD_ID_CELLBOARD_2_CHOICE (2u)
#define PRIMARY_HV_CELLBOARD_VERSION_CELLBOARD_ID_CELLBOARD_3_CHOICE (3u)
#define PRIMARY_HV_CELLBOARD_VERSION_CELLBOARD_ID_CELLBOARD_4_CHOICE (4u)
#define PRIMARY_HV_CELLBOARD_VERSION_CELLBOARD_ID_CELLBOARD_5_CHOICE (5u)

#define PRIMARY_HV_FANS_STATUS_FANS_OVERRIDE_OFF_CHOICE (0u)
#define PRIMARY_HV_FANS_STATUS_FANS_OVERRIDE_ON_CHOICE (1u)

#define PRIMARY_HV_SET_FANS_STATUS_FANS_OVERRIDE_OFF_CHOICE (0u)
#define PRIMARY_HV_SET_FANS_STATUS_FANS_OVERRIDE_ON_CHOICE (1u)

#define PRIMARY_HV_FEEDBACK_STATUS_FEEDBACK_IMPLAUSIBILITY_DETECTED_FEEDBACK_STATE_LOW_CHOICE (0u)
#define PRIMARY_HV_FEEDBACK_STATUS_FEEDBACK_IMPLAUSIBILITY_DETECTED_FEEDBACK_STATE_ERROR_CHOICE (1u)
#define PRIMARY_HV_FEEDBACK_STATUS_FEEDBACK_IMPLAUSIBILITY_DETECTED_FEEDBACK_STATE_HIGH_CHOICE (2u)

#define PRIMARY_HV_FEEDBACK_STATUS_FEEDBACK_IMD_COCKPIT_FEEDBACK_STATE_LOW_CHOICE (0u)
#define PRIMARY_HV_FEEDBACK_STATUS_FEEDBACK_IMD_COCKPIT_FEEDBACK_STATE_ERROR_CHOICE (1u)
#define PRIMARY_HV_FEEDBACK_STATUS_FEEDBACK_IMD_COCKPIT_FEEDBACK_STATE_HIGH_CHOICE (2u)

#define PRIMARY_HV_FEEDBACK_STATUS_FEEDBACK_TSAL_GREEN_FAULT_LATCHED_FEEDBACK_STATE_LOW_CHOICE (0u)
#define PRIMARY_HV_FEEDBACK_STATUS_FEEDBACK_TSAL_GREEN_FAULT_LATCHED_FEEDBACK_STATE_ERROR_CHOICE (1u)
#define PRIMARY_HV_FEEDBACK_STATUS_FEEDBACK_TSAL_GREEN_FAULT_LATCHED_FEEDBACK_STATE_HIGH_CHOICE (2u)

#define PRIMARY_HV_FEEDBACK_STATUS_FEEDBACK_BMS_COCKPIT_FEEDBACK_STATE_LOW_CHOICE (0u)
#define PRIMARY_HV_FEEDBACK_STATUS_FEEDBACK_BMS_COCKPIT_FEEDBACK_STATE_ERROR_CHOICE (1u)
#define PRIMARY_HV_FEEDBACK_STATUS_FEEDBACK_BMS_COCKPIT_FEEDBACK_STATE_HIGH_CHOICE (2u)

#define PRIMARY_HV_FEEDBACK_STATUS_FEEDBACK_EXT_LATCHED_FEEDBACK_STATE_LOW_CHOICE (0u)
#define PRIMARY_HV_FEEDBACK_STATUS_FEEDBACK_EXT_LATCHED_FEEDBACK_STATE_ERROR_CHOICE (1u)
#define PRIMARY_HV_FEEDBACK_STATUS_FEEDBACK_EXT_LATCHED_FEEDBACK_STATE_HIGH_CHOICE (2u)

#define PRIMARY_HV_FEEDBACK_STATUS_FEEDBACK_TSAL_GREEN_FEEDBACK_STATE_LOW_CHOICE (0u)
#define PRIMARY_HV_FEEDBACK_STATUS_FEEDBACK_TSAL_GREEN_FEEDBACK_STATE_ERROR_CHOICE (1u)
#define PRIMARY_HV_FEEDBACK_STATUS_FEEDBACK_TSAL_GREEN_FEEDBACK_STATE_HIGH_CHOICE (2u)

#define PRIMARY_HV_FEEDBACK_STATUS_FEEDBACK_TS_OVER_60V_STATUS_FEEDBACK_STATE_LOW_CHOICE (0u)
#define PRIMARY_HV_FEEDBACK_STATUS_FEEDBACK_TS_OVER_60V_STATUS_FEEDBACK_STATE_ERROR_CHOICE (1u)
#define PRIMARY_HV_FEEDBACK_STATUS_FEEDBACK_TS_OVER_60V_STATUS_FEEDBACK_STATE_HIGH_CHOICE (2u)

#define PRIMARY_HV_FEEDBACK_STATUS_FEEDBACK_AIRN_STATUS_FEEDBACK_STATE_LOW_CHOICE (0u)
#define PRIMARY_HV_FEEDBACK_STATUS_FEEDBACK_AIRN_STATUS_FEEDBACK_STATE_ERROR_CHOICE (1u)
#define PRIMARY_HV_FEEDBACK_STATUS_FEEDBACK_AIRN_STATUS_FEEDBACK_STATE_HIGH_CHOICE (2u)

#define PRIMARY_HV_FEEDBACK_STATUS_FEEDBACK_AIRP_STATUS_FEEDBACK_STATE_LOW_CHOICE (0u)
#define PRIMARY_HV_FEEDBACK_STATUS_FEEDBACK_AIRP_STATUS_FEEDBACK_STATE_ERROR_CHOICE (1u)
#define PRIMARY_HV_FEEDBACK_STATUS_FEEDBACK_AIRP_STATUS_FEEDBACK_STATE_HIGH_CHOICE (2u)

#define PRIMARY_HV_FEEDBACK_STATUS_FEEDBACK_AIRP_GATE_FEEDBACK_STATE_LOW_CHOICE (0u)
#define PRIMARY_HV_FEEDBACK_STATUS_FEEDBACK_AIRP_GATE_FEEDBACK_STATE_ERROR_CHOICE (1u)
#define PRIMARY_HV_FEEDBACK_STATUS_FEEDBACK_AIRP_GATE_FEEDBACK_STATE_HIGH_CHOICE (2u)

#define PRIMARY_HV_FEEDBACK_STATUS_FEEDBACK_AIRN_GATE_FEEDBACK_STATE_LOW_CHOICE (0u)
#define PRIMARY_HV_FEEDBACK_STATUS_FEEDBACK_AIRN_GATE_FEEDBACK_STATE_ERROR_CHOICE (1u)
#define PRIMARY_HV_FEEDBACK_STATUS_FEEDBACK_AIRN_GATE_FEEDBACK_STATE_HIGH_CHOICE (2u)

#define PRIMARY_HV_FEEDBACK_STATUS_FEEDBACK_PRECHARGE_STATUS_FEEDBACK_STATE_LOW_CHOICE (0u)
#define PRIMARY_HV_FEEDBACK_STATUS_FEEDBACK_PRECHARGE_STATUS_FEEDBACK_STATE_ERROR_CHOICE (1u)
#define PRIMARY_HV_FEEDBACK_STATUS_FEEDBACK_PRECHARGE_STATUS_FEEDBACK_STATE_HIGH_CHOICE (2u)

#define PRIMARY_HV_FEEDBACK_STATUS_FEEDBACK_TSP_OVER_60V_STATUS_FEEDBACK_STATE_LOW_CHOICE (0u)
#define PRIMARY_HV_FEEDBACK_STATUS_FEEDBACK_TSP_OVER_60V_STATUS_FEEDBACK_STATE_ERROR_CHOICE (1u)
#define PRIMARY_HV_FEEDBACK_STATUS_FEEDBACK_TSP_OVER_60V_STATUS_FEEDBACK_STATE_HIGH_CHOICE (2u)

#define PRIMARY_HV_FEEDBACK_STATUS_FEEDBACK_IMD_FAULT_FEEDBACK_STATE_LOW_CHOICE (0u)
#define PRIMARY_HV_FEEDBACK_STATUS_FEEDBACK_IMD_FAULT_FEEDBACK_STATE_ERROR_CHOICE (1u)
#define PRIMARY_HV_FEEDBACK_STATUS_FEEDBACK_IMD_FAULT_FEEDBACK_STATE_HIGH_CHOICE (2u)

#define PRIMARY_HV_FEEDBACK_STATUS_FEEDBACK_CHECK_MUX_FEEDBACK_STATE_LOW_CHOICE (0u)
#define PRIMARY_HV_FEEDBACK_STATUS_FEEDBACK_CHECK_MUX_FEEDBACK_STATE_ERROR_CHOICE (1u)
#define PRIMARY_HV_FEEDBACK_STATUS_FEEDBACK_CHECK_MUX_FEEDBACK_STATE_HIGH_CHOICE (2u)

#define PRIMARY_HV_FEEDBACK_STATUS_FEEDBACK_SD_END_FEEDBACK_STATE_LOW_CHOICE (0u)
#define PRIMARY_HV_FEEDBACK_STATUS_FEEDBACK_SD_END_FEEDBACK_STATE_ERROR_CHOICE (1u)
#define PRIMARY_HV_FEEDBACK_STATUS_FEEDBACK_SD_END_FEEDBACK_STATE_HIGH_CHOICE (2u)

#define PRIMARY_HV_FEEDBACK_STATUS_FEEDBACK_SD_OUT_FEEDBACK_STATE_LOW_CHOICE (0u)
#define PRIMARY_HV_FEEDBACK_STATUS_FEEDBACK_SD_OUT_FEEDBACK_STATE_ERROR_CHOICE (1u)
#define PRIMARY_HV_FEEDBACK_STATUS_FEEDBACK_SD_OUT_FEEDBACK_STATE_HIGH_CHOICE (2u)

#define PRIMARY_HV_FEEDBACK_STATUS_FEEDBACK_SD_IN_FEEDBACK_STATE_LOW_CHOICE (0u)
#define PRIMARY_HV_FEEDBACK_STATUS_FEEDBACK_SD_IN_FEEDBACK_STATE_ERROR_CHOICE (1u)
#define PRIMARY_HV_FEEDBACK_STATUS_FEEDBACK_SD_IN_FEEDBACK_STATE_HIGH_CHOICE (2u)

#define PRIMARY_HV_FEEDBACK_STATUS_FEEDBACK_SD_BMS_FEEDBACK_STATE_LOW_CHOICE (0u)
#define PRIMARY_HV_FEEDBACK_STATUS_FEEDBACK_SD_BMS_FEEDBACK_STATE_ERROR_CHOICE (1u)
#define PRIMARY_HV_FEEDBACK_STATUS_FEEDBACK_SD_BMS_FEEDBACK_STATE_HIGH_CHOICE (2u)

#define PRIMARY_HV_FEEDBACK_STATUS_FEEDBACK_SD_IMD_FEEDBACK_STATE_LOW_CHOICE (0u)
#define PRIMARY_HV_FEEDBACK_STATUS_FEEDBACK_SD_IMD_FEEDBACK_STATE_ERROR_CHOICE (1u)
#define PRIMARY_HV_FEEDBACK_STATUS_FEEDBACK_SD_IMD_FEEDBACK_STATE_HIGH_CHOICE (2u)

#define PRIMARY_HV_IMD_STATUS_IMD_STATUS_SC_CHOICE (0u)
#define PRIMARY_HV_IMD_STATUS_IMD_STATUS_NORMAL_CHOICE (1u)
#define PRIMARY_HV_IMD_STATUS_IMD_STATUS_UNDER_VOLTAGE_CHOICE (2u)
#define PRIMARY_HV_IMD_STATUS_IMD_STATUS_START_MEASURE_CHOICE (3u)
#define PRIMARY_HV_IMD_STATUS_IMD_STATUS_DEVICE_ERROR_CHOICE (4u)
#define PRIMARY_HV_IMD_STATUS_IMD_STATUS_EARTH_FAULT_CHOICE (5u)

#define PRIMARY_HV_STATUS_STATUS_INIT_CHOICE (0u)
#define PRIMARY_HV_STATUS_STATUS_IDLE_CHOICE (1u)
#define PRIMARY_HV_STATUS_STATUS_AIRN_CLOSE_CHOICE (2u)
#define PRIMARY_HV_STATUS_STATUS_PRECHARGE_CHOICE (3u)
#define PRIMARY_HV_STATUS_STATUS_AIRP_CLOSE_CHOICE (4u)
#define PRIMARY_HV_STATUS_STATUS_TS_ON_CHOICE (5u)
#define PRIMARY_HV_STATUS_STATUS_FATAL_ERROR_CHOICE (6u)

#define PRIMARY_HV_SET_STATUS_ECU_HV_STATUS_SET_OFF_CHOICE (0u)
#define PRIMARY_HV_SET_STATUS_ECU_HV_STATUS_SET_ON_CHOICE (1u)

#define PRIMARY_HV_SET_STATUS_HANDCART_HV_STATUS_SET_OFF_CHOICE (0u)
#define PRIMARY_HV_SET_STATUS_HANDCART_HV_STATUS_SET_ON_CHOICE (1u)

#define PRIMARY_HV_BALANCING_STATUS_CELLBOARD_ID_CELLBOARD_0_CHOICE (0u)
#define PRIMARY_HV_BALANCING_STATUS_CELLBOARD_ID_CELLBOARD_1_CHOICE (1u)
#define PRIMARY_HV_BALANCING_STATUS_CELLBOARD_ID_CELLBOARD_2_CHOICE (2u)
#define PRIMARY_HV_BALANCING_STATUS_CELLBOARD_ID_CELLBOARD_3_CHOICE (3u)
#define PRIMARY_HV_BALANCING_STATUS_CELLBOARD_ID_CELLBOARD_4_CHOICE (4u)
#define PRIMARY_HV_BALANCING_STATUS_CELLBOARD_ID_CELLBOARD_5_CHOICE (5u)

#define PRIMARY_HV_BALANCING_STATUS_BALANCING_STATUS_OFF_CHOICE (0u)
#define PRIMARY_HV_BALANCING_STATUS_BALANCING_STATUS_ON_CHOICE (1u)

#define PRIMARY_HV_SET_BALANCING_STATUS_HANDCART_SET_BALANCING_STATUS_OFF_CHOICE (0u)
#define PRIMARY_HV_SET_BALANCING_STATUS_HANDCART_SET_BALANCING_STATUS_ON_CHOICE (1u)

#define PRIMARY_HV_SET_BALANCING_STATUS_STEERING_WHEEL_SET_BALANCING_STATUS_OFF_CHOICE (0u)
#define PRIMARY_HV_SET_BALANCING_STATUS_STEERING_WHEEL_SET_BALANCING_STATUS_ON_CHOICE (1u)

#define PRIMARY_LV_STATUS_STATUS_INIT_CHOICE (0u)
#define PRIMARY_LV_STATUS_STATUS_IDLE_CHOICE (1u)
#define PRIMARY_LV_STATUS_STATUS_TSON_CHOICE (2u)
#define PRIMARY_LV_STATUS_STATUS_RUN_CHOICE (3u)
#define PRIMARY_LV_STATUS_STATUS_FLASHING_CHOICE (4u)
#define PRIMARY_LV_STATUS_STATUS_ERROR_CHOICE (5u)

#define PRIMARY_LV_RADIATOR_SPEED_STATUS_OFF_CHOICE (0u)
#define PRIMARY_LV_RADIATOR_SPEED_STATUS_AUTO_CHOICE (1u)
#define PRIMARY_LV_RADIATOR_SPEED_STATUS_MANUAL_CHOICE (2u)

#define PRIMARY_LV_PUMPS_SPEED_STATUS_OFF_CHOICE (0u)
#define PRIMARY_LV_PUMPS_SPEED_STATUS_AUTO_CHOICE (1u)
#define PRIMARY_LV_PUMPS_SPEED_STATUS_MANUAL_CHOICE (2u)

#define PRIMARY_LV_SET_RADIATOR_SPEED_STATUS_OFF_CHOICE (0u)
#define PRIMARY_LV_SET_RADIATOR_SPEED_STATUS_AUTO_CHOICE (1u)
#define PRIMARY_LV_SET_RADIATOR_SPEED_STATUS_MANUAL_CHOICE (2u)

#define PRIMARY_LV_SET_PUMPS_SPEED_STATUS_OFF_CHOICE (0u)
#define PRIMARY_LV_SET_PUMPS_SPEED_STATUS_AUTO_CHOICE (1u)
#define PRIMARY_LV_SET_PUMPS_SPEED_STATUS_MANUAL_CHOICE (2u)

#define PRIMARY_LV_INVERTER_CONNECTION_STATUS_STATUS_OFF_CHOICE (0u)
#define PRIMARY_LV_INVERTER_CONNECTION_STATUS_STATUS_ON_CHOICE (1u)

#define PRIMARY_LV_SET_INVERTER_CONNECTION_STATUS_STATUS_OFF_CHOICE (0u)
#define PRIMARY_LV_SET_INVERTER_CONNECTION_STATUS_STATUS_ON_CHOICE (1u)

#define PRIMARY_TLM_STATUS_STATUS_OFF_CHOICE (0u)
#define PRIMARY_TLM_STATUS_STATUS_ON_CHOICE (1u)

#define PRIMARY_TLM_SET_STATUS_STATUS_OFF_CHOICE (0u)
#define PRIMARY_TLM_SET_STATUS_STATUS_ON_CHOICE (1u)

#define PRIMARY_HANDCART_STATUS_CONNECTED_OFF_CHOICE (0u)
#define PRIMARY_HANDCART_STATUS_CONNECTED_ON_CHOICE (1u)

#define PRIMARY_HANDCART_SETTINGS_FANS_OVERRIDE_OFF_CHOICE (0u)
#define PRIMARY_HANDCART_SETTINGS_FANS_OVERRIDE_ON_CHOICE (1u)

#define PRIMARY_HANDCART_SETTINGS_STATUS_NONE_CHOICE (0u)
#define PRIMARY_HANDCART_SETTINGS_STATUS_CHECK_CHOICE (1u)
#define PRIMARY_HANDCART_SETTINGS_STATUS_IDLE_CHOICE (2u)
#define PRIMARY_HANDCART_SETTINGS_STATUS_PRECHARGE_CHOICE (3u)
#define PRIMARY_HANDCART_SETTINGS_STATUS_READY_CHOICE (4u)
#define PRIMARY_HANDCART_SETTINGS_STATUS_CHARGE_CHOICE (5u)
#define PRIMARY_HANDCART_SETTINGS_STATUS_CHARGE_DONE_CHOICE (6u)
#define PRIMARY_HANDCART_SETTINGS_STATUS_BALANCING_CHOICE (7u)
#define PRIMARY_HANDCART_SETTINGS_STATUS_ERROR_CHOICE (8u)

#define PRIMARY_HANDCART_SET_SETTINGS_FANS_OVERRIDE_OFF_CHOICE (0u)
#define PRIMARY_HANDCART_SET_SETTINGS_FANS_OVERRIDE_ON_CHOICE (1u)

#define PRIMARY_HANDCART_SET_SETTINGS_STATUS_NONE_CHOICE (0u)
#define PRIMARY_HANDCART_SET_SETTINGS_STATUS_CHECK_CHOICE (1u)
#define PRIMARY_HANDCART_SET_SETTINGS_STATUS_IDLE_CHOICE (2u)
#define PRIMARY_HANDCART_SET_SETTINGS_STATUS_PRECHARGE_CHOICE (3u)
#define PRIMARY_HANDCART_SET_SETTINGS_STATUS_READY_CHOICE (4u)
#define PRIMARY_HANDCART_SET_SETTINGS_STATUS_CHARGE_CHOICE (5u)
#define PRIMARY_HANDCART_SET_SETTINGS_STATUS_CHARGE_DONE_CHOICE (6u)
#define PRIMARY_HANDCART_SET_SETTINGS_STATUS_BALANCING_CHOICE (7u)
#define PRIMARY_HANDCART_SET_SETTINGS_STATUS_ERROR_CHOICE (8u)

#define PRIMARY_ECU_STATUS_STATUS_INIT_CHOICE (0u)
#define PRIMARY_ECU_STATUS_STATUS_ENABLE_INV_UPDATES_CHOICE (1u)
#define PRIMARY_ECU_STATUS_STATUS_CHECK_INV_SETTINGS_CHOICE (2u)
#define PRIMARY_ECU_STATUS_STATUS_IDLE_CHOICE (3u)
#define PRIMARY_ECU_STATUS_STATUS_START_TS_PRECHARGE_CHOICE (4u)
#define PRIMARY_ECU_STATUS_STATUS_WAIT_TS_PRECHARGE_CHOICE (5u)
#define PRIMARY_ECU_STATUS_STATUS_WAIT_DRIVER_CHOICE (6u)
#define PRIMARY_ECU_STATUS_STATUS_ENABLE_INV_DRIVE_CHOICE (7u)
#define PRIMARY_ECU_STATUS_STATUS_DRIVE_CHOICE (8u)
#define PRIMARY_ECU_STATUS_STATUS_DISABLE_INV_DRIVE_CHOICE (9u)
#define PRIMARY_ECU_STATUS_STATUS_START_TS_DISCHARGE_CHOICE (10u)
#define PRIMARY_ECU_STATUS_STATUS_WAIT_TS_DISCHARGE_CHOICE (11u)
#define PRIMARY_ECU_STATUS_STATUS_FATAL_ERROR_CHOICE (12u)

#define PRIMARY_ECU_SET_STATUS_STATUS_IDLE_CHOICE (0u)
#define PRIMARY_ECU_SET_STATUS_STATUS_READY_CHOICE (1u)
#define PRIMARY_ECU_SET_STATUS_STATUS_DRIVE_CHOICE (2u)

#define PRIMARY_ECU_INVERTER_STATUS_RL_DISABLED_CHOICE (0u)
#define PRIMARY_ECU_INVERTER_STATUS_RL_RFE_ON_CHOICE (1u)
#define PRIMARY_ECU_INVERTER_STATUS_RL_FRG_ON_CHOICE (2u)
#define PRIMARY_ECU_INVERTER_STATUS_RL_ENABLED_CHOICE (3u)

#define PRIMARY_ECU_INVERTER_STATUS_RR_DISABLED_CHOICE (0u)
#define PRIMARY_ECU_INVERTER_STATUS_RR_RFE_ON_CHOICE (1u)
#define PRIMARY_ECU_INVERTER_STATUS_RR_FRG_ON_CHOICE (2u)
#define PRIMARY_ECU_INVERTER_STATUS_RR_ENABLED_CHOICE (3u)

#define PRIMARY_ECU_PTT_STATUS_STATUS_OFF_CHOICE (0u)
#define PRIMARY_ECU_PTT_STATUS_STATUS_ON_CHOICE (1u)

#define PRIMARY_ECU_SET_PTT_STATUS_STATUS_OFF_CHOICE (0u)
#define PRIMARY_ECU_SET_PTT_STATUS_STATUS_ON_CHOICE (1u)

#define PRIMARY_ECU_STEER_ACTUATOR_STATUS_STATUS_OFF_CHOICE (0u)
#define PRIMARY_ECU_STEER_ACTUATOR_STATUS_STATUS_ON_CHOICE (1u)

#define PRIMARY_ECU_SET_STEER_ACTUATOR_STATUS_STEERING_WHEEL_STATUS_OFF_CHOICE (0u)
#define PRIMARY_ECU_SET_STEER_ACTUATOR_STATUS_STEERING_WHEEL_STATUS_ON_CHOICE (1u)

#define PRIMARY_ECU_SET_STEER_ACTUATOR_STATUS_TLM_STATUS_OFF_CHOICE (0u)
#define PRIMARY_ECU_SET_STEER_ACTUATOR_STATUS_TLM_STATUS_ON_CHOICE (1u)

/* Indexes */
#define PRIMARY_NLG5_DIAG_TX_INDEX 0
#define PRIMARY_NLG5_DIAG_RX_INDEX 1
#define PRIMARY_NLG5_ERR_INDEX 2
#define PRIMARY_NLG5_TEMP_INDEX 3
#define PRIMARY_NLG5_ACT_II_INDEX 4
#define PRIMARY_NLG5_ACT_I_INDEX 5
#define PRIMARY_NLG5_ST_INDEX 6
#define PRIMARY_NLG5_CTL_INDEX 7
#define PRIMARY_HV_JMP_TO_BLT_INDEX 8
#define PRIMARY_HV_FLASH_MAINBOARD_TX_INDEX 9
#define PRIMARY_HV_FLASH_MAINBOARD_RX_INDEX 10
#define PRIMARY_HV_FLASH_CELLBOARD_0_TX_INDEX 11
#define PRIMARY_HV_FLASH_CELLBOARD_0_RX_INDEX 12
#define PRIMARY_HV_FLASH_CELLBOARD_1_TX_INDEX 13
#define PRIMARY_HV_FLASH_CELLBOARD_1_RX_INDEX 14
#define PRIMARY_HV_FLASH_CELLBOARD_2_TX_INDEX 15
#define PRIMARY_HV_FLASH_CELLBOARD_2_RX_INDEX 16
#define PRIMARY_HV_FLASH_CELLBOARD_3_TX_INDEX 17
#define PRIMARY_HV_FLASH_CELLBOARD_3_RX_INDEX 18
#define PRIMARY_HV_FLASH_CELLBOARD_4_TX_INDEX 19
#define PRIMARY_HV_FLASH_CELLBOARD_4_RX_INDEX 20
#define PRIMARY_HV_FLASH_CELLBOARD_5_TX_INDEX 21
#define PRIMARY_HV_FLASH_CELLBOARD_5_RX_INDEX 22
#define PRIMARY_LV_JMP_TO_BLT_INDEX 23
#define PRIMARY_LV_FLASH_TX_INDEX 24
#define PRIMARY_LV_FLASH_RX_INDEX 25
#define PRIMARY_ECU_JMP_TO_BLT_INDEX 26
#define PRIMARY_ECU_FLASH_TX_INDEX 27
#define PRIMARY_ECU_FLASH_RX_INDEX 28
#define PRIMARY_STEERING_WHEEL_JMP_TO_BLT_INDEX 29
#define PRIMARY_STEERING_WHEEL_FLASH_TX_INDEX 30
#define PRIMARY_STEERING_WHEEL_FLASH_RX_INDEX 31
#define PRIMARY_STEERING_WHEEL_VERSION_INDEX 32
#define PRIMARY_ECU_VERSION_INDEX 33
#define PRIMARY_LV_VERSION_INDEX 34
#define PRIMARY_TLM_VERSION_INDEX 35
#define PRIMARY_HV_MAINBOARD_VERSION_INDEX 36
#define PRIMARY_HV_CELLBOARD_VERSION_INDEX 37
#define PRIMARY_HV_ERRORS_INDEX 38
#define PRIMARY_HV_DEBUG_SIGNALS_INDEX 39
#define PRIMARY_HV_FANS_STATUS_INDEX 40
#define PRIMARY_HV_SET_FANS_STATUS_INDEX 41
#define PRIMARY_HV_FEEDBACK_STATUS_INDEX 42
#define PRIMARY_HV_FEEDBACK_TS_VOLTAGE_INDEX 43
#define PRIMARY_HV_FEEDBACK_MISC_VOLTAGE_INDEX 44
#define PRIMARY_HV_FEEDBACK_SD_VOLTAGE_INDEX 45
#define PRIMARY_HV_IMD_STATUS_INDEX 46
#define PRIMARY_HV_STATUS_INDEX 47
#define PRIMARY_HV_SET_STATUS_ECU_INDEX 48
#define PRIMARY_HV_SET_STATUS_HANDCART_INDEX 49
#define PRIMARY_HV_BALANCING_STATUS_INDEX 50
#define PRIMARY_HV_SET_BALANCING_STATUS_HANDCART_INDEX 51
#define PRIMARY_HV_SET_BALANCING_STATUS_STEERING_WHEEL_INDEX 52
#define PRIMARY_LV_STATUS_INDEX 53
#define PRIMARY_LV_RADIATOR_SPEED_INDEX 54
#define PRIMARY_LV_PUMPS_SPEED_INDEX 55
#define PRIMARY_LV_SET_RADIATOR_SPEED_INDEX 56
#define PRIMARY_LV_SET_PUMPS_SPEED_INDEX 57
#define PRIMARY_LV_ERRORS_INDEX 58
#define PRIMARY_LV_FEEDBACK_TS_VOLTAGE_INDEX 59
#define PRIMARY_LV_FEEDBACK_SD_VOLTAGE_INDEX 60
#define PRIMARY_LV_FEEDBACK_ENCLOSURE_VOLTAGE_INDEX 61
#define PRIMARY_LV_FEEDBACK_GPIO_EXTENDER_INDEX 62
#define PRIMARY_LV_CAN_FLASH_REQ_TLM_INDEX 63
#define PRIMARY_LV_CAN_FLASH_REQ_STEERING_WHEEL_INDEX 64
#define PRIMARY_LV_CAN_FLASH_ACK_INDEX 65
#define PRIMARY_LV_INVERTER_CONNECTION_STATUS_INDEX 66
#define PRIMARY_LV_SET_INVERTER_CONNECTION_STATUS_INDEX 67
#define PRIMARY_TLM_STATUS_INDEX 68
#define PRIMARY_TLM_SET_STATUS_INDEX 69
#define PRIMARY_HANDCART_STATUS_INDEX 70
#define PRIMARY_HANDCART_SETTINGS_INDEX 71
#define PRIMARY_HANDCART_SET_SETTINGS_INDEX 72
#define PRIMARY_ECU_STATUS_INDEX 73
#define PRIMARY_ECU_SET_STATUS_INDEX 74
#define PRIMARY_ECU_INVERTER_STATUS_INDEX 75
#define PRIMARY_ECU_CONTROL_STATUS_INDEX 76
#define PRIMARY_ECU_ERRORS_INDEX 77
#define PRIMARY_ECU_FEEDBACKS_INDEX 78
#define PRIMARY_ECU_POWER_MAPS_INDEX 79
#define PRIMARY_ECU_SET_POWER_MAPS_INDEX 80
#define PRIMARY_ECU_PTT_STATUS_INDEX 81
#define PRIMARY_ECU_SET_PTT_STATUS_INDEX 82
#define PRIMARY_INV_L_REQUEST_INDEX 83
#define PRIMARY_CONTROL_OUTPUT_INDEX 84
#define PRIMARY_CONTROL_STATUS_INDEX 85
#define PRIMARY_INV_R_REQUEST_INDEX 86
#define PRIMARY_INV_L_RESPONSE_INDEX 87
#define PRIMARY_INV_R_RESPONSE_INDEX 88
#define PRIMARY_LV_CURRENT_BATTERY_INDEX 89
#define PRIMARY_LV_CURRENT_CHARGER_INDEX 90
#define PRIMARY_LV_TOTAL_VOLTAGE_INDEX 91
#define PRIMARY_LV_CELLS_VOLTAGE_INDEX 92
#define PRIMARY_LV_CELLS_VOLTAGE_STATS_INDEX 93
#define PRIMARY_LV_CELLS_TEMP_INDEX 94
#define PRIMARY_LV_CELLS_TEMP_STATS_INDEX 95
#define PRIMARY_HV_CURRENT_INDEX 96
#define PRIMARY_HV_POWER_INDEX 97
#define PRIMARY_HV_ENERGY_INDEX 98
#define PRIMARY_HV_SOC_INDEX 99
#define PRIMARY_HV_TOTAL_VOLTAGE_INDEX 100
#define PRIMARY_HV_CELLS_VOLTAGE_INDEX 101
#define PRIMARY_HV_CELLS_VOLTAGE_STATS_INDEX 102
#define PRIMARY_HV_CELLS_TEMP_INDEX 103
#define PRIMARY_HV_CELLS_TEMP_STATS_INDEX 104
#define PRIMARY_ECU_STEER_ACTUATOR_STATUS_INDEX 105
#define PRIMARY_ECU_SET_STEER_ACTUATOR_STATUS_STEERING_WHEEL_INDEX 106
#define PRIMARY_ECU_SET_STEER_ACTUATOR_STATUS_TLM_INDEX 107
#define PRIMARY_ECU_STEER_ACTUATOR_CURRENT_INDEX 108
#define PRIMARY_DEBUG_SIGNAL_CRASH_DEBUG_INDEX 109
#define PRIMARY_DEBUG_SIGNAL_CRASH_DEBUG_ACK_INDEX 110
#define PRIMARY_DEBUG_SIGNAL_1_INDEX 111
#define PRIMARY_DEBUG_SIGNAL_2_INDEX 112


#define primary_MESSAGE_COUNT 113

#ifndef CANLIB_DEVICE_T
#define CANLIB_DEVICE_T
typedef struct {
    void* message;
    void* _converted;
    void* _raw;
    int _size_raw;
    int _size_converted;
} device_t;
void device_init(device_t *device);
void device_preallocate(device_t *device, int bytes);
void device_free(device_t *device);
void device_set_address(device_t *device, void* raw, size_t raw_size, void *converted, size_t converted_size);
#endif // CANLIB_DEVICE_T

#ifdef CANLIB_DEVICE_IMPLEMENTATION
#undef CANLIB_DEVICE_IMPLEMENTATION
void device_init(device_t *device) {
    device->message = NULL;
    device->_converted = NULL;
    device->_raw = NULL;
    device->_size_raw = 0;
    device->_size_converted = 0;
}
void device_preallocate(device_t *device, int bytes){
    if(device->_size_raw > 0)
        free(device->_raw);
    if(device->_size_converted > 0)
        free(device->_converted);
    device->_raw = malloc(bytes);
    device->_converted = malloc(bytes);
    device->_size_converted = device->_size_raw = bytes;
}
void device_free(device_t *device) {
    free(device->_raw);
    free(device->_converted);
    device->message = NULL;
    device->_raw = NULL;
    device->_converted = NULL;
    device->_size_raw = 0;
    device->_size_converted = 0;
}
void device_set_address(device_t *device, void* raw, size_t raw_size, void *converted, size_t converted_size) {
    device->_raw = raw;
    device->_converted = converted;
    device->_size_raw = raw_size;
    device->_size_converted = converted_size;
}
#endif // CANLIB_DEVICE_IMPLEMENTATION

void primary_devices_deserialize_from_id(
    device_t* device,
    uint16_t message_id,
    uint8_t* data
#ifdef CANLIB_TIMESTAMP
    , uint64_t timestamp
#endif // CANLIB_TIMESTAMP
);

int primary_message_name_from_id(uint16_t id, char* buffer);
int primary_index_from_id(uint16_t id);
int primary_id_from_index(int index);

typedef enum {
	primary_hv_jmp_to_blt_forward_off = 0,
	primary_hv_jmp_to_blt_forward_on = 1,
} primary_hv_jmp_to_blt_forward;

typedef enum {
	primary_hv_jmp_to_blt_cellboard_id_cellboard_0 = 0,
	primary_hv_jmp_to_blt_cellboard_id_cellboard_1 = 1,
	primary_hv_jmp_to_blt_cellboard_id_cellboard_2 = 2,
	primary_hv_jmp_to_blt_cellboard_id_cellboard_3 = 3,
	primary_hv_jmp_to_blt_cellboard_id_cellboard_4 = 4,
	primary_hv_jmp_to_blt_cellboard_id_cellboard_5 = 5,
} primary_hv_jmp_to_blt_cellboard_id;

typedef enum {
	primary_hv_cellboard_version_cellboard_id_cellboard_0 = 0,
	primary_hv_cellboard_version_cellboard_id_cellboard_1 = 1,
	primary_hv_cellboard_version_cellboard_id_cellboard_2 = 2,
	primary_hv_cellboard_version_cellboard_id_cellboard_3 = 3,
	primary_hv_cellboard_version_cellboard_id_cellboard_4 = 4,
	primary_hv_cellboard_version_cellboard_id_cellboard_5 = 5,
} primary_hv_cellboard_version_cellboard_id;

typedef enum {
	primary_hv_fans_status_fans_override_off = 0,
	primary_hv_fans_status_fans_override_on = 1,
} primary_hv_fans_status_fans_override;

typedef enum {
	primary_hv_set_fans_status_fans_override_off = 0,
	primary_hv_set_fans_status_fans_override_on = 1,
} primary_hv_set_fans_status_fans_override;

typedef enum {
	primary_hv_feedback_status_feedback_implausibility_detected_feedback_state_low = 0,
	primary_hv_feedback_status_feedback_implausibility_detected_feedback_state_error = 1,
	primary_hv_feedback_status_feedback_implausibility_detected_feedback_state_high = 2,
} primary_hv_feedback_status_feedback_implausibility_detected;

typedef enum {
	primary_hv_feedback_status_feedback_imd_cockpit_feedback_state_low = 0,
	primary_hv_feedback_status_feedback_imd_cockpit_feedback_state_error = 1,
	primary_hv_feedback_status_feedback_imd_cockpit_feedback_state_high = 2,
} primary_hv_feedback_status_feedback_imd_cockpit;

typedef enum {
	primary_hv_feedback_status_feedback_tsal_green_fault_latched_feedback_state_low = 0,
	primary_hv_feedback_status_feedback_tsal_green_fault_latched_feedback_state_error = 1,
	primary_hv_feedback_status_feedback_tsal_green_fault_latched_feedback_state_high = 2,
} primary_hv_feedback_status_feedback_tsal_green_fault_latched;

typedef enum {
	primary_hv_feedback_status_feedback_bms_cockpit_feedback_state_low = 0,
	primary_hv_feedback_status_feedback_bms_cockpit_feedback_state_error = 1,
	primary_hv_feedback_status_feedback_bms_cockpit_feedback_state_high = 2,
} primary_hv_feedback_status_feedback_bms_cockpit;

typedef enum {
	primary_hv_feedback_status_feedback_ext_latched_feedback_state_low = 0,
	primary_hv_feedback_status_feedback_ext_latched_feedback_state_error = 1,
	primary_hv_feedback_status_feedback_ext_latched_feedback_state_high = 2,
} primary_hv_feedback_status_feedback_ext_latched;

typedef enum {
	primary_hv_feedback_status_feedback_tsal_green_feedback_state_low = 0,
	primary_hv_feedback_status_feedback_tsal_green_feedback_state_error = 1,
	primary_hv_feedback_status_feedback_tsal_green_feedback_state_high = 2,
} primary_hv_feedback_status_feedback_tsal_green;

typedef enum {
	primary_hv_feedback_status_feedback_ts_over_60v_status_feedback_state_low = 0,
	primary_hv_feedback_status_feedback_ts_over_60v_status_feedback_state_error = 1,
	primary_hv_feedback_status_feedback_ts_over_60v_status_feedback_state_high = 2,
} primary_hv_feedback_status_feedback_ts_over_60v_status;

typedef enum {
	primary_hv_feedback_status_feedback_airn_status_feedback_state_low = 0,
	primary_hv_feedback_status_feedback_airn_status_feedback_state_error = 1,
	primary_hv_feedback_status_feedback_airn_status_feedback_state_high = 2,
} primary_hv_feedback_status_feedback_airn_status;

typedef enum {
	primary_hv_feedback_status_feedback_airp_status_feedback_state_low = 0,
	primary_hv_feedback_status_feedback_airp_status_feedback_state_error = 1,
	primary_hv_feedback_status_feedback_airp_status_feedback_state_high = 2,
} primary_hv_feedback_status_feedback_airp_status;

typedef enum {
	primary_hv_feedback_status_feedback_airp_gate_feedback_state_low = 0,
	primary_hv_feedback_status_feedback_airp_gate_feedback_state_error = 1,
	primary_hv_feedback_status_feedback_airp_gate_feedback_state_high = 2,
} primary_hv_feedback_status_feedback_airp_gate;

typedef enum {
	primary_hv_feedback_status_feedback_airn_gate_feedback_state_low = 0,
	primary_hv_feedback_status_feedback_airn_gate_feedback_state_error = 1,
	primary_hv_feedback_status_feedback_airn_gate_feedback_state_high = 2,
} primary_hv_feedback_status_feedback_airn_gate;

typedef enum {
	primary_hv_feedback_status_feedback_precharge_status_feedback_state_low = 0,
	primary_hv_feedback_status_feedback_precharge_status_feedback_state_error = 1,
	primary_hv_feedback_status_feedback_precharge_status_feedback_state_high = 2,
} primary_hv_feedback_status_feedback_precharge_status;

typedef enum {
	primary_hv_feedback_status_feedback_tsp_over_60v_status_feedback_state_low = 0,
	primary_hv_feedback_status_feedback_tsp_over_60v_status_feedback_state_error = 1,
	primary_hv_feedback_status_feedback_tsp_over_60v_status_feedback_state_high = 2,
} primary_hv_feedback_status_feedback_tsp_over_60v_status;

typedef enum {
	primary_hv_feedback_status_feedback_imd_fault_feedback_state_low = 0,
	primary_hv_feedback_status_feedback_imd_fault_feedback_state_error = 1,
	primary_hv_feedback_status_feedback_imd_fault_feedback_state_high = 2,
} primary_hv_feedback_status_feedback_imd_fault;

typedef enum {
	primary_hv_feedback_status_feedback_check_mux_feedback_state_low = 0,
	primary_hv_feedback_status_feedback_check_mux_feedback_state_error = 1,
	primary_hv_feedback_status_feedback_check_mux_feedback_state_high = 2,
} primary_hv_feedback_status_feedback_check_mux;

typedef enum {
	primary_hv_feedback_status_feedback_sd_end_feedback_state_low = 0,
	primary_hv_feedback_status_feedback_sd_end_feedback_state_error = 1,
	primary_hv_feedback_status_feedback_sd_end_feedback_state_high = 2,
} primary_hv_feedback_status_feedback_sd_end;

typedef enum {
	primary_hv_feedback_status_feedback_sd_out_feedback_state_low = 0,
	primary_hv_feedback_status_feedback_sd_out_feedback_state_error = 1,
	primary_hv_feedback_status_feedback_sd_out_feedback_state_high = 2,
} primary_hv_feedback_status_feedback_sd_out;

typedef enum {
	primary_hv_feedback_status_feedback_sd_in_feedback_state_low = 0,
	primary_hv_feedback_status_feedback_sd_in_feedback_state_error = 1,
	primary_hv_feedback_status_feedback_sd_in_feedback_state_high = 2,
} primary_hv_feedback_status_feedback_sd_in;

typedef enum {
	primary_hv_feedback_status_feedback_sd_bms_feedback_state_low = 0,
	primary_hv_feedback_status_feedback_sd_bms_feedback_state_error = 1,
	primary_hv_feedback_status_feedback_sd_bms_feedback_state_high = 2,
} primary_hv_feedback_status_feedback_sd_bms;

typedef enum {
	primary_hv_feedback_status_feedback_sd_imd_feedback_state_low = 0,
	primary_hv_feedback_status_feedback_sd_imd_feedback_state_error = 1,
	primary_hv_feedback_status_feedback_sd_imd_feedback_state_high = 2,
} primary_hv_feedback_status_feedback_sd_imd;

typedef enum {
	primary_hv_imd_status_imd_status_sc = 0,
	primary_hv_imd_status_imd_status_normal = 1,
	primary_hv_imd_status_imd_status_under_voltage = 2,
	primary_hv_imd_status_imd_status_start_measure = 3,
	primary_hv_imd_status_imd_status_device_error = 4,
	primary_hv_imd_status_imd_status_earth_fault = 5,
} primary_hv_imd_status_imd_status;

typedef enum {
	primary_hv_status_status_init = 0,
	primary_hv_status_status_idle = 1,
	primary_hv_status_status_airn_close = 2,
	primary_hv_status_status_precharge = 3,
	primary_hv_status_status_airp_close = 4,
	primary_hv_status_status_ts_on = 5,
	primary_hv_status_status_fatal_error = 6,
} primary_hv_status_status;

typedef enum {
	primary_hv_set_status_ecu_hv_status_set_off = 0,
	primary_hv_set_status_ecu_hv_status_set_on = 1,
} primary_hv_set_status_ecu_hv_status_set;

typedef enum {
	primary_hv_set_status_handcart_hv_status_set_off = 0,
	primary_hv_set_status_handcart_hv_status_set_on = 1,
} primary_hv_set_status_handcart_hv_status_set;

typedef enum {
	primary_hv_balancing_status_cellboard_id_cellboard_0 = 0,
	primary_hv_balancing_status_cellboard_id_cellboard_1 = 1,
	primary_hv_balancing_status_cellboard_id_cellboard_2 = 2,
	primary_hv_balancing_status_cellboard_id_cellboard_3 = 3,
	primary_hv_balancing_status_cellboard_id_cellboard_4 = 4,
	primary_hv_balancing_status_cellboard_id_cellboard_5 = 5,
} primary_hv_balancing_status_cellboard_id;

typedef enum {
	primary_hv_balancing_status_balancing_status_off = 0,
	primary_hv_balancing_status_balancing_status_on = 1,
} primary_hv_balancing_status_balancing_status;

typedef enum {
	primary_hv_set_balancing_status_handcart_set_balancing_status_off = 0,
	primary_hv_set_balancing_status_handcart_set_balancing_status_on = 1,
} primary_hv_set_balancing_status_handcart_set_balancing_status;

typedef enum {
	primary_hv_set_balancing_status_steering_wheel_set_balancing_status_off = 0,
	primary_hv_set_balancing_status_steering_wheel_set_balancing_status_on = 1,
} primary_hv_set_balancing_status_steering_wheel_set_balancing_status;

typedef enum {
	primary_lv_status_status_init = 0,
	primary_lv_status_status_idle = 1,
	primary_lv_status_status_tson = 2,
	primary_lv_status_status_run = 3,
	primary_lv_status_status_flashing = 4,
	primary_lv_status_status_error = 5,
} primary_lv_status_status;

typedef enum {
	primary_lv_radiator_speed_status_off = 0,
	primary_lv_radiator_speed_status_auto = 1,
	primary_lv_radiator_speed_status_manual = 2,
} primary_lv_radiator_speed_status;

typedef enum {
	primary_lv_pumps_speed_status_off = 0,
	primary_lv_pumps_speed_status_auto = 1,
	primary_lv_pumps_speed_status_manual = 2,
} primary_lv_pumps_speed_status;

typedef enum {
	primary_lv_set_radiator_speed_status_off = 0,
	primary_lv_set_radiator_speed_status_auto = 1,
	primary_lv_set_radiator_speed_status_manual = 2,
} primary_lv_set_radiator_speed_status;

typedef enum {
	primary_lv_set_pumps_speed_status_off = 0,
	primary_lv_set_pumps_speed_status_auto = 1,
	primary_lv_set_pumps_speed_status_manual = 2,
} primary_lv_set_pumps_speed_status;

typedef enum {
	primary_lv_inverter_connection_status_status_off = 0,
	primary_lv_inverter_connection_status_status_on = 1,
} primary_lv_inverter_connection_status_status;

typedef enum {
	primary_lv_set_inverter_connection_status_status_off = 0,
	primary_lv_set_inverter_connection_status_status_on = 1,
} primary_lv_set_inverter_connection_status_status;

typedef enum {
	primary_tlm_status_status_off = 0,
	primary_tlm_status_status_on = 1,
} primary_tlm_status_status;

typedef enum {
	primary_tlm_set_status_status_off = 0,
	primary_tlm_set_status_status_on = 1,
} primary_tlm_set_status_status;

typedef enum {
	primary_handcart_status_connected_off = 0,
	primary_handcart_status_connected_on = 1,
} primary_handcart_status_connected;

typedef enum {
	primary_handcart_settings_fans_override_off = 0,
	primary_handcart_settings_fans_override_on = 1,
} primary_handcart_settings_fans_override;

typedef enum {
	primary_handcart_settings_status_none = 0,
	primary_handcart_settings_status_check = 1,
	primary_handcart_settings_status_idle = 2,
	primary_handcart_settings_status_precharge = 3,
	primary_handcart_settings_status_ready = 4,
	primary_handcart_settings_status_charge = 5,
	primary_handcart_settings_status_charge_done = 6,
	primary_handcart_settings_status_balancing = 7,
	primary_handcart_settings_status_error = 8,
} primary_handcart_settings_status;

typedef enum {
	primary_handcart_set_settings_fans_override_off = 0,
	primary_handcart_set_settings_fans_override_on = 1,
} primary_handcart_set_settings_fans_override;

typedef enum {
	primary_handcart_set_settings_status_none = 0,
	primary_handcart_set_settings_status_check = 1,
	primary_handcart_set_settings_status_idle = 2,
	primary_handcart_set_settings_status_precharge = 3,
	primary_handcart_set_settings_status_ready = 4,
	primary_handcart_set_settings_status_charge = 5,
	primary_handcart_set_settings_status_charge_done = 6,
	primary_handcart_set_settings_status_balancing = 7,
	primary_handcart_set_settings_status_error = 8,
} primary_handcart_set_settings_status;

typedef enum {
	primary_ecu_status_status_init = 0,
	primary_ecu_status_status_enable_inv_updates = 1,
	primary_ecu_status_status_check_inv_settings = 2,
	primary_ecu_status_status_idle = 3,
	primary_ecu_status_status_start_ts_precharge = 4,
	primary_ecu_status_status_wait_ts_precharge = 5,
	primary_ecu_status_status_wait_driver = 6,
	primary_ecu_status_status_enable_inv_drive = 7,
	primary_ecu_status_status_drive = 8,
	primary_ecu_status_status_disable_inv_drive = 9,
	primary_ecu_status_status_start_ts_discharge = 10,
	primary_ecu_status_status_wait_ts_discharge = 11,
	primary_ecu_status_status_fatal_error = 12,
} primary_ecu_status_status;

typedef enum {
	primary_ecu_set_status_status_idle = 0,
	primary_ecu_set_status_status_ready = 1,
	primary_ecu_set_status_status_drive = 2,
} primary_ecu_set_status_status;

typedef enum {
	primary_ecu_inverter_status_rl_disabled = 0,
	primary_ecu_inverter_status_rl_rfe_on = 1,
	primary_ecu_inverter_status_rl_frg_on = 2,
	primary_ecu_inverter_status_rl_enabled = 3,
} primary_ecu_inverter_status_rl;

typedef enum {
	primary_ecu_inverter_status_rr_disabled = 0,
	primary_ecu_inverter_status_rr_rfe_on = 1,
	primary_ecu_inverter_status_rr_frg_on = 2,
	primary_ecu_inverter_status_rr_enabled = 3,
} primary_ecu_inverter_status_rr;

typedef enum {
	primary_ecu_ptt_status_status_off = 0,
	primary_ecu_ptt_status_status_on = 1,
} primary_ecu_ptt_status_status;

typedef enum {
	primary_ecu_set_ptt_status_status_off = 0,
	primary_ecu_set_ptt_status_status_on = 1,
} primary_ecu_set_ptt_status_status;

typedef enum {
	primary_ecu_steer_actuator_status_status_off = 0,
	primary_ecu_steer_actuator_status_status_on = 1,
} primary_ecu_steer_actuator_status_status;

typedef enum {
	primary_ecu_set_steer_actuator_status_steering_wheel_status_off = 0,
	primary_ecu_set_steer_actuator_status_steering_wheel_status_on = 1,
} primary_ecu_set_steer_actuator_status_steering_wheel_status;

typedef enum {
	primary_ecu_set_steer_actuator_status_tlm_status_off = 0,
	primary_ecu_set_steer_actuator_status_tlm_status_on = 1,
} primary_ecu_set_steer_actuator_status_tlm_status;

/**
 * Signals in message NLG5_DIAG_TX.
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Diag responded data to host
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint64_t lad_d_paramrp;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_nlg5_diag_tx_t;

/**
 * Signals in message NLG5_DIAG_TX.
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Diag responded data to host
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint64_t lad_d_paramrp;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_nlg5_diag_tx_converted_t;

/**
 * Signals in message NLG5_DIAG_RX.
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Diag requested data from host
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint64_t lad_d_paramrq;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_nlg5_diag_rx_t;

/**
 * Signals in message NLG5_DIAG_RX.
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Diag requested data from host
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint64_t lad_d_paramrq;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_nlg5_diag_rx_converted_t;

/**
 * Signals in message NLG5_ERR.
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * battery output overvoltage; error can only be cleared by cycling power ON-OFF-ON
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_e_oov;

    /**
     * Mains overvoltage 2 detected
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_e_mov_ii;

    /**
     * Mains overvoltage 1 detected
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_e_mov_i;

    /**
     * power stage short circuit condition detected; error can only be cleared by cycling power ON-OFF-ON
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_e_sc;

    /**
     * plausibility battery output voltage measurement wrong
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_e_p_om;

    /**
     * plausibility mains voltage measurement wrong
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_e_p_mv;

    /**
     * output fuse defective
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_e_of;

    /**
     * Mains fuse defective
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_e_mf;

    /**
     * wrong battery polarity;  error can only be cleared by cycling power ON-OFF-ON
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_e_b_p;

    /**
     * Temperature sensor for prim capacitor defective
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_e_t_c;

    /**
     * Temperature sensor for prim power stage defective
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_e_t_pow;

    /**
     * Temperature sensor for diodes defective
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_e_t_dio;

    /**
     * Temperature sensor for transformer defective
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_e_t_tr;

    /**
     * Ext. temperature sensor 1 defective (if enabled)
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_e_t_ext1;

    /**
     * Ext. temperature sensor 2 defective (if enabled)
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_e_t_ext2;

    /**
     * Ext. temperature sensor 3 defective (if enabled)
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_e_t_ext3;

    /**
     * Flash memory checksum failure
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_e_f_crc;

    /**
     * NVSRAM check sum failure; contains most of the scaling & calibration values, CAN ID's and  charging profile etc.
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_e_nv_crc;

    /**
     * Sys EEPROM checksum failure
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_e_es_crc;

    /**
     * Pow EEPROM checksum failure
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_e_ep_crc;

    /**
     * Internal Watchdog Timeout
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_e_wdt;

    /**
     * Initialization error
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_e_init;

    /**
     * CAN timeout, no control message received for >300ms
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_e_c_to;

    /**
     * CAN off, transmit buffer >255
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_e_c_off;

    /**
     * CAN transmit buffer >127
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_e_c_tx;

    /**
     * CAN receiver buffer >127
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_e_c_rx;

    /**
     * Emergency Shutdown Threshold 'Battery Temperature' is exceeded; see ChargeStar help section 'protective features';  error can only be cleared by cycling power ON-OFF-ON
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_e_sdt_bt;

    /**
     * Emergency Shutdown Threshold 'Battery Voltage' is exceeded; see ChargeStar help section 'protective features';  error can only be cleared by cycling power ON-OFF-ON
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_e_sdt_bv;

    /**
     * Emergency Shutdown Threshold 'Amp Hours' is exceeded; see ChargeStar help section 'protective features';  error can only be cleared by cycling power ON-OFF-ON
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_e_sdt_ah;

    /**
     * Emergency Shutdown Threshold 'Charging Time' is exceeded; see ChargeStar help section 'protective features';  error can only be cleared by cycling power ON-OFF-ON
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_e_sdt_ct;

    /**
     * Output power limited by low mains voltage
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_w_pl_mv;

    /**
     * Output power limited by low battery voltage
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_w_pl_bv;

    /**
     * Output power limited by charger internal overtemperature
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_w_pl_it;

    /**
     * Commanded value is out of specified range; max or min applicable value is assumed instead
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_w_c_vor;

    /**
     * NLG5 Control message not active
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_w_cm_na;

    /**
     * LED Output driver defective, LEDs can´t be controlled by NLG5 anymore. Charging is still possible.
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_w_od;

    /**
     * Save-Charging-Mode reduces primary current to 3.95 A as long as one of the four internal temperature sensors indicates -18° C or less.
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_w_sc_m;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_nlg5_err_t;

/**
 * Signals in message NLG5_ERR.
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * battery output overvoltage; error can only be cleared by cycling power ON-OFF-ON
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int nlg5_e_oov : 1;

    /**
     * Mains overvoltage 2 detected
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int nlg5_e_mov_ii : 1;

    /**
     * Mains overvoltage 1 detected
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int nlg5_e_mov_i : 1;

    /**
     * power stage short circuit condition detected; error can only be cleared by cycling power ON-OFF-ON
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int nlg5_e_sc : 1;

    /**
     * plausibility battery output voltage measurement wrong
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int nlg5_e_p_om : 1;

    /**
     * plausibility mains voltage measurement wrong
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int nlg5_e_p_mv : 1;

    /**
     * output fuse defective
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int nlg5_e_of : 1;

    /**
     * Mains fuse defective
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int nlg5_e_mf : 1;

    /**
     * wrong battery polarity;  error can only be cleared by cycling power ON-OFF-ON
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int nlg5_e_b_p : 1;

    /**
     * Temperature sensor for prim capacitor defective
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int nlg5_e_t_c : 1;

    /**
     * Temperature sensor for prim power stage defective
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int nlg5_e_t_pow : 1;

    /**
     * Temperature sensor for diodes defective
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int nlg5_e_t_dio : 1;

    /**
     * Temperature sensor for transformer defective
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int nlg5_e_t_tr : 1;

    /**
     * Ext. temperature sensor 1 defective (if enabled)
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int nlg5_e_t_ext1 : 1;

    /**
     * Ext. temperature sensor 2 defective (if enabled)
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int nlg5_e_t_ext2 : 1;

    /**
     * Ext. temperature sensor 3 defective (if enabled)
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int nlg5_e_t_ext3 : 1;

    /**
     * Flash memory checksum failure
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int nlg5_e_f_crc : 1;

    /**
     * NVSRAM check sum failure; contains most of the scaling & calibration values, CAN ID's and  charging profile etc.
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int nlg5_e_nv_crc : 1;

    /**
     * Sys EEPROM checksum failure
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int nlg5_e_es_crc : 1;

    /**
     * Pow EEPROM checksum failure
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int nlg5_e_ep_crc : 1;

    /**
     * Internal Watchdog Timeout
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int nlg5_e_wdt : 1;

    /**
     * Initialization error
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int nlg5_e_init : 1;

    /**
     * CAN timeout, no control message received for >300ms
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int nlg5_e_c_to : 1;

    /**
     * CAN off, transmit buffer >255
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int nlg5_e_c_off : 1;

    /**
     * CAN transmit buffer >127
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int nlg5_e_c_tx : 1;

    /**
     * CAN receiver buffer >127
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int nlg5_e_c_rx : 1;

    /**
     * Emergency Shutdown Threshold 'Battery Temperature' is exceeded; see ChargeStar help section 'protective features';  error can only be cleared by cycling power ON-OFF-ON
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int nlg5_e_sdt_bt : 1;

    /**
     * Emergency Shutdown Threshold 'Battery Voltage' is exceeded; see ChargeStar help section 'protective features';  error can only be cleared by cycling power ON-OFF-ON
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int nlg5_e_sdt_bv : 1;

    /**
     * Emergency Shutdown Threshold 'Amp Hours' is exceeded; see ChargeStar help section 'protective features';  error can only be cleared by cycling power ON-OFF-ON
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int nlg5_e_sdt_ah : 1;

    /**
     * Emergency Shutdown Threshold 'Charging Time' is exceeded; see ChargeStar help section 'protective features';  error can only be cleared by cycling power ON-OFF-ON
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int nlg5_e_sdt_ct : 1;

    /**
     * Output power limited by low mains voltage
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int nlg5_w_pl_mv : 1;

    /**
     * Output power limited by low battery voltage
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int nlg5_w_pl_bv : 1;

    /**
     * Output power limited by charger internal overtemperature
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int nlg5_w_pl_it : 1;

    /**
     * Commanded value is out of specified range; max or min applicable value is assumed instead
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int nlg5_w_c_vor : 1;

    /**
     * NLG5 Control message not active
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    unsigned int nlg5_w_cm_na : 1;

    /**
     * LED Output driver defective, LEDs can´t be controlled by NLG5 anymore. Charging is still possible.
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    unsigned int nlg5_w_od : 1;

    /**
     * Save-Charging-Mode reduces primary current to 3.95 A as long as one of the four internal temperature sensors indicates -18° C or less.
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    unsigned int nlg5_w_sc_m : 1;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_nlg5_err_converted_t;

/**
 * Signals in message NLG5_TEMP.
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Power stage temperature
     *
     * Range: -400..3000 (-40..300 °C)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t nlg5_p_tmp;

    /**
     * Value of external battery temperature sensor #1 (if connected and enabled)
     *
     * Range: -400..3000 (-40..300 °C)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t nlg5_tmp_ext1;

    /**
     * Value of external battery temperature sensor #2 (if connected and enabled)
     *
     * Range: -400..3000 (-40..300 °C)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t nlg5_temp_ext2;

    /**
     * Value of external battery temperature sensor #3 (if connected and enabled)
     *
     * Range: -400..3000 (-40..300 °C)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t nlg5_tmp_ext3;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_nlg5_temp_t;

/**
 * Signals in message NLG5_TEMP.
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Power stage temperature
     *
     * Range: -400..3000 (-40..300 °C)
     * Scale: 0.1
     * Offset: 0
     */
    float nlg5_p_tmp;

    /**
     * Value of external battery temperature sensor #1 (if connected and enabled)
     *
     * Range: -400..3000 (-40..300 °C)
     * Scale: 0.1
     * Offset: 0
     */
    float nlg5_tmp_ext1;

    /**
     * Value of external battery temperature sensor #2 (if connected and enabled)
     *
     * Range: -400..3000 (-40..300 °C)
     * Scale: 0.1
     * Offset: 0
     */
    float nlg5_temp_ext2;

    /**
     * Value of external battery temperature sensor #3 (if connected and enabled)
     *
     * Range: -400..3000 (-40..300 °C)
     * Scale: 0.1
     * Offset: 0
     */
    float nlg5_tmp_ext3;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_nlg5_temp_converted_t;

/**
 * Signals in message NLG5_ACT_II.
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Value of mains current limit, commanded by the control pilot (SAE J1772) signal
     *
     * Range: 0..1000 (0..100 A)
     * Scale: 0.1
     * Offset: 0
     */
    uint16_t nlg5_s_mc_m_cp;

    /**
     * Value of mains current limit, commanded by the 'power indicator' (PI) analog input signal
     *
     * Range: 0..200 (0..20 A)
     * Scale: 0.1
     * Offset: 0
     */
    uint8_t nlg5_s_mc_m_pi;

    /**
     * Aux battery voltage
     *
     * Range: 0..250 (0..25 V)
     * Scale: 0.1
     * Offset: 0
     */
    uint8_t nlg5_abv;

    /**
     * Charge balance obtained via  Ext. Ah counter connected to DI1 / DI2
     *
     * Range: -32768..32767 (-327.68..327.67 Ah)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t nlg5_ahc_ext;

    /**
     * output current of the booster (if one is present and active)
     *
     * Range: 0..5000 (0..50 A)
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t nlg5_oc_bo;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_nlg5_act_ii_t;

/**
 * Signals in message NLG5_ACT_II.
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Value of mains current limit, commanded by the control pilot (SAE J1772) signal
     *
     * Range: 0..1000 (0..100 A)
     * Scale: 0.1
     * Offset: 0
     */
    float nlg5_s_mc_m_cp;

    /**
     * Value of mains current limit, commanded by the 'power indicator' (PI) analog input signal
     *
     * Range: 0..200 (0..20 A)
     * Scale: 0.1
     * Offset: 0
     */
    float nlg5_s_mc_m_pi;

    /**
     * Aux battery voltage
     *
     * Range: 0..250 (0..25 V)
     * Scale: 0.1
     * Offset: 0
     */
    float nlg5_abv;

    /**
     * Charge balance obtained via  Ext. Ah counter connected to DI1 / DI2
     *
     * Range: -32768..32767 (-327.68..327.67 Ah)
     * Scale: 0.01
     * Offset: 0
     */
    float nlg5_ahc_ext;

    /**
     * output current of the booster (if one is present and active)
     *
     * Range: 0..5000 (0..50 A)
     * Scale: 0.01
     * Offset: 0
     */
    float nlg5_oc_bo;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_nlg5_act_ii_converted_t;

/**
 * Signals in message NLG5_ACT_I.
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Actual mains current
     *
     * Range: 0..5000 (0..50 A)
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t nlg5_mc_act;

    /**
     * Actual mains voltage
     *
     * Range: 0..5000 (0..500 V)
     * Scale: 0.1
     * Offset: 0
     */
    uint16_t nlg5_mv_act;

    /**
     * Actual battery output voltage
     *
     * Range: 0..10000 (0..1000 V)
     * Scale: 0.1
     * Offset: 0
     */
    uint16_t nlg5_ov_act;

    /**
     * output current to the battery
     *
     * Range: 0..15000 (0..150 A)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t nlg5_oc_act;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_nlg5_act_i_t;

/**
 * Signals in message NLG5_ACT_I.
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Actual mains current
     *
     * Range: 0..5000 (0..50 A)
     * Scale: 0.01
     * Offset: 0
     */
    float nlg5_mc_act;

    /**
     * Actual mains voltage
     *
     * Range: 0..5000 (0..500 V)
     * Scale: 0.1
     * Offset: 0
     */
    float nlg5_mv_act;

    /**
     * Actual battery output voltage
     *
     * Range: 0..10000 (0..1000 V)
     * Scale: 0.1
     * Offset: 0
     */
    float nlg5_ov_act;

    /**
     * output current to the battery
     *
     * Range: 0..15000 (0..150 A)
     * Scale: 0.01
     * Offset: 0
     */
    float nlg5_oc_act;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_nlg5_act_i_converted_t;

/**
 * Signals in message NLG5_ST.
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Indicates if hardware enabled, i.e. a hi or lo signal is fed to the 'Power On' pin (pin3 of control connector)
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_s_he;

    /**
     * An error has been detected, red LED is ON, no power is output
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_s_err;

    /**
     * Warning condition on, i.e. charging power limited due to any limiting condition; red LED is blinking
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_s_war;

    /**
     * Charger cooling fan is active
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_s_fan;

    /**
     * European mains input detected (230V, 50Hz)
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_s_eum;

    /**
     * US mains level 1 (120VAC / 60Hz) detected
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_s_um_i;

    /**
     * US mains level 2 (240VAC / 60Hz) detected
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_s_um_ii;

    /**
     * Control pilot signal (SAE J1772) detected
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_s_cp_dt;

    /**
     * Bypass detection bit 1; 00: no bypass, 01: DC bypass detected, 10:AC bypass in phase, 11: AC bypass not in phase
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_s_bpd_i;

    /**
     * Bypass detection bit 2; 00: no bypass, 01: DC bypass detected, 10:AC bypass in phase, 11: AC bypass not in phase
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_s_bpd_ii;

    /**
     * Output power limited by battery output voltage limit
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_s_l_ov;

    /**
     * Output power limited by battery output current limit
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_s_l_oc;

    /**
     * Output power limited by mains current limit
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_s_l_mc;

    /**
     * Output power limited by analog input 'power indicator' (PI) limit
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_s_l_pi;

    /**
     * Output power limited by control pilot signal (SAE J1772)
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_s_l_cp;

    /**
     * Output power limited by maximum power capability of NLG5
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_s_l_pmax;

    /**
     * Output power limited by maximum mains current capability of NLG5
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_s_l_mc_max;

    /**
     * Output power limited by maximum output current capability of NLG5
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_s_l_oc_max;

    /**
     * Output power limited by maximum output voltage capability of NLG5
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_s_l_mo_max;

    /**
     * Output power limited by temperature of primary capacitors
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_s_l_t_cprim;

    /**
     * Output power limited by temperature of power stage
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_s_l_t_pow;

    /**
     * Output power limited by temperature of diodes
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_s_l_t_dio;

    /**
     * Output power limited by temperature of transformer
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_s_l_t_tr;

    /**
     * Output power limited by battery temperature
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_s_l_t_batt;

    /**
     * AUX 12 V Automatic Charging Active
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_s_aac;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_nlg5_st_t;

/**
 * Signals in message NLG5_ST.
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Indicates if hardware enabled, i.e. a hi or lo signal is fed to the 'Power On' pin (pin3 of control connector)
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int nlg5_s_he : 1;

    /**
     * An error has been detected, red LED is ON, no power is output
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int nlg5_s_err : 1;

    /**
     * Warning condition on, i.e. charging power limited due to any limiting condition; red LED is blinking
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int nlg5_s_war : 1;

    /**
     * Charger cooling fan is active
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int nlg5_s_fan : 1;

    /**
     * European mains input detected (230V, 50Hz)
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int nlg5_s_eum : 1;

    /**
     * US mains level 1 (120VAC / 60Hz) detected
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int nlg5_s_um_i : 1;

    /**
     * US mains level 2 (240VAC / 60Hz) detected
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int nlg5_s_um_ii : 1;

    /**
     * Control pilot signal (SAE J1772) detected
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int nlg5_s_cp_dt : 1;

    /**
     * Bypass detection bit 1; 00: no bypass, 01: DC bypass detected, 10:AC bypass in phase, 11: AC bypass not in phase
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int nlg5_s_bpd_i : 1;

    /**
     * Bypass detection bit 2; 00: no bypass, 01: DC bypass detected, 10:AC bypass in phase, 11: AC bypass not in phase
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int nlg5_s_bpd_ii : 1;

    /**
     * Output power limited by battery output voltage limit
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int nlg5_s_l_ov : 1;

    /**
     * Output power limited by battery output current limit
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int nlg5_s_l_oc : 1;

    /**
     * Output power limited by mains current limit
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int nlg5_s_l_mc : 1;

    /**
     * Output power limited by analog input 'power indicator' (PI) limit
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int nlg5_s_l_pi : 1;

    /**
     * Output power limited by control pilot signal (SAE J1772)
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int nlg5_s_l_cp : 1;

    /**
     * Output power limited by maximum power capability of NLG5
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int nlg5_s_l_pmax : 1;

    /**
     * Output power limited by maximum mains current capability of NLG5
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int nlg5_s_l_mc_max : 1;

    /**
     * Output power limited by maximum output current capability of NLG5
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int nlg5_s_l_oc_max : 1;

    /**
     * Output power limited by maximum output voltage capability of NLG5
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int nlg5_s_l_mo_max : 1;

    /**
     * Output power limited by temperature of primary capacitors
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int nlg5_s_l_t_cprim : 1;

    /**
     * Output power limited by temperature of power stage
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int nlg5_s_l_t_pow : 1;

    /**
     * Output power limited by temperature of diodes
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int nlg5_s_l_t_dio : 1;

    /**
     * Output power limited by temperature of transformer
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int nlg5_s_l_t_tr : 1;

    /**
     * Output power limited by battery temperature
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int nlg5_s_l_t_batt : 1;

    /**
     * AUX 12 V Automatic Charging Active
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int nlg5_s_aac : 1;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_nlg5_st_converted_t;

/**
 * Signals in message NLG5_CTL.
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Must be ON to enable power stage of the charger
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_c_c_en;

    /**
     * cycle this value 0-1-0 to clear all latched charger errors
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_c_c_el;

    /**
     * special signal to tell a charging station equipped with the Control Pilot interface (SAE J1772) to switch on the facility's ventilation (in order to get rid of battery gases like hydrogen, e.g.)
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_c_cp_v;

    /**
     * Enables CP-State C to request mains voltage
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_c_mr;

    /**
     * Maximum current to be drawn from the mains outlet, usually 16A. Must always contain a valid value in order to keep on charging.
     *
     * Range: 0..500 (0..50 A)
     * Scale: 0.1
     * Offset: 0
     */
    uint16_t nlg5_mc_max;

    /**
     * Desired voltage to be output to the battery. Must always contain a valid value in order to keep on charging.
     *
     * Range: 0..10000 (0..1000 V)
     * Scale: 0.1
     * Offset: 0
     */
    uint16_t nlg5_ov_com;

    /**
     * Desired battery current. Must always contain a valid value in order to keep on charging.
     *
     * Range: 0..1500 (0..150 A)
     * Scale: 0.1
     * Offset: 0
     */
    uint16_t nlg5_oc_com;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_nlg5_ctl_t;

/**
 * Signals in message NLG5_CTL.
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Must be ON to enable power stage of the charger
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int nlg5_c_c_en : 1;

    /**
     * cycle this value 0-1-0 to clear all latched charger errors
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int nlg5_c_c_el : 1;

    /**
     * special signal to tell a charging station equipped with the Control Pilot interface (SAE J1772) to switch on the facility's ventilation (in order to get rid of battery gases like hydrogen, e.g.)
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int nlg5_c_cp_v : 1;

    /**
     * Enables CP-State C to request mains voltage
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int nlg5_c_mr : 1;

    /**
     * Maximum current to be drawn from the mains outlet, usually 16A. Must always contain a valid value in order to keep on charging.
     *
     * Range: 0..500 (0..50 A)
     * Scale: 0.1
     * Offset: 0
     */
    float nlg5_mc_max;

    /**
     * Desired voltage to be output to the battery. Must always contain a valid value in order to keep on charging.
     *
     * Range: 0..10000 (0..1000 V)
     * Scale: 0.1
     * Offset: 0
     */
    float nlg5_ov_com;

    /**
     * Desired battery current. Must always contain a valid value in order to keep on charging.
     *
     * Range: 0..1500 (0..150 A)
     * Scale: 0.1
     * Offset: 0
     */
    float nlg5_oc_com;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_nlg5_ctl_converted_t;

/**
 * Signals in message HV_JMP_TO_BLT.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_hv_jmp_to_blt_forward forward;

    /**
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    primary_hv_jmp_to_blt_cellboard_id cellboard_id;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_jmp_to_blt_t;

/**
 * Signals in message HV_JMP_TO_BLT.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_hv_jmp_to_blt_forward forward;

    /**
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    primary_hv_jmp_to_blt_cellboard_id cellboard_id;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_jmp_to_blt_converted_t;

/**
 * Signals in message HV_FLASH_MAINBOARD_TX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_flash_mainboard_tx_t;

/**
 * Signals in message HV_FLASH_MAINBOARD_TX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_flash_mainboard_tx_converted_t;

/**
 * Signals in message HV_FLASH_MAINBOARD_RX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_flash_mainboard_rx_t;

/**
 * Signals in message HV_FLASH_MAINBOARD_RX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_flash_mainboard_rx_converted_t;

/**
 * Signals in message HV_FLASH_CELLBOARD_0_TX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_flash_cellboard_0_tx_t;

/**
 * Signals in message HV_FLASH_CELLBOARD_0_TX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_flash_cellboard_0_tx_converted_t;

/**
 * Signals in message HV_FLASH_CELLBOARD_0_RX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_flash_cellboard_0_rx_t;

/**
 * Signals in message HV_FLASH_CELLBOARD_0_RX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_flash_cellboard_0_rx_converted_t;

/**
 * Signals in message HV_FLASH_CELLBOARD_1_TX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_flash_cellboard_1_tx_t;

/**
 * Signals in message HV_FLASH_CELLBOARD_1_TX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_flash_cellboard_1_tx_converted_t;

/**
 * Signals in message HV_FLASH_CELLBOARD_1_RX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_flash_cellboard_1_rx_t;

/**
 * Signals in message HV_FLASH_CELLBOARD_1_RX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_flash_cellboard_1_rx_converted_t;

/**
 * Signals in message HV_FLASH_CELLBOARD_2_TX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_flash_cellboard_2_tx_t;

/**
 * Signals in message HV_FLASH_CELLBOARD_2_TX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_flash_cellboard_2_tx_converted_t;

/**
 * Signals in message HV_FLASH_CELLBOARD_2_RX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_flash_cellboard_2_rx_t;

/**
 * Signals in message HV_FLASH_CELLBOARD_2_RX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_flash_cellboard_2_rx_converted_t;

/**
 * Signals in message HV_FLASH_CELLBOARD_3_TX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_flash_cellboard_3_tx_t;

/**
 * Signals in message HV_FLASH_CELLBOARD_3_TX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_flash_cellboard_3_tx_converted_t;

/**
 * Signals in message HV_FLASH_CELLBOARD_3_RX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_flash_cellboard_3_rx_t;

/**
 * Signals in message HV_FLASH_CELLBOARD_3_RX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_flash_cellboard_3_rx_converted_t;

/**
 * Signals in message HV_FLASH_CELLBOARD_4_TX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_flash_cellboard_4_tx_t;

/**
 * Signals in message HV_FLASH_CELLBOARD_4_TX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_flash_cellboard_4_tx_converted_t;

/**
 * Signals in message HV_FLASH_CELLBOARD_4_RX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_flash_cellboard_4_rx_t;

/**
 * Signals in message HV_FLASH_CELLBOARD_4_RX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_flash_cellboard_4_rx_converted_t;

/**
 * Signals in message HV_FLASH_CELLBOARD_5_TX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_flash_cellboard_5_tx_t;

/**
 * Signals in message HV_FLASH_CELLBOARD_5_TX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_flash_cellboard_5_tx_converted_t;

/**
 * Signals in message HV_FLASH_CELLBOARD_5_RX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_flash_cellboard_5_rx_t;

/**
 * Signals in message HV_FLASH_CELLBOARD_5_RX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_flash_cellboard_5_rx_converted_t;

/**
 * Signals in message LV_JMP_TO_BLT.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_lv_jmp_to_blt_t;

/**
 * Signals in message LV_JMP_TO_BLT.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_lv_jmp_to_blt_converted_t;

/**
 * Signals in message LV_FLASH_TX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_lv_flash_tx_t;

/**
 * Signals in message LV_FLASH_TX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_lv_flash_tx_converted_t;

/**
 * Signals in message LV_FLASH_RX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_lv_flash_rx_t;

/**
 * Signals in message LV_FLASH_RX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_lv_flash_rx_converted_t;

/**
 * Signals in message ECU_JMP_TO_BLT.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_ecu_jmp_to_blt_t;

/**
 * Signals in message ECU_JMP_TO_BLT.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_ecu_jmp_to_blt_converted_t;

/**
 * Signals in message ECU_FLASH_TX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_ecu_flash_tx_t;

/**
 * Signals in message ECU_FLASH_TX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_ecu_flash_tx_converted_t;

/**
 * Signals in message ECU_FLASH_RX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_ecu_flash_rx_t;

/**
 * Signals in message ECU_FLASH_RX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_ecu_flash_rx_converted_t;

/**
 * Signals in message STEERING_WHEEL_JMP_TO_BLT.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_steering_wheel_jmp_to_blt_t;

/**
 * Signals in message STEERING_WHEEL_JMP_TO_BLT.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_steering_wheel_jmp_to_blt_converted_t;

/**
 * Signals in message STEERING_WHEEL_FLASH_TX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_steering_wheel_flash_tx_t;

/**
 * Signals in message STEERING_WHEEL_FLASH_TX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_steering_wheel_flash_tx_converted_t;

/**
 * Signals in message STEERING_WHEEL_FLASH_RX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_steering_wheel_flash_rx_t;

/**
 * Signals in message STEERING_WHEEL_FLASH_RX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_steering_wheel_flash_rx_converted_t;

/**
 * Signals in message STEERING_WHEEL_VERSION.
 *
 * Steering wheel version: build-time timestamp and canlib build-time timestamp
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..4294967295 (0..4294967295 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t component_build_time;

    /**
     * Range: 0..4294967295 (0..4294967295 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t canlib_build_time;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_steering_wheel_version_t;

/**
 * Signals in message STEERING_WHEEL_VERSION.
 *
 * Steering wheel version: build-time timestamp and canlib build-time timestamp
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..4294967295 (0..4294967295 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t component_build_time;

    /**
     * Range: 0..4294967295 (0..4294967295 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t canlib_build_time;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_steering_wheel_version_converted_t;

/**
 * Signals in message ECU_VERSION.
 *
 * Ecu version: build-time timestamp and canlib build-time timestamp
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..4294967295 (0..4294967295 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t component_build_time;

    /**
     * Range: 0..4294967295 (0..4294967295 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t canlib_build_time;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_ecu_version_t;

/**
 * Signals in message ECU_VERSION.
 *
 * Ecu version: build-time timestamp and canlib build-time timestamp
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..4294967295 (0..4294967295 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t component_build_time;

    /**
     * Range: 0..4294967295 (0..4294967295 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t canlib_build_time;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_ecu_version_converted_t;

/**
 * Signals in message LV_VERSION.
 *
 * Telemetry version: build-time timestamp and canlib build-time timestamp
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..4294967295 (0..4294967295 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t component_build_time;

    /**
     * Range: 0..4294967295 (0..4294967295 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t canlib_build_time;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_lv_version_t;

/**
 * Signals in message LV_VERSION.
 *
 * Telemetry version: build-time timestamp and canlib build-time timestamp
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..4294967295 (0..4294967295 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t component_build_time;

    /**
     * Range: 0..4294967295 (0..4294967295 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t canlib_build_time;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_lv_version_converted_t;

/**
 * Signals in message TLM_VERSION.
 *
 * Telemetry version: build-time timestamp and canlib build-time timestamp
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..4294967295 (0..4294967295 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t component_build_time;

    /**
     * Range: 0..4294967295 (0..4294967295 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t canlib_build_time;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_tlm_version_t;

/**
 * Signals in message TLM_VERSION.
 *
 * Telemetry version: build-time timestamp and canlib build-time timestamp
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..4294967295 (0..4294967295 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t component_build_time;

    /**
     * Range: 0..4294967295 (0..4294967295 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t canlib_build_time;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_tlm_version_converted_t;

/**
 * Signals in message HV_MAINBOARD_VERSION.
 *
 * Hv mainboard version: build-time timestamp and canlib build-time timestamp
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..4294967295 (0..4294967295 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t component_build_time;

    /**
     * Range: 0..4294967295 (0..4294967295 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t canlib_build_time;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_mainboard_version_t;

/**
 * Signals in message HV_MAINBOARD_VERSION.
 *
 * Hv mainboard version: build-time timestamp and canlib build-time timestamp
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..4294967295 (0..4294967295 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t component_build_time;

    /**
     * Range: 0..4294967295 (0..4294967295 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t canlib_build_time;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_mainboard_version_converted_t;

/**
 * Signals in message HV_CELLBOARD_VERSION.
 *
 * Hv cellboard version: build-time timestamp and canlib build-time timestamp
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    primary_hv_cellboard_version_cellboard_id cellboard_id;

    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t component_version;

    /**
     * Range: 0..4294967295 (0..4294967295 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t canlib_build_time;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_cellboard_version_t;

/**
 * Signals in message HV_CELLBOARD_VERSION.
 *
 * Hv cellboard version: build-time timestamp and canlib build-time timestamp
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    primary_hv_cellboard_version_cellboard_id cellboard_id;

    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t component_version;

    /**
     * Range: 0..4294967295 (0..4294967295 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t canlib_build_time;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_cellboard_version_converted_t;

/**
 * Signals in message HV_ERRORS.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_cell_under_voltage;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_cell_over_voltage;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_cell_under_temperature;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_cell_over_temperature;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_over_current;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_can;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_int_voltage_mismatch;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_cellboard_comm;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_cellboard_internal;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_connector_disconnected;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_fans_disconnected;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_feedback;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_feedback_circuitry;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_eeprom_comm;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_eeprom_write;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_errors_t;

/**
 * Signals in message HV_ERRORS.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_cell_under_voltage : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_cell_over_voltage : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_cell_under_temperature : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_cell_over_temperature : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_over_current : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_can : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_int_voltage_mismatch : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_cellboard_comm : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_cellboard_internal : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_connector_disconnected : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_fans_disconnected : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_feedback : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_feedback_circuitry : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_eeprom_comm : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_eeprom_write : 1;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_errors_converted_t;

/**
 * Signals in message HV_DEBUG_SIGNALS.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t feedbacks_implausibility_detected;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t feedbacks_imd_cockpit;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t feedbacks_tsal_green_fault_latched;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t feedbacks_bms_cockpit;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t feedbacks_ext_latched;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t feedbacks_tsal_green;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t feedbacks_ts_over_60v_status;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t feedbacks_airn_status;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t feedbacks_airp_status;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t feedbacks_airp_gate;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t feedbacks_airn_gate;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t feedbacks_precharge_status;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t feedbacks_tsp_over_60v_status;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t feedbacks_imd_fault;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t feedbacks_check_mux;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t feedbacks_sd_end;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t feedbacks_sd_out;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t feedbacks_sd_in;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t feedbacks_sd_bms;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t feedbacks_sd_imd;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_cell_under_voltage;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_cell_over_voltage;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_cell_under_temperature;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_cell_over_temperature;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_over_current;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_can;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_int_voltage_mismatch;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_cellboard_comm;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_cellboard_internal;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_connector_disconnected;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_fans_disconnected;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_feedback;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_feedback_circuitry;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_eeprom_comm;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_eeprom_write;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_debug_signals_t;

/**
 * Signals in message HV_DEBUG_SIGNALS.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int feedbacks_implausibility_detected : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int feedbacks_imd_cockpit : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int feedbacks_tsal_green_fault_latched : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int feedbacks_bms_cockpit : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int feedbacks_ext_latched : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int feedbacks_tsal_green : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int feedbacks_ts_over_60v_status : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int feedbacks_airn_status : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int feedbacks_airp_status : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int feedbacks_airp_gate : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int feedbacks_airn_gate : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int feedbacks_precharge_status : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int feedbacks_tsp_over_60v_status : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int feedbacks_imd_fault : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int feedbacks_check_mux : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int feedbacks_sd_end : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int feedbacks_sd_out : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int feedbacks_sd_in : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int feedbacks_sd_bms : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int feedbacks_sd_imd : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_cell_under_voltage : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_cell_over_voltage : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_cell_under_temperature : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_cell_over_temperature : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_over_current : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_can : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_int_voltage_mismatch : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_cellboard_comm : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_cellboard_internal : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_connector_disconnected : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_fans_disconnected : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_feedback : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_feedback_circuitry : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_eeprom_comm : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_eeprom_write : 1;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_debug_signals_converted_t;

/**
 * Signals in message HV_FANS_STATUS.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_hv_fans_status_fans_override fans_override;

    /**
     * Range: 0..65535 (0..1 -)
     * Scale: 1.5259021896696422e-05
     * Offset: 0
     */
    uint16_t fans_speed;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_fans_status_t;

/**
 * Signals in message HV_FANS_STATUS.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_hv_fans_status_fans_override fans_override;

    /**
     * Range: 0..65535 (0..1 -)
     * Scale: 1.5259021896696422e-05
     * Offset: 0
     */
    float fans_speed;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_fans_status_converted_t;

/**
 * Signals in message HV_SET_FANS_STATUS.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_hv_set_fans_status_fans_override fans_override;

    /**
     * Range: 0..65535 (0..1 -)
     * Scale: 1.5259021896696422e-05
     * Offset: 0
     */
    uint16_t fans_speed;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_set_fans_status_t;

/**
 * Signals in message HV_SET_FANS_STATUS.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_hv_set_fans_status_fans_override fans_override;

    /**
     * Range: 0..65535 (0..1 -)
     * Scale: 1.5259021896696422e-05
     * Offset: 0
     */
    float fans_speed;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_set_fans_status_converted_t;

/**
 * Signals in message HV_FEEDBACK_STATUS.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    primary_hv_feedback_status_feedback_implausibility_detected feedback_implausibility_detected;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    primary_hv_feedback_status_feedback_imd_cockpit feedback_imd_cockpit;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    primary_hv_feedback_status_feedback_tsal_green_fault_latched feedback_tsal_green_fault_latched;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    primary_hv_feedback_status_feedback_bms_cockpit feedback_bms_cockpit;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    primary_hv_feedback_status_feedback_ext_latched feedback_ext_latched;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    primary_hv_feedback_status_feedback_tsal_green feedback_tsal_green;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    primary_hv_feedback_status_feedback_ts_over_60v_status feedback_ts_over_60v_status;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    primary_hv_feedback_status_feedback_airn_status feedback_airn_status;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    primary_hv_feedback_status_feedback_airp_status feedback_airp_status;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    primary_hv_feedback_status_feedback_airp_gate feedback_airp_gate;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    primary_hv_feedback_status_feedback_airn_gate feedback_airn_gate;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    primary_hv_feedback_status_feedback_precharge_status feedback_precharge_status;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    primary_hv_feedback_status_feedback_tsp_over_60v_status feedback_tsp_over_60v_status;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    primary_hv_feedback_status_feedback_imd_fault feedback_imd_fault;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    primary_hv_feedback_status_feedback_check_mux feedback_check_mux;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    primary_hv_feedback_status_feedback_sd_end feedback_sd_end;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    primary_hv_feedback_status_feedback_sd_out feedback_sd_out;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    primary_hv_feedback_status_feedback_sd_in feedback_sd_in;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    primary_hv_feedback_status_feedback_sd_bms feedback_sd_bms;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    primary_hv_feedback_status_feedback_sd_imd feedback_sd_imd;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_feedback_status_t;

/**
 * Signals in message HV_FEEDBACK_STATUS.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    primary_hv_feedback_status_feedback_implausibility_detected feedback_implausibility_detected;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    primary_hv_feedback_status_feedback_imd_cockpit feedback_imd_cockpit;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    primary_hv_feedback_status_feedback_tsal_green_fault_latched feedback_tsal_green_fault_latched;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    primary_hv_feedback_status_feedback_bms_cockpit feedback_bms_cockpit;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    primary_hv_feedback_status_feedback_ext_latched feedback_ext_latched;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    primary_hv_feedback_status_feedback_tsal_green feedback_tsal_green;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    primary_hv_feedback_status_feedback_ts_over_60v_status feedback_ts_over_60v_status;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    primary_hv_feedback_status_feedback_airn_status feedback_airn_status;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    primary_hv_feedback_status_feedback_airp_status feedback_airp_status;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    primary_hv_feedback_status_feedback_airp_gate feedback_airp_gate;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    primary_hv_feedback_status_feedback_airn_gate feedback_airn_gate;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    primary_hv_feedback_status_feedback_precharge_status feedback_precharge_status;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    primary_hv_feedback_status_feedback_tsp_over_60v_status feedback_tsp_over_60v_status;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    primary_hv_feedback_status_feedback_imd_fault feedback_imd_fault;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    primary_hv_feedback_status_feedback_check_mux feedback_check_mux;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    primary_hv_feedback_status_feedback_sd_end feedback_sd_end;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    primary_hv_feedback_status_feedback_sd_out feedback_sd_out;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    primary_hv_feedback_status_feedback_sd_in feedback_sd_in;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    primary_hv_feedback_status_feedback_sd_bms feedback_sd_bms;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    primary_hv_feedback_status_feedback_sd_imd feedback_sd_imd;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_feedback_status_converted_t;

/**
 * Signals in message HV_FEEDBACK_TS_VOLTAGE.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..254.99999999999997 (0..3.3 -)
     * Scale: 0.012941176470588235
     * Offset: 0
     */
    uint8_t ts_over_60v_status;

    /**
     * Range: 0..254.99999999999997 (0..3.3 -)
     * Scale: 0.012941176470588235
     * Offset: 0
     */
    uint8_t airn_status;

    /**
     * Range: 0..254.99999999999997 (0..3.3 -)
     * Scale: 0.012941176470588235
     * Offset: 0
     */
    uint8_t airp_status;

    /**
     * Range: 0..254.99999999999997 (0..3.3 -)
     * Scale: 0.012941176470588235
     * Offset: 0
     */
    uint8_t airp_gate;

    /**
     * Range: 0..254.99999999999997 (0..3.3 -)
     * Scale: 0.012941176470588235
     * Offset: 0
     */
    uint8_t airn_gate;

    /**
     * Range: 0..254.99999999999997 (0..3.3 -)
     * Scale: 0.012941176470588235
     * Offset: 0
     */
    uint8_t precharge_status;

    /**
     * Range: 0..254.99999999999997 (0..3.3 -)
     * Scale: 0.012941176470588235
     * Offset: 0
     */
    uint8_t tsp_over_60v_status;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_feedback_ts_voltage_t;

/**
 * Signals in message HV_FEEDBACK_TS_VOLTAGE.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..254.99999999999997 (0..3.3 -)
     * Scale: 0.012941176470588235
     * Offset: 0
     */
    float ts_over_60v_status;

    /**
     * Range: 0..254.99999999999997 (0..3.3 -)
     * Scale: 0.012941176470588235
     * Offset: 0
     */
    float airn_status;

    /**
     * Range: 0..254.99999999999997 (0..3.3 -)
     * Scale: 0.012941176470588235
     * Offset: 0
     */
    float airp_status;

    /**
     * Range: 0..254.99999999999997 (0..3.3 -)
     * Scale: 0.012941176470588235
     * Offset: 0
     */
    float airp_gate;

    /**
     * Range: 0..254.99999999999997 (0..3.3 -)
     * Scale: 0.012941176470588235
     * Offset: 0
     */
    float airn_gate;

    /**
     * Range: 0..254.99999999999997 (0..3.3 -)
     * Scale: 0.012941176470588235
     * Offset: 0
     */
    float precharge_status;

    /**
     * Range: 0..254.99999999999997 (0..3.3 -)
     * Scale: 0.012941176470588235
     * Offset: 0
     */
    float tsp_over_60v_status;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_feedback_ts_voltage_converted_t;

/**
 * Signals in message HV_FEEDBACK_MISC_VOLTAGE.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..254.99999999999997 (0..3.3 -)
     * Scale: 0.012941176470588235
     * Offset: 0
     */
    uint8_t implausibility_detected;

    /**
     * Range: 0..254.99999999999997 (0..3.3 -)
     * Scale: 0.012941176470588235
     * Offset: 0
     */
    uint8_t imd_cockpit;

    /**
     * Range: 0..254.99999999999997 (0..3.3 -)
     * Scale: 0.012941176470588235
     * Offset: 0
     */
    uint8_t tsal_green_fault_latched;

    /**
     * Range: 0..254.99999999999997 (0..3.3 -)
     * Scale: 0.012941176470588235
     * Offset: 0
     */
    uint8_t bms_cockpit;

    /**
     * Range: 0..254.99999999999997 (0..3.3 -)
     * Scale: 0.012941176470588235
     * Offset: 0
     */
    uint8_t ext_latched;

    /**
     * Range: 0..254.99999999999997 (0..3.3 -)
     * Scale: 0.012941176470588235
     * Offset: 0
     */
    uint8_t tsal_green;

    /**
     * Range: 0..254.99999999999997 (0..3.3 -)
     * Scale: 0.012941176470588235
     * Offset: 0
     */
    uint8_t imd_fault;

    /**
     * Range: 0..254.99999999999997 (0..3.3 -)
     * Scale: 0.012941176470588235
     * Offset: 0
     */
    uint8_t check_mux;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_feedback_misc_voltage_t;

/**
 * Signals in message HV_FEEDBACK_MISC_VOLTAGE.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..254.99999999999997 (0..3.3 -)
     * Scale: 0.012941176470588235
     * Offset: 0
     */
    float implausibility_detected;

    /**
     * Range: 0..254.99999999999997 (0..3.3 -)
     * Scale: 0.012941176470588235
     * Offset: 0
     */
    float imd_cockpit;

    /**
     * Range: 0..254.99999999999997 (0..3.3 -)
     * Scale: 0.012941176470588235
     * Offset: 0
     */
    float tsal_green_fault_latched;

    /**
     * Range: 0..254.99999999999997 (0..3.3 -)
     * Scale: 0.012941176470588235
     * Offset: 0
     */
    float bms_cockpit;

    /**
     * Range: 0..254.99999999999997 (0..3.3 -)
     * Scale: 0.012941176470588235
     * Offset: 0
     */
    float ext_latched;

    /**
     * Range: 0..254.99999999999997 (0..3.3 -)
     * Scale: 0.012941176470588235
     * Offset: 0
     */
    float tsal_green;

    /**
     * Range: 0..254.99999999999997 (0..3.3 -)
     * Scale: 0.012941176470588235
     * Offset: 0
     */
    float imd_fault;

    /**
     * Range: 0..254.99999999999997 (0..3.3 -)
     * Scale: 0.012941176470588235
     * Offset: 0
     */
    float check_mux;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_feedback_misc_voltage_converted_t;

/**
 * Signals in message HV_FEEDBACK_SD_VOLTAGE.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..254.99999999999997 (0..3.3 -)
     * Scale: 0.012941176470588235
     * Offset: 0
     */
    uint8_t sd_end;

    /**
     * Range: 0..254.99999999999997 (0..3.3 -)
     * Scale: 0.012941176470588235
     * Offset: 0
     */
    uint8_t sd_out;

    /**
     * Range: 0..254.99999999999997 (0..3.3 -)
     * Scale: 0.012941176470588235
     * Offset: 0
     */
    uint8_t sd_in;

    /**
     * Range: 0..254.99999999999997 (0..3.3 -)
     * Scale: 0.012941176470588235
     * Offset: 0
     */
    uint8_t sd_bms;

    /**
     * Range: 0..254.99999999999997 (0..3.3 -)
     * Scale: 0.012941176470588235
     * Offset: 0
     */
    uint8_t sd_imd;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_feedback_sd_voltage_t;

/**
 * Signals in message HV_FEEDBACK_SD_VOLTAGE.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..254.99999999999997 (0..3.3 -)
     * Scale: 0.012941176470588235
     * Offset: 0
     */
    float sd_end;

    /**
     * Range: 0..254.99999999999997 (0..3.3 -)
     * Scale: 0.012941176470588235
     * Offset: 0
     */
    float sd_out;

    /**
     * Range: 0..254.99999999999997 (0..3.3 -)
     * Scale: 0.012941176470588235
     * Offset: 0
     */
    float sd_in;

    /**
     * Range: 0..254.99999999999997 (0..3.3 -)
     * Scale: 0.012941176470588235
     * Offset: 0
     */
    float sd_bms;

    /**
     * Range: 0..254.99999999999997 (0..3.3 -)
     * Scale: 0.012941176470588235
     * Offset: 0
     */
    float sd_imd;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_feedback_sd_voltage_converted_t;

/**
 * Signals in message HV_IMD_STATUS.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t imd_fault;

    /**
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    primary_hv_imd_status_imd_status imd_status;

    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t imd_details;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t imd_duty_cycle;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t imd_freq;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t imd_period;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_imd_status_t;

/**
 * Signals in message HV_IMD_STATUS.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int imd_fault : 1;

    /**
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    primary_hv_imd_status_imd_status imd_status;

    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t imd_details;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t imd_duty_cycle;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t imd_freq;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t imd_period;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_imd_status_converted_t;

/**
 * Signals in message HV_STATUS.
 *
 * Bms hv status
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    primary_hv_status_status status;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_status_t;

/**
 * Signals in message HV_STATUS.
 *
 * Bms hv status
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    primary_hv_status_status status;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_status_converted_t;

/**
 * Signals in message HV_SET_STATUS_ECU.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_hv_set_status_ecu_hv_status_set hv_status_set;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_set_status_ecu_t;

/**
 * Signals in message HV_SET_STATUS_ECU.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_hv_set_status_ecu_hv_status_set hv_status_set;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_set_status_ecu_converted_t;

/**
 * Signals in message HV_SET_STATUS_HANDCART.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_hv_set_status_handcart_hv_status_set hv_status_set;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_set_status_handcart_t;

/**
 * Signals in message HV_SET_STATUS_HANDCART.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_hv_set_status_handcart_hv_status_set hv_status_set;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_set_status_handcart_converted_t;

/**
 * Signals in message HV_BALANCING_STATUS.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    primary_hv_balancing_status_cellboard_id cellboard_id;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_hv_balancing_status_balancing_status balancing_status;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_can_comm;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_ltc_comm;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_temp_comm_0;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_temp_comm_1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_temp_comm_2;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_temp_comm_3;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_temp_comm_4;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_temp_comm_5;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_open_wire;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t balancing_cells_cell0;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t balancing_cells_cell1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t balancing_cells_cell2;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t balancing_cells_cell3;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t balancing_cells_cell4;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t balancing_cells_cell5;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t balancing_cells_cell6;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t balancing_cells_cell7;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t balancing_cells_cell8;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t balancing_cells_cell9;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t balancing_cells_cell10;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t balancing_cells_cell11;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t balancing_cells_cell12;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t balancing_cells_cell13;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t balancing_cells_cell14;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t balancing_cells_cell15;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t balancing_cells_cell16;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t balancing_cells_cell17;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_balancing_status_t;

/**
 * Signals in message HV_BALANCING_STATUS.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    primary_hv_balancing_status_cellboard_id cellboard_id;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_hv_balancing_status_balancing_status balancing_status;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_can_comm : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_ltc_comm : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_temp_comm_0 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_temp_comm_1 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_temp_comm_2 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_temp_comm_3 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_temp_comm_4 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_temp_comm_5 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_open_wire : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int balancing_cells_cell0 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int balancing_cells_cell1 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int balancing_cells_cell2 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int balancing_cells_cell3 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int balancing_cells_cell4 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int balancing_cells_cell5 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int balancing_cells_cell6 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int balancing_cells_cell7 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int balancing_cells_cell8 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int balancing_cells_cell9 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int balancing_cells_cell10 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int balancing_cells_cell11 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int balancing_cells_cell12 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int balancing_cells_cell13 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int balancing_cells_cell14 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int balancing_cells_cell15 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int balancing_cells_cell16 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int balancing_cells_cell17 : 1;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_balancing_status_converted_t;

/**
 * Signals in message HV_SET_BALANCING_STATUS_HANDCART.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_hv_set_balancing_status_handcart_set_balancing_status set_balancing_status;

    /**
     * Range: 0..195 (5..200 -)
     * Scale: 1
     * Offset: 5
     */
    uint8_t balancing_threshold;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_set_balancing_status_handcart_t;

/**
 * Signals in message HV_SET_BALANCING_STATUS_HANDCART.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_hv_set_balancing_status_handcart_set_balancing_status set_balancing_status;

    /**
     * Range: 0..195 (5..200 -)
     * Scale: 1
     * Offset: 5
     */
    uint8_t balancing_threshold;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_set_balancing_status_handcart_converted_t;

/**
 * Signals in message HV_SET_BALANCING_STATUS_STEERING_WHEEL.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_hv_set_balancing_status_steering_wheel_set_balancing_status set_balancing_status;

    /**
     * Range: 0..195 (5..200 -)
     * Scale: 1
     * Offset: 5
     */
    uint8_t balancing_threshold;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_set_balancing_status_steering_wheel_t;

/**
 * Signals in message HV_SET_BALANCING_STATUS_STEERING_WHEEL.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_hv_set_balancing_status_steering_wheel_set_balancing_status set_balancing_status;

    /**
     * Range: 0..195 (5..200 -)
     * Scale: 1
     * Offset: 5
     */
    uint8_t balancing_threshold;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_set_balancing_status_steering_wheel_converted_t;

/**
 * Signals in message LV_STATUS.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    primary_lv_status_status status;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_lv_status_t;

/**
 * Signals in message LV_STATUS.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    primary_lv_status_status status;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_lv_status_converted_t;

/**
 * Signals in message LV_RADIATOR_SPEED.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    primary_lv_radiator_speed_status status;

    /**
     * Range: 0..127 (0..1 -)
     * Scale: 0.007874015748031496
     * Offset: 0
     */
    uint8_t radiator_speed;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_lv_radiator_speed_t;

/**
 * Signals in message LV_RADIATOR_SPEED.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    primary_lv_radiator_speed_status status;

    /**
     * Range: 0..127 (0..1 -)
     * Scale: 0.007874015748031496
     * Offset: 0
     */
    float radiator_speed;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_lv_radiator_speed_converted_t;

/**
 * Signals in message LV_PUMPS_SPEED.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    primary_lv_pumps_speed_status status;

    /**
     * Range: 0..127 (0..1 -)
     * Scale: 0.007874015748031496
     * Offset: 0
     */
    uint8_t pumps_speed;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_lv_pumps_speed_t;

/**
 * Signals in message LV_PUMPS_SPEED.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    primary_lv_pumps_speed_status status;

    /**
     * Range: 0..127 (0..1 -)
     * Scale: 0.007874015748031496
     * Offset: 0
     */
    float pumps_speed;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_lv_pumps_speed_converted_t;

/**
 * Signals in message LV_SET_RADIATOR_SPEED.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    primary_lv_set_radiator_speed_status status;

    /**
     * Range: 0..127 (0..1 -)
     * Scale: 0.007874015748031496
     * Offset: 0
     */
    uint8_t radiator_speed;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_lv_set_radiator_speed_t;

/**
 * Signals in message LV_SET_RADIATOR_SPEED.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    primary_lv_set_radiator_speed_status status;

    /**
     * Range: 0..127 (0..1 -)
     * Scale: 0.007874015748031496
     * Offset: 0
     */
    float radiator_speed;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_lv_set_radiator_speed_converted_t;

/**
 * Signals in message LV_SET_PUMPS_SPEED.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    primary_lv_set_pumps_speed_status status;

    /**
     * Range: 0..127 (0..1 -)
     * Scale: 0.007874015748031496
     * Offset: 0
     */
    uint8_t pumps_speed;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_lv_set_pumps_speed_t;

/**
 * Signals in message LV_SET_PUMPS_SPEED.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    primary_lv_set_pumps_speed_status status;

    /**
     * Range: 0..127 (0..1 -)
     * Scale: 0.007874015748031496
     * Offset: 0
     */
    float pumps_speed;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_lv_set_pumps_speed_converted_t;

/**
 * Signals in message LV_ERRORS.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_cell_undervoltage;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_cell_overvoltage;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_battery_open_wire;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_can;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_spi;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_over_current;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_cell_under_temperature;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_cell_over_temperature;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_relay;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_bms_monitor;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_voltages_not_ready;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_mcp23017;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_radiator;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_fan;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_pump;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_adc_init;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_mux;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t health_signals_lvms_out;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t health_signals_relay_out;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t health_signals_battery_voltage_out;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t health_signals_charger_current;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t health_signals_battery_current;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t health_signals_sign_battery_current;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_lv_errors_t;

/**
 * Signals in message LV_ERRORS.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_cell_undervoltage : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_cell_overvoltage : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_battery_open_wire : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_can : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_spi : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_over_current : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_cell_under_temperature : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_cell_over_temperature : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_relay : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_bms_monitor : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_voltages_not_ready : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_mcp23017 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_radiator : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_fan : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_pump : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_adc_init : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_mux : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int health_signals_lvms_out : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int health_signals_relay_out : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int health_signals_battery_voltage_out : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int health_signals_charger_current : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int health_signals_battery_current : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int health_signals_sign_battery_current : 1;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_lv_errors_converted_t;

/**
 * Signals in message LV_FEEDBACK_TS_VOLTAGE.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..4095 (0..14 -)
     * Scale: 0.003418803418803419
     * Offset: 0
     */
    uint16_t bspd;

    /**
     * Range: 0..4095 (0..14 -)
     * Scale: 0.003418803418803419
     * Offset: 0
     */
    uint16_t hvd;

    /**
     * Range: 0..4095 (0..14 -)
     * Scale: 0.003418803418803419
     * Offset: 0
     */
    uint16_t invc_interlock;

    /**
     * Range: 0..4095 (0..14 -)
     * Scale: 0.003418803418803419
     * Offset: 0
     */
    uint16_t ams;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_lv_feedback_ts_voltage_t;

/**
 * Signals in message LV_FEEDBACK_TS_VOLTAGE.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..4095 (0..14 -)
     * Scale: 0.003418803418803419
     * Offset: 0
     */
    float bspd;

    /**
     * Range: 0..4095 (0..14 -)
     * Scale: 0.003418803418803419
     * Offset: 0
     */
    float hvd;

    /**
     * Range: 0..4095 (0..14 -)
     * Scale: 0.003418803418803419
     * Offset: 0
     */
    float invc_interlock;

    /**
     * Range: 0..4095 (0..14 -)
     * Scale: 0.003418803418803419
     * Offset: 0
     */
    float ams;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_lv_feedback_ts_voltage_converted_t;

/**
 * Signals in message LV_FEEDBACK_SD_VOLTAGE.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..4095 (0..14 -)
     * Scale: 0.003418803418803419
     * Offset: 0
     */
    uint16_t sd_end;

    /**
     * Range: 0..4095 (0..14 -)
     * Scale: 0.003418803418803419
     * Offset: 0
     */
    uint16_t lvms;

    /**
     * Range: 0..4095 (0..14 -)
     * Scale: 0.003418803418803419
     * Offset: 0
     */
    uint16_t interlock;

    /**
     * Range: 0..4095 (0..14 -)
     * Scale: 0.003418803418803419
     * Offset: 0
     */
    uint16_t sd_start;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_lv_feedback_sd_voltage_t;

/**
 * Signals in message LV_FEEDBACK_SD_VOLTAGE.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..4095 (0..14 -)
     * Scale: 0.003418803418803419
     * Offset: 0
     */
    float sd_end;

    /**
     * Range: 0..4095 (0..14 -)
     * Scale: 0.003418803418803419
     * Offset: 0
     */
    float lvms;

    /**
     * Range: 0..4095 (0..14 -)
     * Scale: 0.003418803418803419
     * Offset: 0
     */
    float interlock;

    /**
     * Range: 0..4095 (0..14 -)
     * Scale: 0.003418803418803419
     * Offset: 0
     */
    float sd_start;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_lv_feedback_sd_voltage_converted_t;

/**
 * Signals in message LV_FEEDBACK_ENCLOSURE_VOLTAGE.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..4095 (0..14 -)
     * Scale: 0.003418803418803419
     * Offset: 0
     */
    uint16_t lv_encl;

    /**
     * Range: 0..4095 (0..14 -)
     * Scale: 0.003418803418803419
     * Offset: 0
     */
    uint16_t invc_lid;

    /**
     * Range: 0..4095 (0..14 -)
     * Scale: 0.003418803418803419
     * Offset: 0
     */
    uint16_t hv_encl_2;

    /**
     * Range: 0..4095 (0..14 -)
     * Scale: 0.003418803418803419
     * Offset: 0
     */
    uint16_t backplate;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_lv_feedback_enclosure_voltage_t;

/**
 * Signals in message LV_FEEDBACK_ENCLOSURE_VOLTAGE.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..4095 (0..14 -)
     * Scale: 0.003418803418803419
     * Offset: 0
     */
    float lv_encl;

    /**
     * Range: 0..4095 (0..14 -)
     * Scale: 0.003418803418803419
     * Offset: 0
     */
    float invc_lid;

    /**
     * Range: 0..4095 (0..14 -)
     * Scale: 0.003418803418803419
     * Offset: 0
     */
    float hv_encl_2;

    /**
     * Range: 0..4095 (0..14 -)
     * Scale: 0.003418803418803419
     * Offset: 0
     */
    float backplate;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_lv_feedback_enclosure_voltage_converted_t;

/**
 * Signals in message LV_FEEDBACK_GPIO_EXTENDER.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t feedback_inverters;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t feedback_pcbs;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t feedback_pumps;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t feedback_radiators;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t feedback_shutdown;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t feedback_hv_fans;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t feedback_autonomous_system_actuation;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t feedback_rfe;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t feedback_frg;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t feedback_discharge;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_lv_feedback_gpio_extender_t;

/**
 * Signals in message LV_FEEDBACK_GPIO_EXTENDER.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int feedback_inverters : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int feedback_pcbs : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int feedback_pumps : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int feedback_radiators : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int feedback_shutdown : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int feedback_hv_fans : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int feedback_autonomous_system_actuation : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int feedback_rfe : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int feedback_frg : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int feedback_discharge : 1;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_lv_feedback_gpio_extender_converted_t;

/**
 * Signals in message LV_CAN_FLASH_REQ_TLM.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_lv_can_flash_req_tlm_t;

/**
 * Signals in message LV_CAN_FLASH_REQ_TLM.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_lv_can_flash_req_tlm_converted_t;

/**
 * Signals in message LV_CAN_FLASH_REQ_STEERING_WHEEL.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_lv_can_flash_req_steering_wheel_t;

/**
 * Signals in message LV_CAN_FLASH_REQ_STEERING_WHEEL.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_lv_can_flash_req_steering_wheel_converted_t;

/**
 * Signals in message LV_CAN_FLASH_ACK.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_lv_can_flash_ack_t;

/**
 * Signals in message LV_CAN_FLASH_ACK.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_lv_can_flash_ack_converted_t;

/**
 * Signals in message LV_INVERTER_CONNECTION_STATUS.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_lv_inverter_connection_status_status status;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_lv_inverter_connection_status_t;

/**
 * Signals in message LV_INVERTER_CONNECTION_STATUS.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_lv_inverter_connection_status_status status;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_lv_inverter_connection_status_converted_t;

/**
 * Signals in message LV_SET_INVERTER_CONNECTION_STATUS.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_lv_set_inverter_connection_status_status status;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_lv_set_inverter_connection_status_t;

/**
 * Signals in message LV_SET_INVERTER_CONNECTION_STATUS.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_lv_set_inverter_connection_status_status status;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_lv_set_inverter_connection_status_converted_t;

/**
 * Signals in message TLM_STATUS.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_tlm_status_status status;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_tlm_status_t;

/**
 * Signals in message TLM_STATUS.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_tlm_status_status status;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_tlm_status_converted_t;

/**
 * Signals in message TLM_SET_STATUS.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_tlm_set_status_status status;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_tlm_set_status_t;

/**
 * Signals in message TLM_SET_STATUS.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_tlm_set_status_status status;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_tlm_set_status_converted_t;

/**
 * Signals in message HANDCART_STATUS.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_handcart_status_connected connected;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_handcart_status_t;

/**
 * Signals in message HANDCART_STATUS.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_handcart_status_connected connected;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_handcart_status_converted_t;

/**
 * Signals in message HANDCART_SETTINGS.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..255.00000000000003 (300..454 -)
     * Scale: 0.6039215686274509
     * Offset: 300
     */
    uint8_t target_voltage;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_handcart_settings_fans_override fans_override;

    /**
     * Range: 0..255 (0..1 -)
     * Scale: 0.00392156862745098
     * Offset: 0
     */
    uint8_t fans_speed;

    /**
     * Range: 0..255 (1..16 -)
     * Scale: 0.058823529411764705
     * Offset: 1
     */
    uint8_t acc_charge_current;

    /**
     * Range: 0..255 (1..16 -)
     * Scale: 0.058823529411764705
     * Offset: 1
     */
    uint8_t grid_max_current;

    /**
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    primary_handcart_settings_status status;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_handcart_settings_t;

/**
 * Signals in message HANDCART_SETTINGS.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..255.00000000000003 (300..454 -)
     * Scale: 0.6039215686274509
     * Offset: 300
     */
    float target_voltage;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_handcart_settings_fans_override fans_override;

    /**
     * Range: 0..255 (0..1 -)
     * Scale: 0.00392156862745098
     * Offset: 0
     */
    float fans_speed;

    /**
     * Range: 0..255 (1..16 -)
     * Scale: 0.058823529411764705
     * Offset: 1
     */
    float acc_charge_current;

    /**
     * Range: 0..255 (1..16 -)
     * Scale: 0.058823529411764705
     * Offset: 1
     */
    float grid_max_current;

    /**
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    primary_handcart_settings_status status;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_handcart_settings_converted_t;

/**
 * Signals in message HANDCART_SET_SETTINGS.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..255.00000000000003 (300..454 -)
     * Scale: 0.6039215686274509
     * Offset: 300
     */
    uint8_t target_voltage;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_handcart_set_settings_fans_override fans_override;

    /**
     * Range: 0..255 (0..1 -)
     * Scale: 0.00392156862745098
     * Offset: 0
     */
    uint8_t fans_speed;

    /**
     * Range: 0..255 (1..16 -)
     * Scale: 0.058823529411764705
     * Offset: 1
     */
    uint8_t acc_charge_current;

    /**
     * Range: 0..255 (1..16 -)
     * Scale: 0.058823529411764705
     * Offset: 1
     */
    uint8_t grid_max_current;

    /**
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    primary_handcart_set_settings_status status;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_handcart_set_settings_t;

/**
 * Signals in message HANDCART_SET_SETTINGS.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..255.00000000000003 (300..454 -)
     * Scale: 0.6039215686274509
     * Offset: 300
     */
    float target_voltage;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_handcart_set_settings_fans_override fans_override;

    /**
     * Range: 0..255 (0..1 -)
     * Scale: 0.00392156862745098
     * Offset: 0
     */
    float fans_speed;

    /**
     * Range: 0..255 (1..16 -)
     * Scale: 0.058823529411764705
     * Offset: 1
     */
    float acc_charge_current;

    /**
     * Range: 0..255 (1..16 -)
     * Scale: 0.058823529411764705
     * Offset: 1
     */
    float grid_max_current;

    /**
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    primary_handcart_set_settings_status status;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_handcart_set_settings_converted_t;

/**
 * Signals in message ECU_STATUS.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    primary_ecu_status_status status;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_ecu_status_t;

/**
 * Signals in message ECU_STATUS.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    primary_ecu_status_status status;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_ecu_status_converted_t;

/**
 * Signals in message ECU_SET_STATUS.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    primary_ecu_set_status_status status;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_ecu_set_status_t;

/**
 * Signals in message ECU_SET_STATUS.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    primary_ecu_set_status_status status;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_ecu_set_status_converted_t;

/**
 * Signals in message ECU_INVERTER_STATUS.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    primary_ecu_inverter_status_rl rl;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    primary_ecu_inverter_status_rr rr;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_ecu_inverter_status_t;

/**
 * Signals in message ECU_INVERTER_STATUS.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    primary_ecu_inverter_status_rl rl;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    primary_ecu_inverter_status_rr rr;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_ecu_inverter_status_converted_t;

/**
 * Signals in message ECU_CONTROL_STATUS.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t control_enabled;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t control_errors_forced_off;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t control_errors_wrong_maps;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t control_errors_control_watchdog;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_ecu_control_status_t;

/**
 * Signals in message ECU_CONTROL_STATUS.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int control_enabled : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int control_errors_forced_off : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int control_errors_wrong_maps : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int control_errors_control_watchdog : 1;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_ecu_control_status_converted_t;

/**
 * Signals in message ECU_ERRORS.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t error_pedal_adc;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t error_pedal_implausibility;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t error_imu_tout;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t error_irts_tout;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t error_ts_tout;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t error_invl_tout;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t error_invr_tout;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t error_steer_tout;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t error_fsm;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_ecu_errors_t;

/**
 * Signals in message ECU_ERRORS.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int error_pedal_adc : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int error_pedal_implausibility : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int error_imu_tout : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int error_irts_tout : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int error_ts_tout : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int error_invl_tout : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int error_invr_tout : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int error_steer_tout : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int error_fsm : 1;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_ecu_errors_converted_t;

/**
 * Signals in message ECU_FEEDBACKS.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t feedbacks_sd_cock_fb;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t feedbacks_sd_fb1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t feedbacks_sd_bots_fb;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t feedbacks_sd_interial_fb;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t feedbacks_sd_fb4;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t feedbacks_sd_in;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t feedbacks_sd_out;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t feedbacks_sd_ctrl_pin;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_ecu_feedbacks_t;

/**
 * Signals in message ECU_FEEDBACKS.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int feedbacks_sd_cock_fb : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int feedbacks_sd_fb1 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int feedbacks_sd_bots_fb : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int feedbacks_sd_interial_fb : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int feedbacks_sd_fb4 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int feedbacks_sd_in : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int feedbacks_sd_out : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int feedbacks_sd_ctrl_pin : 1;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_ecu_feedbacks_converted_t;

/**
 * Signals in message ECU_POWER_MAPS.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..150 (-0.5..1 -)
     * Scale: 0.01
     * Offset: -0.5
     */
    uint8_t map_pw;

    /**
     * Range: 0..100 (0..1 -)
     * Scale: 0.01
     * Offset: 0
     */
    uint8_t map_sc;

    /**
     * Range: 0..100 (0..1 -)
     * Scale: 0.01
     * Offset: 0
     */
    uint8_t map_tv;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_ecu_power_maps_t;

/**
 * Signals in message ECU_POWER_MAPS.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..150 (-0.5..1 -)
     * Scale: 0.01
     * Offset: -0.5
     */
    float map_pw;

    /**
     * Range: 0..100 (0..1 -)
     * Scale: 0.01
     * Offset: 0
     */
    float map_sc;

    /**
     * Range: 0..100 (0..1 -)
     * Scale: 0.01
     * Offset: 0
     */
    float map_tv;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_ecu_power_maps_converted_t;

/**
 * Signals in message ECU_SET_POWER_MAPS.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..150 (-0.5..1 -)
     * Scale: 0.01
     * Offset: -0.5
     */
    uint8_t map_pw;

    /**
     * Range: 0..100 (0..1 -)
     * Scale: 0.01
     * Offset: 0
     */
    uint8_t map_sc;

    /**
     * Range: 0..100 (0..1 -)
     * Scale: 0.01
     * Offset: 0
     */
    uint8_t map_tv;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_ecu_set_power_maps_t;

/**
 * Signals in message ECU_SET_POWER_MAPS.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..150 (-0.5..1 -)
     * Scale: 0.01
     * Offset: -0.5
     */
    float map_pw;

    /**
     * Range: 0..100 (0..1 -)
     * Scale: 0.01
     * Offset: 0
     */
    float map_sc;

    /**
     * Range: 0..100 (0..1 -)
     * Scale: 0.01
     * Offset: 0
     */
    float map_tv;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_ecu_set_power_maps_converted_t;

/**
 * Signals in message ECU_PTT_STATUS.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_ecu_ptt_status_status status;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_ecu_ptt_status_t;

/**
 * Signals in message ECU_PTT_STATUS.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_ecu_ptt_status_status status;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_ecu_ptt_status_converted_t;

/**
 * Signals in message ECU_SET_PTT_STATUS.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_ecu_set_ptt_status_status status;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_ecu_set_ptt_status_t;

/**
 * Signals in message ECU_SET_PTT_STATUS.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_ecu_set_ptt_status_status status;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_ecu_set_ptt_status_converted_t;

/**
 * Signals in message INV_L_REQUEST.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_0;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_1;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_2;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_3;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_4;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_5;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_6;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_7;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_inv_l_request_t;

/**
 * Signals in message INV_L_REQUEST.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_0;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_1;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_2;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_3;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_4;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_5;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_6;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_7;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_inv_l_request_converted_t;

/**
 * Signals in message CONTROL_OUTPUT.
 *
 * Torques and signals calculated by the controls algorithms
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65534.99999999999 (-10..35 -)
     * Scale: 0.000686655985351339
     * Offset: -10
     */
    uint16_t estimated_velocity;

    /**
     * Range: 0..255 (-100..100 -)
     * Scale: 0.7843137254901961
     * Offset: -100
     */
    uint8_t torque_max_l;

    /**
     * Range: 0..255 (-100..100 -)
     * Scale: 0.7843137254901961
     * Offset: -100
     */
    uint8_t torque_max_r;

    /**
     * Range: 0..65535 (-100..100 -)
     * Scale: 0.0030518043793392844
     * Offset: -100
     */
    uint16_t torque_l;

    /**
     * Range: 0..65535 (-100..100 -)
     * Scale: 0.0030518043793392844
     * Offset: -100
     */
    uint16_t torque_r;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_control_output_t;

/**
 * Signals in message CONTROL_OUTPUT.
 *
 * Torques and signals calculated by the controls algorithms
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65534.99999999999 (-10..35 -)
     * Scale: 0.000686655985351339
     * Offset: -10
     */
    float estimated_velocity;

    /**
     * Range: 0..255 (-100..100 -)
     * Scale: 0.7843137254901961
     * Offset: -100
     */
    float torque_max_l;

    /**
     * Range: 0..255 (-100..100 -)
     * Scale: 0.7843137254901961
     * Offset: -100
     */
    float torque_max_r;

    /**
     * Range: 0..65535 (-100..100 -)
     * Scale: 0.0030518043793392844
     * Offset: -100
     */
    float torque_l;

    /**
     * Range: 0..65535 (-100..100 -)
     * Scale: 0.0030518043793392844
     * Offset: -100
     */
    float torque_r;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_control_output_converted_t;

/**
 * Signals in message CONTROL_STATUS.
 *
 * Power maps used by the control algorithm. (ECU checks if are coherent with the ones in the ECU)
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..150 (-0.5..1 -)
     * Scale: 0.01
     * Offset: -0.5
     */
    uint8_t map_pw;

    /**
     * Range: 0..100 (0..1 -)
     * Scale: 0.01
     * Offset: 0
     */
    uint8_t map_sc;

    /**
     * Range: 0..100 (0..1 -)
     * Scale: 0.01
     * Offset: 0
     */
    uint8_t map_tv;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_control_status_t;

/**
 * Signals in message CONTROL_STATUS.
 *
 * Power maps used by the control algorithm. (ECU checks if are coherent with the ones in the ECU)
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..150 (-0.5..1 -)
     * Scale: 0.01
     * Offset: -0.5
     */
    float map_pw;

    /**
     * Range: 0..100 (0..1 -)
     * Scale: 0.01
     * Offset: 0
     */
    float map_sc;

    /**
     * Range: 0..100 (0..1 -)
     * Scale: 0.01
     * Offset: 0
     */
    float map_tv;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_control_status_converted_t;

/**
 * Signals in message INV_R_REQUEST.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_0;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_1;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_2;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_3;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_4;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_5;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_6;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_7;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_inv_r_request_t;

/**
 * Signals in message INV_R_REQUEST.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_0;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_1;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_2;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_3;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_4;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_5;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_6;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_7;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_inv_r_request_converted_t;

/**
 * Signals in message INV_L_RESPONSE.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t reg_id;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_0;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_1;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_2;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_3;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_4;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_5;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_6;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_inv_l_response_t;

/**
 * Signals in message INV_L_RESPONSE.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t reg_id;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_0;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_1;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_2;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_3;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_4;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_5;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_6;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_inv_l_response_converted_t;

/**
 * Signals in message INV_R_RESPONSE.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t reg_id;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_0;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_1;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_2;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_3;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_4;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_5;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_6;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_inv_r_response_t;

/**
 * Signals in message INV_R_RESPONSE.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t reg_id;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_0;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_1;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_2;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_3;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_4;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_5;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_6;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_inv_r_response_converted_t;

/**
 * Signals in message LV_CURRENT_BATTERY.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..511 (-20..20 -)
     * Scale: 0.07827788649706457
     * Offset: -20
     */
    uint16_t lv_current;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_lv_current_battery_t;

/**
 * Signals in message LV_CURRENT_BATTERY.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..511 (-20..20 -)
     * Scale: 0.07827788649706457
     * Offset: -20
     */
    float lv_current;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_lv_current_battery_converted_t;

/**
 * Signals in message LV_CURRENT_CHARGER.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..511 (-20..20 -)
     * Scale: 0.07827788649706457
     * Offset: -20
     */
    uint16_t charger_current;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_lv_current_charger_t;

/**
 * Signals in message LV_CURRENT_CHARGER.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..511 (-20..20 -)
     * Scale: 0.07827788649706457
     * Offset: -20
     */
    float charger_current;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_lv_current_charger_converted_t;

/**
 * Signals in message LV_TOTAL_VOLTAGE.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..262143 (0..26 -)
     * Scale: 9.918250725748923e-05
     * Offset: 0
     */
    uint32_t total;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_lv_total_voltage_t;

/**
 * Signals in message LV_TOTAL_VOLTAGE.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..262143 (0..26 -)
     * Scale: 9.918250725748923e-05
     * Offset: 0
     */
    float total;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_lv_total_voltage_converted_t;

/**
 * Signals in message LV_CELLS_VOLTAGE.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t start_index;

    /**
     * Range: 0..65535 (0..5 -)
     * Scale: 7.629510948348211e-05
     * Offset: 0
     */
    uint16_t voltage_0;

    /**
     * Range: 0..65535 (0..5 -)
     * Scale: 7.629510948348211e-05
     * Offset: 0
     */
    uint16_t voltage_1;

    /**
     * Range: 0..65535 (0..5 -)
     * Scale: 7.629510948348211e-05
     * Offset: 0
     */
    uint16_t voltage_2;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_lv_cells_voltage_t;

/**
 * Signals in message LV_CELLS_VOLTAGE.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t start_index;

    /**
     * Range: 0..65535 (0..5 -)
     * Scale: 7.629510948348211e-05
     * Offset: 0
     */
    float voltage_0;

    /**
     * Range: 0..65535 (0..5 -)
     * Scale: 7.629510948348211e-05
     * Offset: 0
     */
    float voltage_1;

    /**
     * Range: 0..65535 (0..5 -)
     * Scale: 7.629510948348211e-05
     * Offset: 0
     */
    float voltage_2;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_lv_cells_voltage_converted_t;

/**
 * Signals in message LV_CELLS_VOLTAGE_STATS.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (0..5 -)
     * Scale: 7.629510948348211e-05
     * Offset: 0
     */
    uint16_t max;

    /**
     * Range: 0..65535 (0..5 -)
     * Scale: 7.629510948348211e-05
     * Offset: 0
     */
    uint16_t min;

    /**
     * Range: 0..65535 (0..5 -)
     * Scale: 7.629510948348211e-05
     * Offset: 0
     */
    uint16_t delta;

    /**
     * Range: 0..65535 (0..5 -)
     * Scale: 7.629510948348211e-05
     * Offset: 0
     */
    uint16_t avg;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_lv_cells_voltage_stats_t;

/**
 * Signals in message LV_CELLS_VOLTAGE_STATS.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (0..5 -)
     * Scale: 7.629510948348211e-05
     * Offset: 0
     */
    float max;

    /**
     * Range: 0..65535 (0..5 -)
     * Scale: 7.629510948348211e-05
     * Offset: 0
     */
    float min;

    /**
     * Range: 0..65535 (0..5 -)
     * Scale: 7.629510948348211e-05
     * Offset: 0
     */
    float delta;

    /**
     * Range: 0..65535 (0..5 -)
     * Scale: 7.629510948348211e-05
     * Offset: 0
     */
    float avg;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_lv_cells_voltage_stats_converted_t;

/**
 * Signals in message LV_CELLS_TEMP.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t start_index;

    /**
     * Range: 0..16383 (-20..80 -)
     * Scale: 0.0061038881767686015
     * Offset: -20
     */
    uint16_t temp_0;

    /**
     * Range: 0..16383 (-20..80 -)
     * Scale: 0.0061038881767686015
     * Offset: -20
     */
    uint16_t temp_1;

    /**
     * Range: 0..16383 (-20..80 -)
     * Scale: 0.0061038881767686015
     * Offset: -20
     */
    uint16_t temp_2;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_lv_cells_temp_t;

/**
 * Signals in message LV_CELLS_TEMP.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t start_index;

    /**
     * Range: 0..16383 (-20..80 -)
     * Scale: 0.0061038881767686015
     * Offset: -20
     */
    float temp_0;

    /**
     * Range: 0..16383 (-20..80 -)
     * Scale: 0.0061038881767686015
     * Offset: -20
     */
    float temp_1;

    /**
     * Range: 0..16383 (-20..80 -)
     * Scale: 0.0061038881767686015
     * Offset: -20
     */
    float temp_2;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_lv_cells_temp_converted_t;

/**
 * Signals in message LV_CELLS_TEMP_STATS.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..16383 (-20..80 -)
     * Scale: 0.0061038881767686015
     * Offset: -20
     */
    uint16_t max;

    /**
     * Range: 0..16383 (-20..80 -)
     * Scale: 0.0061038881767686015
     * Offset: -20
     */
    uint16_t min;

    /**
     * Range: 0..16383 (-20..80 -)
     * Scale: 0.0061038881767686015
     * Offset: -20
     */
    uint16_t avg;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_lv_cells_temp_stats_t;

/**
 * Signals in message LV_CELLS_TEMP_STATS.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..16383 (-20..80 -)
     * Scale: 0.0061038881767686015
     * Offset: -20
     */
    float max;

    /**
     * Range: 0..16383 (-20..80 -)
     * Scale: 0.0061038881767686015
     * Offset: -20
     */
    float min;

    /**
     * Range: 0..16383 (-20..80 -)
     * Scale: 0.0061038881767686015
     * Offset: -20
     */
    float avg;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_lv_cells_temp_stats_converted_t;

/**
 * Signals in message HV_CURRENT.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (-200..200 -)
     * Scale: 0.006103608758678569
     * Offset: -200
     */
    uint16_t current;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_current_t;

/**
 * Signals in message HV_CURRENT.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (-200..200 -)
     * Scale: 0.006103608758678569
     * Offset: -200
     */
    float current;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_current_converted_t;

/**
 * Signals in message HV_POWER.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (-100..100 -)
     * Scale: 0.0030518043793392844
     * Offset: -100
     */
    uint16_t power;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_power_t;

/**
 * Signals in message HV_POWER.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (-100..100 -)
     * Scale: 0.0030518043793392844
     * Offset: -100
     */
    float power;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_power_converted_t;

/**
 * Signals in message HV_ENERGY.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (0..7000 -)
     * Scale: 0.10681315327687495
     * Offset: 0
     */
    uint16_t energy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_energy_t;

/**
 * Signals in message HV_ENERGY.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (0..7000 -)
     * Scale: 0.10681315327687495
     * Offset: 0
     */
    float energy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_energy_converted_t;

/**
 * Signals in message HV_SOC.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..255 (0..100 -)
     * Scale: 0.39215686274509803
     * Offset: 0
     */
    uint8_t soc;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_soc_t;

/**
 * Signals in message HV_SOC.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..255 (0..100 -)
     * Scale: 0.39215686274509803
     * Offset: 0
     */
    float soc;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_soc_converted_t;

/**
 * Signals in message HV_TOTAL_VOLTAGE.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..511 (0..460 -)
     * Scale: 0.9001956947162426
     * Offset: 0
     */
    uint16_t pack;

    /**
     * Range: 0..511 (0..460 -)
     * Scale: 0.9001956947162426
     * Offset: 0
     */
    uint16_t sum_cell;

    /**
     * Range: 0..511 (0..460 -)
     * Scale: 0.9001956947162426
     * Offset: 0
     */
    uint16_t bus;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_total_voltage_t;

/**
 * Signals in message HV_TOTAL_VOLTAGE.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..511 (0..460 -)
     * Scale: 0.9001956947162426
     * Offset: 0
     */
    float pack;

    /**
     * Range: 0..511 (0..460 -)
     * Scale: 0.9001956947162426
     * Offset: 0
     */
    float sum_cell;

    /**
     * Range: 0..511 (0..460 -)
     * Scale: 0.9001956947162426
     * Offset: 0
     */
    float bus;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_total_voltage_converted_t;

/**
 * Signals in message HV_CELLS_VOLTAGE.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t start_index;

    /**
     * Range: 0..65535 (0..5 -)
     * Scale: 7.629510948348211e-05
     * Offset: 0
     */
    uint16_t voltage_0;

    /**
     * Range: 0..65535 (0..5 -)
     * Scale: 7.629510948348211e-05
     * Offset: 0
     */
    uint16_t voltage_1;

    /**
     * Range: 0..65535 (0..5 -)
     * Scale: 7.629510948348211e-05
     * Offset: 0
     */
    uint16_t voltage_2;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_cells_voltage_t;

/**
 * Signals in message HV_CELLS_VOLTAGE.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t start_index;

    /**
     * Range: 0..65535 (0..5 -)
     * Scale: 7.629510948348211e-05
     * Offset: 0
     */
    float voltage_0;

    /**
     * Range: 0..65535 (0..5 -)
     * Scale: 7.629510948348211e-05
     * Offset: 0
     */
    float voltage_1;

    /**
     * Range: 0..65535 (0..5 -)
     * Scale: 7.629510948348211e-05
     * Offset: 0
     */
    float voltage_2;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_cells_voltage_converted_t;

/**
 * Signals in message HV_CELLS_VOLTAGE_STATS.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (0..5 -)
     * Scale: 7.629510948348211e-05
     * Offset: 0
     */
    uint16_t max;

    /**
     * Range: 0..65535 (0..5 -)
     * Scale: 7.629510948348211e-05
     * Offset: 0
     */
    uint16_t min;

    /**
     * Range: 0..65535 (0..460 -)
     * Scale: 0.007019150072480354
     * Offset: 0
     */
    uint16_t delta;

    /**
     * Range: 0..65535 (0..5 -)
     * Scale: 7.629510948348211e-05
     * Offset: 0
     */
    uint16_t avg;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_cells_voltage_stats_t;

/**
 * Signals in message HV_CELLS_VOLTAGE_STATS.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (0..5 -)
     * Scale: 7.629510948348211e-05
     * Offset: 0
     */
    float max;

    /**
     * Range: 0..65535 (0..5 -)
     * Scale: 7.629510948348211e-05
     * Offset: 0
     */
    float min;

    /**
     * Range: 0..65535 (0..460 -)
     * Scale: 0.007019150072480354
     * Offset: 0
     */
    float delta;

    /**
     * Range: 0..65535 (0..5 -)
     * Scale: 7.629510948348211e-05
     * Offset: 0
     */
    float avg;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_cells_voltage_stats_converted_t;

/**
 * Signals in message HV_CELLS_TEMP.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t start_index;

    /**
     * Range: 0..255 (-20..80 -)
     * Scale: 0.39215686274509803
     * Offset: -20
     */
    uint8_t temp_0;

    /**
     * Range: 0..255 (-20..80 -)
     * Scale: 0.39215686274509803
     * Offset: -20
     */
    uint8_t temp_1;

    /**
     * Range: 0..255 (-20..80 -)
     * Scale: 0.39215686274509803
     * Offset: -20
     */
    uint8_t temp_2;

    /**
     * Range: 0..255 (-20..80 -)
     * Scale: 0.39215686274509803
     * Offset: -20
     */
    uint8_t temp_3;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_cells_temp_t;

/**
 * Signals in message HV_CELLS_TEMP.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t start_index;

    /**
     * Range: 0..255 (-20..80 -)
     * Scale: 0.39215686274509803
     * Offset: -20
     */
    float temp_0;

    /**
     * Range: 0..255 (-20..80 -)
     * Scale: 0.39215686274509803
     * Offset: -20
     */
    float temp_1;

    /**
     * Range: 0..255 (-20..80 -)
     * Scale: 0.39215686274509803
     * Offset: -20
     */
    float temp_2;

    /**
     * Range: 0..255 (-20..80 -)
     * Scale: 0.39215686274509803
     * Offset: -20
     */
    float temp_3;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_cells_temp_converted_t;

/**
 * Signals in message HV_CELLS_TEMP_STATS.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..16383 (-20..80 -)
     * Scale: 0.0061038881767686015
     * Offset: -20
     */
    uint16_t max;

    /**
     * Range: 0..16383 (-20..80 -)
     * Scale: 0.0061038881767686015
     * Offset: -20
     */
    uint16_t min;

    /**
     * Range: 0..16383 (-20..80 -)
     * Scale: 0.0061038881767686015
     * Offset: -20
     */
    uint16_t avg;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_cells_temp_stats_t;

/**
 * Signals in message HV_CELLS_TEMP_STATS.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..16383 (-20..80 -)
     * Scale: 0.0061038881767686015
     * Offset: -20
     */
    float max;

    /**
     * Range: 0..16383 (-20..80 -)
     * Scale: 0.0061038881767686015
     * Offset: -20
     */
    float min;

    /**
     * Range: 0..16383 (-20..80 -)
     * Scale: 0.0061038881767686015
     * Offset: -20
     */
    float avg;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_cells_temp_stats_converted_t;

/**
 * Signals in message ECU_STEER_ACTUATOR_STATUS.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_ecu_steer_actuator_status_status status;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_ecu_steer_actuator_status_t;

/**
 * Signals in message ECU_STEER_ACTUATOR_STATUS.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_ecu_steer_actuator_status_status status;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_ecu_steer_actuator_status_converted_t;

/**
 * Signals in message ECU_SET_STEER_ACTUATOR_STATUS_STEERING_WHEEL.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_ecu_set_steer_actuator_status_steering_wheel_status status;

    /**
     * Range: 0..15.000000000000002 (-0.1..1 -)
     * Scale: 0.07333333333333333
     * Offset: -0.1
     */
    uint8_t target;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_ecu_set_steer_actuator_status_steering_wheel_t;

/**
 * Signals in message ECU_SET_STEER_ACTUATOR_STATUS_STEERING_WHEEL.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_ecu_set_steer_actuator_status_steering_wheel_status status;

    /**
     * Range: 0..15.000000000000002 (-0.1..1 -)
     * Scale: 0.07333333333333333
     * Offset: -0.1
     */
    float target;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_ecu_set_steer_actuator_status_steering_wheel_converted_t;

/**
 * Signals in message ECU_SET_STEER_ACTUATOR_STATUS_TLM.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_ecu_set_steer_actuator_status_tlm_status status;

    /**
     * Range: 0..15.000000000000002 (-0.1..1 -)
     * Scale: 0.07333333333333333
     * Offset: -0.1
     */
    uint8_t target;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_ecu_set_steer_actuator_status_tlm_t;

/**
 * Signals in message ECU_SET_STEER_ACTUATOR_STATUS_TLM.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_ecu_set_steer_actuator_status_tlm_status status;

    /**
     * Range: 0..15.000000000000002 (-0.1..1 -)
     * Scale: 0.07333333333333333
     * Offset: -0.1
     */
    float target;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_ecu_set_steer_actuator_status_tlm_converted_t;

/**
 * Signals in message ECU_STEER_ACTUATOR_CURRENT.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..255 (-25..25 -)
     * Scale: 0.19607843137254902
     * Offset: -25
     */
    uint8_t current;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_ecu_steer_actuator_current_t;

/**
 * Signals in message ECU_STEER_ACTUATOR_CURRENT.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..255 (-25..25 -)
     * Scale: 0.19607843137254902
     * Offset: -25
     */
    float current;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_ecu_steer_actuator_current_converted_t;

/**
 * Signals in message DEBUG_SIGNAL_CRASH_DEBUG.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t seq_number;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t byte_1;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t byte_2;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t byte_3;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t byte_4;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t byte_5;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t byte_6;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t byte_7;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_debug_signal_crash_debug_t;

/**
 * Signals in message DEBUG_SIGNAL_CRASH_DEBUG.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t seq_number;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t byte_1;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t byte_2;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t byte_3;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t byte_4;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t byte_5;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t byte_6;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t byte_7;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_debug_signal_crash_debug_converted_t;

/**
 * Signals in message DEBUG_SIGNAL_CRASH_DEBUG_ACK.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t seq_number;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_debug_signal_crash_debug_ack_t;

/**
 * Signals in message DEBUG_SIGNAL_CRASH_DEBUG_ACK.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t seq_number;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_debug_signal_crash_debug_ack_converted_t;

/**
 * Signals in message DEBUG_SIGNAL_1.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (-1..1 -)
     * Scale: 3.0518043793392844e-05
     * Offset: -1
     */
    uint16_t field_1;

    /**
     * Range: 0..65535 (-1..1 -)
     * Scale: 3.0518043793392844e-05
     * Offset: -1
     */
    uint16_t field_2;

    /**
     * Range: 0..65535 (-1..1 -)
     * Scale: 3.0518043793392844e-05
     * Offset: -1
     */
    uint16_t field_3;

    /**
     * Range: 0..65535 (-1..1 -)
     * Scale: 3.0518043793392844e-05
     * Offset: -1
     */
    uint16_t field_4;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_debug_signal_1_t;

/**
 * Signals in message DEBUG_SIGNAL_1.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (-1..1 -)
     * Scale: 3.0518043793392844e-05
     * Offset: -1
     */
    float field_1;

    /**
     * Range: 0..65535 (-1..1 -)
     * Scale: 3.0518043793392844e-05
     * Offset: -1
     */
    float field_2;

    /**
     * Range: 0..65535 (-1..1 -)
     * Scale: 3.0518043793392844e-05
     * Offset: -1
     */
    float field_3;

    /**
     * Range: 0..65535 (-1..1 -)
     * Scale: 3.0518043793392844e-05
     * Offset: -1
     */
    float field_4;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_debug_signal_1_converted_t;

/**
 * Signals in message DEBUG_SIGNAL_2.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (-1..1 -)
     * Scale: 3.0518043793392844e-05
     * Offset: -1
     */
    uint16_t field_1;

    /**
     * Range: 0..65535 (-1..1 -)
     * Scale: 3.0518043793392844e-05
     * Offset: -1
     */
    uint16_t field_2;

    /**
     * Range: 0..65535 (-1..1 -)
     * Scale: 3.0518043793392844e-05
     * Offset: -1
     */
    uint16_t field_3;

    /**
     * Range: 0..65535 (-1..1 -)
     * Scale: 3.0518043793392844e-05
     * Offset: -1
     */
    uint16_t field_4;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_debug_signal_2_t;

/**
 * Signals in message DEBUG_SIGNAL_2.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (-1..1 -)
     * Scale: 3.0518043793392844e-05
     * Offset: -1
     */
    float field_1;

    /**
     * Range: 0..65535 (-1..1 -)
     * Scale: 3.0518043793392844e-05
     * Offset: -1
     */
    float field_2;

    /**
     * Range: 0..65535 (-1..1 -)
     * Scale: 3.0518043793392844e-05
     * Offset: -1
     */
    float field_3;

    /**
     * Range: 0..65535 (-1..1 -)
     * Scale: 3.0518043793392844e-05
     * Offset: -1
     */
    float field_4;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_debug_signal_2_converted_t;


void primary_nlg5_diag_tx_raw_to_conversion(
    primary_nlg5_diag_tx_converted_t *conversion,
    uint64_t lad_d_paramrp
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_nlg5_diag_tx_conversion_to_raw(
    primary_nlg5_diag_tx_t *raw,
    uint64_t lad_d_paramrp
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_nlg5_diag_tx_raw_to_conversion_struct(
    primary_nlg5_diag_tx_converted_t *conversion, 
    const primary_nlg5_diag_tx_t *raw);


void primary_nlg5_diag_tx_conversion_to_raw_struct(
    primary_nlg5_diag_tx_t *raw,
    const primary_nlg5_diag_tx_converted_t *conversion);


int primary_nlg5_diag_tx_to_string(primary_nlg5_diag_tx_t *message, char *buffer);

int primary_nlg5_diag_tx_to_string_file(primary_nlg5_diag_tx_t *message, FILE *buffer);

int primary_nlg5_diag_tx_fields(char *buffer);

int primary_nlg5_diag_tx_fields_file(FILE *buffer);

/**
 * Pack message NLG5_DIAG_TX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_nlg5_diag_tx_pack(
    uint8_t *dst_p,
    const primary_nlg5_diag_tx_t *src_p,
    size_t byte_size);

/**
 * Unpack message NLG5_DIAG_TX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_nlg5_diag_tx_unpack(
    primary_nlg5_diag_tx_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_diag_tx_lad_d_paramrp_is_in_range(uint64_t value);


void primary_nlg5_diag_rx_raw_to_conversion(
    primary_nlg5_diag_rx_converted_t *conversion,
    uint64_t lad_d_paramrq
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_nlg5_diag_rx_conversion_to_raw(
    primary_nlg5_diag_rx_t *raw,
    uint64_t lad_d_paramrq
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_nlg5_diag_rx_raw_to_conversion_struct(
    primary_nlg5_diag_rx_converted_t *conversion, 
    const primary_nlg5_diag_rx_t *raw);


void primary_nlg5_diag_rx_conversion_to_raw_struct(
    primary_nlg5_diag_rx_t *raw,
    const primary_nlg5_diag_rx_converted_t *conversion);


int primary_nlg5_diag_rx_to_string(primary_nlg5_diag_rx_t *message, char *buffer);

int primary_nlg5_diag_rx_to_string_file(primary_nlg5_diag_rx_t *message, FILE *buffer);

int primary_nlg5_diag_rx_fields(char *buffer);

int primary_nlg5_diag_rx_fields_file(FILE *buffer);

/**
 * Pack message NLG5_DIAG_RX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_nlg5_diag_rx_pack(
    uint8_t *dst_p,
    const primary_nlg5_diag_rx_t *src_p,
    size_t byte_size);

/**
 * Unpack message NLG5_DIAG_RX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_nlg5_diag_rx_unpack(
    primary_nlg5_diag_rx_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_diag_rx_lad_d_paramrq_is_in_range(uint64_t value);


void primary_nlg5_err_raw_to_conversion(
    primary_nlg5_err_converted_t *conversion,
    uint8_t nlg5_e_oov,
    uint8_t nlg5_e_mov_ii,
    uint8_t nlg5_e_mov_i,
    uint8_t nlg5_e_sc,
    uint8_t nlg5_e_p_om,
    uint8_t nlg5_e_p_mv,
    uint8_t nlg5_e_of,
    uint8_t nlg5_e_mf,
    uint8_t nlg5_e_b_p,
    uint8_t nlg5_e_t_c,
    uint8_t nlg5_e_t_pow,
    uint8_t nlg5_e_t_dio,
    uint8_t nlg5_e_t_tr,
    uint8_t nlg5_e_t_ext1,
    uint8_t nlg5_e_t_ext2,
    uint8_t nlg5_e_t_ext3,
    uint8_t nlg5_e_f_crc,
    uint8_t nlg5_e_nv_crc,
    uint8_t nlg5_e_es_crc,
    uint8_t nlg5_e_ep_crc,
    uint8_t nlg5_e_wdt,
    uint8_t nlg5_e_init,
    uint8_t nlg5_e_c_to,
    uint8_t nlg5_e_c_off,
    uint8_t nlg5_e_c_tx,
    uint8_t nlg5_e_c_rx,
    uint8_t nlg5_e_sdt_bt,
    uint8_t nlg5_e_sdt_bv,
    uint8_t nlg5_e_sdt_ah,
    uint8_t nlg5_e_sdt_ct,
    uint8_t nlg5_w_pl_mv,
    uint8_t nlg5_w_pl_bv,
    uint8_t nlg5_w_pl_it,
    uint8_t nlg5_w_c_vor,
    uint8_t nlg5_w_cm_na,
    uint8_t nlg5_w_od,
    uint8_t nlg5_w_sc_m
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_nlg5_err_conversion_to_raw(
    primary_nlg5_err_t *raw,
    uint8_t nlg5_e_oov,
    uint8_t nlg5_e_mov_ii,
    uint8_t nlg5_e_mov_i,
    uint8_t nlg5_e_sc,
    uint8_t nlg5_e_p_om,
    uint8_t nlg5_e_p_mv,
    uint8_t nlg5_e_of,
    uint8_t nlg5_e_mf,
    uint8_t nlg5_e_b_p,
    uint8_t nlg5_e_t_c,
    uint8_t nlg5_e_t_pow,
    uint8_t nlg5_e_t_dio,
    uint8_t nlg5_e_t_tr,
    uint8_t nlg5_e_t_ext1,
    uint8_t nlg5_e_t_ext2,
    uint8_t nlg5_e_t_ext3,
    uint8_t nlg5_e_f_crc,
    uint8_t nlg5_e_nv_crc,
    uint8_t nlg5_e_es_crc,
    uint8_t nlg5_e_ep_crc,
    uint8_t nlg5_e_wdt,
    uint8_t nlg5_e_init,
    uint8_t nlg5_e_c_to,
    uint8_t nlg5_e_c_off,
    uint8_t nlg5_e_c_tx,
    uint8_t nlg5_e_c_rx,
    uint8_t nlg5_e_sdt_bt,
    uint8_t nlg5_e_sdt_bv,
    uint8_t nlg5_e_sdt_ah,
    uint8_t nlg5_e_sdt_ct,
    uint8_t nlg5_w_pl_mv,
    uint8_t nlg5_w_pl_bv,
    uint8_t nlg5_w_pl_it,
    uint8_t nlg5_w_c_vor,
    uint8_t nlg5_w_cm_na,
    uint8_t nlg5_w_od,
    uint8_t nlg5_w_sc_m
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_nlg5_err_raw_to_conversion_struct(
    primary_nlg5_err_converted_t *conversion, 
    const primary_nlg5_err_t *raw);


void primary_nlg5_err_conversion_to_raw_struct(
    primary_nlg5_err_t *raw,
    const primary_nlg5_err_converted_t *conversion);


int primary_nlg5_err_to_string(primary_nlg5_err_t *message, char *buffer);

int primary_nlg5_err_to_string_file(primary_nlg5_err_t *message, FILE *buffer);

int primary_nlg5_err_fields(char *buffer);

int primary_nlg5_err_fields_file(FILE *buffer);

/**
 * Pack message NLG5_ERR.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_nlg5_err_pack(
    uint8_t *dst_p,
    const primary_nlg5_err_t *src_p,
    size_t byte_size);

/**
 * Unpack message NLG5_ERR.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_nlg5_err_unpack(
    primary_nlg5_err_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_err_nlg5_e_oov_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_err_nlg5_e_mov_ii_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_err_nlg5_e_mov_i_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_err_nlg5_e_sc_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_err_nlg5_e_p_om_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_err_nlg5_e_p_mv_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_err_nlg5_e_of_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_err_nlg5_e_mf_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_err_nlg5_e_b_p_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_err_nlg5_e_t_c_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_err_nlg5_e_t_pow_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_err_nlg5_e_t_dio_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_err_nlg5_e_t_tr_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_err_nlg5_e_t_ext1_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_err_nlg5_e_t_ext2_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_err_nlg5_e_t_ext3_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_err_nlg5_e_f_crc_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_err_nlg5_e_nv_crc_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_err_nlg5_e_es_crc_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_err_nlg5_e_ep_crc_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_err_nlg5_e_wdt_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_err_nlg5_e_init_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_err_nlg5_e_c_to_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_err_nlg5_e_c_off_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_err_nlg5_e_c_tx_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_err_nlg5_e_c_rx_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_err_nlg5_e_sdt_bt_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_err_nlg5_e_sdt_bv_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_err_nlg5_e_sdt_ah_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_err_nlg5_e_sdt_ct_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_err_nlg5_w_pl_mv_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_err_nlg5_w_pl_bv_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_err_nlg5_w_pl_it_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_err_nlg5_w_c_vor_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_err_nlg5_w_cm_na_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_err_nlg5_w_od_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_err_nlg5_w_sc_m_is_in_range(uint8_t value);


void primary_nlg5_temp_raw_to_conversion(
    primary_nlg5_temp_converted_t *conversion,
    float nlg5_p_tmp,
    float nlg5_tmp_ext1,
    float nlg5_temp_ext2,
    float nlg5_tmp_ext3
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_nlg5_temp_conversion_to_raw(
    primary_nlg5_temp_t *raw,
    float nlg5_p_tmp,
    float nlg5_tmp_ext1,
    float nlg5_temp_ext2,
    float nlg5_tmp_ext3
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_nlg5_temp_raw_to_conversion_struct(
    primary_nlg5_temp_converted_t *conversion, 
    const primary_nlg5_temp_t *raw);


void primary_nlg5_temp_conversion_to_raw_struct(
    primary_nlg5_temp_t *raw,
    const primary_nlg5_temp_converted_t *conversion);


int primary_nlg5_temp_converted_to_string(primary_nlg5_temp_converted_t *message, char *buffer);

int primary_nlg5_temp_converted_to_string_file(primary_nlg5_temp_converted_t *message, FILE *buffer);

int primary_nlg5_temp_fields(char *buffer);

int primary_nlg5_temp_fields_file(FILE *buffer);

/**
 * Pack message NLG5_TEMP.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_nlg5_temp_pack(
    uint8_t *dst_p,
    const primary_nlg5_temp_t *src_p,
    size_t byte_size);

/**
 * Unpack message NLG5_TEMP.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_nlg5_temp_unpack(
    primary_nlg5_temp_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t primary_nlg5_temp_nlg5_p_tmp_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_nlg5_temp_nlg5_p_tmp_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_temp_nlg5_p_tmp_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t primary_nlg5_temp_nlg5_tmp_ext1_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_nlg5_temp_nlg5_tmp_ext1_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_temp_nlg5_tmp_ext1_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t primary_nlg5_temp_nlg5_temp_ext2_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_nlg5_temp_nlg5_temp_ext2_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_temp_nlg5_temp_ext2_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t primary_nlg5_temp_nlg5_tmp_ext3_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_nlg5_temp_nlg5_tmp_ext3_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_temp_nlg5_tmp_ext3_is_in_range(int16_t value);


void primary_nlg5_act_ii_raw_to_conversion(
    primary_nlg5_act_ii_converted_t *conversion,
    float nlg5_s_mc_m_cp,
    float nlg5_s_mc_m_pi,
    float nlg5_abv,
    float nlg5_ahc_ext,
    float nlg5_oc_bo
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_nlg5_act_ii_conversion_to_raw(
    primary_nlg5_act_ii_t *raw,
    float nlg5_s_mc_m_cp,
    float nlg5_s_mc_m_pi,
    float nlg5_abv,
    float nlg5_ahc_ext,
    float nlg5_oc_bo
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_nlg5_act_ii_raw_to_conversion_struct(
    primary_nlg5_act_ii_converted_t *conversion, 
    const primary_nlg5_act_ii_t *raw);


void primary_nlg5_act_ii_conversion_to_raw_struct(
    primary_nlg5_act_ii_t *raw,
    const primary_nlg5_act_ii_converted_t *conversion);


int primary_nlg5_act_ii_converted_to_string(primary_nlg5_act_ii_converted_t *message, char *buffer);

int primary_nlg5_act_ii_converted_to_string_file(primary_nlg5_act_ii_converted_t *message, FILE *buffer);

int primary_nlg5_act_ii_fields(char *buffer);

int primary_nlg5_act_ii_fields_file(FILE *buffer);

/**
 * Pack message NLG5_ACT_II.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_nlg5_act_ii_pack(
    uint8_t *dst_p,
    const primary_nlg5_act_ii_t *src_p,
    size_t byte_size);

/**
 * Unpack message NLG5_ACT_II.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_nlg5_act_ii_unpack(
    primary_nlg5_act_ii_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_nlg5_act_ii_nlg5_s_mc_m_cp_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_nlg5_act_ii_nlg5_s_mc_m_cp_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_act_ii_nlg5_s_mc_m_cp_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t primary_nlg5_act_ii_nlg5_s_mc_m_pi_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_nlg5_act_ii_nlg5_s_mc_m_pi_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_act_ii_nlg5_s_mc_m_pi_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t primary_nlg5_act_ii_nlg5_abv_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_nlg5_act_ii_nlg5_abv_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_act_ii_nlg5_abv_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t primary_nlg5_act_ii_nlg5_ahc_ext_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_nlg5_act_ii_nlg5_ahc_ext_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_act_ii_nlg5_ahc_ext_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_nlg5_act_ii_nlg5_oc_bo_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_nlg5_act_ii_nlg5_oc_bo_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_act_ii_nlg5_oc_bo_is_in_range(uint16_t value);


void primary_nlg5_act_i_raw_to_conversion(
    primary_nlg5_act_i_converted_t *conversion,
    float nlg5_mc_act,
    float nlg5_mv_act,
    float nlg5_ov_act,
    float nlg5_oc_act
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_nlg5_act_i_conversion_to_raw(
    primary_nlg5_act_i_t *raw,
    float nlg5_mc_act,
    float nlg5_mv_act,
    float nlg5_ov_act,
    float nlg5_oc_act
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_nlg5_act_i_raw_to_conversion_struct(
    primary_nlg5_act_i_converted_t *conversion, 
    const primary_nlg5_act_i_t *raw);


void primary_nlg5_act_i_conversion_to_raw_struct(
    primary_nlg5_act_i_t *raw,
    const primary_nlg5_act_i_converted_t *conversion);


int primary_nlg5_act_i_converted_to_string(primary_nlg5_act_i_converted_t *message, char *buffer);

int primary_nlg5_act_i_converted_to_string_file(primary_nlg5_act_i_converted_t *message, FILE *buffer);

int primary_nlg5_act_i_fields(char *buffer);

int primary_nlg5_act_i_fields_file(FILE *buffer);

/**
 * Pack message NLG5_ACT_I.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_nlg5_act_i_pack(
    uint8_t *dst_p,
    const primary_nlg5_act_i_t *src_p,
    size_t byte_size);

/**
 * Unpack message NLG5_ACT_I.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_nlg5_act_i_unpack(
    primary_nlg5_act_i_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_nlg5_act_i_nlg5_mc_act_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_nlg5_act_i_nlg5_mc_act_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_act_i_nlg5_mc_act_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_nlg5_act_i_nlg5_mv_act_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_nlg5_act_i_nlg5_mv_act_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_act_i_nlg5_mv_act_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_nlg5_act_i_nlg5_ov_act_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_nlg5_act_i_nlg5_ov_act_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_act_i_nlg5_ov_act_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t primary_nlg5_act_i_nlg5_oc_act_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_nlg5_act_i_nlg5_oc_act_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_act_i_nlg5_oc_act_is_in_range(int16_t value);


void primary_nlg5_st_raw_to_conversion(
    primary_nlg5_st_converted_t *conversion,
    uint8_t nlg5_s_he,
    uint8_t nlg5_s_err,
    uint8_t nlg5_s_war,
    uint8_t nlg5_s_fan,
    uint8_t nlg5_s_eum,
    uint8_t nlg5_s_um_i,
    uint8_t nlg5_s_um_ii,
    uint8_t nlg5_s_cp_dt,
    uint8_t nlg5_s_bpd_i,
    uint8_t nlg5_s_bpd_ii,
    uint8_t nlg5_s_l_ov,
    uint8_t nlg5_s_l_oc,
    uint8_t nlg5_s_l_mc,
    uint8_t nlg5_s_l_pi,
    uint8_t nlg5_s_l_cp,
    uint8_t nlg5_s_l_pmax,
    uint8_t nlg5_s_l_mc_max,
    uint8_t nlg5_s_l_oc_max,
    uint8_t nlg5_s_l_mo_max,
    uint8_t nlg5_s_l_t_cprim,
    uint8_t nlg5_s_l_t_pow,
    uint8_t nlg5_s_l_t_dio,
    uint8_t nlg5_s_l_t_tr,
    uint8_t nlg5_s_l_t_batt,
    uint8_t nlg5_s_aac
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_nlg5_st_conversion_to_raw(
    primary_nlg5_st_t *raw,
    uint8_t nlg5_s_he,
    uint8_t nlg5_s_err,
    uint8_t nlg5_s_war,
    uint8_t nlg5_s_fan,
    uint8_t nlg5_s_eum,
    uint8_t nlg5_s_um_i,
    uint8_t nlg5_s_um_ii,
    uint8_t nlg5_s_cp_dt,
    uint8_t nlg5_s_bpd_i,
    uint8_t nlg5_s_bpd_ii,
    uint8_t nlg5_s_l_ov,
    uint8_t nlg5_s_l_oc,
    uint8_t nlg5_s_l_mc,
    uint8_t nlg5_s_l_pi,
    uint8_t nlg5_s_l_cp,
    uint8_t nlg5_s_l_pmax,
    uint8_t nlg5_s_l_mc_max,
    uint8_t nlg5_s_l_oc_max,
    uint8_t nlg5_s_l_mo_max,
    uint8_t nlg5_s_l_t_cprim,
    uint8_t nlg5_s_l_t_pow,
    uint8_t nlg5_s_l_t_dio,
    uint8_t nlg5_s_l_t_tr,
    uint8_t nlg5_s_l_t_batt,
    uint8_t nlg5_s_aac
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_nlg5_st_raw_to_conversion_struct(
    primary_nlg5_st_converted_t *conversion, 
    const primary_nlg5_st_t *raw);


void primary_nlg5_st_conversion_to_raw_struct(
    primary_nlg5_st_t *raw,
    const primary_nlg5_st_converted_t *conversion);


int primary_nlg5_st_to_string(primary_nlg5_st_t *message, char *buffer);

int primary_nlg5_st_to_string_file(primary_nlg5_st_t *message, FILE *buffer);

int primary_nlg5_st_fields(char *buffer);

int primary_nlg5_st_fields_file(FILE *buffer);

/**
 * Pack message NLG5_ST.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_nlg5_st_pack(
    uint8_t *dst_p,
    const primary_nlg5_st_t *src_p,
    size_t byte_size);

/**
 * Unpack message NLG5_ST.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_nlg5_st_unpack(
    primary_nlg5_st_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_st_nlg5_s_he_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_st_nlg5_s_err_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_st_nlg5_s_war_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_st_nlg5_s_fan_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_st_nlg5_s_eum_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_st_nlg5_s_um_i_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_st_nlg5_s_um_ii_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_st_nlg5_s_cp_dt_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_st_nlg5_s_bpd_i_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_st_nlg5_s_bpd_ii_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_st_nlg5_s_l_ov_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_st_nlg5_s_l_oc_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_st_nlg5_s_l_mc_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_st_nlg5_s_l_pi_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_st_nlg5_s_l_cp_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_st_nlg5_s_l_pmax_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_st_nlg5_s_l_mc_max_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_st_nlg5_s_l_oc_max_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_st_nlg5_s_l_mo_max_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_st_nlg5_s_l_t_cprim_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_st_nlg5_s_l_t_pow_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_st_nlg5_s_l_t_dio_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_st_nlg5_s_l_t_tr_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_st_nlg5_s_l_t_batt_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_st_nlg5_s_aac_is_in_range(uint8_t value);


void primary_nlg5_ctl_raw_to_conversion(
    primary_nlg5_ctl_converted_t *conversion,
    uint8_t nlg5_c_c_en,
    uint8_t nlg5_c_c_el,
    uint8_t nlg5_c_cp_v,
    uint8_t nlg5_c_mr,
    float nlg5_mc_max,
    float nlg5_ov_com,
    float nlg5_oc_com
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_nlg5_ctl_conversion_to_raw(
    primary_nlg5_ctl_t *raw,
    uint8_t nlg5_c_c_en,
    uint8_t nlg5_c_c_el,
    uint8_t nlg5_c_cp_v,
    uint8_t nlg5_c_mr,
    float nlg5_mc_max,
    float nlg5_ov_com,
    float nlg5_oc_com
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_nlg5_ctl_raw_to_conversion_struct(
    primary_nlg5_ctl_converted_t *conversion, 
    const primary_nlg5_ctl_t *raw);


void primary_nlg5_ctl_conversion_to_raw_struct(
    primary_nlg5_ctl_t *raw,
    const primary_nlg5_ctl_converted_t *conversion);


int primary_nlg5_ctl_converted_to_string(primary_nlg5_ctl_converted_t *message, char *buffer);

int primary_nlg5_ctl_converted_to_string_file(primary_nlg5_ctl_converted_t *message, FILE *buffer);

int primary_nlg5_ctl_fields(char *buffer);

int primary_nlg5_ctl_fields_file(FILE *buffer);

/**
 * Pack message NLG5_CTL.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_nlg5_ctl_pack(
    uint8_t *dst_p,
    const primary_nlg5_ctl_t *src_p,
    size_t byte_size);

/**
 * Unpack message NLG5_CTL.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_nlg5_ctl_unpack(
    primary_nlg5_ctl_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_ctl_nlg5_c_c_en_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_ctl_nlg5_c_c_el_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_ctl_nlg5_c_cp_v_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_ctl_nlg5_c_mr_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_nlg5_ctl_nlg5_mc_max_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_nlg5_ctl_nlg5_mc_max_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_ctl_nlg5_mc_max_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_nlg5_ctl_nlg5_ov_com_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_nlg5_ctl_nlg5_ov_com_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_ctl_nlg5_ov_com_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_nlg5_ctl_nlg5_oc_com_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_nlg5_ctl_nlg5_oc_com_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_nlg5_ctl_nlg5_oc_com_is_in_range(uint16_t value);


void primary_hv_jmp_to_blt_raw_to_conversion(
    primary_hv_jmp_to_blt_converted_t *conversion,
    primary_hv_jmp_to_blt_forward forward,
    primary_hv_jmp_to_blt_cellboard_id cellboard_id
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_hv_jmp_to_blt_conversion_to_raw(
    primary_hv_jmp_to_blt_t *raw,
    primary_hv_jmp_to_blt_forward forward,
    primary_hv_jmp_to_blt_cellboard_id cellboard_id
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_hv_jmp_to_blt_raw_to_conversion_struct(
    primary_hv_jmp_to_blt_converted_t *conversion, 
    const primary_hv_jmp_to_blt_t *raw);


void primary_hv_jmp_to_blt_conversion_to_raw_struct(
    primary_hv_jmp_to_blt_t *raw,
    const primary_hv_jmp_to_blt_converted_t *conversion);

int primary_hv_jmp_to_blt_forward_enum_to_string(primary_hv_jmp_to_blt_forward value, char *buffer);
int primary_hv_jmp_to_blt_cellboard_id_enum_to_string(primary_hv_jmp_to_blt_cellboard_id value, char *buffer);

int primary_hv_jmp_to_blt_to_string(primary_hv_jmp_to_blt_t *message, char *buffer);

int primary_hv_jmp_to_blt_to_string_file(primary_hv_jmp_to_blt_t *message, FILE *buffer);

int primary_hv_jmp_to_blt_fields(char *buffer);

int primary_hv_jmp_to_blt_fields_file(FILE *buffer);

/**
 * Pack message HV_JMP_TO_BLT.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_hv_jmp_to_blt_pack(
    uint8_t *dst_p,
    const primary_hv_jmp_to_blt_t *src_p,
    size_t byte_size);

/**
 * Unpack message HV_JMP_TO_BLT.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_hv_jmp_to_blt_unpack(
    primary_hv_jmp_to_blt_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_jmp_to_blt_forward_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_jmp_to_blt_cellboard_id_is_in_range(uint8_t value);


;


;


void primary_hv_flash_mainboard_tx_raw_to_conversion_struct(
    primary_hv_flash_mainboard_tx_converted_t *conversion, 
    const primary_hv_flash_mainboard_tx_t *raw);


void primary_hv_flash_mainboard_tx_conversion_to_raw_struct(
    primary_hv_flash_mainboard_tx_t *raw,
    const primary_hv_flash_mainboard_tx_converted_t *conversion);


int primary_hv_flash_mainboard_tx_to_string(primary_hv_flash_mainboard_tx_t *message, char *buffer);

int primary_hv_flash_mainboard_tx_to_string_file(primary_hv_flash_mainboard_tx_t *message, FILE *buffer);

int primary_hv_flash_mainboard_tx_fields(char *buffer);

int primary_hv_flash_mainboard_tx_fields_file(FILE *buffer);

/**
 * Pack message HV_FLASH_MAINBOARD_TX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_hv_flash_mainboard_tx_pack(
    uint8_t *dst_p,
    const primary_hv_flash_mainboard_tx_t *src_p,
    size_t byte_size);

/**
 * Unpack message HV_FLASH_MAINBOARD_TX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_hv_flash_mainboard_tx_unpack(
    primary_hv_flash_mainboard_tx_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void primary_hv_flash_mainboard_rx_raw_to_conversion_struct(
    primary_hv_flash_mainboard_rx_converted_t *conversion, 
    const primary_hv_flash_mainboard_rx_t *raw);


void primary_hv_flash_mainboard_rx_conversion_to_raw_struct(
    primary_hv_flash_mainboard_rx_t *raw,
    const primary_hv_flash_mainboard_rx_converted_t *conversion);


int primary_hv_flash_mainboard_rx_to_string(primary_hv_flash_mainboard_rx_t *message, char *buffer);

int primary_hv_flash_mainboard_rx_to_string_file(primary_hv_flash_mainboard_rx_t *message, FILE *buffer);

int primary_hv_flash_mainboard_rx_fields(char *buffer);

int primary_hv_flash_mainboard_rx_fields_file(FILE *buffer);

/**
 * Pack message HV_FLASH_MAINBOARD_RX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_hv_flash_mainboard_rx_pack(
    uint8_t *dst_p,
    const primary_hv_flash_mainboard_rx_t *src_p,
    size_t byte_size);

/**
 * Unpack message HV_FLASH_MAINBOARD_RX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_hv_flash_mainboard_rx_unpack(
    primary_hv_flash_mainboard_rx_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void primary_hv_flash_cellboard_0_tx_raw_to_conversion_struct(
    primary_hv_flash_cellboard_0_tx_converted_t *conversion, 
    const primary_hv_flash_cellboard_0_tx_t *raw);


void primary_hv_flash_cellboard_0_tx_conversion_to_raw_struct(
    primary_hv_flash_cellboard_0_tx_t *raw,
    const primary_hv_flash_cellboard_0_tx_converted_t *conversion);


int primary_hv_flash_cellboard_0_tx_to_string(primary_hv_flash_cellboard_0_tx_t *message, char *buffer);

int primary_hv_flash_cellboard_0_tx_to_string_file(primary_hv_flash_cellboard_0_tx_t *message, FILE *buffer);

int primary_hv_flash_cellboard_0_tx_fields(char *buffer);

int primary_hv_flash_cellboard_0_tx_fields_file(FILE *buffer);

/**
 * Pack message HV_FLASH_CELLBOARD_0_TX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_hv_flash_cellboard_0_tx_pack(
    uint8_t *dst_p,
    const primary_hv_flash_cellboard_0_tx_t *src_p,
    size_t byte_size);

/**
 * Unpack message HV_FLASH_CELLBOARD_0_TX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_hv_flash_cellboard_0_tx_unpack(
    primary_hv_flash_cellboard_0_tx_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void primary_hv_flash_cellboard_0_rx_raw_to_conversion_struct(
    primary_hv_flash_cellboard_0_rx_converted_t *conversion, 
    const primary_hv_flash_cellboard_0_rx_t *raw);


void primary_hv_flash_cellboard_0_rx_conversion_to_raw_struct(
    primary_hv_flash_cellboard_0_rx_t *raw,
    const primary_hv_flash_cellboard_0_rx_converted_t *conversion);


int primary_hv_flash_cellboard_0_rx_to_string(primary_hv_flash_cellboard_0_rx_t *message, char *buffer);

int primary_hv_flash_cellboard_0_rx_to_string_file(primary_hv_flash_cellboard_0_rx_t *message, FILE *buffer);

int primary_hv_flash_cellboard_0_rx_fields(char *buffer);

int primary_hv_flash_cellboard_0_rx_fields_file(FILE *buffer);

/**
 * Pack message HV_FLASH_CELLBOARD_0_RX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_hv_flash_cellboard_0_rx_pack(
    uint8_t *dst_p,
    const primary_hv_flash_cellboard_0_rx_t *src_p,
    size_t byte_size);

/**
 * Unpack message HV_FLASH_CELLBOARD_0_RX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_hv_flash_cellboard_0_rx_unpack(
    primary_hv_flash_cellboard_0_rx_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void primary_hv_flash_cellboard_1_tx_raw_to_conversion_struct(
    primary_hv_flash_cellboard_1_tx_converted_t *conversion, 
    const primary_hv_flash_cellboard_1_tx_t *raw);


void primary_hv_flash_cellboard_1_tx_conversion_to_raw_struct(
    primary_hv_flash_cellboard_1_tx_t *raw,
    const primary_hv_flash_cellboard_1_tx_converted_t *conversion);


int primary_hv_flash_cellboard_1_tx_to_string(primary_hv_flash_cellboard_1_tx_t *message, char *buffer);

int primary_hv_flash_cellboard_1_tx_to_string_file(primary_hv_flash_cellboard_1_tx_t *message, FILE *buffer);

int primary_hv_flash_cellboard_1_tx_fields(char *buffer);

int primary_hv_flash_cellboard_1_tx_fields_file(FILE *buffer);

/**
 * Pack message HV_FLASH_CELLBOARD_1_TX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_hv_flash_cellboard_1_tx_pack(
    uint8_t *dst_p,
    const primary_hv_flash_cellboard_1_tx_t *src_p,
    size_t byte_size);

/**
 * Unpack message HV_FLASH_CELLBOARD_1_TX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_hv_flash_cellboard_1_tx_unpack(
    primary_hv_flash_cellboard_1_tx_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void primary_hv_flash_cellboard_1_rx_raw_to_conversion_struct(
    primary_hv_flash_cellboard_1_rx_converted_t *conversion, 
    const primary_hv_flash_cellboard_1_rx_t *raw);


void primary_hv_flash_cellboard_1_rx_conversion_to_raw_struct(
    primary_hv_flash_cellboard_1_rx_t *raw,
    const primary_hv_flash_cellboard_1_rx_converted_t *conversion);


int primary_hv_flash_cellboard_1_rx_to_string(primary_hv_flash_cellboard_1_rx_t *message, char *buffer);

int primary_hv_flash_cellboard_1_rx_to_string_file(primary_hv_flash_cellboard_1_rx_t *message, FILE *buffer);

int primary_hv_flash_cellboard_1_rx_fields(char *buffer);

int primary_hv_flash_cellboard_1_rx_fields_file(FILE *buffer);

/**
 * Pack message HV_FLASH_CELLBOARD_1_RX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_hv_flash_cellboard_1_rx_pack(
    uint8_t *dst_p,
    const primary_hv_flash_cellboard_1_rx_t *src_p,
    size_t byte_size);

/**
 * Unpack message HV_FLASH_CELLBOARD_1_RX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_hv_flash_cellboard_1_rx_unpack(
    primary_hv_flash_cellboard_1_rx_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void primary_hv_flash_cellboard_2_tx_raw_to_conversion_struct(
    primary_hv_flash_cellboard_2_tx_converted_t *conversion, 
    const primary_hv_flash_cellboard_2_tx_t *raw);


void primary_hv_flash_cellboard_2_tx_conversion_to_raw_struct(
    primary_hv_flash_cellboard_2_tx_t *raw,
    const primary_hv_flash_cellboard_2_tx_converted_t *conversion);


int primary_hv_flash_cellboard_2_tx_to_string(primary_hv_flash_cellboard_2_tx_t *message, char *buffer);

int primary_hv_flash_cellboard_2_tx_to_string_file(primary_hv_flash_cellboard_2_tx_t *message, FILE *buffer);

int primary_hv_flash_cellboard_2_tx_fields(char *buffer);

int primary_hv_flash_cellboard_2_tx_fields_file(FILE *buffer);

/**
 * Pack message HV_FLASH_CELLBOARD_2_TX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_hv_flash_cellboard_2_tx_pack(
    uint8_t *dst_p,
    const primary_hv_flash_cellboard_2_tx_t *src_p,
    size_t byte_size);

/**
 * Unpack message HV_FLASH_CELLBOARD_2_TX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_hv_flash_cellboard_2_tx_unpack(
    primary_hv_flash_cellboard_2_tx_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void primary_hv_flash_cellboard_2_rx_raw_to_conversion_struct(
    primary_hv_flash_cellboard_2_rx_converted_t *conversion, 
    const primary_hv_flash_cellboard_2_rx_t *raw);


void primary_hv_flash_cellboard_2_rx_conversion_to_raw_struct(
    primary_hv_flash_cellboard_2_rx_t *raw,
    const primary_hv_flash_cellboard_2_rx_converted_t *conversion);


int primary_hv_flash_cellboard_2_rx_to_string(primary_hv_flash_cellboard_2_rx_t *message, char *buffer);

int primary_hv_flash_cellboard_2_rx_to_string_file(primary_hv_flash_cellboard_2_rx_t *message, FILE *buffer);

int primary_hv_flash_cellboard_2_rx_fields(char *buffer);

int primary_hv_flash_cellboard_2_rx_fields_file(FILE *buffer);

/**
 * Pack message HV_FLASH_CELLBOARD_2_RX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_hv_flash_cellboard_2_rx_pack(
    uint8_t *dst_p,
    const primary_hv_flash_cellboard_2_rx_t *src_p,
    size_t byte_size);

/**
 * Unpack message HV_FLASH_CELLBOARD_2_RX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_hv_flash_cellboard_2_rx_unpack(
    primary_hv_flash_cellboard_2_rx_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void primary_hv_flash_cellboard_3_tx_raw_to_conversion_struct(
    primary_hv_flash_cellboard_3_tx_converted_t *conversion, 
    const primary_hv_flash_cellboard_3_tx_t *raw);


void primary_hv_flash_cellboard_3_tx_conversion_to_raw_struct(
    primary_hv_flash_cellboard_3_tx_t *raw,
    const primary_hv_flash_cellboard_3_tx_converted_t *conversion);


int primary_hv_flash_cellboard_3_tx_to_string(primary_hv_flash_cellboard_3_tx_t *message, char *buffer);

int primary_hv_flash_cellboard_3_tx_to_string_file(primary_hv_flash_cellboard_3_tx_t *message, FILE *buffer);

int primary_hv_flash_cellboard_3_tx_fields(char *buffer);

int primary_hv_flash_cellboard_3_tx_fields_file(FILE *buffer);

/**
 * Pack message HV_FLASH_CELLBOARD_3_TX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_hv_flash_cellboard_3_tx_pack(
    uint8_t *dst_p,
    const primary_hv_flash_cellboard_3_tx_t *src_p,
    size_t byte_size);

/**
 * Unpack message HV_FLASH_CELLBOARD_3_TX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_hv_flash_cellboard_3_tx_unpack(
    primary_hv_flash_cellboard_3_tx_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void primary_hv_flash_cellboard_3_rx_raw_to_conversion_struct(
    primary_hv_flash_cellboard_3_rx_converted_t *conversion, 
    const primary_hv_flash_cellboard_3_rx_t *raw);


void primary_hv_flash_cellboard_3_rx_conversion_to_raw_struct(
    primary_hv_flash_cellboard_3_rx_t *raw,
    const primary_hv_flash_cellboard_3_rx_converted_t *conversion);


int primary_hv_flash_cellboard_3_rx_to_string(primary_hv_flash_cellboard_3_rx_t *message, char *buffer);

int primary_hv_flash_cellboard_3_rx_to_string_file(primary_hv_flash_cellboard_3_rx_t *message, FILE *buffer);

int primary_hv_flash_cellboard_3_rx_fields(char *buffer);

int primary_hv_flash_cellboard_3_rx_fields_file(FILE *buffer);

/**
 * Pack message HV_FLASH_CELLBOARD_3_RX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_hv_flash_cellboard_3_rx_pack(
    uint8_t *dst_p,
    const primary_hv_flash_cellboard_3_rx_t *src_p,
    size_t byte_size);

/**
 * Unpack message HV_FLASH_CELLBOARD_3_RX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_hv_flash_cellboard_3_rx_unpack(
    primary_hv_flash_cellboard_3_rx_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void primary_hv_flash_cellboard_4_tx_raw_to_conversion_struct(
    primary_hv_flash_cellboard_4_tx_converted_t *conversion, 
    const primary_hv_flash_cellboard_4_tx_t *raw);


void primary_hv_flash_cellboard_4_tx_conversion_to_raw_struct(
    primary_hv_flash_cellboard_4_tx_t *raw,
    const primary_hv_flash_cellboard_4_tx_converted_t *conversion);


int primary_hv_flash_cellboard_4_tx_to_string(primary_hv_flash_cellboard_4_tx_t *message, char *buffer);

int primary_hv_flash_cellboard_4_tx_to_string_file(primary_hv_flash_cellboard_4_tx_t *message, FILE *buffer);

int primary_hv_flash_cellboard_4_tx_fields(char *buffer);

int primary_hv_flash_cellboard_4_tx_fields_file(FILE *buffer);

/**
 * Pack message HV_FLASH_CELLBOARD_4_TX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_hv_flash_cellboard_4_tx_pack(
    uint8_t *dst_p,
    const primary_hv_flash_cellboard_4_tx_t *src_p,
    size_t byte_size);

/**
 * Unpack message HV_FLASH_CELLBOARD_4_TX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_hv_flash_cellboard_4_tx_unpack(
    primary_hv_flash_cellboard_4_tx_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void primary_hv_flash_cellboard_4_rx_raw_to_conversion_struct(
    primary_hv_flash_cellboard_4_rx_converted_t *conversion, 
    const primary_hv_flash_cellboard_4_rx_t *raw);


void primary_hv_flash_cellboard_4_rx_conversion_to_raw_struct(
    primary_hv_flash_cellboard_4_rx_t *raw,
    const primary_hv_flash_cellboard_4_rx_converted_t *conversion);


int primary_hv_flash_cellboard_4_rx_to_string(primary_hv_flash_cellboard_4_rx_t *message, char *buffer);

int primary_hv_flash_cellboard_4_rx_to_string_file(primary_hv_flash_cellboard_4_rx_t *message, FILE *buffer);

int primary_hv_flash_cellboard_4_rx_fields(char *buffer);

int primary_hv_flash_cellboard_4_rx_fields_file(FILE *buffer);

/**
 * Pack message HV_FLASH_CELLBOARD_4_RX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_hv_flash_cellboard_4_rx_pack(
    uint8_t *dst_p,
    const primary_hv_flash_cellboard_4_rx_t *src_p,
    size_t byte_size);

/**
 * Unpack message HV_FLASH_CELLBOARD_4_RX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_hv_flash_cellboard_4_rx_unpack(
    primary_hv_flash_cellboard_4_rx_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void primary_hv_flash_cellboard_5_tx_raw_to_conversion_struct(
    primary_hv_flash_cellboard_5_tx_converted_t *conversion, 
    const primary_hv_flash_cellboard_5_tx_t *raw);


void primary_hv_flash_cellboard_5_tx_conversion_to_raw_struct(
    primary_hv_flash_cellboard_5_tx_t *raw,
    const primary_hv_flash_cellboard_5_tx_converted_t *conversion);


int primary_hv_flash_cellboard_5_tx_to_string(primary_hv_flash_cellboard_5_tx_t *message, char *buffer);

int primary_hv_flash_cellboard_5_tx_to_string_file(primary_hv_flash_cellboard_5_tx_t *message, FILE *buffer);

int primary_hv_flash_cellboard_5_tx_fields(char *buffer);

int primary_hv_flash_cellboard_5_tx_fields_file(FILE *buffer);

/**
 * Pack message HV_FLASH_CELLBOARD_5_TX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_hv_flash_cellboard_5_tx_pack(
    uint8_t *dst_p,
    const primary_hv_flash_cellboard_5_tx_t *src_p,
    size_t byte_size);

/**
 * Unpack message HV_FLASH_CELLBOARD_5_TX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_hv_flash_cellboard_5_tx_unpack(
    primary_hv_flash_cellboard_5_tx_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void primary_hv_flash_cellboard_5_rx_raw_to_conversion_struct(
    primary_hv_flash_cellboard_5_rx_converted_t *conversion, 
    const primary_hv_flash_cellboard_5_rx_t *raw);


void primary_hv_flash_cellboard_5_rx_conversion_to_raw_struct(
    primary_hv_flash_cellboard_5_rx_t *raw,
    const primary_hv_flash_cellboard_5_rx_converted_t *conversion);


int primary_hv_flash_cellboard_5_rx_to_string(primary_hv_flash_cellboard_5_rx_t *message, char *buffer);

int primary_hv_flash_cellboard_5_rx_to_string_file(primary_hv_flash_cellboard_5_rx_t *message, FILE *buffer);

int primary_hv_flash_cellboard_5_rx_fields(char *buffer);

int primary_hv_flash_cellboard_5_rx_fields_file(FILE *buffer);

/**
 * Pack message HV_FLASH_CELLBOARD_5_RX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_hv_flash_cellboard_5_rx_pack(
    uint8_t *dst_p,
    const primary_hv_flash_cellboard_5_rx_t *src_p,
    size_t byte_size);

/**
 * Unpack message HV_FLASH_CELLBOARD_5_RX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_hv_flash_cellboard_5_rx_unpack(
    primary_hv_flash_cellboard_5_rx_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void primary_lv_jmp_to_blt_raw_to_conversion_struct(
    primary_lv_jmp_to_blt_converted_t *conversion, 
    const primary_lv_jmp_to_blt_t *raw);


void primary_lv_jmp_to_blt_conversion_to_raw_struct(
    primary_lv_jmp_to_blt_t *raw,
    const primary_lv_jmp_to_blt_converted_t *conversion);


int primary_lv_jmp_to_blt_to_string(primary_lv_jmp_to_blt_t *message, char *buffer);

int primary_lv_jmp_to_blt_to_string_file(primary_lv_jmp_to_blt_t *message, FILE *buffer);

int primary_lv_jmp_to_blt_fields(char *buffer);

int primary_lv_jmp_to_blt_fields_file(FILE *buffer);

/**
 * Pack message LV_JMP_TO_BLT.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_lv_jmp_to_blt_pack(
    uint8_t *dst_p,
    const primary_lv_jmp_to_blt_t *src_p,
    size_t byte_size);

/**
 * Unpack message LV_JMP_TO_BLT.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_lv_jmp_to_blt_unpack(
    primary_lv_jmp_to_blt_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void primary_lv_flash_tx_raw_to_conversion_struct(
    primary_lv_flash_tx_converted_t *conversion, 
    const primary_lv_flash_tx_t *raw);


void primary_lv_flash_tx_conversion_to_raw_struct(
    primary_lv_flash_tx_t *raw,
    const primary_lv_flash_tx_converted_t *conversion);


int primary_lv_flash_tx_to_string(primary_lv_flash_tx_t *message, char *buffer);

int primary_lv_flash_tx_to_string_file(primary_lv_flash_tx_t *message, FILE *buffer);

int primary_lv_flash_tx_fields(char *buffer);

int primary_lv_flash_tx_fields_file(FILE *buffer);

/**
 * Pack message LV_FLASH_TX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_lv_flash_tx_pack(
    uint8_t *dst_p,
    const primary_lv_flash_tx_t *src_p,
    size_t byte_size);

/**
 * Unpack message LV_FLASH_TX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_lv_flash_tx_unpack(
    primary_lv_flash_tx_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void primary_lv_flash_rx_raw_to_conversion_struct(
    primary_lv_flash_rx_converted_t *conversion, 
    const primary_lv_flash_rx_t *raw);


void primary_lv_flash_rx_conversion_to_raw_struct(
    primary_lv_flash_rx_t *raw,
    const primary_lv_flash_rx_converted_t *conversion);


int primary_lv_flash_rx_to_string(primary_lv_flash_rx_t *message, char *buffer);

int primary_lv_flash_rx_to_string_file(primary_lv_flash_rx_t *message, FILE *buffer);

int primary_lv_flash_rx_fields(char *buffer);

int primary_lv_flash_rx_fields_file(FILE *buffer);

/**
 * Pack message LV_FLASH_RX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_lv_flash_rx_pack(
    uint8_t *dst_p,
    const primary_lv_flash_rx_t *src_p,
    size_t byte_size);

/**
 * Unpack message LV_FLASH_RX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_lv_flash_rx_unpack(
    primary_lv_flash_rx_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void primary_ecu_jmp_to_blt_raw_to_conversion_struct(
    primary_ecu_jmp_to_blt_converted_t *conversion, 
    const primary_ecu_jmp_to_blt_t *raw);


void primary_ecu_jmp_to_blt_conversion_to_raw_struct(
    primary_ecu_jmp_to_blt_t *raw,
    const primary_ecu_jmp_to_blt_converted_t *conversion);


int primary_ecu_jmp_to_blt_to_string(primary_ecu_jmp_to_blt_t *message, char *buffer);

int primary_ecu_jmp_to_blt_to_string_file(primary_ecu_jmp_to_blt_t *message, FILE *buffer);

int primary_ecu_jmp_to_blt_fields(char *buffer);

int primary_ecu_jmp_to_blt_fields_file(FILE *buffer);

/**
 * Pack message ECU_JMP_TO_BLT.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_ecu_jmp_to_blt_pack(
    uint8_t *dst_p,
    const primary_ecu_jmp_to_blt_t *src_p,
    size_t byte_size);

/**
 * Unpack message ECU_JMP_TO_BLT.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_ecu_jmp_to_blt_unpack(
    primary_ecu_jmp_to_blt_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void primary_ecu_flash_tx_raw_to_conversion_struct(
    primary_ecu_flash_tx_converted_t *conversion, 
    const primary_ecu_flash_tx_t *raw);


void primary_ecu_flash_tx_conversion_to_raw_struct(
    primary_ecu_flash_tx_t *raw,
    const primary_ecu_flash_tx_converted_t *conversion);


int primary_ecu_flash_tx_to_string(primary_ecu_flash_tx_t *message, char *buffer);

int primary_ecu_flash_tx_to_string_file(primary_ecu_flash_tx_t *message, FILE *buffer);

int primary_ecu_flash_tx_fields(char *buffer);

int primary_ecu_flash_tx_fields_file(FILE *buffer);

/**
 * Pack message ECU_FLASH_TX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_ecu_flash_tx_pack(
    uint8_t *dst_p,
    const primary_ecu_flash_tx_t *src_p,
    size_t byte_size);

/**
 * Unpack message ECU_FLASH_TX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_ecu_flash_tx_unpack(
    primary_ecu_flash_tx_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void primary_ecu_flash_rx_raw_to_conversion_struct(
    primary_ecu_flash_rx_converted_t *conversion, 
    const primary_ecu_flash_rx_t *raw);


void primary_ecu_flash_rx_conversion_to_raw_struct(
    primary_ecu_flash_rx_t *raw,
    const primary_ecu_flash_rx_converted_t *conversion);


int primary_ecu_flash_rx_to_string(primary_ecu_flash_rx_t *message, char *buffer);

int primary_ecu_flash_rx_to_string_file(primary_ecu_flash_rx_t *message, FILE *buffer);

int primary_ecu_flash_rx_fields(char *buffer);

int primary_ecu_flash_rx_fields_file(FILE *buffer);

/**
 * Pack message ECU_FLASH_RX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_ecu_flash_rx_pack(
    uint8_t *dst_p,
    const primary_ecu_flash_rx_t *src_p,
    size_t byte_size);

/**
 * Unpack message ECU_FLASH_RX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_ecu_flash_rx_unpack(
    primary_ecu_flash_rx_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void primary_steering_wheel_jmp_to_blt_raw_to_conversion_struct(
    primary_steering_wheel_jmp_to_blt_converted_t *conversion, 
    const primary_steering_wheel_jmp_to_blt_t *raw);


void primary_steering_wheel_jmp_to_blt_conversion_to_raw_struct(
    primary_steering_wheel_jmp_to_blt_t *raw,
    const primary_steering_wheel_jmp_to_blt_converted_t *conversion);


int primary_steering_wheel_jmp_to_blt_to_string(primary_steering_wheel_jmp_to_blt_t *message, char *buffer);

int primary_steering_wheel_jmp_to_blt_to_string_file(primary_steering_wheel_jmp_to_blt_t *message, FILE *buffer);

int primary_steering_wheel_jmp_to_blt_fields(char *buffer);

int primary_steering_wheel_jmp_to_blt_fields_file(FILE *buffer);

/**
 * Pack message STEERING_WHEEL_JMP_TO_BLT.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_steering_wheel_jmp_to_blt_pack(
    uint8_t *dst_p,
    const primary_steering_wheel_jmp_to_blt_t *src_p,
    size_t byte_size);

/**
 * Unpack message STEERING_WHEEL_JMP_TO_BLT.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_steering_wheel_jmp_to_blt_unpack(
    primary_steering_wheel_jmp_to_blt_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void primary_steering_wheel_flash_tx_raw_to_conversion_struct(
    primary_steering_wheel_flash_tx_converted_t *conversion, 
    const primary_steering_wheel_flash_tx_t *raw);


void primary_steering_wheel_flash_tx_conversion_to_raw_struct(
    primary_steering_wheel_flash_tx_t *raw,
    const primary_steering_wheel_flash_tx_converted_t *conversion);


int primary_steering_wheel_flash_tx_to_string(primary_steering_wheel_flash_tx_t *message, char *buffer);

int primary_steering_wheel_flash_tx_to_string_file(primary_steering_wheel_flash_tx_t *message, FILE *buffer);

int primary_steering_wheel_flash_tx_fields(char *buffer);

int primary_steering_wheel_flash_tx_fields_file(FILE *buffer);

/**
 * Pack message STEERING_WHEEL_FLASH_TX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_steering_wheel_flash_tx_pack(
    uint8_t *dst_p,
    const primary_steering_wheel_flash_tx_t *src_p,
    size_t byte_size);

/**
 * Unpack message STEERING_WHEEL_FLASH_TX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_steering_wheel_flash_tx_unpack(
    primary_steering_wheel_flash_tx_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void primary_steering_wheel_flash_rx_raw_to_conversion_struct(
    primary_steering_wheel_flash_rx_converted_t *conversion, 
    const primary_steering_wheel_flash_rx_t *raw);


void primary_steering_wheel_flash_rx_conversion_to_raw_struct(
    primary_steering_wheel_flash_rx_t *raw,
    const primary_steering_wheel_flash_rx_converted_t *conversion);


int primary_steering_wheel_flash_rx_to_string(primary_steering_wheel_flash_rx_t *message, char *buffer);

int primary_steering_wheel_flash_rx_to_string_file(primary_steering_wheel_flash_rx_t *message, FILE *buffer);

int primary_steering_wheel_flash_rx_fields(char *buffer);

int primary_steering_wheel_flash_rx_fields_file(FILE *buffer);

/**
 * Pack message STEERING_WHEEL_FLASH_RX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_steering_wheel_flash_rx_pack(
    uint8_t *dst_p,
    const primary_steering_wheel_flash_rx_t *src_p,
    size_t byte_size);

/**
 * Unpack message STEERING_WHEEL_FLASH_RX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_steering_wheel_flash_rx_unpack(
    primary_steering_wheel_flash_rx_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


void primary_steering_wheel_version_raw_to_conversion(
    primary_steering_wheel_version_converted_t *conversion,
    uint32_t component_build_time,
    uint32_t canlib_build_time
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_steering_wheel_version_conversion_to_raw(
    primary_steering_wheel_version_t *raw,
    uint32_t component_build_time,
    uint32_t canlib_build_time
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_steering_wheel_version_raw_to_conversion_struct(
    primary_steering_wheel_version_converted_t *conversion, 
    const primary_steering_wheel_version_t *raw);


void primary_steering_wheel_version_conversion_to_raw_struct(
    primary_steering_wheel_version_t *raw,
    const primary_steering_wheel_version_converted_t *conversion);


int primary_steering_wheel_version_to_string(primary_steering_wheel_version_t *message, char *buffer);

int primary_steering_wheel_version_to_string_file(primary_steering_wheel_version_t *message, FILE *buffer);

int primary_steering_wheel_version_fields(char *buffer);

int primary_steering_wheel_version_fields_file(FILE *buffer);

/**
 * Pack message STEERING_WHEEL_VERSION.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_steering_wheel_version_pack(
    uint8_t *dst_p,
    const primary_steering_wheel_version_t *src_p,
    size_t byte_size);

/**
 * Unpack message STEERING_WHEEL_VERSION.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_steering_wheel_version_unpack(
    primary_steering_wheel_version_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_steering_wheel_version_component_build_time_is_in_range(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_steering_wheel_version_canlib_build_time_is_in_range(uint32_t value);


void primary_ecu_version_raw_to_conversion(
    primary_ecu_version_converted_t *conversion,
    uint32_t component_build_time,
    uint32_t canlib_build_time
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_ecu_version_conversion_to_raw(
    primary_ecu_version_t *raw,
    uint32_t component_build_time,
    uint32_t canlib_build_time
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_ecu_version_raw_to_conversion_struct(
    primary_ecu_version_converted_t *conversion, 
    const primary_ecu_version_t *raw);


void primary_ecu_version_conversion_to_raw_struct(
    primary_ecu_version_t *raw,
    const primary_ecu_version_converted_t *conversion);


int primary_ecu_version_to_string(primary_ecu_version_t *message, char *buffer);

int primary_ecu_version_to_string_file(primary_ecu_version_t *message, FILE *buffer);

int primary_ecu_version_fields(char *buffer);

int primary_ecu_version_fields_file(FILE *buffer);

/**
 * Pack message ECU_VERSION.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_ecu_version_pack(
    uint8_t *dst_p,
    const primary_ecu_version_t *src_p,
    size_t byte_size);

/**
 * Unpack message ECU_VERSION.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_ecu_version_unpack(
    primary_ecu_version_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_ecu_version_component_build_time_is_in_range(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_ecu_version_canlib_build_time_is_in_range(uint32_t value);


void primary_lv_version_raw_to_conversion(
    primary_lv_version_converted_t *conversion,
    uint32_t component_build_time,
    uint32_t canlib_build_time
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_lv_version_conversion_to_raw(
    primary_lv_version_t *raw,
    uint32_t component_build_time,
    uint32_t canlib_build_time
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_lv_version_raw_to_conversion_struct(
    primary_lv_version_converted_t *conversion, 
    const primary_lv_version_t *raw);


void primary_lv_version_conversion_to_raw_struct(
    primary_lv_version_t *raw,
    const primary_lv_version_converted_t *conversion);


int primary_lv_version_to_string(primary_lv_version_t *message, char *buffer);

int primary_lv_version_to_string_file(primary_lv_version_t *message, FILE *buffer);

int primary_lv_version_fields(char *buffer);

int primary_lv_version_fields_file(FILE *buffer);

/**
 * Pack message LV_VERSION.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_lv_version_pack(
    uint8_t *dst_p,
    const primary_lv_version_t *src_p,
    size_t byte_size);

/**
 * Unpack message LV_VERSION.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_lv_version_unpack(
    primary_lv_version_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_version_component_build_time_is_in_range(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_version_canlib_build_time_is_in_range(uint32_t value);


void primary_tlm_version_raw_to_conversion(
    primary_tlm_version_converted_t *conversion,
    uint32_t component_build_time,
    uint32_t canlib_build_time
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_tlm_version_conversion_to_raw(
    primary_tlm_version_t *raw,
    uint32_t component_build_time,
    uint32_t canlib_build_time
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_tlm_version_raw_to_conversion_struct(
    primary_tlm_version_converted_t *conversion, 
    const primary_tlm_version_t *raw);


void primary_tlm_version_conversion_to_raw_struct(
    primary_tlm_version_t *raw,
    const primary_tlm_version_converted_t *conversion);


int primary_tlm_version_to_string(primary_tlm_version_t *message, char *buffer);

int primary_tlm_version_to_string_file(primary_tlm_version_t *message, FILE *buffer);

int primary_tlm_version_fields(char *buffer);

int primary_tlm_version_fields_file(FILE *buffer);

/**
 * Pack message TLM_VERSION.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_tlm_version_pack(
    uint8_t *dst_p,
    const primary_tlm_version_t *src_p,
    size_t byte_size);

/**
 * Unpack message TLM_VERSION.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_tlm_version_unpack(
    primary_tlm_version_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_tlm_version_component_build_time_is_in_range(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_tlm_version_canlib_build_time_is_in_range(uint32_t value);


void primary_hv_mainboard_version_raw_to_conversion(
    primary_hv_mainboard_version_converted_t *conversion,
    uint32_t component_build_time,
    uint32_t canlib_build_time
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_hv_mainboard_version_conversion_to_raw(
    primary_hv_mainboard_version_t *raw,
    uint32_t component_build_time,
    uint32_t canlib_build_time
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_hv_mainboard_version_raw_to_conversion_struct(
    primary_hv_mainboard_version_converted_t *conversion, 
    const primary_hv_mainboard_version_t *raw);


void primary_hv_mainboard_version_conversion_to_raw_struct(
    primary_hv_mainboard_version_t *raw,
    const primary_hv_mainboard_version_converted_t *conversion);


int primary_hv_mainboard_version_to_string(primary_hv_mainboard_version_t *message, char *buffer);

int primary_hv_mainboard_version_to_string_file(primary_hv_mainboard_version_t *message, FILE *buffer);

int primary_hv_mainboard_version_fields(char *buffer);

int primary_hv_mainboard_version_fields_file(FILE *buffer);

/**
 * Pack message HV_MAINBOARD_VERSION.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_hv_mainboard_version_pack(
    uint8_t *dst_p,
    const primary_hv_mainboard_version_t *src_p,
    size_t byte_size);

/**
 * Unpack message HV_MAINBOARD_VERSION.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_hv_mainboard_version_unpack(
    primary_hv_mainboard_version_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_mainboard_version_component_build_time_is_in_range(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_mainboard_version_canlib_build_time_is_in_range(uint32_t value);


void primary_hv_cellboard_version_raw_to_conversion(
    primary_hv_cellboard_version_converted_t *conversion,
    primary_hv_cellboard_version_cellboard_id cellboard_id,
    uint16_t component_version,
    uint32_t canlib_build_time
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_hv_cellboard_version_conversion_to_raw(
    primary_hv_cellboard_version_t *raw,
    primary_hv_cellboard_version_cellboard_id cellboard_id,
    uint16_t component_version,
    uint32_t canlib_build_time
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_hv_cellboard_version_raw_to_conversion_struct(
    primary_hv_cellboard_version_converted_t *conversion, 
    const primary_hv_cellboard_version_t *raw);


void primary_hv_cellboard_version_conversion_to_raw_struct(
    primary_hv_cellboard_version_t *raw,
    const primary_hv_cellboard_version_converted_t *conversion);

int primary_hv_cellboard_version_cellboard_id_enum_to_string(primary_hv_cellboard_version_cellboard_id value, char *buffer);

int primary_hv_cellboard_version_to_string(primary_hv_cellboard_version_t *message, char *buffer);

int primary_hv_cellboard_version_to_string_file(primary_hv_cellboard_version_t *message, FILE *buffer);

int primary_hv_cellboard_version_fields(char *buffer);

int primary_hv_cellboard_version_fields_file(FILE *buffer);

/**
 * Pack message HV_CELLBOARD_VERSION.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_hv_cellboard_version_pack(
    uint8_t *dst_p,
    const primary_hv_cellboard_version_t *src_p,
    size_t byte_size);

/**
 * Unpack message HV_CELLBOARD_VERSION.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_hv_cellboard_version_unpack(
    primary_hv_cellboard_version_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_cellboard_version_cellboard_id_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_cellboard_version_component_version_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_cellboard_version_canlib_build_time_is_in_range(uint32_t value);


void primary_hv_errors_raw_to_conversion(
    primary_hv_errors_converted_t *conversion,
    uint8_t errors_cell_under_voltage,
    uint8_t errors_cell_over_voltage,
    uint8_t errors_cell_under_temperature,
    uint8_t errors_cell_over_temperature,
    uint8_t errors_over_current,
    uint8_t errors_can,
    uint8_t errors_int_voltage_mismatch,
    uint8_t errors_cellboard_comm,
    uint8_t errors_cellboard_internal,
    uint8_t errors_connector_disconnected,
    uint8_t errors_fans_disconnected,
    uint8_t errors_feedback,
    uint8_t errors_feedback_circuitry,
    uint8_t errors_eeprom_comm,
    uint8_t errors_eeprom_write
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_hv_errors_conversion_to_raw(
    primary_hv_errors_t *raw,
    uint8_t errors_cell_under_voltage,
    uint8_t errors_cell_over_voltage,
    uint8_t errors_cell_under_temperature,
    uint8_t errors_cell_over_temperature,
    uint8_t errors_over_current,
    uint8_t errors_can,
    uint8_t errors_int_voltage_mismatch,
    uint8_t errors_cellboard_comm,
    uint8_t errors_cellboard_internal,
    uint8_t errors_connector_disconnected,
    uint8_t errors_fans_disconnected,
    uint8_t errors_feedback,
    uint8_t errors_feedback_circuitry,
    uint8_t errors_eeprom_comm,
    uint8_t errors_eeprom_write
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_hv_errors_raw_to_conversion_struct(
    primary_hv_errors_converted_t *conversion, 
    const primary_hv_errors_t *raw);


void primary_hv_errors_conversion_to_raw_struct(
    primary_hv_errors_t *raw,
    const primary_hv_errors_converted_t *conversion);


int primary_hv_errors_to_string(primary_hv_errors_t *message, char *buffer);

int primary_hv_errors_to_string_file(primary_hv_errors_t *message, FILE *buffer);

int primary_hv_errors_fields(char *buffer);

int primary_hv_errors_fields_file(FILE *buffer);

/**
 * Pack message HV_ERRORS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_hv_errors_pack(
    uint8_t *dst_p,
    const primary_hv_errors_t *src_p,
    size_t byte_size);

/**
 * Unpack message HV_ERRORS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_hv_errors_unpack(
    primary_hv_errors_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_errors_errors_cell_under_voltage_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_errors_errors_cell_over_voltage_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_errors_errors_cell_under_temperature_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_errors_errors_cell_over_temperature_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_errors_errors_over_current_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_errors_errors_can_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_errors_errors_int_voltage_mismatch_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_errors_errors_cellboard_comm_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_errors_errors_cellboard_internal_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_errors_errors_connector_disconnected_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_errors_errors_fans_disconnected_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_errors_errors_feedback_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_errors_errors_feedback_circuitry_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_errors_errors_eeprom_comm_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_errors_errors_eeprom_write_is_in_range(uint8_t value);


void primary_hv_debug_signals_raw_to_conversion(
    primary_hv_debug_signals_converted_t *conversion,
    uint8_t feedbacks_implausibility_detected,
    uint8_t feedbacks_imd_cockpit,
    uint8_t feedbacks_tsal_green_fault_latched,
    uint8_t feedbacks_bms_cockpit,
    uint8_t feedbacks_ext_latched,
    uint8_t feedbacks_tsal_green,
    uint8_t feedbacks_ts_over_60v_status,
    uint8_t feedbacks_airn_status,
    uint8_t feedbacks_airp_status,
    uint8_t feedbacks_airp_gate,
    uint8_t feedbacks_airn_gate,
    uint8_t feedbacks_precharge_status,
    uint8_t feedbacks_tsp_over_60v_status,
    uint8_t feedbacks_imd_fault,
    uint8_t feedbacks_check_mux,
    uint8_t feedbacks_sd_end,
    uint8_t feedbacks_sd_out,
    uint8_t feedbacks_sd_in,
    uint8_t feedbacks_sd_bms,
    uint8_t feedbacks_sd_imd,
    uint8_t errors_cell_under_voltage,
    uint8_t errors_cell_over_voltage,
    uint8_t errors_cell_under_temperature,
    uint8_t errors_cell_over_temperature,
    uint8_t errors_over_current,
    uint8_t errors_can,
    uint8_t errors_int_voltage_mismatch,
    uint8_t errors_cellboard_comm,
    uint8_t errors_cellboard_internal,
    uint8_t errors_connector_disconnected,
    uint8_t errors_fans_disconnected,
    uint8_t errors_feedback,
    uint8_t errors_feedback_circuitry,
    uint8_t errors_eeprom_comm,
    uint8_t errors_eeprom_write
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_hv_debug_signals_conversion_to_raw(
    primary_hv_debug_signals_t *raw,
    uint8_t feedbacks_implausibility_detected,
    uint8_t feedbacks_imd_cockpit,
    uint8_t feedbacks_tsal_green_fault_latched,
    uint8_t feedbacks_bms_cockpit,
    uint8_t feedbacks_ext_latched,
    uint8_t feedbacks_tsal_green,
    uint8_t feedbacks_ts_over_60v_status,
    uint8_t feedbacks_airn_status,
    uint8_t feedbacks_airp_status,
    uint8_t feedbacks_airp_gate,
    uint8_t feedbacks_airn_gate,
    uint8_t feedbacks_precharge_status,
    uint8_t feedbacks_tsp_over_60v_status,
    uint8_t feedbacks_imd_fault,
    uint8_t feedbacks_check_mux,
    uint8_t feedbacks_sd_end,
    uint8_t feedbacks_sd_out,
    uint8_t feedbacks_sd_in,
    uint8_t feedbacks_sd_bms,
    uint8_t feedbacks_sd_imd,
    uint8_t errors_cell_under_voltage,
    uint8_t errors_cell_over_voltage,
    uint8_t errors_cell_under_temperature,
    uint8_t errors_cell_over_temperature,
    uint8_t errors_over_current,
    uint8_t errors_can,
    uint8_t errors_int_voltage_mismatch,
    uint8_t errors_cellboard_comm,
    uint8_t errors_cellboard_internal,
    uint8_t errors_connector_disconnected,
    uint8_t errors_fans_disconnected,
    uint8_t errors_feedback,
    uint8_t errors_feedback_circuitry,
    uint8_t errors_eeprom_comm,
    uint8_t errors_eeprom_write
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_hv_debug_signals_raw_to_conversion_struct(
    primary_hv_debug_signals_converted_t *conversion, 
    const primary_hv_debug_signals_t *raw);


void primary_hv_debug_signals_conversion_to_raw_struct(
    primary_hv_debug_signals_t *raw,
    const primary_hv_debug_signals_converted_t *conversion);


int primary_hv_debug_signals_to_string(primary_hv_debug_signals_t *message, char *buffer);

int primary_hv_debug_signals_to_string_file(primary_hv_debug_signals_t *message, FILE *buffer);

int primary_hv_debug_signals_fields(char *buffer);

int primary_hv_debug_signals_fields_file(FILE *buffer);

/**
 * Pack message HV_DEBUG_SIGNALS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_hv_debug_signals_pack(
    uint8_t *dst_p,
    const primary_hv_debug_signals_t *src_p,
    size_t byte_size);

/**
 * Unpack message HV_DEBUG_SIGNALS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_hv_debug_signals_unpack(
    primary_hv_debug_signals_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_debug_signals_feedbacks_implausibility_detected_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_debug_signals_feedbacks_imd_cockpit_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_debug_signals_feedbacks_tsal_green_fault_latched_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_debug_signals_feedbacks_bms_cockpit_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_debug_signals_feedbacks_ext_latched_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_debug_signals_feedbacks_tsal_green_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_debug_signals_feedbacks_ts_over_60v_status_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_debug_signals_feedbacks_airn_status_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_debug_signals_feedbacks_airp_status_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_debug_signals_feedbacks_airp_gate_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_debug_signals_feedbacks_airn_gate_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_debug_signals_feedbacks_precharge_status_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_debug_signals_feedbacks_tsp_over_60v_status_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_debug_signals_feedbacks_imd_fault_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_debug_signals_feedbacks_check_mux_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_debug_signals_feedbacks_sd_end_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_debug_signals_feedbacks_sd_out_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_debug_signals_feedbacks_sd_in_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_debug_signals_feedbacks_sd_bms_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_debug_signals_feedbacks_sd_imd_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_debug_signals_errors_cell_under_voltage_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_debug_signals_errors_cell_over_voltage_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_debug_signals_errors_cell_under_temperature_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_debug_signals_errors_cell_over_temperature_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_debug_signals_errors_over_current_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_debug_signals_errors_can_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_debug_signals_errors_int_voltage_mismatch_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_debug_signals_errors_cellboard_comm_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_debug_signals_errors_cellboard_internal_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_debug_signals_errors_connector_disconnected_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_debug_signals_errors_fans_disconnected_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_debug_signals_errors_feedback_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_debug_signals_errors_feedback_circuitry_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_debug_signals_errors_eeprom_comm_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_debug_signals_errors_eeprom_write_is_in_range(uint8_t value);


void primary_hv_fans_status_raw_to_conversion(
    primary_hv_fans_status_converted_t *conversion,
    primary_hv_fans_status_fans_override fans_override,
    float fans_speed
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_hv_fans_status_conversion_to_raw(
    primary_hv_fans_status_t *raw,
    primary_hv_fans_status_fans_override fans_override,
    float fans_speed
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_hv_fans_status_raw_to_conversion_struct(
    primary_hv_fans_status_converted_t *conversion, 
    const primary_hv_fans_status_t *raw);


void primary_hv_fans_status_conversion_to_raw_struct(
    primary_hv_fans_status_t *raw,
    const primary_hv_fans_status_converted_t *conversion);

int primary_hv_fans_status_fans_override_enum_to_string(primary_hv_fans_status_fans_override value, char *buffer);

int primary_hv_fans_status_converted_to_string(primary_hv_fans_status_converted_t *message, char *buffer);

int primary_hv_fans_status_converted_to_string_file(primary_hv_fans_status_converted_t *message, FILE *buffer);

int primary_hv_fans_status_fields(char *buffer);

int primary_hv_fans_status_fields_file(FILE *buffer);

/**
 * Pack message HV_FANS_STATUS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_hv_fans_status_pack(
    uint8_t *dst_p,
    const primary_hv_fans_status_t *src_p,
    size_t byte_size);

/**
 * Unpack message HV_FANS_STATUS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_hv_fans_status_unpack(
    primary_hv_fans_status_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_fans_status_fans_override_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_hv_fans_status_fans_speed_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_hv_fans_status_fans_speed_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_fans_status_fans_speed_is_in_range(uint16_t value);


void primary_hv_set_fans_status_raw_to_conversion(
    primary_hv_set_fans_status_converted_t *conversion,
    primary_hv_set_fans_status_fans_override fans_override,
    float fans_speed
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_hv_set_fans_status_conversion_to_raw(
    primary_hv_set_fans_status_t *raw,
    primary_hv_set_fans_status_fans_override fans_override,
    float fans_speed
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_hv_set_fans_status_raw_to_conversion_struct(
    primary_hv_set_fans_status_converted_t *conversion, 
    const primary_hv_set_fans_status_t *raw);


void primary_hv_set_fans_status_conversion_to_raw_struct(
    primary_hv_set_fans_status_t *raw,
    const primary_hv_set_fans_status_converted_t *conversion);

int primary_hv_set_fans_status_fans_override_enum_to_string(primary_hv_set_fans_status_fans_override value, char *buffer);

int primary_hv_set_fans_status_converted_to_string(primary_hv_set_fans_status_converted_t *message, char *buffer);

int primary_hv_set_fans_status_converted_to_string_file(primary_hv_set_fans_status_converted_t *message, FILE *buffer);

int primary_hv_set_fans_status_fields(char *buffer);

int primary_hv_set_fans_status_fields_file(FILE *buffer);

/**
 * Pack message HV_SET_FANS_STATUS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_hv_set_fans_status_pack(
    uint8_t *dst_p,
    const primary_hv_set_fans_status_t *src_p,
    size_t byte_size);

/**
 * Unpack message HV_SET_FANS_STATUS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_hv_set_fans_status_unpack(
    primary_hv_set_fans_status_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_set_fans_status_fans_override_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_hv_set_fans_status_fans_speed_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_hv_set_fans_status_fans_speed_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_set_fans_status_fans_speed_is_in_range(uint16_t value);


void primary_hv_feedback_status_raw_to_conversion(
    primary_hv_feedback_status_converted_t *conversion,
    primary_hv_feedback_status_feedback_implausibility_detected feedback_implausibility_detected,
    primary_hv_feedback_status_feedback_imd_cockpit feedback_imd_cockpit,
    primary_hv_feedback_status_feedback_tsal_green_fault_latched feedback_tsal_green_fault_latched,
    primary_hv_feedback_status_feedback_bms_cockpit feedback_bms_cockpit,
    primary_hv_feedback_status_feedback_ext_latched feedback_ext_latched,
    primary_hv_feedback_status_feedback_tsal_green feedback_tsal_green,
    primary_hv_feedback_status_feedback_ts_over_60v_status feedback_ts_over_60v_status,
    primary_hv_feedback_status_feedback_airn_status feedback_airn_status,
    primary_hv_feedback_status_feedback_airp_status feedback_airp_status,
    primary_hv_feedback_status_feedback_airp_gate feedback_airp_gate,
    primary_hv_feedback_status_feedback_airn_gate feedback_airn_gate,
    primary_hv_feedback_status_feedback_precharge_status feedback_precharge_status,
    primary_hv_feedback_status_feedback_tsp_over_60v_status feedback_tsp_over_60v_status,
    primary_hv_feedback_status_feedback_imd_fault feedback_imd_fault,
    primary_hv_feedback_status_feedback_check_mux feedback_check_mux,
    primary_hv_feedback_status_feedback_sd_end feedback_sd_end,
    primary_hv_feedback_status_feedback_sd_out feedback_sd_out,
    primary_hv_feedback_status_feedback_sd_in feedback_sd_in,
    primary_hv_feedback_status_feedback_sd_bms feedback_sd_bms,
    primary_hv_feedback_status_feedback_sd_imd feedback_sd_imd
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_hv_feedback_status_conversion_to_raw(
    primary_hv_feedback_status_t *raw,
    primary_hv_feedback_status_feedback_implausibility_detected feedback_implausibility_detected,
    primary_hv_feedback_status_feedback_imd_cockpit feedback_imd_cockpit,
    primary_hv_feedback_status_feedback_tsal_green_fault_latched feedback_tsal_green_fault_latched,
    primary_hv_feedback_status_feedback_bms_cockpit feedback_bms_cockpit,
    primary_hv_feedback_status_feedback_ext_latched feedback_ext_latched,
    primary_hv_feedback_status_feedback_tsal_green feedback_tsal_green,
    primary_hv_feedback_status_feedback_ts_over_60v_status feedback_ts_over_60v_status,
    primary_hv_feedback_status_feedback_airn_status feedback_airn_status,
    primary_hv_feedback_status_feedback_airp_status feedback_airp_status,
    primary_hv_feedback_status_feedback_airp_gate feedback_airp_gate,
    primary_hv_feedback_status_feedback_airn_gate feedback_airn_gate,
    primary_hv_feedback_status_feedback_precharge_status feedback_precharge_status,
    primary_hv_feedback_status_feedback_tsp_over_60v_status feedback_tsp_over_60v_status,
    primary_hv_feedback_status_feedback_imd_fault feedback_imd_fault,
    primary_hv_feedback_status_feedback_check_mux feedback_check_mux,
    primary_hv_feedback_status_feedback_sd_end feedback_sd_end,
    primary_hv_feedback_status_feedback_sd_out feedback_sd_out,
    primary_hv_feedback_status_feedback_sd_in feedback_sd_in,
    primary_hv_feedback_status_feedback_sd_bms feedback_sd_bms,
    primary_hv_feedback_status_feedback_sd_imd feedback_sd_imd
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_hv_feedback_status_raw_to_conversion_struct(
    primary_hv_feedback_status_converted_t *conversion, 
    const primary_hv_feedback_status_t *raw);


void primary_hv_feedback_status_conversion_to_raw_struct(
    primary_hv_feedback_status_t *raw,
    const primary_hv_feedback_status_converted_t *conversion);

int primary_hv_feedback_status_feedback_implausibility_detected_enum_to_string(primary_hv_feedback_status_feedback_implausibility_detected value, char *buffer);
int primary_hv_feedback_status_feedback_imd_cockpit_enum_to_string(primary_hv_feedback_status_feedback_imd_cockpit value, char *buffer);
int primary_hv_feedback_status_feedback_tsal_green_fault_latched_enum_to_string(primary_hv_feedback_status_feedback_tsal_green_fault_latched value, char *buffer);
int primary_hv_feedback_status_feedback_bms_cockpit_enum_to_string(primary_hv_feedback_status_feedback_bms_cockpit value, char *buffer);
int primary_hv_feedback_status_feedback_ext_latched_enum_to_string(primary_hv_feedback_status_feedback_ext_latched value, char *buffer);
int primary_hv_feedback_status_feedback_tsal_green_enum_to_string(primary_hv_feedback_status_feedback_tsal_green value, char *buffer);
int primary_hv_feedback_status_feedback_ts_over_60v_status_enum_to_string(primary_hv_feedback_status_feedback_ts_over_60v_status value, char *buffer);
int primary_hv_feedback_status_feedback_airn_status_enum_to_string(primary_hv_feedback_status_feedback_airn_status value, char *buffer);
int primary_hv_feedback_status_feedback_airp_status_enum_to_string(primary_hv_feedback_status_feedback_airp_status value, char *buffer);
int primary_hv_feedback_status_feedback_airp_gate_enum_to_string(primary_hv_feedback_status_feedback_airp_gate value, char *buffer);
int primary_hv_feedback_status_feedback_airn_gate_enum_to_string(primary_hv_feedback_status_feedback_airn_gate value, char *buffer);
int primary_hv_feedback_status_feedback_precharge_status_enum_to_string(primary_hv_feedback_status_feedback_precharge_status value, char *buffer);
int primary_hv_feedback_status_feedback_tsp_over_60v_status_enum_to_string(primary_hv_feedback_status_feedback_tsp_over_60v_status value, char *buffer);
int primary_hv_feedback_status_feedback_imd_fault_enum_to_string(primary_hv_feedback_status_feedback_imd_fault value, char *buffer);
int primary_hv_feedback_status_feedback_check_mux_enum_to_string(primary_hv_feedback_status_feedback_check_mux value, char *buffer);
int primary_hv_feedback_status_feedback_sd_end_enum_to_string(primary_hv_feedback_status_feedback_sd_end value, char *buffer);
int primary_hv_feedback_status_feedback_sd_out_enum_to_string(primary_hv_feedback_status_feedback_sd_out value, char *buffer);
int primary_hv_feedback_status_feedback_sd_in_enum_to_string(primary_hv_feedback_status_feedback_sd_in value, char *buffer);
int primary_hv_feedback_status_feedback_sd_bms_enum_to_string(primary_hv_feedback_status_feedback_sd_bms value, char *buffer);
int primary_hv_feedback_status_feedback_sd_imd_enum_to_string(primary_hv_feedback_status_feedback_sd_imd value, char *buffer);

int primary_hv_feedback_status_to_string(primary_hv_feedback_status_t *message, char *buffer);

int primary_hv_feedback_status_to_string_file(primary_hv_feedback_status_t *message, FILE *buffer);

int primary_hv_feedback_status_fields(char *buffer);

int primary_hv_feedback_status_fields_file(FILE *buffer);

/**
 * Pack message HV_FEEDBACK_STATUS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_hv_feedback_status_pack(
    uint8_t *dst_p,
    const primary_hv_feedback_status_t *src_p,
    size_t byte_size);

/**
 * Unpack message HV_FEEDBACK_STATUS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_hv_feedback_status_unpack(
    primary_hv_feedback_status_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedback_status_feedback_implausibility_detected_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedback_status_feedback_imd_cockpit_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedback_status_feedback_tsal_green_fault_latched_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedback_status_feedback_bms_cockpit_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedback_status_feedback_ext_latched_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedback_status_feedback_tsal_green_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedback_status_feedback_ts_over_60v_status_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedback_status_feedback_airn_status_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedback_status_feedback_airp_status_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedback_status_feedback_airp_gate_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedback_status_feedback_airn_gate_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedback_status_feedback_precharge_status_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedback_status_feedback_tsp_over_60v_status_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedback_status_feedback_imd_fault_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedback_status_feedback_check_mux_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedback_status_feedback_sd_end_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedback_status_feedback_sd_out_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedback_status_feedback_sd_in_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedback_status_feedback_sd_bms_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedback_status_feedback_sd_imd_is_in_range(uint8_t value);


void primary_hv_feedback_ts_voltage_raw_to_conversion(
    primary_hv_feedback_ts_voltage_converted_t *conversion,
    float ts_over_60v_status,
    float airn_status,
    float airp_status,
    float airp_gate,
    float airn_gate,
    float precharge_status,
    float tsp_over_60v_status
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_hv_feedback_ts_voltage_conversion_to_raw(
    primary_hv_feedback_ts_voltage_t *raw,
    float ts_over_60v_status,
    float airn_status,
    float airp_status,
    float airp_gate,
    float airn_gate,
    float precharge_status,
    float tsp_over_60v_status
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_hv_feedback_ts_voltage_raw_to_conversion_struct(
    primary_hv_feedback_ts_voltage_converted_t *conversion, 
    const primary_hv_feedback_ts_voltage_t *raw);


void primary_hv_feedback_ts_voltage_conversion_to_raw_struct(
    primary_hv_feedback_ts_voltage_t *raw,
    const primary_hv_feedback_ts_voltage_converted_t *conversion);


int primary_hv_feedback_ts_voltage_converted_to_string(primary_hv_feedback_ts_voltage_converted_t *message, char *buffer);

int primary_hv_feedback_ts_voltage_converted_to_string_file(primary_hv_feedback_ts_voltage_converted_t *message, FILE *buffer);

int primary_hv_feedback_ts_voltage_fields(char *buffer);

int primary_hv_feedback_ts_voltage_fields_file(FILE *buffer);

/**
 * Pack message HV_FEEDBACK_TS_VOLTAGE.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_hv_feedback_ts_voltage_pack(
    uint8_t *dst_p,
    const primary_hv_feedback_ts_voltage_t *src_p,
    size_t byte_size);

/**
 * Unpack message HV_FEEDBACK_TS_VOLTAGE.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_hv_feedback_ts_voltage_unpack(
    primary_hv_feedback_ts_voltage_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t primary_hv_feedback_ts_voltage_ts_over_60v_status_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_hv_feedback_ts_voltage_ts_over_60v_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedback_ts_voltage_ts_over_60v_status_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t primary_hv_feedback_ts_voltage_airn_status_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_hv_feedback_ts_voltage_airn_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedback_ts_voltage_airn_status_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t primary_hv_feedback_ts_voltage_airp_status_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_hv_feedback_ts_voltage_airp_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedback_ts_voltage_airp_status_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t primary_hv_feedback_ts_voltage_airp_gate_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_hv_feedback_ts_voltage_airp_gate_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedback_ts_voltage_airp_gate_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t primary_hv_feedback_ts_voltage_airn_gate_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_hv_feedback_ts_voltage_airn_gate_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedback_ts_voltage_airn_gate_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t primary_hv_feedback_ts_voltage_precharge_status_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_hv_feedback_ts_voltage_precharge_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedback_ts_voltage_precharge_status_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t primary_hv_feedback_ts_voltage_tsp_over_60v_status_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_hv_feedback_ts_voltage_tsp_over_60v_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedback_ts_voltage_tsp_over_60v_status_is_in_range(uint8_t value);


void primary_hv_feedback_misc_voltage_raw_to_conversion(
    primary_hv_feedback_misc_voltage_converted_t *conversion,
    float implausibility_detected,
    float imd_cockpit,
    float tsal_green_fault_latched,
    float bms_cockpit,
    float ext_latched,
    float tsal_green,
    float imd_fault,
    float check_mux
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_hv_feedback_misc_voltage_conversion_to_raw(
    primary_hv_feedback_misc_voltage_t *raw,
    float implausibility_detected,
    float imd_cockpit,
    float tsal_green_fault_latched,
    float bms_cockpit,
    float ext_latched,
    float tsal_green,
    float imd_fault,
    float check_mux
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_hv_feedback_misc_voltage_raw_to_conversion_struct(
    primary_hv_feedback_misc_voltage_converted_t *conversion, 
    const primary_hv_feedback_misc_voltage_t *raw);


void primary_hv_feedback_misc_voltage_conversion_to_raw_struct(
    primary_hv_feedback_misc_voltage_t *raw,
    const primary_hv_feedback_misc_voltage_converted_t *conversion);


int primary_hv_feedback_misc_voltage_converted_to_string(primary_hv_feedback_misc_voltage_converted_t *message, char *buffer);

int primary_hv_feedback_misc_voltage_converted_to_string_file(primary_hv_feedback_misc_voltage_converted_t *message, FILE *buffer);

int primary_hv_feedback_misc_voltage_fields(char *buffer);

int primary_hv_feedback_misc_voltage_fields_file(FILE *buffer);

/**
 * Pack message HV_FEEDBACK_MISC_VOLTAGE.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_hv_feedback_misc_voltage_pack(
    uint8_t *dst_p,
    const primary_hv_feedback_misc_voltage_t *src_p,
    size_t byte_size);

/**
 * Unpack message HV_FEEDBACK_MISC_VOLTAGE.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_hv_feedback_misc_voltage_unpack(
    primary_hv_feedback_misc_voltage_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t primary_hv_feedback_misc_voltage_implausibility_detected_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_hv_feedback_misc_voltage_implausibility_detected_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedback_misc_voltage_implausibility_detected_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t primary_hv_feedback_misc_voltage_imd_cockpit_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_hv_feedback_misc_voltage_imd_cockpit_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedback_misc_voltage_imd_cockpit_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t primary_hv_feedback_misc_voltage_tsal_green_fault_latched_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_hv_feedback_misc_voltage_tsal_green_fault_latched_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedback_misc_voltage_tsal_green_fault_latched_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t primary_hv_feedback_misc_voltage_bms_cockpit_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_hv_feedback_misc_voltage_bms_cockpit_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedback_misc_voltage_bms_cockpit_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t primary_hv_feedback_misc_voltage_ext_latched_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_hv_feedback_misc_voltage_ext_latched_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedback_misc_voltage_ext_latched_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t primary_hv_feedback_misc_voltage_tsal_green_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_hv_feedback_misc_voltage_tsal_green_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedback_misc_voltage_tsal_green_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t primary_hv_feedback_misc_voltage_imd_fault_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_hv_feedback_misc_voltage_imd_fault_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedback_misc_voltage_imd_fault_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t primary_hv_feedback_misc_voltage_check_mux_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_hv_feedback_misc_voltage_check_mux_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedback_misc_voltage_check_mux_is_in_range(uint8_t value);


void primary_hv_feedback_sd_voltage_raw_to_conversion(
    primary_hv_feedback_sd_voltage_converted_t *conversion,
    float sd_end,
    float sd_out,
    float sd_in,
    float sd_bms,
    float sd_imd
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_hv_feedback_sd_voltage_conversion_to_raw(
    primary_hv_feedback_sd_voltage_t *raw,
    float sd_end,
    float sd_out,
    float sd_in,
    float sd_bms,
    float sd_imd
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_hv_feedback_sd_voltage_raw_to_conversion_struct(
    primary_hv_feedback_sd_voltage_converted_t *conversion, 
    const primary_hv_feedback_sd_voltage_t *raw);


void primary_hv_feedback_sd_voltage_conversion_to_raw_struct(
    primary_hv_feedback_sd_voltage_t *raw,
    const primary_hv_feedback_sd_voltage_converted_t *conversion);


int primary_hv_feedback_sd_voltage_converted_to_string(primary_hv_feedback_sd_voltage_converted_t *message, char *buffer);

int primary_hv_feedback_sd_voltage_converted_to_string_file(primary_hv_feedback_sd_voltage_converted_t *message, FILE *buffer);

int primary_hv_feedback_sd_voltage_fields(char *buffer);

int primary_hv_feedback_sd_voltage_fields_file(FILE *buffer);

/**
 * Pack message HV_FEEDBACK_SD_VOLTAGE.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_hv_feedback_sd_voltage_pack(
    uint8_t *dst_p,
    const primary_hv_feedback_sd_voltage_t *src_p,
    size_t byte_size);

/**
 * Unpack message HV_FEEDBACK_SD_VOLTAGE.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_hv_feedback_sd_voltage_unpack(
    primary_hv_feedback_sd_voltage_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t primary_hv_feedback_sd_voltage_sd_end_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_hv_feedback_sd_voltage_sd_end_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedback_sd_voltage_sd_end_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t primary_hv_feedback_sd_voltage_sd_out_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_hv_feedback_sd_voltage_sd_out_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedback_sd_voltage_sd_out_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t primary_hv_feedback_sd_voltage_sd_in_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_hv_feedback_sd_voltage_sd_in_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedback_sd_voltage_sd_in_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t primary_hv_feedback_sd_voltage_sd_bms_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_hv_feedback_sd_voltage_sd_bms_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedback_sd_voltage_sd_bms_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t primary_hv_feedback_sd_voltage_sd_imd_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_hv_feedback_sd_voltage_sd_imd_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedback_sd_voltage_sd_imd_is_in_range(uint8_t value);


void primary_hv_imd_status_raw_to_conversion(
    primary_hv_imd_status_converted_t *conversion,
    uint8_t imd_fault,
    primary_hv_imd_status_imd_status imd_status,
    uint16_t imd_details,
    uint8_t imd_duty_cycle,
    uint8_t imd_freq,
    uint8_t imd_period
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_hv_imd_status_conversion_to_raw(
    primary_hv_imd_status_t *raw,
    uint8_t imd_fault,
    primary_hv_imd_status_imd_status imd_status,
    uint16_t imd_details,
    uint8_t imd_duty_cycle,
    uint8_t imd_freq,
    uint8_t imd_period
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_hv_imd_status_raw_to_conversion_struct(
    primary_hv_imd_status_converted_t *conversion, 
    const primary_hv_imd_status_t *raw);


void primary_hv_imd_status_conversion_to_raw_struct(
    primary_hv_imd_status_t *raw,
    const primary_hv_imd_status_converted_t *conversion);

int primary_hv_imd_status_imd_status_enum_to_string(primary_hv_imd_status_imd_status value, char *buffer);

int primary_hv_imd_status_to_string(primary_hv_imd_status_t *message, char *buffer);

int primary_hv_imd_status_to_string_file(primary_hv_imd_status_t *message, FILE *buffer);

int primary_hv_imd_status_fields(char *buffer);

int primary_hv_imd_status_fields_file(FILE *buffer);

/**
 * Pack message HV_IMD_STATUS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_hv_imd_status_pack(
    uint8_t *dst_p,
    const primary_hv_imd_status_t *src_p,
    size_t byte_size);

/**
 * Unpack message HV_IMD_STATUS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_hv_imd_status_unpack(
    primary_hv_imd_status_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_imd_status_imd_fault_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_imd_status_imd_status_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_imd_status_imd_details_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_imd_status_imd_duty_cycle_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_imd_status_imd_freq_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_imd_status_imd_period_is_in_range(uint8_t value);


void primary_hv_status_raw_to_conversion(
    primary_hv_status_converted_t *conversion,
    primary_hv_status_status status
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_hv_status_conversion_to_raw(
    primary_hv_status_t *raw,
    primary_hv_status_status status
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_hv_status_raw_to_conversion_struct(
    primary_hv_status_converted_t *conversion, 
    const primary_hv_status_t *raw);


void primary_hv_status_conversion_to_raw_struct(
    primary_hv_status_t *raw,
    const primary_hv_status_converted_t *conversion);

int primary_hv_status_status_enum_to_string(primary_hv_status_status value, char *buffer);

int primary_hv_status_to_string(primary_hv_status_t *message, char *buffer);

int primary_hv_status_to_string_file(primary_hv_status_t *message, FILE *buffer);

int primary_hv_status_fields(char *buffer);

int primary_hv_status_fields_file(FILE *buffer);

/**
 * Pack message HV_STATUS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_hv_status_pack(
    uint8_t *dst_p,
    const primary_hv_status_t *src_p,
    size_t byte_size);

/**
 * Unpack message HV_STATUS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_hv_status_unpack(
    primary_hv_status_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_status_status_is_in_range(uint8_t value);


void primary_hv_set_status_ecu_raw_to_conversion(
    primary_hv_set_status_ecu_converted_t *conversion,
    primary_hv_set_status_ecu_hv_status_set hv_status_set
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_hv_set_status_ecu_conversion_to_raw(
    primary_hv_set_status_ecu_t *raw,
    primary_hv_set_status_ecu_hv_status_set hv_status_set
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_hv_set_status_ecu_raw_to_conversion_struct(
    primary_hv_set_status_ecu_converted_t *conversion, 
    const primary_hv_set_status_ecu_t *raw);


void primary_hv_set_status_ecu_conversion_to_raw_struct(
    primary_hv_set_status_ecu_t *raw,
    const primary_hv_set_status_ecu_converted_t *conversion);

int primary_hv_set_status_ecu_hv_status_set_enum_to_string(primary_hv_set_status_ecu_hv_status_set value, char *buffer);

int primary_hv_set_status_ecu_to_string(primary_hv_set_status_ecu_t *message, char *buffer);

int primary_hv_set_status_ecu_to_string_file(primary_hv_set_status_ecu_t *message, FILE *buffer);

int primary_hv_set_status_ecu_fields(char *buffer);

int primary_hv_set_status_ecu_fields_file(FILE *buffer);

/**
 * Pack message HV_SET_STATUS_ECU.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_hv_set_status_ecu_pack(
    uint8_t *dst_p,
    const primary_hv_set_status_ecu_t *src_p,
    size_t byte_size);

/**
 * Unpack message HV_SET_STATUS_ECU.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_hv_set_status_ecu_unpack(
    primary_hv_set_status_ecu_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_set_status_ecu_hv_status_set_is_in_range(uint8_t value);


void primary_hv_set_status_handcart_raw_to_conversion(
    primary_hv_set_status_handcart_converted_t *conversion,
    primary_hv_set_status_handcart_hv_status_set hv_status_set
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_hv_set_status_handcart_conversion_to_raw(
    primary_hv_set_status_handcart_t *raw,
    primary_hv_set_status_handcart_hv_status_set hv_status_set
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_hv_set_status_handcart_raw_to_conversion_struct(
    primary_hv_set_status_handcart_converted_t *conversion, 
    const primary_hv_set_status_handcart_t *raw);


void primary_hv_set_status_handcart_conversion_to_raw_struct(
    primary_hv_set_status_handcart_t *raw,
    const primary_hv_set_status_handcart_converted_t *conversion);

int primary_hv_set_status_handcart_hv_status_set_enum_to_string(primary_hv_set_status_handcart_hv_status_set value, char *buffer);

int primary_hv_set_status_handcart_to_string(primary_hv_set_status_handcart_t *message, char *buffer);

int primary_hv_set_status_handcart_to_string_file(primary_hv_set_status_handcart_t *message, FILE *buffer);

int primary_hv_set_status_handcart_fields(char *buffer);

int primary_hv_set_status_handcart_fields_file(FILE *buffer);

/**
 * Pack message HV_SET_STATUS_HANDCART.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_hv_set_status_handcart_pack(
    uint8_t *dst_p,
    const primary_hv_set_status_handcart_t *src_p,
    size_t byte_size);

/**
 * Unpack message HV_SET_STATUS_HANDCART.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_hv_set_status_handcart_unpack(
    primary_hv_set_status_handcart_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_set_status_handcart_hv_status_set_is_in_range(uint8_t value);


void primary_hv_balancing_status_raw_to_conversion(
    primary_hv_balancing_status_converted_t *conversion,
    primary_hv_balancing_status_cellboard_id cellboard_id,
    primary_hv_balancing_status_balancing_status balancing_status,
    uint8_t errors_can_comm,
    uint8_t errors_ltc_comm,
    uint8_t errors_temp_comm_0,
    uint8_t errors_temp_comm_1,
    uint8_t errors_temp_comm_2,
    uint8_t errors_temp_comm_3,
    uint8_t errors_temp_comm_4,
    uint8_t errors_temp_comm_5,
    uint8_t errors_open_wire,
    uint8_t balancing_cells_cell0,
    uint8_t balancing_cells_cell1,
    uint8_t balancing_cells_cell2,
    uint8_t balancing_cells_cell3,
    uint8_t balancing_cells_cell4,
    uint8_t balancing_cells_cell5,
    uint8_t balancing_cells_cell6,
    uint8_t balancing_cells_cell7,
    uint8_t balancing_cells_cell8,
    uint8_t balancing_cells_cell9,
    uint8_t balancing_cells_cell10,
    uint8_t balancing_cells_cell11,
    uint8_t balancing_cells_cell12,
    uint8_t balancing_cells_cell13,
    uint8_t balancing_cells_cell14,
    uint8_t balancing_cells_cell15,
    uint8_t balancing_cells_cell16,
    uint8_t balancing_cells_cell17
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_hv_balancing_status_conversion_to_raw(
    primary_hv_balancing_status_t *raw,
    primary_hv_balancing_status_cellboard_id cellboard_id,
    primary_hv_balancing_status_balancing_status balancing_status,
    uint8_t errors_can_comm,
    uint8_t errors_ltc_comm,
    uint8_t errors_temp_comm_0,
    uint8_t errors_temp_comm_1,
    uint8_t errors_temp_comm_2,
    uint8_t errors_temp_comm_3,
    uint8_t errors_temp_comm_4,
    uint8_t errors_temp_comm_5,
    uint8_t errors_open_wire,
    uint8_t balancing_cells_cell0,
    uint8_t balancing_cells_cell1,
    uint8_t balancing_cells_cell2,
    uint8_t balancing_cells_cell3,
    uint8_t balancing_cells_cell4,
    uint8_t balancing_cells_cell5,
    uint8_t balancing_cells_cell6,
    uint8_t balancing_cells_cell7,
    uint8_t balancing_cells_cell8,
    uint8_t balancing_cells_cell9,
    uint8_t balancing_cells_cell10,
    uint8_t balancing_cells_cell11,
    uint8_t balancing_cells_cell12,
    uint8_t balancing_cells_cell13,
    uint8_t balancing_cells_cell14,
    uint8_t balancing_cells_cell15,
    uint8_t balancing_cells_cell16,
    uint8_t balancing_cells_cell17
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_hv_balancing_status_raw_to_conversion_struct(
    primary_hv_balancing_status_converted_t *conversion, 
    const primary_hv_balancing_status_t *raw);


void primary_hv_balancing_status_conversion_to_raw_struct(
    primary_hv_balancing_status_t *raw,
    const primary_hv_balancing_status_converted_t *conversion);

int primary_hv_balancing_status_cellboard_id_enum_to_string(primary_hv_balancing_status_cellboard_id value, char *buffer);
int primary_hv_balancing_status_balancing_status_enum_to_string(primary_hv_balancing_status_balancing_status value, char *buffer);

int primary_hv_balancing_status_to_string(primary_hv_balancing_status_t *message, char *buffer);

int primary_hv_balancing_status_to_string_file(primary_hv_balancing_status_t *message, FILE *buffer);

int primary_hv_balancing_status_fields(char *buffer);

int primary_hv_balancing_status_fields_file(FILE *buffer);

/**
 * Pack message HV_BALANCING_STATUS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_hv_balancing_status_pack(
    uint8_t *dst_p,
    const primary_hv_balancing_status_t *src_p,
    size_t byte_size);

/**
 * Unpack message HV_BALANCING_STATUS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_hv_balancing_status_unpack(
    primary_hv_balancing_status_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_balancing_status_cellboard_id_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_balancing_status_balancing_status_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_balancing_status_errors_can_comm_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_balancing_status_errors_ltc_comm_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_balancing_status_errors_temp_comm_0_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_balancing_status_errors_temp_comm_1_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_balancing_status_errors_temp_comm_2_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_balancing_status_errors_temp_comm_3_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_balancing_status_errors_temp_comm_4_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_balancing_status_errors_temp_comm_5_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_balancing_status_errors_open_wire_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_balancing_status_balancing_cells_cell0_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_balancing_status_balancing_cells_cell1_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_balancing_status_balancing_cells_cell2_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_balancing_status_balancing_cells_cell3_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_balancing_status_balancing_cells_cell4_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_balancing_status_balancing_cells_cell5_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_balancing_status_balancing_cells_cell6_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_balancing_status_balancing_cells_cell7_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_balancing_status_balancing_cells_cell8_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_balancing_status_balancing_cells_cell9_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_balancing_status_balancing_cells_cell10_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_balancing_status_balancing_cells_cell11_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_balancing_status_balancing_cells_cell12_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_balancing_status_balancing_cells_cell13_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_balancing_status_balancing_cells_cell14_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_balancing_status_balancing_cells_cell15_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_balancing_status_balancing_cells_cell16_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_balancing_status_balancing_cells_cell17_is_in_range(uint8_t value);


void primary_hv_set_balancing_status_handcart_raw_to_conversion(
    primary_hv_set_balancing_status_handcart_converted_t *conversion,
    primary_hv_set_balancing_status_handcart_set_balancing_status set_balancing_status,
    uint8_t balancing_threshold
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_hv_set_balancing_status_handcart_conversion_to_raw(
    primary_hv_set_balancing_status_handcart_t *raw,
    primary_hv_set_balancing_status_handcart_set_balancing_status set_balancing_status,
    uint8_t balancing_threshold
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_hv_set_balancing_status_handcart_raw_to_conversion_struct(
    primary_hv_set_balancing_status_handcart_converted_t *conversion, 
    const primary_hv_set_balancing_status_handcart_t *raw);


void primary_hv_set_balancing_status_handcart_conversion_to_raw_struct(
    primary_hv_set_balancing_status_handcart_t *raw,
    const primary_hv_set_balancing_status_handcart_converted_t *conversion);

int primary_hv_set_balancing_status_handcart_set_balancing_status_enum_to_string(primary_hv_set_balancing_status_handcart_set_balancing_status value, char *buffer);

int primary_hv_set_balancing_status_handcart_to_string(primary_hv_set_balancing_status_handcart_t *message, char *buffer);

int primary_hv_set_balancing_status_handcart_to_string_file(primary_hv_set_balancing_status_handcart_t *message, FILE *buffer);

int primary_hv_set_balancing_status_handcart_fields(char *buffer);

int primary_hv_set_balancing_status_handcart_fields_file(FILE *buffer);

/**
 * Pack message HV_SET_BALANCING_STATUS_HANDCART.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_hv_set_balancing_status_handcart_pack(
    uint8_t *dst_p,
    const primary_hv_set_balancing_status_handcart_t *src_p,
    size_t byte_size);

/**
 * Unpack message HV_SET_BALANCING_STATUS_HANDCART.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_hv_set_balancing_status_handcart_unpack(
    primary_hv_set_balancing_status_handcart_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_set_balancing_status_handcart_set_balancing_status_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_set_balancing_status_handcart_balancing_threshold_is_in_range(uint8_t value);


void primary_hv_set_balancing_status_steering_wheel_raw_to_conversion(
    primary_hv_set_balancing_status_steering_wheel_converted_t *conversion,
    primary_hv_set_balancing_status_steering_wheel_set_balancing_status set_balancing_status,
    uint8_t balancing_threshold
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_hv_set_balancing_status_steering_wheel_conversion_to_raw(
    primary_hv_set_balancing_status_steering_wheel_t *raw,
    primary_hv_set_balancing_status_steering_wheel_set_balancing_status set_balancing_status,
    uint8_t balancing_threshold
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_hv_set_balancing_status_steering_wheel_raw_to_conversion_struct(
    primary_hv_set_balancing_status_steering_wheel_converted_t *conversion, 
    const primary_hv_set_balancing_status_steering_wheel_t *raw);


void primary_hv_set_balancing_status_steering_wheel_conversion_to_raw_struct(
    primary_hv_set_balancing_status_steering_wheel_t *raw,
    const primary_hv_set_balancing_status_steering_wheel_converted_t *conversion);

int primary_hv_set_balancing_status_steering_wheel_set_balancing_status_enum_to_string(primary_hv_set_balancing_status_steering_wheel_set_balancing_status value, char *buffer);

int primary_hv_set_balancing_status_steering_wheel_to_string(primary_hv_set_balancing_status_steering_wheel_t *message, char *buffer);

int primary_hv_set_balancing_status_steering_wheel_to_string_file(primary_hv_set_balancing_status_steering_wheel_t *message, FILE *buffer);

int primary_hv_set_balancing_status_steering_wheel_fields(char *buffer);

int primary_hv_set_balancing_status_steering_wheel_fields_file(FILE *buffer);

/**
 * Pack message HV_SET_BALANCING_STATUS_STEERING_WHEEL.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_hv_set_balancing_status_steering_wheel_pack(
    uint8_t *dst_p,
    const primary_hv_set_balancing_status_steering_wheel_t *src_p,
    size_t byte_size);

/**
 * Unpack message HV_SET_BALANCING_STATUS_STEERING_WHEEL.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_hv_set_balancing_status_steering_wheel_unpack(
    primary_hv_set_balancing_status_steering_wheel_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_set_balancing_status_steering_wheel_set_balancing_status_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_set_balancing_status_steering_wheel_balancing_threshold_is_in_range(uint8_t value);


void primary_lv_status_raw_to_conversion(
    primary_lv_status_converted_t *conversion,
    primary_lv_status_status status
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_lv_status_conversion_to_raw(
    primary_lv_status_t *raw,
    primary_lv_status_status status
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_lv_status_raw_to_conversion_struct(
    primary_lv_status_converted_t *conversion, 
    const primary_lv_status_t *raw);


void primary_lv_status_conversion_to_raw_struct(
    primary_lv_status_t *raw,
    const primary_lv_status_converted_t *conversion);

int primary_lv_status_status_enum_to_string(primary_lv_status_status value, char *buffer);

int primary_lv_status_to_string(primary_lv_status_t *message, char *buffer);

int primary_lv_status_to_string_file(primary_lv_status_t *message, FILE *buffer);

int primary_lv_status_fields(char *buffer);

int primary_lv_status_fields_file(FILE *buffer);

/**
 * Pack message LV_STATUS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_lv_status_pack(
    uint8_t *dst_p,
    const primary_lv_status_t *src_p,
    size_t byte_size);

/**
 * Unpack message LV_STATUS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_lv_status_unpack(
    primary_lv_status_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_status_status_is_in_range(uint8_t value);


void primary_lv_radiator_speed_raw_to_conversion(
    primary_lv_radiator_speed_converted_t *conversion,
    primary_lv_radiator_speed_status status,
    float radiator_speed
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_lv_radiator_speed_conversion_to_raw(
    primary_lv_radiator_speed_t *raw,
    primary_lv_radiator_speed_status status,
    float radiator_speed
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_lv_radiator_speed_raw_to_conversion_struct(
    primary_lv_radiator_speed_converted_t *conversion, 
    const primary_lv_radiator_speed_t *raw);


void primary_lv_radiator_speed_conversion_to_raw_struct(
    primary_lv_radiator_speed_t *raw,
    const primary_lv_radiator_speed_converted_t *conversion);

int primary_lv_radiator_speed_status_enum_to_string(primary_lv_radiator_speed_status value, char *buffer);

int primary_lv_radiator_speed_converted_to_string(primary_lv_radiator_speed_converted_t *message, char *buffer);

int primary_lv_radiator_speed_converted_to_string_file(primary_lv_radiator_speed_converted_t *message, FILE *buffer);

int primary_lv_radiator_speed_fields(char *buffer);

int primary_lv_radiator_speed_fields_file(FILE *buffer);

/**
 * Pack message LV_RADIATOR_SPEED.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_lv_radiator_speed_pack(
    uint8_t *dst_p,
    const primary_lv_radiator_speed_t *src_p,
    size_t byte_size);

/**
 * Unpack message LV_RADIATOR_SPEED.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_lv_radiator_speed_unpack(
    primary_lv_radiator_speed_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_radiator_speed_status_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t primary_lv_radiator_speed_radiator_speed_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_lv_radiator_speed_radiator_speed_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_radiator_speed_radiator_speed_is_in_range(uint8_t value);


void primary_lv_pumps_speed_raw_to_conversion(
    primary_lv_pumps_speed_converted_t *conversion,
    primary_lv_pumps_speed_status status,
    float pumps_speed
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_lv_pumps_speed_conversion_to_raw(
    primary_lv_pumps_speed_t *raw,
    primary_lv_pumps_speed_status status,
    float pumps_speed
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_lv_pumps_speed_raw_to_conversion_struct(
    primary_lv_pumps_speed_converted_t *conversion, 
    const primary_lv_pumps_speed_t *raw);


void primary_lv_pumps_speed_conversion_to_raw_struct(
    primary_lv_pumps_speed_t *raw,
    const primary_lv_pumps_speed_converted_t *conversion);

int primary_lv_pumps_speed_status_enum_to_string(primary_lv_pumps_speed_status value, char *buffer);

int primary_lv_pumps_speed_converted_to_string(primary_lv_pumps_speed_converted_t *message, char *buffer);

int primary_lv_pumps_speed_converted_to_string_file(primary_lv_pumps_speed_converted_t *message, FILE *buffer);

int primary_lv_pumps_speed_fields(char *buffer);

int primary_lv_pumps_speed_fields_file(FILE *buffer);

/**
 * Pack message LV_PUMPS_SPEED.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_lv_pumps_speed_pack(
    uint8_t *dst_p,
    const primary_lv_pumps_speed_t *src_p,
    size_t byte_size);

/**
 * Unpack message LV_PUMPS_SPEED.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_lv_pumps_speed_unpack(
    primary_lv_pumps_speed_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_pumps_speed_status_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t primary_lv_pumps_speed_pumps_speed_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_lv_pumps_speed_pumps_speed_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_pumps_speed_pumps_speed_is_in_range(uint8_t value);


void primary_lv_set_radiator_speed_raw_to_conversion(
    primary_lv_set_radiator_speed_converted_t *conversion,
    primary_lv_set_radiator_speed_status status,
    float radiator_speed
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_lv_set_radiator_speed_conversion_to_raw(
    primary_lv_set_radiator_speed_t *raw,
    primary_lv_set_radiator_speed_status status,
    float radiator_speed
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_lv_set_radiator_speed_raw_to_conversion_struct(
    primary_lv_set_radiator_speed_converted_t *conversion, 
    const primary_lv_set_radiator_speed_t *raw);


void primary_lv_set_radiator_speed_conversion_to_raw_struct(
    primary_lv_set_radiator_speed_t *raw,
    const primary_lv_set_radiator_speed_converted_t *conversion);

int primary_lv_set_radiator_speed_status_enum_to_string(primary_lv_set_radiator_speed_status value, char *buffer);

int primary_lv_set_radiator_speed_converted_to_string(primary_lv_set_radiator_speed_converted_t *message, char *buffer);

int primary_lv_set_radiator_speed_converted_to_string_file(primary_lv_set_radiator_speed_converted_t *message, FILE *buffer);

int primary_lv_set_radiator_speed_fields(char *buffer);

int primary_lv_set_radiator_speed_fields_file(FILE *buffer);

/**
 * Pack message LV_SET_RADIATOR_SPEED.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_lv_set_radiator_speed_pack(
    uint8_t *dst_p,
    const primary_lv_set_radiator_speed_t *src_p,
    size_t byte_size);

/**
 * Unpack message LV_SET_RADIATOR_SPEED.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_lv_set_radiator_speed_unpack(
    primary_lv_set_radiator_speed_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_set_radiator_speed_status_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t primary_lv_set_radiator_speed_radiator_speed_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_lv_set_radiator_speed_radiator_speed_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_set_radiator_speed_radiator_speed_is_in_range(uint8_t value);


void primary_lv_set_pumps_speed_raw_to_conversion(
    primary_lv_set_pumps_speed_converted_t *conversion,
    primary_lv_set_pumps_speed_status status,
    float pumps_speed
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_lv_set_pumps_speed_conversion_to_raw(
    primary_lv_set_pumps_speed_t *raw,
    primary_lv_set_pumps_speed_status status,
    float pumps_speed
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_lv_set_pumps_speed_raw_to_conversion_struct(
    primary_lv_set_pumps_speed_converted_t *conversion, 
    const primary_lv_set_pumps_speed_t *raw);


void primary_lv_set_pumps_speed_conversion_to_raw_struct(
    primary_lv_set_pumps_speed_t *raw,
    const primary_lv_set_pumps_speed_converted_t *conversion);

int primary_lv_set_pumps_speed_status_enum_to_string(primary_lv_set_pumps_speed_status value, char *buffer);

int primary_lv_set_pumps_speed_converted_to_string(primary_lv_set_pumps_speed_converted_t *message, char *buffer);

int primary_lv_set_pumps_speed_converted_to_string_file(primary_lv_set_pumps_speed_converted_t *message, FILE *buffer);

int primary_lv_set_pumps_speed_fields(char *buffer);

int primary_lv_set_pumps_speed_fields_file(FILE *buffer);

/**
 * Pack message LV_SET_PUMPS_SPEED.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_lv_set_pumps_speed_pack(
    uint8_t *dst_p,
    const primary_lv_set_pumps_speed_t *src_p,
    size_t byte_size);

/**
 * Unpack message LV_SET_PUMPS_SPEED.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_lv_set_pumps_speed_unpack(
    primary_lv_set_pumps_speed_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_set_pumps_speed_status_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t primary_lv_set_pumps_speed_pumps_speed_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_lv_set_pumps_speed_pumps_speed_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_set_pumps_speed_pumps_speed_is_in_range(uint8_t value);


void primary_lv_errors_raw_to_conversion(
    primary_lv_errors_converted_t *conversion,
    uint8_t errors_cell_undervoltage,
    uint8_t errors_cell_overvoltage,
    uint8_t errors_battery_open_wire,
    uint8_t errors_can,
    uint8_t errors_spi,
    uint8_t errors_over_current,
    uint8_t errors_cell_under_temperature,
    uint8_t errors_cell_over_temperature,
    uint8_t errors_relay,
    uint8_t errors_bms_monitor,
    uint8_t errors_voltages_not_ready,
    uint8_t errors_mcp23017,
    uint8_t errors_radiator,
    uint8_t errors_fan,
    uint8_t errors_pump,
    uint8_t errors_adc_init,
    uint8_t errors_mux,
    uint8_t health_signals_lvms_out,
    uint8_t health_signals_relay_out,
    uint8_t health_signals_battery_voltage_out,
    uint8_t health_signals_charger_current,
    uint8_t health_signals_battery_current,
    uint8_t health_signals_sign_battery_current
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_lv_errors_conversion_to_raw(
    primary_lv_errors_t *raw,
    uint8_t errors_cell_undervoltage,
    uint8_t errors_cell_overvoltage,
    uint8_t errors_battery_open_wire,
    uint8_t errors_can,
    uint8_t errors_spi,
    uint8_t errors_over_current,
    uint8_t errors_cell_under_temperature,
    uint8_t errors_cell_over_temperature,
    uint8_t errors_relay,
    uint8_t errors_bms_monitor,
    uint8_t errors_voltages_not_ready,
    uint8_t errors_mcp23017,
    uint8_t errors_radiator,
    uint8_t errors_fan,
    uint8_t errors_pump,
    uint8_t errors_adc_init,
    uint8_t errors_mux,
    uint8_t health_signals_lvms_out,
    uint8_t health_signals_relay_out,
    uint8_t health_signals_battery_voltage_out,
    uint8_t health_signals_charger_current,
    uint8_t health_signals_battery_current,
    uint8_t health_signals_sign_battery_current
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_lv_errors_raw_to_conversion_struct(
    primary_lv_errors_converted_t *conversion, 
    const primary_lv_errors_t *raw);


void primary_lv_errors_conversion_to_raw_struct(
    primary_lv_errors_t *raw,
    const primary_lv_errors_converted_t *conversion);


int primary_lv_errors_to_string(primary_lv_errors_t *message, char *buffer);

int primary_lv_errors_to_string_file(primary_lv_errors_t *message, FILE *buffer);

int primary_lv_errors_fields(char *buffer);

int primary_lv_errors_fields_file(FILE *buffer);

/**
 * Pack message LV_ERRORS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_lv_errors_pack(
    uint8_t *dst_p,
    const primary_lv_errors_t *src_p,
    size_t byte_size);

/**
 * Unpack message LV_ERRORS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_lv_errors_unpack(
    primary_lv_errors_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_errors_errors_cell_undervoltage_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_errors_errors_cell_overvoltage_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_errors_errors_battery_open_wire_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_errors_errors_can_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_errors_errors_spi_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_errors_errors_over_current_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_errors_errors_cell_under_temperature_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_errors_errors_cell_over_temperature_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_errors_errors_relay_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_errors_errors_bms_monitor_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_errors_errors_voltages_not_ready_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_errors_errors_mcp23017_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_errors_errors_radiator_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_errors_errors_fan_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_errors_errors_pump_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_errors_errors_adc_init_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_errors_errors_mux_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_errors_health_signals_lvms_out_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_errors_health_signals_relay_out_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_errors_health_signals_battery_voltage_out_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_errors_health_signals_charger_current_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_errors_health_signals_battery_current_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_errors_health_signals_sign_battery_current_is_in_range(uint8_t value);


void primary_lv_feedback_ts_voltage_raw_to_conversion(
    primary_lv_feedback_ts_voltage_converted_t *conversion,
    float bspd,
    float hvd,
    float invc_interlock,
    float ams
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_lv_feedback_ts_voltage_conversion_to_raw(
    primary_lv_feedback_ts_voltage_t *raw,
    float bspd,
    float hvd,
    float invc_interlock,
    float ams
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_lv_feedback_ts_voltage_raw_to_conversion_struct(
    primary_lv_feedback_ts_voltage_converted_t *conversion, 
    const primary_lv_feedback_ts_voltage_t *raw);


void primary_lv_feedback_ts_voltage_conversion_to_raw_struct(
    primary_lv_feedback_ts_voltage_t *raw,
    const primary_lv_feedback_ts_voltage_converted_t *conversion);


int primary_lv_feedback_ts_voltage_converted_to_string(primary_lv_feedback_ts_voltage_converted_t *message, char *buffer);

int primary_lv_feedback_ts_voltage_converted_to_string_file(primary_lv_feedback_ts_voltage_converted_t *message, FILE *buffer);

int primary_lv_feedback_ts_voltage_fields(char *buffer);

int primary_lv_feedback_ts_voltage_fields_file(FILE *buffer);

/**
 * Pack message LV_FEEDBACK_TS_VOLTAGE.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_lv_feedback_ts_voltage_pack(
    uint8_t *dst_p,
    const primary_lv_feedback_ts_voltage_t *src_p,
    size_t byte_size);

/**
 * Unpack message LV_FEEDBACK_TS_VOLTAGE.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_lv_feedback_ts_voltage_unpack(
    primary_lv_feedback_ts_voltage_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_lv_feedback_ts_voltage_bspd_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_lv_feedback_ts_voltage_bspd_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_feedback_ts_voltage_bspd_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_lv_feedback_ts_voltage_hvd_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_lv_feedback_ts_voltage_hvd_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_feedback_ts_voltage_hvd_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_lv_feedback_ts_voltage_invc_interlock_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_lv_feedback_ts_voltage_invc_interlock_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_feedback_ts_voltage_invc_interlock_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_lv_feedback_ts_voltage_ams_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_lv_feedback_ts_voltage_ams_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_feedback_ts_voltage_ams_is_in_range(uint16_t value);


void primary_lv_feedback_sd_voltage_raw_to_conversion(
    primary_lv_feedback_sd_voltage_converted_t *conversion,
    float sd_end,
    float lvms,
    float interlock,
    float sd_start
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_lv_feedback_sd_voltage_conversion_to_raw(
    primary_lv_feedback_sd_voltage_t *raw,
    float sd_end,
    float lvms,
    float interlock,
    float sd_start
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_lv_feedback_sd_voltage_raw_to_conversion_struct(
    primary_lv_feedback_sd_voltage_converted_t *conversion, 
    const primary_lv_feedback_sd_voltage_t *raw);


void primary_lv_feedback_sd_voltage_conversion_to_raw_struct(
    primary_lv_feedback_sd_voltage_t *raw,
    const primary_lv_feedback_sd_voltage_converted_t *conversion);


int primary_lv_feedback_sd_voltage_converted_to_string(primary_lv_feedback_sd_voltage_converted_t *message, char *buffer);

int primary_lv_feedback_sd_voltage_converted_to_string_file(primary_lv_feedback_sd_voltage_converted_t *message, FILE *buffer);

int primary_lv_feedback_sd_voltage_fields(char *buffer);

int primary_lv_feedback_sd_voltage_fields_file(FILE *buffer);

/**
 * Pack message LV_FEEDBACK_SD_VOLTAGE.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_lv_feedback_sd_voltage_pack(
    uint8_t *dst_p,
    const primary_lv_feedback_sd_voltage_t *src_p,
    size_t byte_size);

/**
 * Unpack message LV_FEEDBACK_SD_VOLTAGE.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_lv_feedback_sd_voltage_unpack(
    primary_lv_feedback_sd_voltage_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_lv_feedback_sd_voltage_sd_end_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_lv_feedback_sd_voltage_sd_end_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_feedback_sd_voltage_sd_end_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_lv_feedback_sd_voltage_lvms_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_lv_feedback_sd_voltage_lvms_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_feedback_sd_voltage_lvms_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_lv_feedback_sd_voltage_interlock_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_lv_feedback_sd_voltage_interlock_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_feedback_sd_voltage_interlock_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_lv_feedback_sd_voltage_sd_start_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_lv_feedback_sd_voltage_sd_start_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_feedback_sd_voltage_sd_start_is_in_range(uint16_t value);


void primary_lv_feedback_enclosure_voltage_raw_to_conversion(
    primary_lv_feedback_enclosure_voltage_converted_t *conversion,
    float lv_encl,
    float invc_lid,
    float hv_encl_2,
    float backplate
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_lv_feedback_enclosure_voltage_conversion_to_raw(
    primary_lv_feedback_enclosure_voltage_t *raw,
    float lv_encl,
    float invc_lid,
    float hv_encl_2,
    float backplate
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_lv_feedback_enclosure_voltage_raw_to_conversion_struct(
    primary_lv_feedback_enclosure_voltage_converted_t *conversion, 
    const primary_lv_feedback_enclosure_voltage_t *raw);


void primary_lv_feedback_enclosure_voltage_conversion_to_raw_struct(
    primary_lv_feedback_enclosure_voltage_t *raw,
    const primary_lv_feedback_enclosure_voltage_converted_t *conversion);


int primary_lv_feedback_enclosure_voltage_converted_to_string(primary_lv_feedback_enclosure_voltage_converted_t *message, char *buffer);

int primary_lv_feedback_enclosure_voltage_converted_to_string_file(primary_lv_feedback_enclosure_voltage_converted_t *message, FILE *buffer);

int primary_lv_feedback_enclosure_voltage_fields(char *buffer);

int primary_lv_feedback_enclosure_voltage_fields_file(FILE *buffer);

/**
 * Pack message LV_FEEDBACK_ENCLOSURE_VOLTAGE.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_lv_feedback_enclosure_voltage_pack(
    uint8_t *dst_p,
    const primary_lv_feedback_enclosure_voltage_t *src_p,
    size_t byte_size);

/**
 * Unpack message LV_FEEDBACK_ENCLOSURE_VOLTAGE.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_lv_feedback_enclosure_voltage_unpack(
    primary_lv_feedback_enclosure_voltage_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_lv_feedback_enclosure_voltage_lv_encl_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_lv_feedback_enclosure_voltage_lv_encl_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_feedback_enclosure_voltage_lv_encl_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_lv_feedback_enclosure_voltage_invc_lid_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_lv_feedback_enclosure_voltage_invc_lid_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_feedback_enclosure_voltage_invc_lid_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_lv_feedback_enclosure_voltage_hv_encl_2_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_lv_feedback_enclosure_voltage_hv_encl_2_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_feedback_enclosure_voltage_hv_encl_2_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_lv_feedback_enclosure_voltage_backplate_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_lv_feedback_enclosure_voltage_backplate_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_feedback_enclosure_voltage_backplate_is_in_range(uint16_t value);


void primary_lv_feedback_gpio_extender_raw_to_conversion(
    primary_lv_feedback_gpio_extender_converted_t *conversion,
    uint8_t feedback_inverters,
    uint8_t feedback_pcbs,
    uint8_t feedback_pumps,
    uint8_t feedback_radiators,
    uint8_t feedback_shutdown,
    uint8_t feedback_hv_fans,
    uint8_t feedback_autonomous_system_actuation,
    uint8_t feedback_rfe,
    uint8_t feedback_frg,
    uint8_t feedback_discharge
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_lv_feedback_gpio_extender_conversion_to_raw(
    primary_lv_feedback_gpio_extender_t *raw,
    uint8_t feedback_inverters,
    uint8_t feedback_pcbs,
    uint8_t feedback_pumps,
    uint8_t feedback_radiators,
    uint8_t feedback_shutdown,
    uint8_t feedback_hv_fans,
    uint8_t feedback_autonomous_system_actuation,
    uint8_t feedback_rfe,
    uint8_t feedback_frg,
    uint8_t feedback_discharge
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_lv_feedback_gpio_extender_raw_to_conversion_struct(
    primary_lv_feedback_gpio_extender_converted_t *conversion, 
    const primary_lv_feedback_gpio_extender_t *raw);


void primary_lv_feedback_gpio_extender_conversion_to_raw_struct(
    primary_lv_feedback_gpio_extender_t *raw,
    const primary_lv_feedback_gpio_extender_converted_t *conversion);


int primary_lv_feedback_gpio_extender_to_string(primary_lv_feedback_gpio_extender_t *message, char *buffer);

int primary_lv_feedback_gpio_extender_to_string_file(primary_lv_feedback_gpio_extender_t *message, FILE *buffer);

int primary_lv_feedback_gpio_extender_fields(char *buffer);

int primary_lv_feedback_gpio_extender_fields_file(FILE *buffer);

/**
 * Pack message LV_FEEDBACK_GPIO_EXTENDER.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_lv_feedback_gpio_extender_pack(
    uint8_t *dst_p,
    const primary_lv_feedback_gpio_extender_t *src_p,
    size_t byte_size);

/**
 * Unpack message LV_FEEDBACK_GPIO_EXTENDER.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_lv_feedback_gpio_extender_unpack(
    primary_lv_feedback_gpio_extender_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_feedback_gpio_extender_feedback_inverters_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_feedback_gpio_extender_feedback_pcbs_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_feedback_gpio_extender_feedback_pumps_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_feedback_gpio_extender_feedback_radiators_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_feedback_gpio_extender_feedback_shutdown_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_feedback_gpio_extender_feedback_hv_fans_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_feedback_gpio_extender_feedback_autonomous_system_actuation_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_feedback_gpio_extender_feedback_rfe_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_feedback_gpio_extender_feedback_frg_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_feedback_gpio_extender_feedback_discharge_is_in_range(uint8_t value);


;


;


void primary_lv_can_flash_req_tlm_raw_to_conversion_struct(
    primary_lv_can_flash_req_tlm_converted_t *conversion, 
    const primary_lv_can_flash_req_tlm_t *raw);


void primary_lv_can_flash_req_tlm_conversion_to_raw_struct(
    primary_lv_can_flash_req_tlm_t *raw,
    const primary_lv_can_flash_req_tlm_converted_t *conversion);


int primary_lv_can_flash_req_tlm_to_string(primary_lv_can_flash_req_tlm_t *message, char *buffer);

int primary_lv_can_flash_req_tlm_to_string_file(primary_lv_can_flash_req_tlm_t *message, FILE *buffer);

int primary_lv_can_flash_req_tlm_fields(char *buffer);

int primary_lv_can_flash_req_tlm_fields_file(FILE *buffer);

/**
 * Pack message LV_CAN_FLASH_REQ_TLM.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_lv_can_flash_req_tlm_pack(
    uint8_t *dst_p,
    const primary_lv_can_flash_req_tlm_t *src_p,
    size_t byte_size);

/**
 * Unpack message LV_CAN_FLASH_REQ_TLM.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_lv_can_flash_req_tlm_unpack(
    primary_lv_can_flash_req_tlm_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void primary_lv_can_flash_req_steering_wheel_raw_to_conversion_struct(
    primary_lv_can_flash_req_steering_wheel_converted_t *conversion, 
    const primary_lv_can_flash_req_steering_wheel_t *raw);


void primary_lv_can_flash_req_steering_wheel_conversion_to_raw_struct(
    primary_lv_can_flash_req_steering_wheel_t *raw,
    const primary_lv_can_flash_req_steering_wheel_converted_t *conversion);


int primary_lv_can_flash_req_steering_wheel_to_string(primary_lv_can_flash_req_steering_wheel_t *message, char *buffer);

int primary_lv_can_flash_req_steering_wheel_to_string_file(primary_lv_can_flash_req_steering_wheel_t *message, FILE *buffer);

int primary_lv_can_flash_req_steering_wheel_fields(char *buffer);

int primary_lv_can_flash_req_steering_wheel_fields_file(FILE *buffer);

/**
 * Pack message LV_CAN_FLASH_REQ_STEERING_WHEEL.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_lv_can_flash_req_steering_wheel_pack(
    uint8_t *dst_p,
    const primary_lv_can_flash_req_steering_wheel_t *src_p,
    size_t byte_size);

/**
 * Unpack message LV_CAN_FLASH_REQ_STEERING_WHEEL.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_lv_can_flash_req_steering_wheel_unpack(
    primary_lv_can_flash_req_steering_wheel_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void primary_lv_can_flash_ack_raw_to_conversion_struct(
    primary_lv_can_flash_ack_converted_t *conversion, 
    const primary_lv_can_flash_ack_t *raw);


void primary_lv_can_flash_ack_conversion_to_raw_struct(
    primary_lv_can_flash_ack_t *raw,
    const primary_lv_can_flash_ack_converted_t *conversion);


int primary_lv_can_flash_ack_to_string(primary_lv_can_flash_ack_t *message, char *buffer);

int primary_lv_can_flash_ack_to_string_file(primary_lv_can_flash_ack_t *message, FILE *buffer);

int primary_lv_can_flash_ack_fields(char *buffer);

int primary_lv_can_flash_ack_fields_file(FILE *buffer);

/**
 * Pack message LV_CAN_FLASH_ACK.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_lv_can_flash_ack_pack(
    uint8_t *dst_p,
    const primary_lv_can_flash_ack_t *src_p,
    size_t byte_size);

/**
 * Unpack message LV_CAN_FLASH_ACK.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_lv_can_flash_ack_unpack(
    primary_lv_can_flash_ack_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


void primary_lv_inverter_connection_status_raw_to_conversion(
    primary_lv_inverter_connection_status_converted_t *conversion,
    primary_lv_inverter_connection_status_status status
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_lv_inverter_connection_status_conversion_to_raw(
    primary_lv_inverter_connection_status_t *raw,
    primary_lv_inverter_connection_status_status status
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_lv_inverter_connection_status_raw_to_conversion_struct(
    primary_lv_inverter_connection_status_converted_t *conversion, 
    const primary_lv_inverter_connection_status_t *raw);


void primary_lv_inverter_connection_status_conversion_to_raw_struct(
    primary_lv_inverter_connection_status_t *raw,
    const primary_lv_inverter_connection_status_converted_t *conversion);

int primary_lv_inverter_connection_status_status_enum_to_string(primary_lv_inverter_connection_status_status value, char *buffer);

int primary_lv_inverter_connection_status_to_string(primary_lv_inverter_connection_status_t *message, char *buffer);

int primary_lv_inverter_connection_status_to_string_file(primary_lv_inverter_connection_status_t *message, FILE *buffer);

int primary_lv_inverter_connection_status_fields(char *buffer);

int primary_lv_inverter_connection_status_fields_file(FILE *buffer);

/**
 * Pack message LV_INVERTER_CONNECTION_STATUS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_lv_inverter_connection_status_pack(
    uint8_t *dst_p,
    const primary_lv_inverter_connection_status_t *src_p,
    size_t byte_size);

/**
 * Unpack message LV_INVERTER_CONNECTION_STATUS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_lv_inverter_connection_status_unpack(
    primary_lv_inverter_connection_status_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_inverter_connection_status_status_is_in_range(uint8_t value);


void primary_lv_set_inverter_connection_status_raw_to_conversion(
    primary_lv_set_inverter_connection_status_converted_t *conversion,
    primary_lv_set_inverter_connection_status_status status
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_lv_set_inverter_connection_status_conversion_to_raw(
    primary_lv_set_inverter_connection_status_t *raw,
    primary_lv_set_inverter_connection_status_status status
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_lv_set_inverter_connection_status_raw_to_conversion_struct(
    primary_lv_set_inverter_connection_status_converted_t *conversion, 
    const primary_lv_set_inverter_connection_status_t *raw);


void primary_lv_set_inverter_connection_status_conversion_to_raw_struct(
    primary_lv_set_inverter_connection_status_t *raw,
    const primary_lv_set_inverter_connection_status_converted_t *conversion);

int primary_lv_set_inverter_connection_status_status_enum_to_string(primary_lv_set_inverter_connection_status_status value, char *buffer);

int primary_lv_set_inverter_connection_status_to_string(primary_lv_set_inverter_connection_status_t *message, char *buffer);

int primary_lv_set_inverter_connection_status_to_string_file(primary_lv_set_inverter_connection_status_t *message, FILE *buffer);

int primary_lv_set_inverter_connection_status_fields(char *buffer);

int primary_lv_set_inverter_connection_status_fields_file(FILE *buffer);

/**
 * Pack message LV_SET_INVERTER_CONNECTION_STATUS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_lv_set_inverter_connection_status_pack(
    uint8_t *dst_p,
    const primary_lv_set_inverter_connection_status_t *src_p,
    size_t byte_size);

/**
 * Unpack message LV_SET_INVERTER_CONNECTION_STATUS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_lv_set_inverter_connection_status_unpack(
    primary_lv_set_inverter_connection_status_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_set_inverter_connection_status_status_is_in_range(uint8_t value);


void primary_tlm_status_raw_to_conversion(
    primary_tlm_status_converted_t *conversion,
    primary_tlm_status_status status
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_tlm_status_conversion_to_raw(
    primary_tlm_status_t *raw,
    primary_tlm_status_status status
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_tlm_status_raw_to_conversion_struct(
    primary_tlm_status_converted_t *conversion, 
    const primary_tlm_status_t *raw);


void primary_tlm_status_conversion_to_raw_struct(
    primary_tlm_status_t *raw,
    const primary_tlm_status_converted_t *conversion);

int primary_tlm_status_status_enum_to_string(primary_tlm_status_status value, char *buffer);

int primary_tlm_status_to_string(primary_tlm_status_t *message, char *buffer);

int primary_tlm_status_to_string_file(primary_tlm_status_t *message, FILE *buffer);

int primary_tlm_status_fields(char *buffer);

int primary_tlm_status_fields_file(FILE *buffer);

/**
 * Pack message TLM_STATUS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_tlm_status_pack(
    uint8_t *dst_p,
    const primary_tlm_status_t *src_p,
    size_t byte_size);

/**
 * Unpack message TLM_STATUS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_tlm_status_unpack(
    primary_tlm_status_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_tlm_status_status_is_in_range(uint8_t value);


void primary_tlm_set_status_raw_to_conversion(
    primary_tlm_set_status_converted_t *conversion,
    primary_tlm_set_status_status status
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_tlm_set_status_conversion_to_raw(
    primary_tlm_set_status_t *raw,
    primary_tlm_set_status_status status
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_tlm_set_status_raw_to_conversion_struct(
    primary_tlm_set_status_converted_t *conversion, 
    const primary_tlm_set_status_t *raw);


void primary_tlm_set_status_conversion_to_raw_struct(
    primary_tlm_set_status_t *raw,
    const primary_tlm_set_status_converted_t *conversion);

int primary_tlm_set_status_status_enum_to_string(primary_tlm_set_status_status value, char *buffer);

int primary_tlm_set_status_to_string(primary_tlm_set_status_t *message, char *buffer);

int primary_tlm_set_status_to_string_file(primary_tlm_set_status_t *message, FILE *buffer);

int primary_tlm_set_status_fields(char *buffer);

int primary_tlm_set_status_fields_file(FILE *buffer);

/**
 * Pack message TLM_SET_STATUS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_tlm_set_status_pack(
    uint8_t *dst_p,
    const primary_tlm_set_status_t *src_p,
    size_t byte_size);

/**
 * Unpack message TLM_SET_STATUS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_tlm_set_status_unpack(
    primary_tlm_set_status_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_tlm_set_status_status_is_in_range(uint8_t value);


void primary_handcart_status_raw_to_conversion(
    primary_handcart_status_converted_t *conversion,
    primary_handcart_status_connected connected
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_handcart_status_conversion_to_raw(
    primary_handcart_status_t *raw,
    primary_handcart_status_connected connected
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_handcart_status_raw_to_conversion_struct(
    primary_handcart_status_converted_t *conversion, 
    const primary_handcart_status_t *raw);


void primary_handcart_status_conversion_to_raw_struct(
    primary_handcart_status_t *raw,
    const primary_handcart_status_converted_t *conversion);

int primary_handcart_status_connected_enum_to_string(primary_handcart_status_connected value, char *buffer);

int primary_handcart_status_to_string(primary_handcart_status_t *message, char *buffer);

int primary_handcart_status_to_string_file(primary_handcart_status_t *message, FILE *buffer);

int primary_handcart_status_fields(char *buffer);

int primary_handcart_status_fields_file(FILE *buffer);

/**
 * Pack message HANDCART_STATUS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_handcart_status_pack(
    uint8_t *dst_p,
    const primary_handcart_status_t *src_p,
    size_t byte_size);

/**
 * Unpack message HANDCART_STATUS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_handcart_status_unpack(
    primary_handcart_status_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_handcart_status_connected_is_in_range(uint8_t value);


void primary_handcart_settings_raw_to_conversion(
    primary_handcart_settings_converted_t *conversion,
    float target_voltage,
    primary_handcart_settings_fans_override fans_override,
    float fans_speed,
    float acc_charge_current,
    float grid_max_current,
    primary_handcart_settings_status status
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_handcart_settings_conversion_to_raw(
    primary_handcart_settings_t *raw,
    float target_voltage,
    primary_handcart_settings_fans_override fans_override,
    float fans_speed,
    float acc_charge_current,
    float grid_max_current,
    primary_handcart_settings_status status
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_handcart_settings_raw_to_conversion_struct(
    primary_handcart_settings_converted_t *conversion, 
    const primary_handcart_settings_t *raw);


void primary_handcart_settings_conversion_to_raw_struct(
    primary_handcart_settings_t *raw,
    const primary_handcart_settings_converted_t *conversion);

int primary_handcart_settings_fans_override_enum_to_string(primary_handcart_settings_fans_override value, char *buffer);
int primary_handcart_settings_status_enum_to_string(primary_handcart_settings_status value, char *buffer);

int primary_handcart_settings_converted_to_string(primary_handcart_settings_converted_t *message, char *buffer);

int primary_handcart_settings_converted_to_string_file(primary_handcart_settings_converted_t *message, FILE *buffer);

int primary_handcart_settings_fields(char *buffer);

int primary_handcart_settings_fields_file(FILE *buffer);

/**
 * Pack message HANDCART_SETTINGS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_handcart_settings_pack(
    uint8_t *dst_p,
    const primary_handcart_settings_t *src_p,
    size_t byte_size);

/**
 * Unpack message HANDCART_SETTINGS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_handcart_settings_unpack(
    primary_handcart_settings_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t primary_handcart_settings_target_voltage_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_handcart_settings_target_voltage_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_handcart_settings_target_voltage_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_handcart_settings_fans_override_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t primary_handcart_settings_fans_speed_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_handcart_settings_fans_speed_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_handcart_settings_fans_speed_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t primary_handcart_settings_acc_charge_current_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_handcart_settings_acc_charge_current_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_handcart_settings_acc_charge_current_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t primary_handcart_settings_grid_max_current_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_handcart_settings_grid_max_current_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_handcart_settings_grid_max_current_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_handcart_settings_status_is_in_range(uint8_t value);


void primary_handcart_set_settings_raw_to_conversion(
    primary_handcart_set_settings_converted_t *conversion,
    float target_voltage,
    primary_handcart_set_settings_fans_override fans_override,
    float fans_speed,
    float acc_charge_current,
    float grid_max_current,
    primary_handcart_set_settings_status status
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_handcart_set_settings_conversion_to_raw(
    primary_handcart_set_settings_t *raw,
    float target_voltage,
    primary_handcart_set_settings_fans_override fans_override,
    float fans_speed,
    float acc_charge_current,
    float grid_max_current,
    primary_handcart_set_settings_status status
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_handcart_set_settings_raw_to_conversion_struct(
    primary_handcart_set_settings_converted_t *conversion, 
    const primary_handcart_set_settings_t *raw);


void primary_handcart_set_settings_conversion_to_raw_struct(
    primary_handcart_set_settings_t *raw,
    const primary_handcart_set_settings_converted_t *conversion);

int primary_handcart_set_settings_fans_override_enum_to_string(primary_handcart_set_settings_fans_override value, char *buffer);
int primary_handcart_set_settings_status_enum_to_string(primary_handcart_set_settings_status value, char *buffer);

int primary_handcart_set_settings_converted_to_string(primary_handcart_set_settings_converted_t *message, char *buffer);

int primary_handcart_set_settings_converted_to_string_file(primary_handcart_set_settings_converted_t *message, FILE *buffer);

int primary_handcart_set_settings_fields(char *buffer);

int primary_handcart_set_settings_fields_file(FILE *buffer);

/**
 * Pack message HANDCART_SET_SETTINGS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_handcart_set_settings_pack(
    uint8_t *dst_p,
    const primary_handcart_set_settings_t *src_p,
    size_t byte_size);

/**
 * Unpack message HANDCART_SET_SETTINGS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_handcart_set_settings_unpack(
    primary_handcart_set_settings_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t primary_handcart_set_settings_target_voltage_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_handcart_set_settings_target_voltage_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_handcart_set_settings_target_voltage_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_handcart_set_settings_fans_override_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t primary_handcart_set_settings_fans_speed_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_handcart_set_settings_fans_speed_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_handcart_set_settings_fans_speed_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t primary_handcart_set_settings_acc_charge_current_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_handcart_set_settings_acc_charge_current_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_handcart_set_settings_acc_charge_current_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t primary_handcart_set_settings_grid_max_current_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_handcart_set_settings_grid_max_current_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_handcart_set_settings_grid_max_current_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_handcart_set_settings_status_is_in_range(uint8_t value);


void primary_ecu_status_raw_to_conversion(
    primary_ecu_status_converted_t *conversion,
    primary_ecu_status_status status
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_ecu_status_conversion_to_raw(
    primary_ecu_status_t *raw,
    primary_ecu_status_status status
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_ecu_status_raw_to_conversion_struct(
    primary_ecu_status_converted_t *conversion, 
    const primary_ecu_status_t *raw);


void primary_ecu_status_conversion_to_raw_struct(
    primary_ecu_status_t *raw,
    const primary_ecu_status_converted_t *conversion);

int primary_ecu_status_status_enum_to_string(primary_ecu_status_status value, char *buffer);

int primary_ecu_status_to_string(primary_ecu_status_t *message, char *buffer);

int primary_ecu_status_to_string_file(primary_ecu_status_t *message, FILE *buffer);

int primary_ecu_status_fields(char *buffer);

int primary_ecu_status_fields_file(FILE *buffer);

/**
 * Pack message ECU_STATUS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_ecu_status_pack(
    uint8_t *dst_p,
    const primary_ecu_status_t *src_p,
    size_t byte_size);

/**
 * Unpack message ECU_STATUS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_ecu_status_unpack(
    primary_ecu_status_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_ecu_status_status_is_in_range(uint8_t value);


void primary_ecu_set_status_raw_to_conversion(
    primary_ecu_set_status_converted_t *conversion,
    primary_ecu_set_status_status status
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_ecu_set_status_conversion_to_raw(
    primary_ecu_set_status_t *raw,
    primary_ecu_set_status_status status
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_ecu_set_status_raw_to_conversion_struct(
    primary_ecu_set_status_converted_t *conversion, 
    const primary_ecu_set_status_t *raw);


void primary_ecu_set_status_conversion_to_raw_struct(
    primary_ecu_set_status_t *raw,
    const primary_ecu_set_status_converted_t *conversion);

int primary_ecu_set_status_status_enum_to_string(primary_ecu_set_status_status value, char *buffer);

int primary_ecu_set_status_to_string(primary_ecu_set_status_t *message, char *buffer);

int primary_ecu_set_status_to_string_file(primary_ecu_set_status_t *message, FILE *buffer);

int primary_ecu_set_status_fields(char *buffer);

int primary_ecu_set_status_fields_file(FILE *buffer);

/**
 * Pack message ECU_SET_STATUS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_ecu_set_status_pack(
    uint8_t *dst_p,
    const primary_ecu_set_status_t *src_p,
    size_t byte_size);

/**
 * Unpack message ECU_SET_STATUS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_ecu_set_status_unpack(
    primary_ecu_set_status_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_ecu_set_status_status_is_in_range(uint8_t value);


void primary_ecu_inverter_status_raw_to_conversion(
    primary_ecu_inverter_status_converted_t *conversion,
    primary_ecu_inverter_status_rl rl,
    primary_ecu_inverter_status_rr rr
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_ecu_inverter_status_conversion_to_raw(
    primary_ecu_inverter_status_t *raw,
    primary_ecu_inverter_status_rl rl,
    primary_ecu_inverter_status_rr rr
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_ecu_inverter_status_raw_to_conversion_struct(
    primary_ecu_inverter_status_converted_t *conversion, 
    const primary_ecu_inverter_status_t *raw);


void primary_ecu_inverter_status_conversion_to_raw_struct(
    primary_ecu_inverter_status_t *raw,
    const primary_ecu_inverter_status_converted_t *conversion);

int primary_ecu_inverter_status_rl_enum_to_string(primary_ecu_inverter_status_rl value, char *buffer);
int primary_ecu_inverter_status_rr_enum_to_string(primary_ecu_inverter_status_rr value, char *buffer);

int primary_ecu_inverter_status_to_string(primary_ecu_inverter_status_t *message, char *buffer);

int primary_ecu_inverter_status_to_string_file(primary_ecu_inverter_status_t *message, FILE *buffer);

int primary_ecu_inverter_status_fields(char *buffer);

int primary_ecu_inverter_status_fields_file(FILE *buffer);

/**
 * Pack message ECU_INVERTER_STATUS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_ecu_inverter_status_pack(
    uint8_t *dst_p,
    const primary_ecu_inverter_status_t *src_p,
    size_t byte_size);

/**
 * Unpack message ECU_INVERTER_STATUS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_ecu_inverter_status_unpack(
    primary_ecu_inverter_status_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_ecu_inverter_status_rl_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_ecu_inverter_status_rr_is_in_range(uint8_t value);


void primary_ecu_control_status_raw_to_conversion(
    primary_ecu_control_status_converted_t *conversion,
    uint8_t control_enabled,
    uint8_t control_errors_forced_off,
    uint8_t control_errors_wrong_maps,
    uint8_t control_errors_control_watchdog
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_ecu_control_status_conversion_to_raw(
    primary_ecu_control_status_t *raw,
    uint8_t control_enabled,
    uint8_t control_errors_forced_off,
    uint8_t control_errors_wrong_maps,
    uint8_t control_errors_control_watchdog
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_ecu_control_status_raw_to_conversion_struct(
    primary_ecu_control_status_converted_t *conversion, 
    const primary_ecu_control_status_t *raw);


void primary_ecu_control_status_conversion_to_raw_struct(
    primary_ecu_control_status_t *raw,
    const primary_ecu_control_status_converted_t *conversion);


int primary_ecu_control_status_to_string(primary_ecu_control_status_t *message, char *buffer);

int primary_ecu_control_status_to_string_file(primary_ecu_control_status_t *message, FILE *buffer);

int primary_ecu_control_status_fields(char *buffer);

int primary_ecu_control_status_fields_file(FILE *buffer);

/**
 * Pack message ECU_CONTROL_STATUS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_ecu_control_status_pack(
    uint8_t *dst_p,
    const primary_ecu_control_status_t *src_p,
    size_t byte_size);

/**
 * Unpack message ECU_CONTROL_STATUS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_ecu_control_status_unpack(
    primary_ecu_control_status_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_ecu_control_status_control_enabled_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_ecu_control_status_control_errors_forced_off_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_ecu_control_status_control_errors_wrong_maps_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_ecu_control_status_control_errors_control_watchdog_is_in_range(uint8_t value);


void primary_ecu_errors_raw_to_conversion(
    primary_ecu_errors_converted_t *conversion,
    uint8_t error_pedal_adc,
    uint8_t error_pedal_implausibility,
    uint8_t error_imu_tout,
    uint8_t error_irts_tout,
    uint8_t error_ts_tout,
    uint8_t error_invl_tout,
    uint8_t error_invr_tout,
    uint8_t error_steer_tout,
    uint8_t error_fsm
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_ecu_errors_conversion_to_raw(
    primary_ecu_errors_t *raw,
    uint8_t error_pedal_adc,
    uint8_t error_pedal_implausibility,
    uint8_t error_imu_tout,
    uint8_t error_irts_tout,
    uint8_t error_ts_tout,
    uint8_t error_invl_tout,
    uint8_t error_invr_tout,
    uint8_t error_steer_tout,
    uint8_t error_fsm
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_ecu_errors_raw_to_conversion_struct(
    primary_ecu_errors_converted_t *conversion, 
    const primary_ecu_errors_t *raw);


void primary_ecu_errors_conversion_to_raw_struct(
    primary_ecu_errors_t *raw,
    const primary_ecu_errors_converted_t *conversion);


int primary_ecu_errors_to_string(primary_ecu_errors_t *message, char *buffer);

int primary_ecu_errors_to_string_file(primary_ecu_errors_t *message, FILE *buffer);

int primary_ecu_errors_fields(char *buffer);

int primary_ecu_errors_fields_file(FILE *buffer);

/**
 * Pack message ECU_ERRORS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_ecu_errors_pack(
    uint8_t *dst_p,
    const primary_ecu_errors_t *src_p,
    size_t byte_size);

/**
 * Unpack message ECU_ERRORS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_ecu_errors_unpack(
    primary_ecu_errors_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_ecu_errors_error_pedal_adc_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_ecu_errors_error_pedal_implausibility_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_ecu_errors_error_imu_tout_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_ecu_errors_error_irts_tout_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_ecu_errors_error_ts_tout_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_ecu_errors_error_invl_tout_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_ecu_errors_error_invr_tout_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_ecu_errors_error_steer_tout_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_ecu_errors_error_fsm_is_in_range(uint8_t value);


void primary_ecu_feedbacks_raw_to_conversion(
    primary_ecu_feedbacks_converted_t *conversion,
    uint8_t feedbacks_sd_cock_fb,
    uint8_t feedbacks_sd_fb1,
    uint8_t feedbacks_sd_bots_fb,
    uint8_t feedbacks_sd_interial_fb,
    uint8_t feedbacks_sd_fb4,
    uint8_t feedbacks_sd_in,
    uint8_t feedbacks_sd_out,
    uint8_t feedbacks_sd_ctrl_pin
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_ecu_feedbacks_conversion_to_raw(
    primary_ecu_feedbacks_t *raw,
    uint8_t feedbacks_sd_cock_fb,
    uint8_t feedbacks_sd_fb1,
    uint8_t feedbacks_sd_bots_fb,
    uint8_t feedbacks_sd_interial_fb,
    uint8_t feedbacks_sd_fb4,
    uint8_t feedbacks_sd_in,
    uint8_t feedbacks_sd_out,
    uint8_t feedbacks_sd_ctrl_pin
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_ecu_feedbacks_raw_to_conversion_struct(
    primary_ecu_feedbacks_converted_t *conversion, 
    const primary_ecu_feedbacks_t *raw);


void primary_ecu_feedbacks_conversion_to_raw_struct(
    primary_ecu_feedbacks_t *raw,
    const primary_ecu_feedbacks_converted_t *conversion);


int primary_ecu_feedbacks_to_string(primary_ecu_feedbacks_t *message, char *buffer);

int primary_ecu_feedbacks_to_string_file(primary_ecu_feedbacks_t *message, FILE *buffer);

int primary_ecu_feedbacks_fields(char *buffer);

int primary_ecu_feedbacks_fields_file(FILE *buffer);

/**
 * Pack message ECU_FEEDBACKS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_ecu_feedbacks_pack(
    uint8_t *dst_p,
    const primary_ecu_feedbacks_t *src_p,
    size_t byte_size);

/**
 * Unpack message ECU_FEEDBACKS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_ecu_feedbacks_unpack(
    primary_ecu_feedbacks_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_ecu_feedbacks_feedbacks_sd_cock_fb_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_ecu_feedbacks_feedbacks_sd_fb1_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_ecu_feedbacks_feedbacks_sd_bots_fb_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_ecu_feedbacks_feedbacks_sd_interial_fb_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_ecu_feedbacks_feedbacks_sd_fb4_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_ecu_feedbacks_feedbacks_sd_in_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_ecu_feedbacks_feedbacks_sd_out_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_ecu_feedbacks_feedbacks_sd_ctrl_pin_is_in_range(uint8_t value);


void primary_ecu_power_maps_raw_to_conversion(
    primary_ecu_power_maps_converted_t *conversion,
    float map_pw,
    float map_sc,
    float map_tv
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_ecu_power_maps_conversion_to_raw(
    primary_ecu_power_maps_t *raw,
    float map_pw,
    float map_sc,
    float map_tv
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_ecu_power_maps_raw_to_conversion_struct(
    primary_ecu_power_maps_converted_t *conversion, 
    const primary_ecu_power_maps_t *raw);


void primary_ecu_power_maps_conversion_to_raw_struct(
    primary_ecu_power_maps_t *raw,
    const primary_ecu_power_maps_converted_t *conversion);


int primary_ecu_power_maps_converted_to_string(primary_ecu_power_maps_converted_t *message, char *buffer);

int primary_ecu_power_maps_converted_to_string_file(primary_ecu_power_maps_converted_t *message, FILE *buffer);

int primary_ecu_power_maps_fields(char *buffer);

int primary_ecu_power_maps_fields_file(FILE *buffer);

/**
 * Pack message ECU_POWER_MAPS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_ecu_power_maps_pack(
    uint8_t *dst_p,
    const primary_ecu_power_maps_t *src_p,
    size_t byte_size);

/**
 * Unpack message ECU_POWER_MAPS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_ecu_power_maps_unpack(
    primary_ecu_power_maps_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t primary_ecu_power_maps_map_pw_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_ecu_power_maps_map_pw_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_ecu_power_maps_map_pw_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t primary_ecu_power_maps_map_sc_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_ecu_power_maps_map_sc_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_ecu_power_maps_map_sc_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t primary_ecu_power_maps_map_tv_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_ecu_power_maps_map_tv_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_ecu_power_maps_map_tv_is_in_range(uint8_t value);


void primary_ecu_set_power_maps_raw_to_conversion(
    primary_ecu_set_power_maps_converted_t *conversion,
    float map_pw,
    float map_sc,
    float map_tv
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_ecu_set_power_maps_conversion_to_raw(
    primary_ecu_set_power_maps_t *raw,
    float map_pw,
    float map_sc,
    float map_tv
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_ecu_set_power_maps_raw_to_conversion_struct(
    primary_ecu_set_power_maps_converted_t *conversion, 
    const primary_ecu_set_power_maps_t *raw);


void primary_ecu_set_power_maps_conversion_to_raw_struct(
    primary_ecu_set_power_maps_t *raw,
    const primary_ecu_set_power_maps_converted_t *conversion);


int primary_ecu_set_power_maps_converted_to_string(primary_ecu_set_power_maps_converted_t *message, char *buffer);

int primary_ecu_set_power_maps_converted_to_string_file(primary_ecu_set_power_maps_converted_t *message, FILE *buffer);

int primary_ecu_set_power_maps_fields(char *buffer);

int primary_ecu_set_power_maps_fields_file(FILE *buffer);

/**
 * Pack message ECU_SET_POWER_MAPS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_ecu_set_power_maps_pack(
    uint8_t *dst_p,
    const primary_ecu_set_power_maps_t *src_p,
    size_t byte_size);

/**
 * Unpack message ECU_SET_POWER_MAPS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_ecu_set_power_maps_unpack(
    primary_ecu_set_power_maps_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t primary_ecu_set_power_maps_map_pw_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_ecu_set_power_maps_map_pw_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_ecu_set_power_maps_map_pw_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t primary_ecu_set_power_maps_map_sc_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_ecu_set_power_maps_map_sc_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_ecu_set_power_maps_map_sc_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t primary_ecu_set_power_maps_map_tv_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_ecu_set_power_maps_map_tv_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_ecu_set_power_maps_map_tv_is_in_range(uint8_t value);


void primary_ecu_ptt_status_raw_to_conversion(
    primary_ecu_ptt_status_converted_t *conversion,
    primary_ecu_ptt_status_status status
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_ecu_ptt_status_conversion_to_raw(
    primary_ecu_ptt_status_t *raw,
    primary_ecu_ptt_status_status status
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_ecu_ptt_status_raw_to_conversion_struct(
    primary_ecu_ptt_status_converted_t *conversion, 
    const primary_ecu_ptt_status_t *raw);


void primary_ecu_ptt_status_conversion_to_raw_struct(
    primary_ecu_ptt_status_t *raw,
    const primary_ecu_ptt_status_converted_t *conversion);

int primary_ecu_ptt_status_status_enum_to_string(primary_ecu_ptt_status_status value, char *buffer);

int primary_ecu_ptt_status_to_string(primary_ecu_ptt_status_t *message, char *buffer);

int primary_ecu_ptt_status_to_string_file(primary_ecu_ptt_status_t *message, FILE *buffer);

int primary_ecu_ptt_status_fields(char *buffer);

int primary_ecu_ptt_status_fields_file(FILE *buffer);

/**
 * Pack message ECU_PTT_STATUS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_ecu_ptt_status_pack(
    uint8_t *dst_p,
    const primary_ecu_ptt_status_t *src_p,
    size_t byte_size);

/**
 * Unpack message ECU_PTT_STATUS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_ecu_ptt_status_unpack(
    primary_ecu_ptt_status_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_ecu_ptt_status_status_is_in_range(uint8_t value);


void primary_ecu_set_ptt_status_raw_to_conversion(
    primary_ecu_set_ptt_status_converted_t *conversion,
    primary_ecu_set_ptt_status_status status
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_ecu_set_ptt_status_conversion_to_raw(
    primary_ecu_set_ptt_status_t *raw,
    primary_ecu_set_ptt_status_status status
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_ecu_set_ptt_status_raw_to_conversion_struct(
    primary_ecu_set_ptt_status_converted_t *conversion, 
    const primary_ecu_set_ptt_status_t *raw);


void primary_ecu_set_ptt_status_conversion_to_raw_struct(
    primary_ecu_set_ptt_status_t *raw,
    const primary_ecu_set_ptt_status_converted_t *conversion);

int primary_ecu_set_ptt_status_status_enum_to_string(primary_ecu_set_ptt_status_status value, char *buffer);

int primary_ecu_set_ptt_status_to_string(primary_ecu_set_ptt_status_t *message, char *buffer);

int primary_ecu_set_ptt_status_to_string_file(primary_ecu_set_ptt_status_t *message, FILE *buffer);

int primary_ecu_set_ptt_status_fields(char *buffer);

int primary_ecu_set_ptt_status_fields_file(FILE *buffer);

/**
 * Pack message ECU_SET_PTT_STATUS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_ecu_set_ptt_status_pack(
    uint8_t *dst_p,
    const primary_ecu_set_ptt_status_t *src_p,
    size_t byte_size);

/**
 * Unpack message ECU_SET_PTT_STATUS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_ecu_set_ptt_status_unpack(
    primary_ecu_set_ptt_status_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_ecu_set_ptt_status_status_is_in_range(uint8_t value);


void primary_inv_l_request_raw_to_conversion(
    primary_inv_l_request_converted_t *conversion,
    uint8_t data_0,
    uint8_t data_1,
    uint8_t data_2,
    uint8_t data_3,
    uint8_t data_4,
    uint8_t data_5,
    uint8_t data_6,
    uint8_t data_7
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_inv_l_request_conversion_to_raw(
    primary_inv_l_request_t *raw,
    uint8_t data_0,
    uint8_t data_1,
    uint8_t data_2,
    uint8_t data_3,
    uint8_t data_4,
    uint8_t data_5,
    uint8_t data_6,
    uint8_t data_7
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_inv_l_request_raw_to_conversion_struct(
    primary_inv_l_request_converted_t *conversion, 
    const primary_inv_l_request_t *raw);


void primary_inv_l_request_conversion_to_raw_struct(
    primary_inv_l_request_t *raw,
    const primary_inv_l_request_converted_t *conversion);


int primary_inv_l_request_to_string(primary_inv_l_request_t *message, char *buffer);

int primary_inv_l_request_to_string_file(primary_inv_l_request_t *message, FILE *buffer);

int primary_inv_l_request_fields(char *buffer);

int primary_inv_l_request_fields_file(FILE *buffer);

/**
 * Pack message INV_L_REQUEST.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_inv_l_request_pack(
    uint8_t *dst_p,
    const primary_inv_l_request_t *src_p,
    size_t byte_size);

/**
 * Unpack message INV_L_REQUEST.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_inv_l_request_unpack(
    primary_inv_l_request_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inv_l_request_data_0_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inv_l_request_data_1_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inv_l_request_data_2_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inv_l_request_data_3_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inv_l_request_data_4_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inv_l_request_data_5_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inv_l_request_data_6_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inv_l_request_data_7_is_in_range(uint8_t value);


void primary_control_output_raw_to_conversion(
    primary_control_output_converted_t *conversion,
    float estimated_velocity,
    float torque_max_l,
    float torque_max_r,
    float torque_l,
    float torque_r
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_control_output_conversion_to_raw(
    primary_control_output_t *raw,
    float estimated_velocity,
    float torque_max_l,
    float torque_max_r,
    float torque_l,
    float torque_r
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_control_output_raw_to_conversion_struct(
    primary_control_output_converted_t *conversion, 
    const primary_control_output_t *raw);


void primary_control_output_conversion_to_raw_struct(
    primary_control_output_t *raw,
    const primary_control_output_converted_t *conversion);


int primary_control_output_converted_to_string(primary_control_output_converted_t *message, char *buffer);

int primary_control_output_converted_to_string_file(primary_control_output_converted_t *message, FILE *buffer);

int primary_control_output_fields(char *buffer);

int primary_control_output_fields_file(FILE *buffer);

/**
 * Pack message CONTROL_OUTPUT.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_control_output_pack(
    uint8_t *dst_p,
    const primary_control_output_t *src_p,
    size_t byte_size);

/**
 * Unpack message CONTROL_OUTPUT.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_control_output_unpack(
    primary_control_output_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_control_output_estimated_velocity_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_control_output_estimated_velocity_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_control_output_estimated_velocity_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t primary_control_output_torque_max_l_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_control_output_torque_max_l_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_control_output_torque_max_l_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t primary_control_output_torque_max_r_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_control_output_torque_max_r_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_control_output_torque_max_r_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_control_output_torque_l_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_control_output_torque_l_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_control_output_torque_l_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_control_output_torque_r_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_control_output_torque_r_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_control_output_torque_r_is_in_range(uint16_t value);


void primary_control_status_raw_to_conversion(
    primary_control_status_converted_t *conversion,
    float map_pw,
    float map_sc,
    float map_tv
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_control_status_conversion_to_raw(
    primary_control_status_t *raw,
    float map_pw,
    float map_sc,
    float map_tv
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_control_status_raw_to_conversion_struct(
    primary_control_status_converted_t *conversion, 
    const primary_control_status_t *raw);


void primary_control_status_conversion_to_raw_struct(
    primary_control_status_t *raw,
    const primary_control_status_converted_t *conversion);


int primary_control_status_converted_to_string(primary_control_status_converted_t *message, char *buffer);

int primary_control_status_converted_to_string_file(primary_control_status_converted_t *message, FILE *buffer);

int primary_control_status_fields(char *buffer);

int primary_control_status_fields_file(FILE *buffer);

/**
 * Pack message CONTROL_STATUS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_control_status_pack(
    uint8_t *dst_p,
    const primary_control_status_t *src_p,
    size_t byte_size);

/**
 * Unpack message CONTROL_STATUS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_control_status_unpack(
    primary_control_status_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t primary_control_status_map_pw_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_control_status_map_pw_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_control_status_map_pw_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t primary_control_status_map_sc_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_control_status_map_sc_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_control_status_map_sc_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t primary_control_status_map_tv_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_control_status_map_tv_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_control_status_map_tv_is_in_range(uint8_t value);


void primary_inv_r_request_raw_to_conversion(
    primary_inv_r_request_converted_t *conversion,
    uint8_t data_0,
    uint8_t data_1,
    uint8_t data_2,
    uint8_t data_3,
    uint8_t data_4,
    uint8_t data_5,
    uint8_t data_6,
    uint8_t data_7
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_inv_r_request_conversion_to_raw(
    primary_inv_r_request_t *raw,
    uint8_t data_0,
    uint8_t data_1,
    uint8_t data_2,
    uint8_t data_3,
    uint8_t data_4,
    uint8_t data_5,
    uint8_t data_6,
    uint8_t data_7
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_inv_r_request_raw_to_conversion_struct(
    primary_inv_r_request_converted_t *conversion, 
    const primary_inv_r_request_t *raw);


void primary_inv_r_request_conversion_to_raw_struct(
    primary_inv_r_request_t *raw,
    const primary_inv_r_request_converted_t *conversion);


int primary_inv_r_request_to_string(primary_inv_r_request_t *message, char *buffer);

int primary_inv_r_request_to_string_file(primary_inv_r_request_t *message, FILE *buffer);

int primary_inv_r_request_fields(char *buffer);

int primary_inv_r_request_fields_file(FILE *buffer);

/**
 * Pack message INV_R_REQUEST.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_inv_r_request_pack(
    uint8_t *dst_p,
    const primary_inv_r_request_t *src_p,
    size_t byte_size);

/**
 * Unpack message INV_R_REQUEST.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_inv_r_request_unpack(
    primary_inv_r_request_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inv_r_request_data_0_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inv_r_request_data_1_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inv_r_request_data_2_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inv_r_request_data_3_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inv_r_request_data_4_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inv_r_request_data_5_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inv_r_request_data_6_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inv_r_request_data_7_is_in_range(uint8_t value);


void primary_inv_l_response_raw_to_conversion(
    primary_inv_l_response_converted_t *conversion,
    uint8_t reg_id,
    uint8_t data_0,
    uint8_t data_1,
    uint8_t data_2,
    uint8_t data_3,
    uint8_t data_4,
    uint8_t data_5,
    uint8_t data_6
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_inv_l_response_conversion_to_raw(
    primary_inv_l_response_t *raw,
    uint8_t reg_id,
    uint8_t data_0,
    uint8_t data_1,
    uint8_t data_2,
    uint8_t data_3,
    uint8_t data_4,
    uint8_t data_5,
    uint8_t data_6
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_inv_l_response_raw_to_conversion_struct(
    primary_inv_l_response_converted_t *conversion, 
    const primary_inv_l_response_t *raw);


void primary_inv_l_response_conversion_to_raw_struct(
    primary_inv_l_response_t *raw,
    const primary_inv_l_response_converted_t *conversion);


int primary_inv_l_response_to_string(primary_inv_l_response_t *message, char *buffer);

int primary_inv_l_response_to_string_file(primary_inv_l_response_t *message, FILE *buffer);

int primary_inv_l_response_fields(char *buffer);

int primary_inv_l_response_fields_file(FILE *buffer);

/**
 * Pack message INV_L_RESPONSE.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_inv_l_response_pack(
    uint8_t *dst_p,
    const primary_inv_l_response_t *src_p,
    size_t byte_size);

/**
 * Unpack message INV_L_RESPONSE.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_inv_l_response_unpack(
    primary_inv_l_response_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inv_l_response_reg_id_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inv_l_response_data_0_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inv_l_response_data_1_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inv_l_response_data_2_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inv_l_response_data_3_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inv_l_response_data_4_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inv_l_response_data_5_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inv_l_response_data_6_is_in_range(uint8_t value);


void primary_inv_r_response_raw_to_conversion(
    primary_inv_r_response_converted_t *conversion,
    uint8_t reg_id,
    uint8_t data_0,
    uint8_t data_1,
    uint8_t data_2,
    uint8_t data_3,
    uint8_t data_4,
    uint8_t data_5,
    uint8_t data_6
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_inv_r_response_conversion_to_raw(
    primary_inv_r_response_t *raw,
    uint8_t reg_id,
    uint8_t data_0,
    uint8_t data_1,
    uint8_t data_2,
    uint8_t data_3,
    uint8_t data_4,
    uint8_t data_5,
    uint8_t data_6
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_inv_r_response_raw_to_conversion_struct(
    primary_inv_r_response_converted_t *conversion, 
    const primary_inv_r_response_t *raw);


void primary_inv_r_response_conversion_to_raw_struct(
    primary_inv_r_response_t *raw,
    const primary_inv_r_response_converted_t *conversion);


int primary_inv_r_response_to_string(primary_inv_r_response_t *message, char *buffer);

int primary_inv_r_response_to_string_file(primary_inv_r_response_t *message, FILE *buffer);

int primary_inv_r_response_fields(char *buffer);

int primary_inv_r_response_fields_file(FILE *buffer);

/**
 * Pack message INV_R_RESPONSE.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_inv_r_response_pack(
    uint8_t *dst_p,
    const primary_inv_r_response_t *src_p,
    size_t byte_size);

/**
 * Unpack message INV_R_RESPONSE.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_inv_r_response_unpack(
    primary_inv_r_response_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inv_r_response_reg_id_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inv_r_response_data_0_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inv_r_response_data_1_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inv_r_response_data_2_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inv_r_response_data_3_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inv_r_response_data_4_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inv_r_response_data_5_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inv_r_response_data_6_is_in_range(uint8_t value);


void primary_lv_current_battery_raw_to_conversion(
    primary_lv_current_battery_converted_t *conversion,
    float lv_current
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_lv_current_battery_conversion_to_raw(
    primary_lv_current_battery_t *raw,
    float lv_current
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_lv_current_battery_raw_to_conversion_struct(
    primary_lv_current_battery_converted_t *conversion, 
    const primary_lv_current_battery_t *raw);


void primary_lv_current_battery_conversion_to_raw_struct(
    primary_lv_current_battery_t *raw,
    const primary_lv_current_battery_converted_t *conversion);


int primary_lv_current_battery_converted_to_string(primary_lv_current_battery_converted_t *message, char *buffer);

int primary_lv_current_battery_converted_to_string_file(primary_lv_current_battery_converted_t *message, FILE *buffer);

int primary_lv_current_battery_fields(char *buffer);

int primary_lv_current_battery_fields_file(FILE *buffer);

/**
 * Pack message LV_CURRENT_BATTERY.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_lv_current_battery_pack(
    uint8_t *dst_p,
    const primary_lv_current_battery_t *src_p,
    size_t byte_size);

/**
 * Unpack message LV_CURRENT_BATTERY.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_lv_current_battery_unpack(
    primary_lv_current_battery_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_lv_current_battery_lv_current_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_lv_current_battery_lv_current_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_current_battery_lv_current_is_in_range(uint16_t value);


void primary_lv_current_charger_raw_to_conversion(
    primary_lv_current_charger_converted_t *conversion,
    float charger_current
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_lv_current_charger_conversion_to_raw(
    primary_lv_current_charger_t *raw,
    float charger_current
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_lv_current_charger_raw_to_conversion_struct(
    primary_lv_current_charger_converted_t *conversion, 
    const primary_lv_current_charger_t *raw);


void primary_lv_current_charger_conversion_to_raw_struct(
    primary_lv_current_charger_t *raw,
    const primary_lv_current_charger_converted_t *conversion);


int primary_lv_current_charger_converted_to_string(primary_lv_current_charger_converted_t *message, char *buffer);

int primary_lv_current_charger_converted_to_string_file(primary_lv_current_charger_converted_t *message, FILE *buffer);

int primary_lv_current_charger_fields(char *buffer);

int primary_lv_current_charger_fields_file(FILE *buffer);

/**
 * Pack message LV_CURRENT_CHARGER.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_lv_current_charger_pack(
    uint8_t *dst_p,
    const primary_lv_current_charger_t *src_p,
    size_t byte_size);

/**
 * Unpack message LV_CURRENT_CHARGER.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_lv_current_charger_unpack(
    primary_lv_current_charger_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_lv_current_charger_charger_current_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_lv_current_charger_charger_current_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_current_charger_charger_current_is_in_range(uint16_t value);


void primary_lv_total_voltage_raw_to_conversion(
    primary_lv_total_voltage_converted_t *conversion,
    float total
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_lv_total_voltage_conversion_to_raw(
    primary_lv_total_voltage_t *raw,
    float total
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_lv_total_voltage_raw_to_conversion_struct(
    primary_lv_total_voltage_converted_t *conversion, 
    const primary_lv_total_voltage_t *raw);


void primary_lv_total_voltage_conversion_to_raw_struct(
    primary_lv_total_voltage_t *raw,
    const primary_lv_total_voltage_converted_t *conversion);


int primary_lv_total_voltage_converted_to_string(primary_lv_total_voltage_converted_t *message, char *buffer);

int primary_lv_total_voltage_converted_to_string_file(primary_lv_total_voltage_converted_t *message, FILE *buffer);

int primary_lv_total_voltage_fields(char *buffer);

int primary_lv_total_voltage_fields_file(FILE *buffer);

/**
 * Pack message LV_TOTAL_VOLTAGE.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_lv_total_voltage_pack(
    uint8_t *dst_p,
    const primary_lv_total_voltage_t *src_p,
    size_t byte_size);

/**
 * Unpack message LV_TOTAL_VOLTAGE.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_lv_total_voltage_unpack(
    primary_lv_total_voltage_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t primary_lv_total_voltage_total_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_lv_total_voltage_total_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_total_voltage_total_is_in_range(uint32_t value);


void primary_lv_cells_voltage_raw_to_conversion(
    primary_lv_cells_voltage_converted_t *conversion,
    uint8_t start_index,
    float voltage_0,
    float voltage_1,
    float voltage_2
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_lv_cells_voltage_conversion_to_raw(
    primary_lv_cells_voltage_t *raw,
    uint8_t start_index,
    float voltage_0,
    float voltage_1,
    float voltage_2
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_lv_cells_voltage_raw_to_conversion_struct(
    primary_lv_cells_voltage_converted_t *conversion, 
    const primary_lv_cells_voltage_t *raw);


void primary_lv_cells_voltage_conversion_to_raw_struct(
    primary_lv_cells_voltage_t *raw,
    const primary_lv_cells_voltage_converted_t *conversion);


int primary_lv_cells_voltage_converted_to_string(primary_lv_cells_voltage_converted_t *message, char *buffer);

int primary_lv_cells_voltage_converted_to_string_file(primary_lv_cells_voltage_converted_t *message, FILE *buffer);

int primary_lv_cells_voltage_fields(char *buffer);

int primary_lv_cells_voltage_fields_file(FILE *buffer);

/**
 * Pack message LV_CELLS_VOLTAGE.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_lv_cells_voltage_pack(
    uint8_t *dst_p,
    const primary_lv_cells_voltage_t *src_p,
    size_t byte_size);

/**
 * Unpack message LV_CELLS_VOLTAGE.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_lv_cells_voltage_unpack(
    primary_lv_cells_voltage_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_cells_voltage_start_index_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_lv_cells_voltage_voltage_0_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_lv_cells_voltage_voltage_0_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_cells_voltage_voltage_0_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_lv_cells_voltage_voltage_1_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_lv_cells_voltage_voltage_1_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_cells_voltage_voltage_1_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_lv_cells_voltage_voltage_2_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_lv_cells_voltage_voltage_2_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_cells_voltage_voltage_2_is_in_range(uint16_t value);


void primary_lv_cells_voltage_stats_raw_to_conversion(
    primary_lv_cells_voltage_stats_converted_t *conversion,
    float max,
    float min,
    float delta,
    float avg
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_lv_cells_voltage_stats_conversion_to_raw(
    primary_lv_cells_voltage_stats_t *raw,
    float max,
    float min,
    float delta,
    float avg
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_lv_cells_voltage_stats_raw_to_conversion_struct(
    primary_lv_cells_voltage_stats_converted_t *conversion, 
    const primary_lv_cells_voltage_stats_t *raw);


void primary_lv_cells_voltage_stats_conversion_to_raw_struct(
    primary_lv_cells_voltage_stats_t *raw,
    const primary_lv_cells_voltage_stats_converted_t *conversion);


int primary_lv_cells_voltage_stats_converted_to_string(primary_lv_cells_voltage_stats_converted_t *message, char *buffer);

int primary_lv_cells_voltage_stats_converted_to_string_file(primary_lv_cells_voltage_stats_converted_t *message, FILE *buffer);

int primary_lv_cells_voltage_stats_fields(char *buffer);

int primary_lv_cells_voltage_stats_fields_file(FILE *buffer);

/**
 * Pack message LV_CELLS_VOLTAGE_STATS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_lv_cells_voltage_stats_pack(
    uint8_t *dst_p,
    const primary_lv_cells_voltage_stats_t *src_p,
    size_t byte_size);

/**
 * Unpack message LV_CELLS_VOLTAGE_STATS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_lv_cells_voltage_stats_unpack(
    primary_lv_cells_voltage_stats_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_lv_cells_voltage_stats_max_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_lv_cells_voltage_stats_max_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_cells_voltage_stats_max_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_lv_cells_voltage_stats_min_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_lv_cells_voltage_stats_min_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_cells_voltage_stats_min_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_lv_cells_voltage_stats_delta_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_lv_cells_voltage_stats_delta_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_cells_voltage_stats_delta_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_lv_cells_voltage_stats_avg_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_lv_cells_voltage_stats_avg_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_cells_voltage_stats_avg_is_in_range(uint16_t value);


void primary_lv_cells_temp_raw_to_conversion(
    primary_lv_cells_temp_converted_t *conversion,
    uint8_t start_index,
    float temp_0,
    float temp_1,
    float temp_2
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_lv_cells_temp_conversion_to_raw(
    primary_lv_cells_temp_t *raw,
    uint8_t start_index,
    float temp_0,
    float temp_1,
    float temp_2
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_lv_cells_temp_raw_to_conversion_struct(
    primary_lv_cells_temp_converted_t *conversion, 
    const primary_lv_cells_temp_t *raw);


void primary_lv_cells_temp_conversion_to_raw_struct(
    primary_lv_cells_temp_t *raw,
    const primary_lv_cells_temp_converted_t *conversion);


int primary_lv_cells_temp_converted_to_string(primary_lv_cells_temp_converted_t *message, char *buffer);

int primary_lv_cells_temp_converted_to_string_file(primary_lv_cells_temp_converted_t *message, FILE *buffer);

int primary_lv_cells_temp_fields(char *buffer);

int primary_lv_cells_temp_fields_file(FILE *buffer);

/**
 * Pack message LV_CELLS_TEMP.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_lv_cells_temp_pack(
    uint8_t *dst_p,
    const primary_lv_cells_temp_t *src_p,
    size_t byte_size);

/**
 * Unpack message LV_CELLS_TEMP.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_lv_cells_temp_unpack(
    primary_lv_cells_temp_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_cells_temp_start_index_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_lv_cells_temp_temp_0_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_lv_cells_temp_temp_0_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_cells_temp_temp_0_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_lv_cells_temp_temp_1_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_lv_cells_temp_temp_1_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_cells_temp_temp_1_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_lv_cells_temp_temp_2_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_lv_cells_temp_temp_2_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_cells_temp_temp_2_is_in_range(uint16_t value);


void primary_lv_cells_temp_stats_raw_to_conversion(
    primary_lv_cells_temp_stats_converted_t *conversion,
    float max,
    float min,
    float avg
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_lv_cells_temp_stats_conversion_to_raw(
    primary_lv_cells_temp_stats_t *raw,
    float max,
    float min,
    float avg
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_lv_cells_temp_stats_raw_to_conversion_struct(
    primary_lv_cells_temp_stats_converted_t *conversion, 
    const primary_lv_cells_temp_stats_t *raw);


void primary_lv_cells_temp_stats_conversion_to_raw_struct(
    primary_lv_cells_temp_stats_t *raw,
    const primary_lv_cells_temp_stats_converted_t *conversion);


int primary_lv_cells_temp_stats_converted_to_string(primary_lv_cells_temp_stats_converted_t *message, char *buffer);

int primary_lv_cells_temp_stats_converted_to_string_file(primary_lv_cells_temp_stats_converted_t *message, FILE *buffer);

int primary_lv_cells_temp_stats_fields(char *buffer);

int primary_lv_cells_temp_stats_fields_file(FILE *buffer);

/**
 * Pack message LV_CELLS_TEMP_STATS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_lv_cells_temp_stats_pack(
    uint8_t *dst_p,
    const primary_lv_cells_temp_stats_t *src_p,
    size_t byte_size);

/**
 * Unpack message LV_CELLS_TEMP_STATS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_lv_cells_temp_stats_unpack(
    primary_lv_cells_temp_stats_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_lv_cells_temp_stats_max_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_lv_cells_temp_stats_max_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_cells_temp_stats_max_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_lv_cells_temp_stats_min_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_lv_cells_temp_stats_min_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_cells_temp_stats_min_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_lv_cells_temp_stats_avg_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_lv_cells_temp_stats_avg_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_cells_temp_stats_avg_is_in_range(uint16_t value);


void primary_hv_current_raw_to_conversion(
    primary_hv_current_converted_t *conversion,
    float current
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_hv_current_conversion_to_raw(
    primary_hv_current_t *raw,
    float current
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_hv_current_raw_to_conversion_struct(
    primary_hv_current_converted_t *conversion, 
    const primary_hv_current_t *raw);


void primary_hv_current_conversion_to_raw_struct(
    primary_hv_current_t *raw,
    const primary_hv_current_converted_t *conversion);


int primary_hv_current_converted_to_string(primary_hv_current_converted_t *message, char *buffer);

int primary_hv_current_converted_to_string_file(primary_hv_current_converted_t *message, FILE *buffer);

int primary_hv_current_fields(char *buffer);

int primary_hv_current_fields_file(FILE *buffer);

/**
 * Pack message HV_CURRENT.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_hv_current_pack(
    uint8_t *dst_p,
    const primary_hv_current_t *src_p,
    size_t byte_size);

/**
 * Unpack message HV_CURRENT.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_hv_current_unpack(
    primary_hv_current_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_hv_current_current_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_hv_current_current_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_current_current_is_in_range(uint16_t value);


void primary_hv_power_raw_to_conversion(
    primary_hv_power_converted_t *conversion,
    float power
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_hv_power_conversion_to_raw(
    primary_hv_power_t *raw,
    float power
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_hv_power_raw_to_conversion_struct(
    primary_hv_power_converted_t *conversion, 
    const primary_hv_power_t *raw);


void primary_hv_power_conversion_to_raw_struct(
    primary_hv_power_t *raw,
    const primary_hv_power_converted_t *conversion);


int primary_hv_power_converted_to_string(primary_hv_power_converted_t *message, char *buffer);

int primary_hv_power_converted_to_string_file(primary_hv_power_converted_t *message, FILE *buffer);

int primary_hv_power_fields(char *buffer);

int primary_hv_power_fields_file(FILE *buffer);

/**
 * Pack message HV_POWER.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_hv_power_pack(
    uint8_t *dst_p,
    const primary_hv_power_t *src_p,
    size_t byte_size);

/**
 * Unpack message HV_POWER.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_hv_power_unpack(
    primary_hv_power_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_hv_power_power_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_hv_power_power_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_power_power_is_in_range(uint16_t value);


void primary_hv_energy_raw_to_conversion(
    primary_hv_energy_converted_t *conversion,
    float energy
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_hv_energy_conversion_to_raw(
    primary_hv_energy_t *raw,
    float energy
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_hv_energy_raw_to_conversion_struct(
    primary_hv_energy_converted_t *conversion, 
    const primary_hv_energy_t *raw);


void primary_hv_energy_conversion_to_raw_struct(
    primary_hv_energy_t *raw,
    const primary_hv_energy_converted_t *conversion);


int primary_hv_energy_converted_to_string(primary_hv_energy_converted_t *message, char *buffer);

int primary_hv_energy_converted_to_string_file(primary_hv_energy_converted_t *message, FILE *buffer);

int primary_hv_energy_fields(char *buffer);

int primary_hv_energy_fields_file(FILE *buffer);

/**
 * Pack message HV_ENERGY.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_hv_energy_pack(
    uint8_t *dst_p,
    const primary_hv_energy_t *src_p,
    size_t byte_size);

/**
 * Unpack message HV_ENERGY.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_hv_energy_unpack(
    primary_hv_energy_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_hv_energy_energy_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_hv_energy_energy_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_energy_energy_is_in_range(uint16_t value);


void primary_hv_soc_raw_to_conversion(
    primary_hv_soc_converted_t *conversion,
    float soc
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_hv_soc_conversion_to_raw(
    primary_hv_soc_t *raw,
    float soc
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_hv_soc_raw_to_conversion_struct(
    primary_hv_soc_converted_t *conversion, 
    const primary_hv_soc_t *raw);


void primary_hv_soc_conversion_to_raw_struct(
    primary_hv_soc_t *raw,
    const primary_hv_soc_converted_t *conversion);


int primary_hv_soc_converted_to_string(primary_hv_soc_converted_t *message, char *buffer);

int primary_hv_soc_converted_to_string_file(primary_hv_soc_converted_t *message, FILE *buffer);

int primary_hv_soc_fields(char *buffer);

int primary_hv_soc_fields_file(FILE *buffer);

/**
 * Pack message HV_SOC.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_hv_soc_pack(
    uint8_t *dst_p,
    const primary_hv_soc_t *src_p,
    size_t byte_size);

/**
 * Unpack message HV_SOC.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_hv_soc_unpack(
    primary_hv_soc_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t primary_hv_soc_soc_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_hv_soc_soc_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_soc_soc_is_in_range(uint8_t value);


void primary_hv_total_voltage_raw_to_conversion(
    primary_hv_total_voltage_converted_t *conversion,
    float pack,
    float sum_cell,
    float bus
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_hv_total_voltage_conversion_to_raw(
    primary_hv_total_voltage_t *raw,
    float pack,
    float sum_cell,
    float bus
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_hv_total_voltage_raw_to_conversion_struct(
    primary_hv_total_voltage_converted_t *conversion, 
    const primary_hv_total_voltage_t *raw);


void primary_hv_total_voltage_conversion_to_raw_struct(
    primary_hv_total_voltage_t *raw,
    const primary_hv_total_voltage_converted_t *conversion);


int primary_hv_total_voltage_converted_to_string(primary_hv_total_voltage_converted_t *message, char *buffer);

int primary_hv_total_voltage_converted_to_string_file(primary_hv_total_voltage_converted_t *message, FILE *buffer);

int primary_hv_total_voltage_fields(char *buffer);

int primary_hv_total_voltage_fields_file(FILE *buffer);

/**
 * Pack message HV_TOTAL_VOLTAGE.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_hv_total_voltage_pack(
    uint8_t *dst_p,
    const primary_hv_total_voltage_t *src_p,
    size_t byte_size);

/**
 * Unpack message HV_TOTAL_VOLTAGE.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_hv_total_voltage_unpack(
    primary_hv_total_voltage_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_hv_total_voltage_pack_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_hv_total_voltage_pack_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_total_voltage_pack_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_hv_total_voltage_sum_cell_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_hv_total_voltage_sum_cell_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_total_voltage_sum_cell_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_hv_total_voltage_bus_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_hv_total_voltage_bus_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_total_voltage_bus_is_in_range(uint16_t value);


void primary_hv_cells_voltage_raw_to_conversion(
    primary_hv_cells_voltage_converted_t *conversion,
    uint8_t start_index,
    float voltage_0,
    float voltage_1,
    float voltage_2
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_hv_cells_voltage_conversion_to_raw(
    primary_hv_cells_voltage_t *raw,
    uint8_t start_index,
    float voltage_0,
    float voltage_1,
    float voltage_2
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_hv_cells_voltage_raw_to_conversion_struct(
    primary_hv_cells_voltage_converted_t *conversion, 
    const primary_hv_cells_voltage_t *raw);


void primary_hv_cells_voltage_conversion_to_raw_struct(
    primary_hv_cells_voltage_t *raw,
    const primary_hv_cells_voltage_converted_t *conversion);


int primary_hv_cells_voltage_converted_to_string(primary_hv_cells_voltage_converted_t *message, char *buffer);

int primary_hv_cells_voltage_converted_to_string_file(primary_hv_cells_voltage_converted_t *message, FILE *buffer);

int primary_hv_cells_voltage_fields(char *buffer);

int primary_hv_cells_voltage_fields_file(FILE *buffer);

/**
 * Pack message HV_CELLS_VOLTAGE.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_hv_cells_voltage_pack(
    uint8_t *dst_p,
    const primary_hv_cells_voltage_t *src_p,
    size_t byte_size);

/**
 * Unpack message HV_CELLS_VOLTAGE.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_hv_cells_voltage_unpack(
    primary_hv_cells_voltage_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_cells_voltage_start_index_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_hv_cells_voltage_voltage_0_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_hv_cells_voltage_voltage_0_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_cells_voltage_voltage_0_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_hv_cells_voltage_voltage_1_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_hv_cells_voltage_voltage_1_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_cells_voltage_voltage_1_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_hv_cells_voltage_voltage_2_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_hv_cells_voltage_voltage_2_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_cells_voltage_voltage_2_is_in_range(uint16_t value);


void primary_hv_cells_voltage_stats_raw_to_conversion(
    primary_hv_cells_voltage_stats_converted_t *conversion,
    float max,
    float min,
    float delta,
    float avg
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_hv_cells_voltage_stats_conversion_to_raw(
    primary_hv_cells_voltage_stats_t *raw,
    float max,
    float min,
    float delta,
    float avg
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_hv_cells_voltage_stats_raw_to_conversion_struct(
    primary_hv_cells_voltage_stats_converted_t *conversion, 
    const primary_hv_cells_voltage_stats_t *raw);


void primary_hv_cells_voltage_stats_conversion_to_raw_struct(
    primary_hv_cells_voltage_stats_t *raw,
    const primary_hv_cells_voltage_stats_converted_t *conversion);


int primary_hv_cells_voltage_stats_converted_to_string(primary_hv_cells_voltage_stats_converted_t *message, char *buffer);

int primary_hv_cells_voltage_stats_converted_to_string_file(primary_hv_cells_voltage_stats_converted_t *message, FILE *buffer);

int primary_hv_cells_voltage_stats_fields(char *buffer);

int primary_hv_cells_voltage_stats_fields_file(FILE *buffer);

/**
 * Pack message HV_CELLS_VOLTAGE_STATS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_hv_cells_voltage_stats_pack(
    uint8_t *dst_p,
    const primary_hv_cells_voltage_stats_t *src_p,
    size_t byte_size);

/**
 * Unpack message HV_CELLS_VOLTAGE_STATS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_hv_cells_voltage_stats_unpack(
    primary_hv_cells_voltage_stats_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_hv_cells_voltage_stats_max_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_hv_cells_voltage_stats_max_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_cells_voltage_stats_max_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_hv_cells_voltage_stats_min_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_hv_cells_voltage_stats_min_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_cells_voltage_stats_min_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_hv_cells_voltage_stats_delta_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_hv_cells_voltage_stats_delta_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_cells_voltage_stats_delta_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_hv_cells_voltage_stats_avg_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_hv_cells_voltage_stats_avg_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_cells_voltage_stats_avg_is_in_range(uint16_t value);


void primary_hv_cells_temp_raw_to_conversion(
    primary_hv_cells_temp_converted_t *conversion,
    uint8_t start_index,
    float temp_0,
    float temp_1,
    float temp_2,
    float temp_3
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_hv_cells_temp_conversion_to_raw(
    primary_hv_cells_temp_t *raw,
    uint8_t start_index,
    float temp_0,
    float temp_1,
    float temp_2,
    float temp_3
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_hv_cells_temp_raw_to_conversion_struct(
    primary_hv_cells_temp_converted_t *conversion, 
    const primary_hv_cells_temp_t *raw);


void primary_hv_cells_temp_conversion_to_raw_struct(
    primary_hv_cells_temp_t *raw,
    const primary_hv_cells_temp_converted_t *conversion);


int primary_hv_cells_temp_converted_to_string(primary_hv_cells_temp_converted_t *message, char *buffer);

int primary_hv_cells_temp_converted_to_string_file(primary_hv_cells_temp_converted_t *message, FILE *buffer);

int primary_hv_cells_temp_fields(char *buffer);

int primary_hv_cells_temp_fields_file(FILE *buffer);

/**
 * Pack message HV_CELLS_TEMP.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_hv_cells_temp_pack(
    uint8_t *dst_p,
    const primary_hv_cells_temp_t *src_p,
    size_t byte_size);

/**
 * Unpack message HV_CELLS_TEMP.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_hv_cells_temp_unpack(
    primary_hv_cells_temp_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_cells_temp_start_index_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t primary_hv_cells_temp_temp_0_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_hv_cells_temp_temp_0_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_cells_temp_temp_0_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t primary_hv_cells_temp_temp_1_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_hv_cells_temp_temp_1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_cells_temp_temp_1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t primary_hv_cells_temp_temp_2_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_hv_cells_temp_temp_2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_cells_temp_temp_2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t primary_hv_cells_temp_temp_3_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_hv_cells_temp_temp_3_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_cells_temp_temp_3_is_in_range(uint8_t value);


void primary_hv_cells_temp_stats_raw_to_conversion(
    primary_hv_cells_temp_stats_converted_t *conversion,
    float max,
    float min,
    float avg
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_hv_cells_temp_stats_conversion_to_raw(
    primary_hv_cells_temp_stats_t *raw,
    float max,
    float min,
    float avg
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_hv_cells_temp_stats_raw_to_conversion_struct(
    primary_hv_cells_temp_stats_converted_t *conversion, 
    const primary_hv_cells_temp_stats_t *raw);


void primary_hv_cells_temp_stats_conversion_to_raw_struct(
    primary_hv_cells_temp_stats_t *raw,
    const primary_hv_cells_temp_stats_converted_t *conversion);


int primary_hv_cells_temp_stats_converted_to_string(primary_hv_cells_temp_stats_converted_t *message, char *buffer);

int primary_hv_cells_temp_stats_converted_to_string_file(primary_hv_cells_temp_stats_converted_t *message, FILE *buffer);

int primary_hv_cells_temp_stats_fields(char *buffer);

int primary_hv_cells_temp_stats_fields_file(FILE *buffer);

/**
 * Pack message HV_CELLS_TEMP_STATS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_hv_cells_temp_stats_pack(
    uint8_t *dst_p,
    const primary_hv_cells_temp_stats_t *src_p,
    size_t byte_size);

/**
 * Unpack message HV_CELLS_TEMP_STATS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_hv_cells_temp_stats_unpack(
    primary_hv_cells_temp_stats_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_hv_cells_temp_stats_max_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_hv_cells_temp_stats_max_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_cells_temp_stats_max_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_hv_cells_temp_stats_min_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_hv_cells_temp_stats_min_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_cells_temp_stats_min_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_hv_cells_temp_stats_avg_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_hv_cells_temp_stats_avg_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_cells_temp_stats_avg_is_in_range(uint16_t value);


void primary_ecu_steer_actuator_status_raw_to_conversion(
    primary_ecu_steer_actuator_status_converted_t *conversion,
    primary_ecu_steer_actuator_status_status status
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_ecu_steer_actuator_status_conversion_to_raw(
    primary_ecu_steer_actuator_status_t *raw,
    primary_ecu_steer_actuator_status_status status
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_ecu_steer_actuator_status_raw_to_conversion_struct(
    primary_ecu_steer_actuator_status_converted_t *conversion, 
    const primary_ecu_steer_actuator_status_t *raw);


void primary_ecu_steer_actuator_status_conversion_to_raw_struct(
    primary_ecu_steer_actuator_status_t *raw,
    const primary_ecu_steer_actuator_status_converted_t *conversion);

int primary_ecu_steer_actuator_status_status_enum_to_string(primary_ecu_steer_actuator_status_status value, char *buffer);

int primary_ecu_steer_actuator_status_to_string(primary_ecu_steer_actuator_status_t *message, char *buffer);

int primary_ecu_steer_actuator_status_to_string_file(primary_ecu_steer_actuator_status_t *message, FILE *buffer);

int primary_ecu_steer_actuator_status_fields(char *buffer);

int primary_ecu_steer_actuator_status_fields_file(FILE *buffer);

/**
 * Pack message ECU_STEER_ACTUATOR_STATUS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_ecu_steer_actuator_status_pack(
    uint8_t *dst_p,
    const primary_ecu_steer_actuator_status_t *src_p,
    size_t byte_size);

/**
 * Unpack message ECU_STEER_ACTUATOR_STATUS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_ecu_steer_actuator_status_unpack(
    primary_ecu_steer_actuator_status_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_ecu_steer_actuator_status_status_is_in_range(uint8_t value);


void primary_ecu_set_steer_actuator_status_steering_wheel_raw_to_conversion(
    primary_ecu_set_steer_actuator_status_steering_wheel_converted_t *conversion,
    primary_ecu_set_steer_actuator_status_steering_wheel_status status,
    float target
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_ecu_set_steer_actuator_status_steering_wheel_conversion_to_raw(
    primary_ecu_set_steer_actuator_status_steering_wheel_t *raw,
    primary_ecu_set_steer_actuator_status_steering_wheel_status status,
    float target
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_ecu_set_steer_actuator_status_steering_wheel_raw_to_conversion_struct(
    primary_ecu_set_steer_actuator_status_steering_wheel_converted_t *conversion, 
    const primary_ecu_set_steer_actuator_status_steering_wheel_t *raw);


void primary_ecu_set_steer_actuator_status_steering_wheel_conversion_to_raw_struct(
    primary_ecu_set_steer_actuator_status_steering_wheel_t *raw,
    const primary_ecu_set_steer_actuator_status_steering_wheel_converted_t *conversion);

int primary_ecu_set_steer_actuator_status_steering_wheel_status_enum_to_string(primary_ecu_set_steer_actuator_status_steering_wheel_status value, char *buffer);

int primary_ecu_set_steer_actuator_status_steering_wheel_converted_to_string(primary_ecu_set_steer_actuator_status_steering_wheel_converted_t *message, char *buffer);

int primary_ecu_set_steer_actuator_status_steering_wheel_converted_to_string_file(primary_ecu_set_steer_actuator_status_steering_wheel_converted_t *message, FILE *buffer);

int primary_ecu_set_steer_actuator_status_steering_wheel_fields(char *buffer);

int primary_ecu_set_steer_actuator_status_steering_wheel_fields_file(FILE *buffer);

/**
 * Pack message ECU_SET_STEER_ACTUATOR_STATUS_STEERING_WHEEL.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_ecu_set_steer_actuator_status_steering_wheel_pack(
    uint8_t *dst_p,
    const primary_ecu_set_steer_actuator_status_steering_wheel_t *src_p,
    size_t byte_size);

/**
 * Unpack message ECU_SET_STEER_ACTUATOR_STATUS_STEERING_WHEEL.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_ecu_set_steer_actuator_status_steering_wheel_unpack(
    primary_ecu_set_steer_actuator_status_steering_wheel_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_ecu_set_steer_actuator_status_steering_wheel_status_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t primary_ecu_set_steer_actuator_status_steering_wheel_target_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_ecu_set_steer_actuator_status_steering_wheel_target_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_ecu_set_steer_actuator_status_steering_wheel_target_is_in_range(uint8_t value);


void primary_ecu_set_steer_actuator_status_tlm_raw_to_conversion(
    primary_ecu_set_steer_actuator_status_tlm_converted_t *conversion,
    primary_ecu_set_steer_actuator_status_tlm_status status,
    float target
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_ecu_set_steer_actuator_status_tlm_conversion_to_raw(
    primary_ecu_set_steer_actuator_status_tlm_t *raw,
    primary_ecu_set_steer_actuator_status_tlm_status status,
    float target
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_ecu_set_steer_actuator_status_tlm_raw_to_conversion_struct(
    primary_ecu_set_steer_actuator_status_tlm_converted_t *conversion, 
    const primary_ecu_set_steer_actuator_status_tlm_t *raw);


void primary_ecu_set_steer_actuator_status_tlm_conversion_to_raw_struct(
    primary_ecu_set_steer_actuator_status_tlm_t *raw,
    const primary_ecu_set_steer_actuator_status_tlm_converted_t *conversion);

int primary_ecu_set_steer_actuator_status_tlm_status_enum_to_string(primary_ecu_set_steer_actuator_status_tlm_status value, char *buffer);

int primary_ecu_set_steer_actuator_status_tlm_converted_to_string(primary_ecu_set_steer_actuator_status_tlm_converted_t *message, char *buffer);

int primary_ecu_set_steer_actuator_status_tlm_converted_to_string_file(primary_ecu_set_steer_actuator_status_tlm_converted_t *message, FILE *buffer);

int primary_ecu_set_steer_actuator_status_tlm_fields(char *buffer);

int primary_ecu_set_steer_actuator_status_tlm_fields_file(FILE *buffer);

/**
 * Pack message ECU_SET_STEER_ACTUATOR_STATUS_TLM.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_ecu_set_steer_actuator_status_tlm_pack(
    uint8_t *dst_p,
    const primary_ecu_set_steer_actuator_status_tlm_t *src_p,
    size_t byte_size);

/**
 * Unpack message ECU_SET_STEER_ACTUATOR_STATUS_TLM.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_ecu_set_steer_actuator_status_tlm_unpack(
    primary_ecu_set_steer_actuator_status_tlm_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_ecu_set_steer_actuator_status_tlm_status_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t primary_ecu_set_steer_actuator_status_tlm_target_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_ecu_set_steer_actuator_status_tlm_target_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_ecu_set_steer_actuator_status_tlm_target_is_in_range(uint8_t value);


void primary_ecu_steer_actuator_current_raw_to_conversion(
    primary_ecu_steer_actuator_current_converted_t *conversion,
    float current
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_ecu_steer_actuator_current_conversion_to_raw(
    primary_ecu_steer_actuator_current_t *raw,
    float current
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_ecu_steer_actuator_current_raw_to_conversion_struct(
    primary_ecu_steer_actuator_current_converted_t *conversion, 
    const primary_ecu_steer_actuator_current_t *raw);


void primary_ecu_steer_actuator_current_conversion_to_raw_struct(
    primary_ecu_steer_actuator_current_t *raw,
    const primary_ecu_steer_actuator_current_converted_t *conversion);


int primary_ecu_steer_actuator_current_converted_to_string(primary_ecu_steer_actuator_current_converted_t *message, char *buffer);

int primary_ecu_steer_actuator_current_converted_to_string_file(primary_ecu_steer_actuator_current_converted_t *message, FILE *buffer);

int primary_ecu_steer_actuator_current_fields(char *buffer);

int primary_ecu_steer_actuator_current_fields_file(FILE *buffer);

/**
 * Pack message ECU_STEER_ACTUATOR_CURRENT.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_ecu_steer_actuator_current_pack(
    uint8_t *dst_p,
    const primary_ecu_steer_actuator_current_t *src_p,
    size_t byte_size);

/**
 * Unpack message ECU_STEER_ACTUATOR_CURRENT.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_ecu_steer_actuator_current_unpack(
    primary_ecu_steer_actuator_current_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t primary_ecu_steer_actuator_current_current_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_ecu_steer_actuator_current_current_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_ecu_steer_actuator_current_current_is_in_range(uint8_t value);


void primary_debug_signal_crash_debug_raw_to_conversion(
    primary_debug_signal_crash_debug_converted_t *conversion,
    uint8_t seq_number,
    uint8_t byte_1,
    uint8_t byte_2,
    uint8_t byte_3,
    uint8_t byte_4,
    uint8_t byte_5,
    uint8_t byte_6,
    uint8_t byte_7
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_debug_signal_crash_debug_conversion_to_raw(
    primary_debug_signal_crash_debug_t *raw,
    uint8_t seq_number,
    uint8_t byte_1,
    uint8_t byte_2,
    uint8_t byte_3,
    uint8_t byte_4,
    uint8_t byte_5,
    uint8_t byte_6,
    uint8_t byte_7
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_debug_signal_crash_debug_raw_to_conversion_struct(
    primary_debug_signal_crash_debug_converted_t *conversion, 
    const primary_debug_signal_crash_debug_t *raw);


void primary_debug_signal_crash_debug_conversion_to_raw_struct(
    primary_debug_signal_crash_debug_t *raw,
    const primary_debug_signal_crash_debug_converted_t *conversion);


int primary_debug_signal_crash_debug_to_string(primary_debug_signal_crash_debug_t *message, char *buffer);

int primary_debug_signal_crash_debug_to_string_file(primary_debug_signal_crash_debug_t *message, FILE *buffer);

int primary_debug_signal_crash_debug_fields(char *buffer);

int primary_debug_signal_crash_debug_fields_file(FILE *buffer);

/**
 * Pack message DEBUG_SIGNAL_CRASH_DEBUG.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_debug_signal_crash_debug_pack(
    uint8_t *dst_p,
    const primary_debug_signal_crash_debug_t *src_p,
    size_t byte_size);

/**
 * Unpack message DEBUG_SIGNAL_CRASH_DEBUG.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_debug_signal_crash_debug_unpack(
    primary_debug_signal_crash_debug_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_debug_signal_crash_debug_seq_number_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_debug_signal_crash_debug_byte_1_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_debug_signal_crash_debug_byte_2_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_debug_signal_crash_debug_byte_3_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_debug_signal_crash_debug_byte_4_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_debug_signal_crash_debug_byte_5_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_debug_signal_crash_debug_byte_6_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_debug_signal_crash_debug_byte_7_is_in_range(uint8_t value);


void primary_debug_signal_crash_debug_ack_raw_to_conversion(
    primary_debug_signal_crash_debug_ack_converted_t *conversion,
    uint8_t seq_number
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_debug_signal_crash_debug_ack_conversion_to_raw(
    primary_debug_signal_crash_debug_ack_t *raw,
    uint8_t seq_number
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_debug_signal_crash_debug_ack_raw_to_conversion_struct(
    primary_debug_signal_crash_debug_ack_converted_t *conversion, 
    const primary_debug_signal_crash_debug_ack_t *raw);


void primary_debug_signal_crash_debug_ack_conversion_to_raw_struct(
    primary_debug_signal_crash_debug_ack_t *raw,
    const primary_debug_signal_crash_debug_ack_converted_t *conversion);


int primary_debug_signal_crash_debug_ack_to_string(primary_debug_signal_crash_debug_ack_t *message, char *buffer);

int primary_debug_signal_crash_debug_ack_to_string_file(primary_debug_signal_crash_debug_ack_t *message, FILE *buffer);

int primary_debug_signal_crash_debug_ack_fields(char *buffer);

int primary_debug_signal_crash_debug_ack_fields_file(FILE *buffer);

/**
 * Pack message DEBUG_SIGNAL_CRASH_DEBUG_ACK.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_debug_signal_crash_debug_ack_pack(
    uint8_t *dst_p,
    const primary_debug_signal_crash_debug_ack_t *src_p,
    size_t byte_size);

/**
 * Unpack message DEBUG_SIGNAL_CRASH_DEBUG_ACK.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_debug_signal_crash_debug_ack_unpack(
    primary_debug_signal_crash_debug_ack_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_debug_signal_crash_debug_ack_seq_number_is_in_range(uint8_t value);


void primary_debug_signal_1_raw_to_conversion(
    primary_debug_signal_1_converted_t *conversion,
    float field_1,
    float field_2,
    float field_3,
    float field_4
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_debug_signal_1_conversion_to_raw(
    primary_debug_signal_1_t *raw,
    float field_1,
    float field_2,
    float field_3,
    float field_4
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_debug_signal_1_raw_to_conversion_struct(
    primary_debug_signal_1_converted_t *conversion, 
    const primary_debug_signal_1_t *raw);


void primary_debug_signal_1_conversion_to_raw_struct(
    primary_debug_signal_1_t *raw,
    const primary_debug_signal_1_converted_t *conversion);


int primary_debug_signal_1_converted_to_string(primary_debug_signal_1_converted_t *message, char *buffer);

int primary_debug_signal_1_converted_to_string_file(primary_debug_signal_1_converted_t *message, FILE *buffer);

int primary_debug_signal_1_fields(char *buffer);

int primary_debug_signal_1_fields_file(FILE *buffer);

/**
 * Pack message DEBUG_SIGNAL_1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_debug_signal_1_pack(
    uint8_t *dst_p,
    const primary_debug_signal_1_t *src_p,
    size_t byte_size);

/**
 * Unpack message DEBUG_SIGNAL_1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_debug_signal_1_unpack(
    primary_debug_signal_1_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_debug_signal_1_field_1_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_debug_signal_1_field_1_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_debug_signal_1_field_1_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_debug_signal_1_field_2_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_debug_signal_1_field_2_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_debug_signal_1_field_2_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_debug_signal_1_field_3_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_debug_signal_1_field_3_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_debug_signal_1_field_3_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_debug_signal_1_field_4_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_debug_signal_1_field_4_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_debug_signal_1_field_4_is_in_range(uint16_t value);


void primary_debug_signal_2_raw_to_conversion(
    primary_debug_signal_2_converted_t *conversion,
    float field_1,
    float field_2,
    float field_3,
    float field_4
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_debug_signal_2_conversion_to_raw(
    primary_debug_signal_2_t *raw,
    float field_1,
    float field_2,
    float field_3,
    float field_4
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_debug_signal_2_raw_to_conversion_struct(
    primary_debug_signal_2_converted_t *conversion, 
    const primary_debug_signal_2_t *raw);


void primary_debug_signal_2_conversion_to_raw_struct(
    primary_debug_signal_2_t *raw,
    const primary_debug_signal_2_converted_t *conversion);


int primary_debug_signal_2_converted_to_string(primary_debug_signal_2_converted_t *message, char *buffer);

int primary_debug_signal_2_converted_to_string_file(primary_debug_signal_2_converted_t *message, FILE *buffer);

int primary_debug_signal_2_fields(char *buffer);

int primary_debug_signal_2_fields_file(FILE *buffer);

/**
 * Pack message DEBUG_SIGNAL_2.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_debug_signal_2_pack(
    uint8_t *dst_p,
    const primary_debug_signal_2_t *src_p,
    size_t byte_size);

/**
 * Unpack message DEBUG_SIGNAL_2.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_debug_signal_2_unpack(
    primary_debug_signal_2_t *dst_p,
    const uint8_t *src_p,
    size_t byte_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_debug_signal_2_field_1_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_debug_signal_2_field_1_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_debug_signal_2_field_1_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_debug_signal_2_field_2_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_debug_signal_2_field_2_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_debug_signal_2_field_2_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_debug_signal_2_field_3_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_debug_signal_2_field_3_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_debug_signal_2_field_3_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_debug_signal_2_field_4_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_debug_signal_2_field_4_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_debug_signal_2_field_4_is_in_range(uint16_t value);

bool primary_id_is_message(uint16_t id);

int primary_to_string_from_id(uint16_t message_id, void* message, char* buffer);
int primary_fields_from_id(uint16_t message_id, char* buffer);
int primary_to_string_file_from_id(uint16_t message_id, void* message, FILE* buffer);
int primary_fields_file_from_id(uint16_t message_id, FILE* buffer);


typedef union CANLIB_PARKING {
    primary_nlg5_diag_tx_t _nlg5_diag_tx;
    primary_nlg5_diag_rx_t _nlg5_diag_rx;
    primary_nlg5_err_t _nlg5_err;
    primary_nlg5_temp_t _nlg5_temp;
    primary_nlg5_act_ii_t _nlg5_act_ii;
    primary_nlg5_act_i_t _nlg5_act_i;
    primary_nlg5_st_t _nlg5_st;
    primary_nlg5_ctl_t _nlg5_ctl;
    primary_hv_jmp_to_blt_t _hv_jmp_to_blt;
    primary_hv_flash_mainboard_tx_t _hv_flash_mainboard_tx;
    primary_hv_flash_mainboard_rx_t _hv_flash_mainboard_rx;
    primary_hv_flash_cellboard_0_tx_t _hv_flash_cellboard_0_tx;
    primary_hv_flash_cellboard_0_rx_t _hv_flash_cellboard_0_rx;
    primary_hv_flash_cellboard_1_tx_t _hv_flash_cellboard_1_tx;
    primary_hv_flash_cellboard_1_rx_t _hv_flash_cellboard_1_rx;
    primary_hv_flash_cellboard_2_tx_t _hv_flash_cellboard_2_tx;
    primary_hv_flash_cellboard_2_rx_t _hv_flash_cellboard_2_rx;
    primary_hv_flash_cellboard_3_tx_t _hv_flash_cellboard_3_tx;
    primary_hv_flash_cellboard_3_rx_t _hv_flash_cellboard_3_rx;
    primary_hv_flash_cellboard_4_tx_t _hv_flash_cellboard_4_tx;
    primary_hv_flash_cellboard_4_rx_t _hv_flash_cellboard_4_rx;
    primary_hv_flash_cellboard_5_tx_t _hv_flash_cellboard_5_tx;
    primary_hv_flash_cellboard_5_rx_t _hv_flash_cellboard_5_rx;
    primary_lv_jmp_to_blt_t _lv_jmp_to_blt;
    primary_lv_flash_tx_t _lv_flash_tx;
    primary_lv_flash_rx_t _lv_flash_rx;
    primary_ecu_jmp_to_blt_t _ecu_jmp_to_blt;
    primary_ecu_flash_tx_t _ecu_flash_tx;
    primary_ecu_flash_rx_t _ecu_flash_rx;
    primary_steering_wheel_jmp_to_blt_t _steering_wheel_jmp_to_blt;
    primary_steering_wheel_flash_tx_t _steering_wheel_flash_tx;
    primary_steering_wheel_flash_rx_t _steering_wheel_flash_rx;
    primary_steering_wheel_version_t _steering_wheel_version;
    primary_ecu_version_t _ecu_version;
    primary_lv_version_t _lv_version;
    primary_tlm_version_t _tlm_version;
    primary_hv_mainboard_version_t _hv_mainboard_version;
    primary_hv_cellboard_version_t _hv_cellboard_version;
    primary_hv_errors_t _hv_errors;
    primary_hv_debug_signals_t _hv_debug_signals;
    primary_hv_fans_status_t _hv_fans_status;
    primary_hv_set_fans_status_t _hv_set_fans_status;
    primary_hv_feedback_status_t _hv_feedback_status;
    primary_hv_feedback_ts_voltage_t _hv_feedback_ts_voltage;
    primary_hv_feedback_misc_voltage_t _hv_feedback_misc_voltage;
    primary_hv_feedback_sd_voltage_t _hv_feedback_sd_voltage;
    primary_hv_imd_status_t _hv_imd_status;
    primary_hv_status_t _hv_status;
    primary_hv_set_status_ecu_t _hv_set_status_ecu;
    primary_hv_set_status_handcart_t _hv_set_status_handcart;
    primary_hv_balancing_status_t _hv_balancing_status;
    primary_hv_set_balancing_status_handcart_t _hv_set_balancing_status_handcart;
    primary_hv_set_balancing_status_steering_wheel_t _hv_set_balancing_status_steering_wheel;
    primary_lv_status_t _lv_status;
    primary_lv_radiator_speed_t _lv_radiator_speed;
    primary_lv_pumps_speed_t _lv_pumps_speed;
    primary_lv_set_radiator_speed_t _lv_set_radiator_speed;
    primary_lv_set_pumps_speed_t _lv_set_pumps_speed;
    primary_lv_errors_t _lv_errors;
    primary_lv_feedback_ts_voltage_t _lv_feedback_ts_voltage;
    primary_lv_feedback_sd_voltage_t _lv_feedback_sd_voltage;
    primary_lv_feedback_enclosure_voltage_t _lv_feedback_enclosure_voltage;
    primary_lv_feedback_gpio_extender_t _lv_feedback_gpio_extender;
    primary_lv_can_flash_req_tlm_t _lv_can_flash_req_tlm;
    primary_lv_can_flash_req_steering_wheel_t _lv_can_flash_req_steering_wheel;
    primary_lv_can_flash_ack_t _lv_can_flash_ack;
    primary_lv_inverter_connection_status_t _lv_inverter_connection_status;
    primary_lv_set_inverter_connection_status_t _lv_set_inverter_connection_status;
    primary_tlm_status_t _tlm_status;
    primary_tlm_set_status_t _tlm_set_status;
    primary_handcart_status_t _handcart_status;
    primary_handcart_settings_t _handcart_settings;
    primary_handcart_set_settings_t _handcart_set_settings;
    primary_ecu_status_t _ecu_status;
    primary_ecu_set_status_t _ecu_set_status;
    primary_ecu_inverter_status_t _ecu_inverter_status;
    primary_ecu_control_status_t _ecu_control_status;
    primary_ecu_errors_t _ecu_errors;
    primary_ecu_feedbacks_t _ecu_feedbacks;
    primary_ecu_power_maps_t _ecu_power_maps;
    primary_ecu_set_power_maps_t _ecu_set_power_maps;
    primary_ecu_ptt_status_t _ecu_ptt_status;
    primary_ecu_set_ptt_status_t _ecu_set_ptt_status;
    primary_inv_l_request_t _inv_l_request;
    primary_control_output_t _control_output;
    primary_control_status_t _control_status;
    primary_inv_r_request_t _inv_r_request;
    primary_inv_l_response_t _inv_l_response;
    primary_inv_r_response_t _inv_r_response;
    primary_lv_current_battery_t _lv_current_battery;
    primary_lv_current_charger_t _lv_current_charger;
    primary_lv_total_voltage_t _lv_total_voltage;
    primary_lv_cells_voltage_t _lv_cells_voltage;
    primary_lv_cells_voltage_stats_t _lv_cells_voltage_stats;
    primary_lv_cells_temp_t _lv_cells_temp;
    primary_lv_cells_temp_stats_t _lv_cells_temp_stats;
    primary_hv_current_t _hv_current;
    primary_hv_power_t _hv_power;
    primary_hv_energy_t _hv_energy;
    primary_hv_soc_t _hv_soc;
    primary_hv_total_voltage_t _hv_total_voltage;
    primary_hv_cells_voltage_t _hv_cells_voltage;
    primary_hv_cells_voltage_stats_t _hv_cells_voltage_stats;
    primary_hv_cells_temp_t _hv_cells_temp;
    primary_hv_cells_temp_stats_t _hv_cells_temp_stats;
    primary_ecu_steer_actuator_status_t _ecu_steer_actuator_status;
    primary_ecu_set_steer_actuator_status_steering_wheel_t _ecu_set_steer_actuator_status_steering_wheel;
    primary_ecu_set_steer_actuator_status_tlm_t _ecu_set_steer_actuator_status_tlm;
    primary_ecu_steer_actuator_current_t _ecu_steer_actuator_current;
    primary_debug_signal_crash_debug_t _debug_signal_crash_debug;
    primary_debug_signal_crash_debug_ack_t _debug_signal_crash_debug_ack;
    primary_debug_signal_1_t _debug_signal_1;
    primary_debug_signal_2_t _debug_signal_2;

} _primary_all_struct_raw;

typedef union CANLIB_PARKING {
    primary_nlg5_diag_tx_converted_t _nlg5_diag_tx;
    primary_nlg5_diag_rx_converted_t _nlg5_diag_rx;
    primary_nlg5_err_converted_t _nlg5_err;
    primary_nlg5_temp_converted_t _nlg5_temp;
    primary_nlg5_act_ii_converted_t _nlg5_act_ii;
    primary_nlg5_act_i_converted_t _nlg5_act_i;
    primary_nlg5_st_converted_t _nlg5_st;
    primary_nlg5_ctl_converted_t _nlg5_ctl;
    primary_hv_jmp_to_blt_converted_t _hv_jmp_to_blt;
    primary_hv_flash_mainboard_tx_converted_t _hv_flash_mainboard_tx;
    primary_hv_flash_mainboard_rx_converted_t _hv_flash_mainboard_rx;
    primary_hv_flash_cellboard_0_tx_converted_t _hv_flash_cellboard_0_tx;
    primary_hv_flash_cellboard_0_rx_converted_t _hv_flash_cellboard_0_rx;
    primary_hv_flash_cellboard_1_tx_converted_t _hv_flash_cellboard_1_tx;
    primary_hv_flash_cellboard_1_rx_converted_t _hv_flash_cellboard_1_rx;
    primary_hv_flash_cellboard_2_tx_converted_t _hv_flash_cellboard_2_tx;
    primary_hv_flash_cellboard_2_rx_converted_t _hv_flash_cellboard_2_rx;
    primary_hv_flash_cellboard_3_tx_converted_t _hv_flash_cellboard_3_tx;
    primary_hv_flash_cellboard_3_rx_converted_t _hv_flash_cellboard_3_rx;
    primary_hv_flash_cellboard_4_tx_converted_t _hv_flash_cellboard_4_tx;
    primary_hv_flash_cellboard_4_rx_converted_t _hv_flash_cellboard_4_rx;
    primary_hv_flash_cellboard_5_tx_converted_t _hv_flash_cellboard_5_tx;
    primary_hv_flash_cellboard_5_rx_converted_t _hv_flash_cellboard_5_rx;
    primary_lv_jmp_to_blt_converted_t _lv_jmp_to_blt;
    primary_lv_flash_tx_converted_t _lv_flash_tx;
    primary_lv_flash_rx_converted_t _lv_flash_rx;
    primary_ecu_jmp_to_blt_converted_t _ecu_jmp_to_blt;
    primary_ecu_flash_tx_converted_t _ecu_flash_tx;
    primary_ecu_flash_rx_converted_t _ecu_flash_rx;
    primary_steering_wheel_jmp_to_blt_converted_t _steering_wheel_jmp_to_blt;
    primary_steering_wheel_flash_tx_converted_t _steering_wheel_flash_tx;
    primary_steering_wheel_flash_rx_converted_t _steering_wheel_flash_rx;
    primary_steering_wheel_version_converted_t _steering_wheel_version;
    primary_ecu_version_converted_t _ecu_version;
    primary_lv_version_converted_t _lv_version;
    primary_tlm_version_converted_t _tlm_version;
    primary_hv_mainboard_version_converted_t _hv_mainboard_version;
    primary_hv_cellboard_version_converted_t _hv_cellboard_version;
    primary_hv_errors_converted_t _hv_errors;
    primary_hv_debug_signals_converted_t _hv_debug_signals;
    primary_hv_fans_status_converted_t _hv_fans_status;
    primary_hv_set_fans_status_converted_t _hv_set_fans_status;
    primary_hv_feedback_status_converted_t _hv_feedback_status;
    primary_hv_feedback_ts_voltage_converted_t _hv_feedback_ts_voltage;
    primary_hv_feedback_misc_voltage_converted_t _hv_feedback_misc_voltage;
    primary_hv_feedback_sd_voltage_converted_t _hv_feedback_sd_voltage;
    primary_hv_imd_status_converted_t _hv_imd_status;
    primary_hv_status_converted_t _hv_status;
    primary_hv_set_status_ecu_converted_t _hv_set_status_ecu;
    primary_hv_set_status_handcart_converted_t _hv_set_status_handcart;
    primary_hv_balancing_status_converted_t _hv_balancing_status;
    primary_hv_set_balancing_status_handcart_converted_t _hv_set_balancing_status_handcart;
    primary_hv_set_balancing_status_steering_wheel_converted_t _hv_set_balancing_status_steering_wheel;
    primary_lv_status_converted_t _lv_status;
    primary_lv_radiator_speed_converted_t _lv_radiator_speed;
    primary_lv_pumps_speed_converted_t _lv_pumps_speed;
    primary_lv_set_radiator_speed_converted_t _lv_set_radiator_speed;
    primary_lv_set_pumps_speed_converted_t _lv_set_pumps_speed;
    primary_lv_errors_converted_t _lv_errors;
    primary_lv_feedback_ts_voltage_converted_t _lv_feedback_ts_voltage;
    primary_lv_feedback_sd_voltage_converted_t _lv_feedback_sd_voltage;
    primary_lv_feedback_enclosure_voltage_converted_t _lv_feedback_enclosure_voltage;
    primary_lv_feedback_gpio_extender_converted_t _lv_feedback_gpio_extender;
    primary_lv_can_flash_req_tlm_converted_t _lv_can_flash_req_tlm;
    primary_lv_can_flash_req_steering_wheel_converted_t _lv_can_flash_req_steering_wheel;
    primary_lv_can_flash_ack_converted_t _lv_can_flash_ack;
    primary_lv_inverter_connection_status_converted_t _lv_inverter_connection_status;
    primary_lv_set_inverter_connection_status_converted_t _lv_set_inverter_connection_status;
    primary_tlm_status_converted_t _tlm_status;
    primary_tlm_set_status_converted_t _tlm_set_status;
    primary_handcart_status_converted_t _handcart_status;
    primary_handcart_settings_converted_t _handcart_settings;
    primary_handcart_set_settings_converted_t _handcart_set_settings;
    primary_ecu_status_converted_t _ecu_status;
    primary_ecu_set_status_converted_t _ecu_set_status;
    primary_ecu_inverter_status_converted_t _ecu_inverter_status;
    primary_ecu_control_status_converted_t _ecu_control_status;
    primary_ecu_errors_converted_t _ecu_errors;
    primary_ecu_feedbacks_converted_t _ecu_feedbacks;
    primary_ecu_power_maps_converted_t _ecu_power_maps;
    primary_ecu_set_power_maps_converted_t _ecu_set_power_maps;
    primary_ecu_ptt_status_converted_t _ecu_ptt_status;
    primary_ecu_set_ptt_status_converted_t _ecu_set_ptt_status;
    primary_inv_l_request_converted_t _inv_l_request;
    primary_control_output_converted_t _control_output;
    primary_control_status_converted_t _control_status;
    primary_inv_r_request_converted_t _inv_r_request;
    primary_inv_l_response_converted_t _inv_l_response;
    primary_inv_r_response_converted_t _inv_r_response;
    primary_lv_current_battery_converted_t _lv_current_battery;
    primary_lv_current_charger_converted_t _lv_current_charger;
    primary_lv_total_voltage_converted_t _lv_total_voltage;
    primary_lv_cells_voltage_converted_t _lv_cells_voltage;
    primary_lv_cells_voltage_stats_converted_t _lv_cells_voltage_stats;
    primary_lv_cells_temp_converted_t _lv_cells_temp;
    primary_lv_cells_temp_stats_converted_t _lv_cells_temp_stats;
    primary_hv_current_converted_t _hv_current;
    primary_hv_power_converted_t _hv_power;
    primary_hv_energy_converted_t _hv_energy;
    primary_hv_soc_converted_t _hv_soc;
    primary_hv_total_voltage_converted_t _hv_total_voltage;
    primary_hv_cells_voltage_converted_t _hv_cells_voltage;
    primary_hv_cells_voltage_stats_converted_t _hv_cells_voltage_stats;
    primary_hv_cells_temp_converted_t _hv_cells_temp;
    primary_hv_cells_temp_stats_converted_t _hv_cells_temp_stats;
    primary_ecu_steer_actuator_status_converted_t _ecu_steer_actuator_status;
    primary_ecu_set_steer_actuator_status_steering_wheel_converted_t _ecu_set_steer_actuator_status_steering_wheel;
    primary_ecu_set_steer_actuator_status_tlm_converted_t _ecu_set_steer_actuator_status_tlm;
    primary_ecu_steer_actuator_current_converted_t _ecu_steer_actuator_current;
    primary_debug_signal_crash_debug_converted_t _debug_signal_crash_debug;
    primary_debug_signal_crash_debug_ack_converted_t _debug_signal_crash_debug_ack;
    primary_debug_signal_1_converted_t _debug_signal_1;
    primary_debug_signal_2_converted_t _debug_signal_2;

} _primary_all_struct_converted;



#define primary_MAX_STRUCT_SIZE_RAW sizeof(_primary_all_struct_raw)
#define primary_MAX_STRUCT_SIZE_CONVERSION sizeof(_primary_all_struct_converted)

#ifdef __cplusplus
}
#endif

#endif
