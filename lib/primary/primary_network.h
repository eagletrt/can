/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2018-2019 Erik Moqvist
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/**
 * This file was generated by cantools version 38.0.2 Mon Jun  5 20:49:02 2023.
 */

#ifndef PRIMARY_H
#define PRIMARY_H

#include <stdio.h>
#include <stdlib.h>
#include <inttypes.h>

#ifdef __cplusplus
extern "C" {
#endif

#include <stdint.h>
#include <stdbool.h>
#include <stddef.h>

#ifndef CANLIB_BUILD
#define CANLIB_BUILD
#define CANLIB_BUILD_TIME 1685998145
#endif // CANLIB_BUILD

#ifndef CANLIB_PARKING
/* We know it's PACKING but PARKING sounds a bit better ;) */
#if defined(__MINGW32__)
#define CANLIB_PARKING                                                           __attribute__((__gcc_struct__, __packed__)) // , __aligned__(1)))
#else
#define CANLIB_PARKING __attribute__((__packed__)) // , __aligned__(1)))
#endif                                             // defined(__MINGW32__)
#endif                                             // CANLIB_PARKING

#ifndef EINVAL
#    define EINVAL 22
#endif

/* Frame ids. */
#define PRIMARY_INVERTER_L_SEND_FRAME_ID (0x201u)
#define PRIMARY_INVERTER_L_RCV_FRAME_ID (0x181u)
#define PRIMARY_INVERTER_R_SEND_FRAME_ID (0x202u)
#define PRIMARY_INVERTER_R_RCV_FRAME_ID (0x182u)
#define PRIMARY_BMS_HV_JMP_TO_BLT_FRAME_ID (0x09u)
#define PRIMARY_BMS_LV_JMP_TO_BLT_FRAME_ID (0x29u)
#define PRIMARY_STEER_VERSION_FRAME_ID (0x405u)
#define PRIMARY_DAS_VERSION_FRAME_ID (0x425u)
#define PRIMARY_HV_VERSION_FRAME_ID (0x445u)
#define PRIMARY_LV_VERSION_FRAME_ID (0x465u)
#define PRIMARY_TLM_VERSION_FRAME_ID (0x485u)
#define PRIMARY_TIMESTAMP_FRAME_ID (0x105u)
#define PRIMARY_AMBIENT_TEMPERATURE_FRAME_ID (0x125u)
#define PRIMARY_DATA_LOGGER_FRAME_ID (0x430u)
#define PRIMARY_SET_TLM_STATUS_FRAME_ID (0x101u)
#define PRIMARY_TLM_STATUS_FRAME_ID (0x102u)
#define PRIMARY_STEER_SYSTEM_STATUS_FRAME_ID (0x701u)
#define PRIMARY_HV_VOLTAGE_FRAME_ID (0x306u)
#define PRIMARY_HV_CURRENT_FRAME_ID (0x326u)
#define PRIMARY_HV_TEMP_FRAME_ID (0x346u)
#define PRIMARY_HV_ERRORS_FRAME_ID (0x06u)
#define PRIMARY_HV_CAN_FORWARD_FRAME_ID (0x0au)
#define PRIMARY_HV_FANS_OVERRIDE_FRAME_ID (0x2au)
#define PRIMARY_HV_CAN_FORWARD_STATUS_FRAME_ID (0x08u)
#define PRIMARY_HV_FANS_OVERRIDE_STATUS_FRAME_ID (0x308u)
#define PRIMARY_HV_FEEDBACKS_STATUS_FRAME_ID (0x300u)
#define PRIMARY_HV_IMD_STATUS_FRAME_ID (0x320u)
#define PRIMARY_TS_STATUS_DAS_FRAME_ID (0x26u)
#define PRIMARY_TS_STATUS_STEER_FRAME_ID (0x46u)
#define PRIMARY_TS_STATUS_HANDCART_FRAME_ID (0x66u)
#define PRIMARY_SET_TS_STATUS_DAS_FRAME_ID (0x4au)
#define PRIMARY_SET_TS_STATUS_HANDCART_FRAME_ID (0x6au)
#define PRIMARY_STEER_STATUS_FRAME_ID (0x103u)
#define PRIMARY_SET_CAR_STATUS_FRAME_ID (0x303u)
#define PRIMARY_SET_PEDALS_RANGE_FRAME_ID (0x403u)
#define PRIMARY_SET_STEERING_ANGLE_RANGE_FRAME_ID (0x423u)
#define PRIMARY_CAR_STATUS_FRAME_ID (0x222u)
#define PRIMARY_DAS_ERRORS_FRAME_ID (0x02u)
#define PRIMARY_LV_CURRENT_FRAME_ID (0x340u)
#define PRIMARY_LV_VOLTAGE_FRAME_ID (0x360u)
#define PRIMARY_LV_TOTAL_VOLTAGE_FRAME_ID (0x380u)
#define PRIMARY_LV_TEMPERATURE_FRAME_ID (0x3a0u)
#define PRIMARY_COOLING_STATUS_FRAME_ID (0x3c0u)
#define PRIMARY_SET_RADIATOR_SPEED_FRAME_ID (0x304u)
#define PRIMARY_SET_PUMPS_SPEED_FRAME_ID (0x324u)
#define PRIMARY_SET_INVERTER_CONNECTION_STATUS_FRAME_ID (0x104u)
#define PRIMARY_INVERTER_CONNECTION_STATUS_FRAME_ID (0x100u)
#define PRIMARY_LV_ERRORS_FRAME_ID (0x00u)
#define PRIMARY_SHUTDOWN_STATUS_FRAME_ID (0x120u)
#define PRIMARY_MARKER_FRAME_ID (0x01u)
#define PRIMARY_HV_CELLS_VOLTAGE_FRAME_ID (0x208u)
#define PRIMARY_HV_CELLS_TEMP_FRAME_ID (0x228u)
#define PRIMARY_HV_CELL_BALANCING_STATUS_FRAME_ID (0x248u)
#define PRIMARY_SET_CELL_BALANCING_STATUS_FRAME_ID (0x20au)
#define PRIMARY_HANDCART_STATUS_FRAME_ID (0x30au)
#define PRIMARY_SPEED_FRAME_ID (0x242u)
#define PRIMARY_INV_L_REQUEST_FRAME_ID (0x201u)
#define PRIMARY_INV_R_REQUEST_FRAME_ID (0x202u)
#define PRIMARY_INV_L_RESPONSE_FRAME_ID (0x181u)
#define PRIMARY_INV_R_RESPONSE_FRAME_ID (0x182u)
#define PRIMARY_FLASH_CELLBOARD_0_TX_FRAME_ID (0x10u)
#define PRIMARY_FLASH_CELLBOARD_0_RX_FRAME_ID (0x11u)
#define PRIMARY_FLASH_CELLBOARD_1_TX_FRAME_ID (0x12u)
#define PRIMARY_FLASH_CELLBOARD_1_RX_FRAME_ID (0x13u)
#define PRIMARY_FLASH_CELLBOARD_2_TX_FRAME_ID (0x14u)
#define PRIMARY_FLASH_CELLBOARD_2_RX_FRAME_ID (0x15u)
#define PRIMARY_FLASH_CELLBOARD_3_TX_FRAME_ID (0x16u)
#define PRIMARY_FLASH_CELLBOARD_3_RX_FRAME_ID (0x17u)
#define PRIMARY_FLASH_CELLBOARD_4_TX_FRAME_ID (0x18u)
#define PRIMARY_FLASH_CELLBOARD_4_RX_FRAME_ID (0x19u)
#define PRIMARY_FLASH_CELLBOARD_5_TX_FRAME_ID (0x1au)
#define PRIMARY_FLASH_CELLBOARD_5_RX_FRAME_ID (0x1bu)
#define PRIMARY_FLASH_BMS_HV_TX_FRAME_ID (0x7e1u)
#define PRIMARY_FLASH_BMS_HV_RX_FRAME_ID (0x667u)
#define PRIMARY_FLASH_BMS_LV_TX_FRAME_ID (0x7f1u)
#define PRIMARY_FLASH_BMS_LV_RX_FRAME_ID (0x677u)
#define PRIMARY_BRUSA_NLG5_CTL_FRAME_ID (0x26au)
#define PRIMARY_BRUSA_ST_FRAME_ID (0x262u)
#define PRIMARY_BRUSA_ACT_I_FRAME_ID (0x263u)
#define PRIMARY_BRUSA_ACT_II_FRAME_ID (0x264u)
#define PRIMARY_BRUSA_TEMP_FRAME_ID (0x265u)
#define PRIMARY_BRUSA_ERR_FRAME_ID (0x266u)
#define PRIMARY_CONTROL_OUTPUT_FRAME_ID (0x122u)
#define PRIMARY_LC_RESET_FRAME_ID (0x207u)

/* Frame lengths in bytes. */
#define PRIMARY_INVERTER_L_SEND_LENGTH (5u)
#define PRIMARY_INVERTER_L_RCV_LENGTH (6u)
#define PRIMARY_INVERTER_R_SEND_LENGTH (5u)
#define PRIMARY_INVERTER_R_RCV_LENGTH (6u)
#define PRIMARY_BMS_HV_JMP_TO_BLT_LENGTH (0u)
#define PRIMARY_BMS_LV_JMP_TO_BLT_LENGTH (0u)
#define PRIMARY_STEER_VERSION_LENGTH (40u)
#define PRIMARY_DAS_VERSION_LENGTH (40u)
#define PRIMARY_HV_VERSION_LENGTH (40u)
#define PRIMARY_LV_VERSION_LENGTH (40u)
#define PRIMARY_TLM_VERSION_LENGTH (40u)
#define PRIMARY_TIMESTAMP_LENGTH (32u)
#define PRIMARY_AMBIENT_TEMPERATURE_LENGTH (16u)
#define PRIMARY_DATA_LOGGER_LENGTH (64u)
#define PRIMARY_SET_TLM_STATUS_LENGTH (1u)
#define PRIMARY_TLM_STATUS_LENGTH (1u)
#define PRIMARY_STEER_SYSTEM_STATUS_LENGTH (8u)
#define PRIMARY_HV_VOLTAGE_LENGTH (80u)
#define PRIMARY_HV_CURRENT_LENGTH (112u)
#define PRIMARY_HV_TEMP_LENGTH (48u)
#define PRIMARY_HV_ERRORS_LENGTH (28u)
#define PRIMARY_HV_CAN_FORWARD_LENGTH (1u)
#define PRIMARY_HV_FANS_OVERRIDE_LENGTH (33u)
#define PRIMARY_HV_CAN_FORWARD_STATUS_LENGTH (1u)
#define PRIMARY_HV_FANS_OVERRIDE_STATUS_LENGTH (33u)
#define PRIMARY_HV_FEEDBACKS_STATUS_LENGTH (38u)
#define PRIMARY_HV_IMD_STATUS_LENGTH (34u)
#define PRIMARY_TS_STATUS_DAS_LENGTH (1u)
#define PRIMARY_TS_STATUS_STEER_LENGTH (1u)
#define PRIMARY_TS_STATUS_HANDCART_LENGTH (1u)
#define PRIMARY_SET_TS_STATUS_DAS_LENGTH (1u)
#define PRIMARY_SET_TS_STATUS_HANDCART_LENGTH (1u)
#define PRIMARY_STEER_STATUS_LENGTH (24u)
#define PRIMARY_SET_CAR_STATUS_LENGTH (1u)
#define PRIMARY_SET_PEDALS_RANGE_LENGTH (2u)
#define PRIMARY_SET_STEERING_ANGLE_RANGE_LENGTH (1u)
#define PRIMARY_CAR_STATUS_LENGTH (3u)
#define PRIMARY_DAS_ERRORS_LENGTH (9u)
#define PRIMARY_LV_CURRENT_LENGTH (32u)
#define PRIMARY_LV_VOLTAGE_LENGTH (32u)
#define PRIMARY_LV_TOTAL_VOLTAGE_LENGTH (8u)
#define PRIMARY_LV_TEMPERATURE_LENGTH (128u)
#define PRIMARY_COOLING_STATUS_LENGTH (64u)
#define PRIMARY_SET_RADIATOR_SPEED_LENGTH (32u)
#define PRIMARY_SET_PUMPS_SPEED_LENGTH (32u)
#define PRIMARY_SET_INVERTER_CONNECTION_STATUS_LENGTH (1u)
#define PRIMARY_INVERTER_CONNECTION_STATUS_LENGTH (1u)
#define PRIMARY_LV_ERRORS_LENGTH (44u)
#define PRIMARY_SHUTDOWN_STATUS_LENGTH (2u)
#define PRIMARY_MARKER_LENGTH (0u)
#define PRIMARY_HV_CELLS_VOLTAGE_LENGTH (32u)
#define PRIMARY_HV_CELLS_TEMP_LENGTH (104u)
#define PRIMARY_HV_CELL_BALANCING_STATUS_LENGTH (1u)
#define PRIMARY_SET_CELL_BALANCING_STATUS_LENGTH (1u)
#define PRIMARY_HANDCART_STATUS_LENGTH (1u)
#define PRIMARY_SPEED_LENGTH (128u)
#define PRIMARY_INV_L_REQUEST_LENGTH (64u)
#define PRIMARY_INV_R_REQUEST_LENGTH (64u)
#define PRIMARY_INV_L_RESPONSE_LENGTH (64u)
#define PRIMARY_INV_R_RESPONSE_LENGTH (64u)
#define PRIMARY_FLASH_CELLBOARD_0_TX_LENGTH (0u)
#define PRIMARY_FLASH_CELLBOARD_0_RX_LENGTH (0u)
#define PRIMARY_FLASH_CELLBOARD_1_TX_LENGTH (0u)
#define PRIMARY_FLASH_CELLBOARD_1_RX_LENGTH (0u)
#define PRIMARY_FLASH_CELLBOARD_2_TX_LENGTH (0u)
#define PRIMARY_FLASH_CELLBOARD_2_RX_LENGTH (0u)
#define PRIMARY_FLASH_CELLBOARD_3_TX_LENGTH (0u)
#define PRIMARY_FLASH_CELLBOARD_3_RX_LENGTH (0u)
#define PRIMARY_FLASH_CELLBOARD_4_TX_LENGTH (0u)
#define PRIMARY_FLASH_CELLBOARD_4_RX_LENGTH (0u)
#define PRIMARY_FLASH_CELLBOARD_5_TX_LENGTH (0u)
#define PRIMARY_FLASH_CELLBOARD_5_RX_LENGTH (0u)
#define PRIMARY_FLASH_BMS_HV_TX_LENGTH (0u)
#define PRIMARY_FLASH_BMS_HV_RX_LENGTH (0u)
#define PRIMARY_FLASH_BMS_LV_TX_LENGTH (0u)
#define PRIMARY_FLASH_BMS_LV_RX_LENGTH (0u)
#define PRIMARY_BRUSA_NLG5_CTL_LENGTH (0u)
#define PRIMARY_BRUSA_ST_LENGTH (0u)
#define PRIMARY_BRUSA_ACT_I_LENGTH (0u)
#define PRIMARY_BRUSA_ACT_II_LENGTH (0u)
#define PRIMARY_BRUSA_TEMP_LENGTH (0u)
#define PRIMARY_BRUSA_ERR_LENGTH (0u)
#define PRIMARY_CONTROL_OUTPUT_LENGTH (128u)
#define PRIMARY_LC_RESET_LENGTH (0u)

/* LENGTH IN BYTES */

#define PRIMARY_INVERTER_L_SEND_SIZE (1u)
#define PRIMARY_INVERTER_L_RCV_SIZE (1u)
#define PRIMARY_INVERTER_R_SEND_SIZE (1u)
#define PRIMARY_INVERTER_R_RCV_SIZE (1u)
#define PRIMARY_BMS_HV_JMP_TO_BLT_SIZE (0u)
#define PRIMARY_BMS_LV_JMP_TO_BLT_SIZE (0u)
#define PRIMARY_STEER_VERSION_SIZE (5u)
#define PRIMARY_DAS_VERSION_SIZE (5u)
#define PRIMARY_HV_VERSION_SIZE (5u)
#define PRIMARY_LV_VERSION_SIZE (5u)
#define PRIMARY_TLM_VERSION_SIZE (5u)
#define PRIMARY_TIMESTAMP_SIZE (4u)
#define PRIMARY_AMBIENT_TEMPERATURE_SIZE (2u)
#define PRIMARY_DATA_LOGGER_SIZE (8u)
#define PRIMARY_SET_TLM_STATUS_SIZE (1u)
#define PRIMARY_TLM_STATUS_SIZE (1u)
#define PRIMARY_STEER_SYSTEM_STATUS_SIZE (1u)
#define PRIMARY_HV_VOLTAGE_SIZE (10u)
#define PRIMARY_HV_CURRENT_SIZE (14u)
#define PRIMARY_HV_TEMP_SIZE (6u)
#define PRIMARY_HV_ERRORS_SIZE (4u)
#define PRIMARY_HV_CAN_FORWARD_SIZE (1u)
#define PRIMARY_HV_FANS_OVERRIDE_SIZE (5u)
#define PRIMARY_HV_CAN_FORWARD_STATUS_SIZE (1u)
#define PRIMARY_HV_FANS_OVERRIDE_STATUS_SIZE (5u)
#define PRIMARY_HV_FEEDBACKS_STATUS_SIZE (5u)
#define PRIMARY_HV_IMD_STATUS_SIZE (5u)
#define PRIMARY_TS_STATUS_DAS_SIZE (1u)
#define PRIMARY_TS_STATUS_STEER_SIZE (1u)
#define PRIMARY_TS_STATUS_HANDCART_SIZE (1u)
#define PRIMARY_SET_TS_STATUS_DAS_SIZE (1u)
#define PRIMARY_SET_TS_STATUS_HANDCART_SIZE (1u)
#define PRIMARY_STEER_STATUS_SIZE (3u)
#define PRIMARY_SET_CAR_STATUS_SIZE (1u)
#define PRIMARY_SET_PEDALS_RANGE_SIZE (1u)
#define PRIMARY_SET_STEERING_ANGLE_RANGE_SIZE (1u)
#define PRIMARY_CAR_STATUS_SIZE (1u)
#define PRIMARY_DAS_ERRORS_SIZE (2u)
#define PRIMARY_LV_CURRENT_SIZE (4u)
#define PRIMARY_LV_VOLTAGE_SIZE (4u)
#define PRIMARY_LV_TOTAL_VOLTAGE_SIZE (1u)
#define PRIMARY_LV_TEMPERATURE_SIZE (16u)
#define PRIMARY_COOLING_STATUS_SIZE (8u)
#define PRIMARY_SET_RADIATOR_SPEED_SIZE (4u)
#define PRIMARY_SET_PUMPS_SPEED_SIZE (4u)
#define PRIMARY_SET_INVERTER_CONNECTION_STATUS_SIZE (1u)
#define PRIMARY_INVERTER_CONNECTION_STATUS_SIZE (1u)
#define PRIMARY_LV_ERRORS_SIZE (6u)
#define PRIMARY_SHUTDOWN_STATUS_SIZE (1u)
#define PRIMARY_MARKER_SIZE (0u)
#define PRIMARY_HV_CELLS_VOLTAGE_SIZE (4u)
#define PRIMARY_HV_CELLS_TEMP_SIZE (13u)
#define PRIMARY_HV_CELL_BALANCING_STATUS_SIZE (1u)
#define PRIMARY_SET_CELL_BALANCING_STATUS_SIZE (1u)
#define PRIMARY_HANDCART_STATUS_SIZE (1u)
#define PRIMARY_SPEED_SIZE (16u)
#define PRIMARY_INV_L_REQUEST_SIZE (8u)
#define PRIMARY_INV_R_REQUEST_SIZE (8u)
#define PRIMARY_INV_L_RESPONSE_SIZE (8u)
#define PRIMARY_INV_R_RESPONSE_SIZE (8u)
#define PRIMARY_FLASH_CELLBOARD_0_TX_SIZE (0u)
#define PRIMARY_FLASH_CELLBOARD_0_RX_SIZE (0u)
#define PRIMARY_FLASH_CELLBOARD_1_TX_SIZE (0u)
#define PRIMARY_FLASH_CELLBOARD_1_RX_SIZE (0u)
#define PRIMARY_FLASH_CELLBOARD_2_TX_SIZE (0u)
#define PRIMARY_FLASH_CELLBOARD_2_RX_SIZE (0u)
#define PRIMARY_FLASH_CELLBOARD_3_TX_SIZE (0u)
#define PRIMARY_FLASH_CELLBOARD_3_RX_SIZE (0u)
#define PRIMARY_FLASH_CELLBOARD_4_TX_SIZE (0u)
#define PRIMARY_FLASH_CELLBOARD_4_RX_SIZE (0u)
#define PRIMARY_FLASH_CELLBOARD_5_TX_SIZE (0u)
#define PRIMARY_FLASH_CELLBOARD_5_RX_SIZE (0u)
#define PRIMARY_FLASH_BMS_HV_TX_SIZE (0u)
#define PRIMARY_FLASH_BMS_HV_RX_SIZE (0u)
#define PRIMARY_FLASH_BMS_LV_TX_SIZE (0u)
#define PRIMARY_FLASH_BMS_LV_RX_SIZE (0u)
#define PRIMARY_BRUSA_NLG5_CTL_SIZE (0u)
#define PRIMARY_BRUSA_ST_SIZE (0u)
#define PRIMARY_BRUSA_ACT_I_SIZE (0u)
#define PRIMARY_BRUSA_ACT_II_SIZE (0u)
#define PRIMARY_BRUSA_TEMP_SIZE (0u)
#define PRIMARY_BRUSA_ERR_SIZE (0u)
#define PRIMARY_CONTROL_OUTPUT_SIZE (16u)
#define PRIMARY_LC_RESET_SIZE (0u)

/* Extended or standard frame types. */
#define PRIMARY_INVERTER_L_SEND_IS_EXTENDED (0)
#define PRIMARY_INVERTER_L_RCV_IS_EXTENDED (0)
#define PRIMARY_INVERTER_R_SEND_IS_EXTENDED (0)
#define PRIMARY_INVERTER_R_RCV_IS_EXTENDED (0)
#define PRIMARY_BMS_HV_JMP_TO_BLT_IS_EXTENDED (0)
#define PRIMARY_BMS_LV_JMP_TO_BLT_IS_EXTENDED (0)
#define PRIMARY_STEER_VERSION_IS_EXTENDED (0)
#define PRIMARY_DAS_VERSION_IS_EXTENDED (0)
#define PRIMARY_HV_VERSION_IS_EXTENDED (0)
#define PRIMARY_LV_VERSION_IS_EXTENDED (0)
#define PRIMARY_TLM_VERSION_IS_EXTENDED (0)
#define PRIMARY_TIMESTAMP_IS_EXTENDED (0)
#define PRIMARY_AMBIENT_TEMPERATURE_IS_EXTENDED (0)
#define PRIMARY_DATA_LOGGER_IS_EXTENDED (0)
#define PRIMARY_SET_TLM_STATUS_IS_EXTENDED (0)
#define PRIMARY_TLM_STATUS_IS_EXTENDED (0)
#define PRIMARY_STEER_SYSTEM_STATUS_IS_EXTENDED (0)
#define PRIMARY_HV_VOLTAGE_IS_EXTENDED (0)
#define PRIMARY_HV_CURRENT_IS_EXTENDED (0)
#define PRIMARY_HV_TEMP_IS_EXTENDED (0)
#define PRIMARY_HV_ERRORS_IS_EXTENDED (0)
#define PRIMARY_HV_CAN_FORWARD_IS_EXTENDED (0)
#define PRIMARY_HV_FANS_OVERRIDE_IS_EXTENDED (0)
#define PRIMARY_HV_CAN_FORWARD_STATUS_IS_EXTENDED (0)
#define PRIMARY_HV_FANS_OVERRIDE_STATUS_IS_EXTENDED (0)
#define PRIMARY_HV_FEEDBACKS_STATUS_IS_EXTENDED (0)
#define PRIMARY_HV_IMD_STATUS_IS_EXTENDED (0)
#define PRIMARY_TS_STATUS_DAS_IS_EXTENDED (0)
#define PRIMARY_TS_STATUS_STEER_IS_EXTENDED (0)
#define PRIMARY_TS_STATUS_HANDCART_IS_EXTENDED (0)
#define PRIMARY_SET_TS_STATUS_DAS_IS_EXTENDED (0)
#define PRIMARY_SET_TS_STATUS_HANDCART_IS_EXTENDED (0)
#define PRIMARY_STEER_STATUS_IS_EXTENDED (0)
#define PRIMARY_SET_CAR_STATUS_IS_EXTENDED (0)
#define PRIMARY_SET_PEDALS_RANGE_IS_EXTENDED (0)
#define PRIMARY_SET_STEERING_ANGLE_RANGE_IS_EXTENDED (0)
#define PRIMARY_CAR_STATUS_IS_EXTENDED (0)
#define PRIMARY_DAS_ERRORS_IS_EXTENDED (0)
#define PRIMARY_LV_CURRENT_IS_EXTENDED (0)
#define PRIMARY_LV_VOLTAGE_IS_EXTENDED (0)
#define PRIMARY_LV_TOTAL_VOLTAGE_IS_EXTENDED (0)
#define PRIMARY_LV_TEMPERATURE_IS_EXTENDED (0)
#define PRIMARY_COOLING_STATUS_IS_EXTENDED (0)
#define PRIMARY_SET_RADIATOR_SPEED_IS_EXTENDED (0)
#define PRIMARY_SET_PUMPS_SPEED_IS_EXTENDED (0)
#define PRIMARY_SET_INVERTER_CONNECTION_STATUS_IS_EXTENDED (0)
#define PRIMARY_INVERTER_CONNECTION_STATUS_IS_EXTENDED (0)
#define PRIMARY_LV_ERRORS_IS_EXTENDED (0)
#define PRIMARY_SHUTDOWN_STATUS_IS_EXTENDED (0)
#define PRIMARY_MARKER_IS_EXTENDED (0)
#define PRIMARY_HV_CELLS_VOLTAGE_IS_EXTENDED (0)
#define PRIMARY_HV_CELLS_TEMP_IS_EXTENDED (0)
#define PRIMARY_HV_CELL_BALANCING_STATUS_IS_EXTENDED (0)
#define PRIMARY_SET_CELL_BALANCING_STATUS_IS_EXTENDED (0)
#define PRIMARY_HANDCART_STATUS_IS_EXTENDED (0)
#define PRIMARY_SPEED_IS_EXTENDED (0)
#define PRIMARY_INV_L_REQUEST_IS_EXTENDED (0)
#define PRIMARY_INV_R_REQUEST_IS_EXTENDED (0)
#define PRIMARY_INV_L_RESPONSE_IS_EXTENDED (0)
#define PRIMARY_INV_R_RESPONSE_IS_EXTENDED (0)
#define PRIMARY_FLASH_CELLBOARD_0_TX_IS_EXTENDED (0)
#define PRIMARY_FLASH_CELLBOARD_0_RX_IS_EXTENDED (0)
#define PRIMARY_FLASH_CELLBOARD_1_TX_IS_EXTENDED (0)
#define PRIMARY_FLASH_CELLBOARD_1_RX_IS_EXTENDED (0)
#define PRIMARY_FLASH_CELLBOARD_2_TX_IS_EXTENDED (0)
#define PRIMARY_FLASH_CELLBOARD_2_RX_IS_EXTENDED (0)
#define PRIMARY_FLASH_CELLBOARD_3_TX_IS_EXTENDED (0)
#define PRIMARY_FLASH_CELLBOARD_3_RX_IS_EXTENDED (0)
#define PRIMARY_FLASH_CELLBOARD_4_TX_IS_EXTENDED (0)
#define PRIMARY_FLASH_CELLBOARD_4_RX_IS_EXTENDED (0)
#define PRIMARY_FLASH_CELLBOARD_5_TX_IS_EXTENDED (0)
#define PRIMARY_FLASH_CELLBOARD_5_RX_IS_EXTENDED (0)
#define PRIMARY_FLASH_BMS_HV_TX_IS_EXTENDED (0)
#define PRIMARY_FLASH_BMS_HV_RX_IS_EXTENDED (0)
#define PRIMARY_FLASH_BMS_LV_TX_IS_EXTENDED (0)
#define PRIMARY_FLASH_BMS_LV_RX_IS_EXTENDED (0)
#define PRIMARY_BRUSA_NLG5_CTL_IS_EXTENDED (0)
#define PRIMARY_BRUSA_ST_IS_EXTENDED (0)
#define PRIMARY_BRUSA_ACT_I_IS_EXTENDED (0)
#define PRIMARY_BRUSA_ACT_II_IS_EXTENDED (0)
#define PRIMARY_BRUSA_TEMP_IS_EXTENDED (0)
#define PRIMARY_BRUSA_ERR_IS_EXTENDED (0)
#define PRIMARY_CONTROL_OUTPUT_IS_EXTENDED (0)
#define PRIMARY_LC_RESET_IS_EXTENDED (0)

/* Frame cycle times in milliseconds. */
#define PRIMARY_STEER_VERSION_CYCLE_TIME_MS (1000u)
#define PRIMARY_DAS_VERSION_CYCLE_TIME_MS (1000u)
#define PRIMARY_HV_VERSION_CYCLE_TIME_MS (1000u)
#define PRIMARY_LV_VERSION_CYCLE_TIME_MS (1000u)
#define PRIMARY_TLM_VERSION_CYCLE_TIME_MS (1000u)
#define PRIMARY_TIMESTAMP_CYCLE_TIME_MS (1000u)
#define PRIMARY_AMBIENT_TEMPERATURE_CYCLE_TIME_MS (1000u)
#define PRIMARY_DATA_LOGGER_CYCLE_TIME_MS (1000u)
#define PRIMARY_TLM_STATUS_CYCLE_TIME_MS (1000u)
#define PRIMARY_STEER_SYSTEM_STATUS_CYCLE_TIME_MS (1000u)
#define PRIMARY_HV_VOLTAGE_CYCLE_TIME_MS (10u)
#define PRIMARY_HV_CURRENT_CYCLE_TIME_MS (10u)
#define PRIMARY_HV_TEMP_CYCLE_TIME_MS (100u)
#define PRIMARY_HV_ERRORS_CYCLE_TIME_MS (10u)
#define PRIMARY_TS_STATUS_DAS_CYCLE_TIME_MS (10u)
#define PRIMARY_TS_STATUS_STEER_CYCLE_TIME_MS (10u)
#define PRIMARY_TS_STATUS_HANDCART_CYCLE_TIME_MS (10u)
#define PRIMARY_SET_TS_STATUS_DAS_CYCLE_TIME_MS (100u)
#define PRIMARY_SET_TS_STATUS_HANDCART_CYCLE_TIME_MS (100u)
#define PRIMARY_STEER_STATUS_CYCLE_TIME_MS (100u)
#define PRIMARY_CAR_STATUS_CYCLE_TIME_MS (100u)
#define PRIMARY_DAS_ERRORS_CYCLE_TIME_MS (10u)
#define PRIMARY_LV_CURRENT_CYCLE_TIME_MS (500u)
#define PRIMARY_LV_VOLTAGE_CYCLE_TIME_MS (100u)
#define PRIMARY_LV_TOTAL_VOLTAGE_CYCLE_TIME_MS (100u)
#define PRIMARY_LV_TEMPERATURE_CYCLE_TIME_MS (100u)
#define PRIMARY_COOLING_STATUS_CYCLE_TIME_MS (1000u)
#define PRIMARY_SET_INVERTER_CONNECTION_STATUS_CYCLE_TIME_MS (100u)
#define PRIMARY_INVERTER_CONNECTION_STATUS_CYCLE_TIME_MS (100u)
#define PRIMARY_LV_ERRORS_CYCLE_TIME_MS (10u)
#define PRIMARY_SHUTDOWN_STATUS_CYCLE_TIME_MS (500u)
#define PRIMARY_HV_CELLS_VOLTAGE_CYCLE_TIME_MS (100u)
#define PRIMARY_HV_CELLS_TEMP_CYCLE_TIME_MS (100u)
#define PRIMARY_HV_CELL_BALANCING_STATUS_CYCLE_TIME_MS (500u)
#define PRIMARY_HANDCART_STATUS_CYCLE_TIME_MS (500u)
#define PRIMARY_SPEED_CYCLE_TIME_MS (10u)
#define PRIMARY_INV_L_REQUEST_CYCLE_TIME_MS (10u)
#define PRIMARY_INV_R_REQUEST_CYCLE_TIME_MS (10u)
#define PRIMARY_INV_L_RESPONSE_CYCLE_TIME_MS (100u)
#define PRIMARY_INV_R_RESPONSE_CYCLE_TIME_MS (100u)
#define PRIMARY_CONTROL_OUTPUT_CYCLE_TIME_MS (100u)

/* Signal choices. */
#define PRIMARY_INVERTER_L_SEND_SEND_MUX_ID_04_USER_KEY_CHOICE (4u)
#define PRIMARY_INVERTER_L_SEND_SEND_MUX_ID_05_MOTOR_F_NOM_CHOICE (5u)
#define PRIMARY_INVERTER_L_SEND_SEND_MUX_ID_07_FU_T_DC_CHOICE (7u)
#define PRIMARY_INVERTER_L_SEND_SEND_MUX_ID_08_FU_V_DC_CHOICE (8u)
#define PRIMARY_INVERTER_L_SEND_SEND_MUX_ID_09_FU_SPECIAL_CHOICE (9u)
#define PRIMARY_INVERTER_L_SEND_SEND_MUX_ID_0A_FU_U_MIN_CHOICE (10u)
#define PRIMARY_INVERTER_L_SEND_SEND_MUX_ID_0B_FU_F_MIN_CHOICE (11u)
#define PRIMARY_INVERTER_L_SEND_SEND_MUX_ID_0C_FU_V_CORNER_CHOICE (12u)
#define PRIMARY_INVERTER_L_SEND_SEND_MUX_ID_0D_FU_F_CORNER_CHOICE (13u)
#define PRIMARY_INVERTER_L_SEND_SEND_MUX_ID_0E_MOTOR_COS_PHI_CHOICE (14u)
#define PRIMARY_INVERTER_L_SEND_SEND_MUX_ID_0F_FU_EXTRA_CHOICE (15u)
#define PRIMARY_INVERTER_L_SEND_SEND_MUX_ID_10_OSZI_CHANNEL_CHOICE (16u)
#define PRIMARY_INVERTER_L_SEND_SEND_MUX_ID_12_OSZI_TRIGER_LEVEL_CHOICE (18u)
#define PRIMARY_INVERTER_L_SEND_SEND_MUX_ID_13_OSZI_TRIGER_EDGE_CHOICE (19u)
#define PRIMARY_INVERTER_L_SEND_SEND_MUX_ID_14_OSZI_TRIGER_SOURCE_CHOICE (20u)
#define PRIMARY_INVERTER_L_SEND_SEND_MUX_ID_15_OSZI_SOURCE_CHOICE (21u)
#define PRIMARY_INVERTER_L_SEND_SEND_MUX_ID_16_OSZI_SKIP_CHOICE (22u)
#define PRIMARY_INVERTER_L_SEND_SEND_MUX_ID_17_OSZI_READ_CMD_CHOICE (23u)
#define PRIMARY_INVERTER_L_SEND_SEND_MUX_ID_18_OSZI_RUN_CMD_CHOICE (24u)
#define PRIMARY_INVERTER_L_SEND_SEND_MUX_ID_1A_CALIB_REF_VALUE_CHOICE (26u)
#define PRIMARY_INVERTER_L_SEND_SEND_MUX_ID_1C_PID_I_KP_CHOICE (28u)
#define PRIMARY_INVERTER_L_SEND_SEND_MUX_ID_1D_PID_I_TI_CHOICE (29u)
#define PRIMARY_INVERTER_L_SEND_SEND_MUX_ID_1E_CUTOFFDIG_CHOICE (30u)
#define PRIMARY_INVERTER_L_SEND_SEND_MUX_ID_21_ID_SETDIG_CHOICE (33u)
#define PRIMARY_INVERTER_L_SEND_SEND_MUX_ID_25_I_DELTA_RAMP_CHOICE (37u)
#define PRIMARY_INVERTER_L_SEND_SEND_MUX_ID_2B_PID_I_TIM_CHOICE (43u)
#define PRIMARY_INVERTER_L_SEND_SEND_MUX_ID_2C_PID_N_KP_CHOICE (44u)
#define PRIMARY_INVERTER_L_SEND_SEND_MUX_ID_2D_PID_N_TI_CHOICE (45u)
#define PRIMARY_INVERTER_L_SEND_SEND_MUX_ID_2E_PID_N_TD_CHOICE (46u)
#define PRIMARY_INVERTER_L_SEND_SEND_MUX_ID_2F_AIN_IN_1_OFFSSCALE_CHOICE (47u)
#define PRIMARY_INVERTER_L_SEND_SEND_MUX_ID_31_N_SETDIG_CHOICE (49u)
#define PRIMARY_INVERTER_L_SEND_SEND_MUX_ID_34_N_LIM_CHOICE (52u)
#define PRIMARY_INVERTER_L_SEND_SEND_MUX_ID_35_ACC_RAMPS_CHOICE (53u)
#define PRIMARY_INVERTER_L_SEND_SEND_MUX_ID_36_COMMANDSOURCE_CHOICE (54u)
#define PRIMARY_INVERTER_L_SEND_SEND_MUX_ID_3B_PID_N_TIM_CHOICE (59u)
#define PRIMARY_INVERTER_L_SEND_SEND_MUX_ID_3C_I_DERATING_N_PERC_CHOICE (60u)
#define PRIMARY_INVERTER_L_SEND_SEND_MUX_ID_3D_READ_CMD_CHOICE (61u)
#define PRIMARY_INVERTER_L_SEND_SEND_MUX_ID_3E_N_LIM_MINUS_CHOICE (62u)
#define PRIMARY_INVERTER_L_SEND_SEND_MUX_ID_3F_N_LIM_PLUS_CHOICE (63u)
#define PRIMARY_INVERTER_L_SEND_SEND_MUX_ID_44_FEEDBACK_OFFSET_ANGLE_CHOICE (68u)
#define PRIMARY_INVERTER_L_SEND_SEND_MUX_ID_46_I_LIM_DIG_PERC_CHOICE (70u)
#define PRIMARY_INVERTER_L_SEND_SEND_MUX_ID_4C_I_DERATING_TE_CHOICE (76u)
#define PRIMARY_INVERTER_L_SEND_SEND_MUX_ID_4D_MOTOR_I_MAX_EFF_ARMS_CHOICE (77u)
#define PRIMARY_INVERTER_L_SEND_SEND_MUX_ID_4E_MOTOR_I_NOM_EFF_ARMS_CHOICE (78u)
#define PRIMARY_INVERTER_L_SEND_SEND_MUX_ID_4F_MOTOR_POLE_NUMBER_CHOICE (79u)
#define PRIMARY_INVERTER_L_SEND_SEND_MUX_ID_50_AIN_IN_1_CUTOFF_CHOICE (80u)
#define PRIMARY_INVERTER_L_SEND_SEND_MUX_ID_51_KERN_MODE_STATE_CHOICE (81u)
#define PRIMARY_INVERTER_L_SEND_SEND_MUX_ID_53_AIN_IN_2_CUTOFF_CHOICE (83u)
#define PRIMARY_INVERTER_L_SEND_SEND_MUX_ID_58_I_DERATING_TD_CHOICE (88u)
#define PRIMARY_INVERTER_L_SEND_SEND_MUX_ID_59_MOTOR_NOMINAL_SPEED_CHOICE (89u)
#define PRIMARY_INVERTER_L_SEND_SEND_MUX_ID_5A_DEVICE_OPTIONS_CHOICE (90u)
#define PRIMARY_INVERTER_L_SEND_SEND_MUX_ID_5B_PID_N_KACC_CHOICE (91u)
#define PRIMARY_INVERTER_L_SEND_SEND_MUX_ID_5E_SPEED_FILTER_CHOICE (94u)
#define PRIMARY_INVERTER_L_SEND_SEND_MUX_ID_60_AIN_IN_X_FILTER_CHOICE (96u)
#define PRIMARY_INVERTER_L_SEND_SEND_MUX_ID_62_SERIALNUMBER_CHOICE (98u)
#define PRIMARY_INVERTER_L_SEND_SEND_MUX_ID_64_DEVICE_MAINS_SUPPLY_V_CHOICE (100u)
#define PRIMARY_INVERTER_L_SEND_SEND_MUX_ID_65_REGEN_RESISTOR_P_AND_R_CHOICE (101u)
#define PRIMARY_INVERTER_L_SEND_SEND_MUX_ID_67_DEVICE_TYPE_CHOICE (103u)
#define PRIMARY_INVERTER_L_SEND_SEND_MUX_ID_68_CAN_ID_RX_CHOICE (104u)
#define PRIMARY_INVERTER_L_SEND_SEND_MUX_ID_69_CAN_ID_TX_CHOICE (105u)
#define PRIMARY_INVERTER_L_SEND_SEND_MUX_ID_6A_POS_PID_KP_CHOICE (106u)
#define PRIMARY_INVERTER_L_SEND_SEND_MUX_ID_6B_POS_PID_TI_CHOICE (107u)
#define PRIMARY_INVERTER_L_SEND_SEND_MUX_ID_6C_POS_PID_TD_CHOICE (108u)
#define PRIMARY_INVERTER_L_SEND_SEND_MUX_ID_6E_POS_DESTINATION_CHOICE (110u)
#define PRIMARY_INVERTER_L_SEND_SEND_MUX_ID_71_POS_PID_TIM_CHOICE (113u)
#define PRIMARY_INVERTER_L_SEND_SEND_MUX_ID_72_POS_OFFSETREFERENCE_CHOICE (114u)
#define PRIMARY_INVERTER_L_SEND_SEND_MUX_ID_73_CAN_NBT_CHOICE (115u)
#define PRIMARY_INVERTER_L_SEND_SEND_MUX_ID_75_POS_REF_RESO_EDGE_CHOICE (117u)
#define PRIMARY_INVERTER_L_SEND_SEND_MUX_ID_76_POS_CALIB_SPEED_1_CHOICE (118u)
#define PRIMARY_INVERTER_L_SEND_SEND_MUX_ID_77_POS_CALIB_SPEED_2_CHOICE (119u)
#define PRIMARY_INVERTER_L_SEND_SEND_MUX_ID_79_POS_TOL_WINDOW_CHOICE (121u)
#define PRIMARY_INVERTER_L_SEND_SEND_MUX_ID_7A_POS_PRESET_VALUE_CHOICE (122u)
#define PRIMARY_INVERTER_L_SEND_SEND_MUX_ID_7C_POS_NDRIVE_SCALE_CHOICE (124u)
#define PRIMARY_INVERTER_L_SEND_SEND_MUX_ID_7D_POS_NDRIVE_OFFSET_CHOICE (125u)
#define PRIMARY_INVERTER_L_SEND_SEND_MUX_ID_7E_POS_FB2_SCALE_FAC_EXT_CHOICE (126u)
#define PRIMARY_INVERTER_L_SEND_SEND_MUX_ID_7F_POS_OFFSET_SLACK_CHOICE (127u)
#define PRIMARY_INVERTER_L_SEND_SEND_MUX_ID_80_POS_DIFF_SLACK_CHOICE (128u)
#define PRIMARY_INVERTER_L_SEND_SEND_MUX_ID_83_FUNCTION_PARAMETER_READ_CHOICE (131u)
#define PRIMARY_INVERTER_L_SEND_SEND_MUX_ID_84_FUNCTION_PARAMETER_WRITE_CHOICE (132u)
#define PRIMARY_INVERTER_L_SEND_SEND_MUX_ID_85_FUNCTION_SPECIAL_CHOICE (133u)
#define PRIMARY_INVERTER_L_SEND_SEND_MUX_ID_88_CAN_ID_2_RX_CHOICE (136u)
#define PRIMARY_INVERTER_L_SEND_SEND_MUX_ID_89_CAN_ID_2_TX_CHOICE (137u)
#define PRIMARY_INVERTER_L_SEND_SEND_MUX_ID_8B_VOLTAGECONTROL_REF_CHOICE (139u)
#define PRIMARY_INVERTER_L_SEND_SEND_MUX_ID_8C_VOLTAGECONTROL_KP_CHOICE (140u)
#define PRIMARY_INVERTER_L_SEND_SEND_MUX_ID_8D_VOLTAGECONTROL_TI_CHOICE (141u)
#define PRIMARY_INVERTER_L_SEND_SEND_MUX_ID_8E_CLEAR_ERROR_LIST_CHOICE (142u)
#define PRIMARY_INVERTER_L_SEND_SEND_MUX_ID_90_M_SETDIG_CHOICE (144u)
#define PRIMARY_INVERTER_L_SEND_SEND_MUX_ID_A2_I_DERATING_TM_CHOICE (162u)
#define PRIMARY_INVERTER_L_SEND_SEND_MUX_ID_A3_MOTOR_TEMP_ERROR_LIM_CHOICE (163u)
#define PRIMARY_INVERTER_L_SEND_SEND_MUX_ID_A4_MOTOR_OPTIONS_CHOICE (164u)
#define PRIMARY_INVERTER_L_SEND_SEND_MUX_ID_A5_DEVICE_DC_BUS_MINMAX_LIM_CHOICE (165u)
#define PRIMARY_INVERTER_L_SEND_SEND_MUX_ID_A6_FB_INCREMENTSPERROT_CHOICE (166u)
#define PRIMARY_INVERTER_L_SEND_SEND_MUX_ID_A7_FB_POLE_NUMBER_CHOICE (167u)
#define PRIMARY_INVERTER_L_SEND_SEND_MUX_ID_B1_MOTOR_L_SIGMA_Q_CHOICE (177u)
#define PRIMARY_INVERTER_L_SEND_SEND_MUX_ID_B2_ID_NOMINAL_CHOICE (178u)
#define PRIMARY_INVERTER_L_SEND_SEND_MUX_ID_B3_MOTOR_MAGN_INDUCTANCE_CHOICE (179u)
#define PRIMARY_INVERTER_L_SEND_SEND_MUX_ID_B4_MOTOR_ROTOR_RESISTANCE_CHOICE (180u)
#define PRIMARY_INVERTER_L_SEND_SEND_MUX_ID_B5_ID_MINIMUM_CHOICE (181u)
#define PRIMARY_INVERTER_L_SEND_SEND_MUX_ID_B6_TIME_CONSTANT_ROTOR_CHOICE (182u)
#define PRIMARY_INVERTER_L_SEND_SEND_MUX_ID_BB_MOTOR_L_SIGMA_D_CHOICE (187u)
#define PRIMARY_INVERTER_L_SEND_SEND_MUX_ID_BC_MOTOR_STATOR_RESISTANCE_CHOICE (188u)
#define PRIMARY_INVERTER_L_SEND_SEND_MUX_ID_BD_TIME_CONSTANT_STATOR_CHOICE (189u)
#define PRIMARY_INVERTER_L_SEND_SEND_MUX_ID_BE_LOGICDEFINE_OF_END_1_CHOICE (190u)
#define PRIMARY_INVERTER_L_SEND_SEND_MUX_ID_BF_LOGICDEFINE_OF_END_2_CHOICE (191u)
#define PRIMARY_INVERTER_L_SEND_SEND_MUX_ID_C0_LOGICDEFINE_OF_DIN_1_CHOICE (192u)
#define PRIMARY_INVERTER_L_SEND_SEND_MUX_ID_C1_LOGICDEFINE_OF_DIN_2_CHOICE (193u)
#define PRIMARY_INVERTER_L_SEND_SEND_MUX_ID_C2_LOGICDEFINE_OF_OUT_1_CHOICE (194u)
#define PRIMARY_INVERTER_L_SEND_SEND_MUX_ID_C3_LOGICDEFINE_OF_OUT_2_CHOICE (195u)
#define PRIMARY_INVERTER_L_SEND_SEND_MUX_ID_C4_I_MAX_PK_PERC_CHOICE (196u)
#define PRIMARY_INVERTER_L_SEND_SEND_MUX_ID_C5_I_CON_EFF_PERC_CHOICE (197u)
#define PRIMARY_INVERTER_L_SEND_SEND_MUX_ID_C6_I_DEVICE_CHOICE (198u)
#define PRIMARY_INVERTER_L_SEND_SEND_MUX_ID_C7_RLIM_MRCP_RAMP_CHOICE (199u)
#define PRIMARY_INVERTER_L_SEND_SEND_MUX_ID_C8_NMAX100PERC_CHOICE (200u)
#define PRIMARY_INVERTER_L_SEND_SEND_MUX_ID_C9_CURRENTCONTROL_XKP_CHOICE (201u)
#define PRIMARY_INVERTER_L_SEND_SEND_MUX_ID_CA_BAT_OPR_LIMITS_CHOICE (202u)
#define PRIMARY_INVERTER_L_SEND_SEND_MUX_ID_CB_PID_I_KF_CHOICE (203u)
#define PRIMARY_INVERTER_L_SEND_SEND_MUX_ID_CD_CAR_MODE_CONFIG_CHOICE (205u)
#define PRIMARY_INVERTER_L_SEND_SEND_MUX_ID_D0_CAN_TIMEOUT_CHOICE (208u)
#define PRIMARY_INVERTER_L_SEND_SEND_MUX_ID_D1_VAR_1_CHOICE (209u)
#define PRIMARY_INVERTER_L_SEND_SEND_MUX_ID_D2_VAR_2_CHOICE (210u)
#define PRIMARY_INVERTER_L_SEND_SEND_MUX_ID_D3_VAR_3_CHOICE (211u)
#define PRIMARY_INVERTER_L_SEND_SEND_MUX_ID_D4_VAR_4_CHOICE (212u)
#define PRIMARY_INVERTER_L_SEND_SEND_MUX_ID_D7_AIN_IN_2_OFFSSCALE_CHOICE (215u)
#define PRIMARY_INVERTER_L_SEND_SEND_MUX_ID_DA_LOGICDEFINE_OF_OUT_3_CHOICE (218u)
#define PRIMARY_INVERTER_L_SEND_SEND_MUX_ID_DB_LOGICDEFINE_OF_OUT_4_CHOICE (219u)
#define PRIMARY_INVERTER_L_SEND_SEND_MUX_ID_DC_DAC_SOURCE_ID_CHOICE (220u)
#define PRIMARY_INVERTER_L_SEND_SEND_MUX_ID_ED_DEC_RAMPS_CHOICE (237u)
#define PRIMARY_INVERTER_L_SEND_SEND_MUX_ID_EE_V_SHUNT_CHOICE (238u)
#define PRIMARY_INVERTER_L_SEND_SEND_MUX_ID_F0_TIME_I_PEAK_CHOICE (240u)
#define PRIMARY_INVERTER_L_SEND_SEND_MUX_ID_F1_BRAKE_DELAY_CHOICE (241u)
#define PRIMARY_INVERTER_L_SEND_SEND_MUX_ID_F8_AXIS_LABEL_CHOICE (248u)

#define PRIMARY_INVERTER_L_SEND_CS_AIN_1_FORMAT_OFF_CHOICE (0u)
#define PRIMARY_INVERTER_L_SEND_CS_AIN_1_FORMAT__CMD_1_CHOICE (1u)
#define PRIMARY_INVERTER_L_SEND_CS_AIN_1_FORMAT__CMD_2_CHOICE (2u)
#define PRIMARY_INVERTER_L_SEND_CS_AIN_1_FORMAT_SQ_CMD__CHOICE (3u)

#define PRIMARY_INVERTER_L_SEND_READ_ID_05H_MOTOR_F_NOM_CHOICE (5u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_06H_MOTOR_V_NOM_CHOICE (6u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_07H_FU_T_DC_CHOICE (7u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_08H_FU_V_DC_CHOICE (8u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_09H_FU_SPECIAL_CHOICE (9u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_0AH_FU_U_MIN_CHOICE (10u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_0BH_FU_F_MIN_CHOICE (11u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_0CH_FU_V_CORNER_CHOICE (12u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_0DH_FU_F_CORNER_CHOICE (13u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_0EH_MOTOR_COS_PHI_CHOICE (14u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_0FH_FU_EXTRA_CHOICE (15u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_10H_OSZI_CHANNEL_CHOICE (16u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_11H_CONTROL_STATUS_CHOICE (17u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_12H_OSZI_TRIGER_LEVEL_CHOICE (18u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_13H_OSZI_TRIGER_EDGE_CHOICE (19u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_14H_OSZI_TRIGER_SOURCE_CHOICE (20u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_15H_OSZI_SOURCE_CHOICE (21u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_16H_OSZI_SKIP_CHOICE (22u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_17H_OSZI_READ_CMD_CHOICE (23u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_18H_OSZI_RUN_CMD_CHOICE (24u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_19H_PWM_ENUM_CHOICE (25u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_1AH_CALIB_REF_VALUE_CHOICE (26u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_1BH_FW_NR_CHOICE (27u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_1CH_I_KP_CHOICE (28u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_1DH_I_TI_CHOICE (29u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_1EH_CUTOFFDIG_CHOICE (30u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_1FH_I3_OFFSET_CHOICE (31u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_20H_I_ACTUAL_CHOICE (32u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_21H_ID_SETDIG_CHOICE (33u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_22H_I_CMD_RAMP_CHOICE (34u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_23H_ID_REF_CHOICE (35u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_24H_I_MAX_INUSE_CHOICE (36u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_25H_I_DELTA_RAMP_CHOICE (37u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_26H_I_CMD_CHOICE (38u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_27H_IQ_ACTUAL_CHOICE (39u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_28H_ID_ACTUAL_CHOICE (40u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_29H_VQ_OUTPUT_CHOICE (41u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_2AH_VD_OUTPUT_CHOICE (42u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_2BH_I_TIM_CHOICE (43u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_2CH_N_KP_CHOICE (44u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_2DH_N_TI_CHOICE (45u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_2EH_N_TD_CHOICE (46u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_2FH_AIN_IN_1_OFFSSCALE_CHOICE (47u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_30H_N_ACTUAL_CHOICE (48u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_31H_N_SETDIG_CHOICE (49u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_32H_N_CMD_RAMP_CHOICE (50u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_33H_N_ERROR_CHOICE (51u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_34H_N_LIM_CHOICE (52u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_35H_ACC_RAMPS_CHOICE (53u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_36H_COMMANDSOURCE_CHOICE (54u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_37H_DZR_SEQUENCER_VALUE_CHOICE (55u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_38H_IQ_ERROR_CHOICE (56u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_39H_ID_ERROR_CHOICE (57u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_3AH_M_CMD_RAMP_CHOICE (58u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_3BH_N_TIM_CHOICE (59u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_3CH_I_DERATING_N_PERC_CHOICE (60u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_3EH_N_LIM_MINUS_CHOICE (62u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_3FH_N_LIM_PLUS_CHOICE (63u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_40H_STATUS_MAP_CHOICE (64u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_41H_INCR_DELTA_CHOICE (65u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_42H_MOTORPOSITION_MECH_CHOICE (66u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_43H_MOTORPOSITION_ELEC_CHOICE (67u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_44H_FEEDBACK_OFFSET_ANGLE_CHOICE (68u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_45H_IXT_AND_REGENE_MONITOR_CHOICE (69u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_46H_I_LIM_DIG_PERC_CHOICE (70u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_48H_I_LIMIT_INUSE_CHOICE (72u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_49H_T_MOTOR_CHOICE (73u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_4AH_T_IGBT_CHOICE (74u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_4BH_T_AIR_INSIDE_CHOICE (75u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_4CH_I_DERATING_TE_CHOICE (76u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_4DH_MOTOR_I_MAX_EFF_CHOICE (77u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_4EH_MOTOR_I_NOM_EFF_CHOICE (78u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_4FH_MOTOR_POLE_CHOICE (79u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_50H_AIN_IN_1_CUTOFF_CHOICE (80u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_51H_KERN_MODE_STATE_CHOICE (81u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_52H_STATUS_MASK_CHOICE (82u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_53H_AIN_IN_2_CUTOFF_CHOICE (83u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_54H_I1_ACTUAL_CHOICE (84u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_55H_I2_ACTUAL_CHOICE (85u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_56H_I3_ACTUAL_CHOICE (86u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_57H_I_LIMIT_INUSE_RAMP_CHOICE (87u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_58H_I_DERATING_TD_CHOICE (88u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_59H_MOTOR_NOM_CHOICE (89u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_5AH_DEVICE_OPTIONS_CHOICE (90u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_5BH_SPEEDCONTROL_KACC_CHOICE (91u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_5CH_ROTOR_SIGNALS_CHOICE (92u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_5DH_N_CMD_CHOICE (93u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_5EH_SPEED_FILTER_CHOICE (94u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_5FH_I_ACTUAL_FILT_CHOICE (95u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_60H_AIN_IN_X_FILTER_CHOICE (96u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_61H_IXT_MONITOR_CHOICE (97u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_62H_SERIALNUMBER_CHOICE (98u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_63H_FPGA_STATUS_CHOICE (99u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_64H_DEVICE_MAINS_CHOICE (100u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_65H_REGEN_P_R_CHOICE (101u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_66H_DC_BUS_VOLTAGE_CHOICE (102u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_67H_DEVICE_TYPE_CHOICE (103u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_68H_CAN_ID_RX_CHOICE (104u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_69H_CAN_ID_TX_CHOICE (105u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_6AH_POS_KP_CHOICE (106u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_6BH_POS_TI_CHOICE (107u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_6CH_POS_TD_CHOICE (108u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_6DH_POS_ACTUAL_CHOICE (109u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_6EH_POS_DEST_CHOICE (110u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_6FH_POS_ACTUAL_2_CHOICE (111u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_70H_POS_ERR_CHOICE (112u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_71H_POS_TIM_CHOICE (113u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_72H_POS_OFFSETREF_CHOICE (114u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_73H_CAN_NBT_CHOICE (115u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_74H_POS_ZERO_CAPTURE_CHOICE (116u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_75H_POS_REF_RESO_EDGE_CHOICE (117u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_76H_POS_SPEED_1_CHOICE (118u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_77H_POS_SPEED_2_CHOICE (119u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_78H_POS_REF_START_CHOICE (120u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_79H_POS_TOL_WIN_CHOICE (121u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_7AH_POS_PRESET_CHOICE (122u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_7BH_POS_ZERO_OFFSET_CHOICE (123u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_7CH_POS_ND_SCALE_CHOICE (124u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_7DH_POS_ND_OFFSET_CHOICE (125u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_7EH_POS_FB2_SCALE_FAC_EXT_CHOICE (126u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_7FH_POS_OFFSET_SLACK_CHOICE (127u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_80H_POS_DIFF_SLACK_CHOICE (128u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_83H_FUNC_PARA_READ_CHOICE (131u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_84H_FUNC_PARA_WRITE_CHOICE (132u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_85H_FUNC_SPECIAL_CHOICE (133u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_88H_CAN_ID_2_RX_CHOICE (136u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_89H_CAN_ID_2_TX_CHOICE (137u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_8AH_VOUT_CHOICE (138u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_8BH_V_REF_CHOICE (139u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_8CH_V_KP_CHOICE (140u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_8DH_V_TI_CHOICE (141u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_8EH_CLEAR_ERROR_LIST_CHOICE (142u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_8FH_ERRORWARNING_MAP_CHOICE (143u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_90H_M_SETDIG_CHOICE (144u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_91H_POS_CMD_INT_CHOICE (145u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_92H_CAN_ERROR_BUSOFF_CNTR_CHOICE (146u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_93H_CAN_ERROR_WRITETIME_CNTR_CHOICE (147u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_94H_CAN_ERROR_RXMSGLOST_CNTR_CHOICE (148u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_95H_CAN_ERROR_NOACK_CNTR_CHOICE (149u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_96H_CAN_ERROR_CRC_CHECK_CNTR_CHOICE (150u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_97H_CAN_ERROR_BIT_CNTR_CHOICE (151u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_99H_INFO_TIMER_DIFF_CHOICE (153u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_9AH_TEMP_DEBUG_CHOICE (154u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_A0H_MOUT_CHOICE (160u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_A1H_BALLAST_CNTR_CHOICE (161u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_A2H_I_DERATING_TM_CHOICE (162u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_A3H_M_TEMP_CHOICE (163u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_A4H_MOTOR_OPTIONS_CHOICE (164u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_A5H_DC_BUS_MINMAX_LIM_CHOICE (165u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_A6H_FB_INCPERROT_CHOICE (166u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_A7H_FB_POLE_CHOICE (167u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_A8H_N_ACTUAL_FILT_CHOICE (168u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_A9H_I3_ADC_CHOICE (169u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_AAH_I2_ADC_CHOICE (170u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_ABH_LOGIC_FREQ_CHOICE (171u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_ACH_PWM_1_56_CHOICE (172u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_ADH_PWM_2_34_CHOICE (173u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_AEH_PWM_3_12_CHOICE (174u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_AFH_TIMER_DELTA_CHOICE (175u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_B1H_MOTOR_LSQ_CHOICE (177u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_B2H_ID_NOM_CHOICE (178u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_B3H_MOTOR_LM_CHOICE (179u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_B4H_MOTOR_RR_CHOICE (180u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_B5H_ID_MIN_CHOICE (181u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_B6H_MOTOR_TR_CHOICE (182u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_B8H_PTR_1_DEBUG_CHOICE (184u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_BAH_PTR_2_DEBUG_CHOICE (186u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_BBH_MOTOR_LSD_CHOICE (187u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_BCH_MOTOR_RS_CHOICE (188u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_BDH_MOTOR_TS_CHOICE (189u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_BEH_DEF_END_1_CHOICE (190u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_BFH_DEF_END_2_CHOICE (191u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_C0H_DEF_DIN_1_CHOICE (192u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_C1H_DEF_DIN_2_CHOICE (193u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_C2H_DEF_OUT_1_CHOICE (194u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_C3H_DEF_OUT_2_CHOICE (195u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_C4H_I_MAX_PK_CHOICE (196u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_C5H_I_CON_EFF_CHOICE (197u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_C6H_I_DEVICE_CHOICE (198u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_C7H_RLIM_MRCP_RAMP_CHOICE (199u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_C8H_NMAX100PERC_CHOICE (200u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_C9H_I_XKP_CHOICE (201u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_CAH_BAT_OPR_LIMITS_CHOICE (202u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_CBH_I_KF_CHOICE (203u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_CCH_CAR_MODE_STATUS_CHOICE (204u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_CDH_CAR_MODE_CONFIG_CHOICE (205u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_CEH_N_RPM_MAXINT_CHOICE (206u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_D0H_CAN_TIMEOUT_CHOICE (208u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_D1H_VAR_1_CHOICE (209u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_D2H_VAR_2_CHOICE (210u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_D3H_VAR_3_CHOICE (211u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_D4H_VAR_4_CHOICE (212u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_D5H_AIN_IN_1_CHOICE (213u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_D6H_AIN_IN_2_CHOICE (214u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_D7H_AIN_IN_2_OFFSSCALE_CHOICE (215u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_D8H_LOGICREADBITSIN_OUT_CHOICE (216u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_D9H_I_200PERC_CHOICE (217u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_DAH_DEF_OUT_3_CHOICE (218u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_DBH_DEF_OUT_4_CHOICE (219u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_DCH_DAC_SOURCE_ID_CHOICE (220u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_DEH_DS_DOUT_3_CHOICE (222u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_DFH_DS_DOUT_4_CHOICE (223u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_E0H_DS_DOUT_1_CHOICE (224u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_E1H_DS_DOUT_2_CHOICE (225u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_E2H_DS_RDY_BTB_CHOICE (226u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_E3H_DS_GO_CHOICE (227u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_E4H_DS_END_1_CHOICE (228u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_E5H_DS_END_2_CHOICE (229u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_E6H_DS_DIN_1_CHOICE (230u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_E7H_DS_DIN_2_CHOICE (231u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_E8H_DS_RUN_CHOICE (232u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_E9H_DS_I_FAULT_CHOICE (233u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_EBH_VDC_BUS_CHOICE (235u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_ECH_DS_FB_LOSSOFSIGNAL_CHOICE (236u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_EDH_DEC_RAMPS_CHOICE (237u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_EEH_V_SHUNT_CHOICE (238u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_EFH_DS_NOHWFAULT_CHOICE (239u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_F0H_T_PEAK_CHOICE (240u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_F1H_BRAKE_DELAY_CHOICE (241u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_F2H_DS_BRAKE_CHOICE (242u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_F3H_DS_ICNS_CHOICE (243u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_F4H_DS_POSTOLERANCE_CHOICE (244u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_F5H_DS_LESSN0_CHOICE (245u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_F6H_INVERTER_POWER_CHOICE (246u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_F7H_INVERTER_WORK_CHOICE (247u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_F8H_AXIS_CHOICE (248u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_FBH_AIN_IN_1_CALC_CHOICE (251u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_FCH_AIN_IN_2_CALC_CHOICE (252u)
#define PRIMARY_INVERTER_L_SEND_READ_ID_FEH_SUBV_SVNREV_NR_CHOICE (254u)

#define PRIMARY_INVERTER_L_SEND_DEVICETYPE_HOMEMADE_CHOICE (0u)
#define PRIMARY_INVERTER_L_SEND_DEVICETYPE_DS205_2PH_230V_CHOICE (14u)
#define PRIMARY_INVERTER_L_SEND_DEVICETYPE_DS403_2PH_400V_CHOICE (15u)
#define PRIMARY_INVERTER_L_SEND_DEVICETYPE_DS205_NEU_230V_CHOICE (16u)
#define PRIMARY_INVERTER_L_SEND_DEVICETYPE_DS403_NEU_400V_CHOICE (17u)
#define PRIMARY_INVERTER_L_SEND_DEVICETYPE_DS405_CHOICE (19u)
#define PRIMARY_INVERTER_L_SEND_DEVICETYPE_DS412_CHOICE (21u)
#define PRIMARY_INVERTER_L_SEND_DEVICETYPE_DS420_CHOICE (23u)
#define PRIMARY_INVERTER_L_SEND_DEVICETYPE_DS450_CHOICE (25u)
#define PRIMARY_INVERTER_L_SEND_DEVICETYPE_DS475_CHOICE (27u)
#define PRIMARY_INVERTER_L_SEND_DEVICETYPE_DS4100_CHOICE (29u)
#define PRIMARY_INVERTER_L_SEND_DEVICETYPE_DS4820_CHOICE (48u)
#define PRIMARY_INVERTER_L_SEND_DEVICETYPE_DS451_CHOICE (49u)
#define PRIMARY_INVERTER_L_SEND_DEVICETYPE_DS476_CHOICE (51u)
#define PRIMARY_INVERTER_L_SEND_DEVICETYPE_DS8020_CHOICE (56u)
#define PRIMARY_INVERTER_L_SEND_DEVICETYPE_DPC440_CHOICE (60u)
#define PRIMARY_INVERTER_L_SEND_DEVICETYPE_DPC460_CHOICE (65u)
#define PRIMARY_INVERTER_L_SEND_DEVICETYPE_DPC460_DC1Q_3P_CHOICE (67u)
#define PRIMARY_INVERTER_L_SEND_DEVICETYPE_BAMO_160_60_CHOICE (81u)
#define PRIMARY_INVERTER_L_SEND_DEVICETYPE_BAMO_160_120_CHOICE (83u)
#define PRIMARY_INVERTER_L_SEND_DEVICETYPE_BAMO_160_180_CHOICE (85u)
#define PRIMARY_INVERTER_L_SEND_DEVICETYPE_BAMO_360_60_CHOICE (87u)
#define PRIMARY_INVERTER_L_SEND_DEVICETYPE_BAMO_360_120_CHOICE (89u)
#define PRIMARY_INVERTER_L_SEND_DEVICETYPE_BAMO_360_180_CHOICE (91u)
#define PRIMARY_INVERTER_L_SEND_DEVICETYPE_BAMO_360_240_CHOICE (93u)
#define PRIMARY_INVERTER_L_SEND_DEVICETYPE_BAMOBIL_D3_3_62_80_CHOICE (112u)
#define PRIMARY_INVERTER_L_SEND_DEVICETYPE_BAMOBIL_D3_2_62_80_CHOICE (113u)
#define PRIMARY_INVERTER_L_SEND_DEVICETYPE_BAMOBIL_D3_3_62_120_CHOICE (114u)
#define PRIMARY_INVERTER_L_SEND_DEVICETYPE_BAMOBIL_D3_2_62_120_CHOICE (115u)
#define PRIMARY_INVERTER_L_SEND_DEVICETYPE_BAMOBIL_D3_3_62_250_CHOICE (116u)
#define PRIMARY_INVERTER_L_SEND_DEVICETYPE_BAMOBIL_D3_2_62_250_CHOICE (117u)
#define PRIMARY_INVERTER_L_SEND_DEVICETYPE_BAMOBIL_D3_3_62_350_CHOICE (118u)
#define PRIMARY_INVERTER_L_SEND_DEVICETYPE_BAMOBIL_D3_2_62_350_CHOICE (119u)
#define PRIMARY_INVERTER_L_SEND_DEVICETYPE_BAMOBIL_D3_3_62_450_CHOICE (120u)
#define PRIMARY_INVERTER_L_SEND_DEVICETYPE_BAMOBIL_D3_2_62_450_CHOICE (121u)
#define PRIMARY_INVERTER_L_SEND_DEVICETYPE_BAMOBIL_D3_3_160_50_CHOICE (122u)
#define PRIMARY_INVERTER_L_SEND_DEVICETYPE_BAMOBIL_D3_2_160_50_CHOICE (123u)
#define PRIMARY_INVERTER_L_SEND_DEVICETYPE_BAMOBIL_D3_3_160_100_CHOICE (124u)
#define PRIMARY_INVERTER_L_SEND_DEVICETYPE_BAMOBIL_D3_2_160_100_CHOICE (125u)
#define PRIMARY_INVERTER_L_SEND_DEVICETYPE_BAMOBIL_D3_3_160_200_CHOICE (126u)
#define PRIMARY_INVERTER_L_SEND_DEVICETYPE_BAMOBIL_D3_2_160_200_CHOICE (127u)
#define PRIMARY_INVERTER_L_SEND_DEVICETYPE_BAMOCAR_700_160_CHOICE (192u)
#define PRIMARY_INVERTER_L_SEND_DEVICETYPE_BAMOCAR_700_100_CHOICE (193u)
#define PRIMARY_INVERTER_L_SEND_DEVICETYPE_BAMOCAR_700_900_CHOICE (194u)
#define PRIMARY_INVERTER_L_SEND_DEVICETYPE_BAMOCAR_700_200_DC_CHOICE (203u)
#define PRIMARY_INVERTER_L_SEND_DEVICETYPE_BAMOCAR_400_400_CHOICE (204u)
#define PRIMARY_INVERTER_L_SEND_DEVICETYPE_BAMOCAR_700_400_CHOICE (205u)
#define PRIMARY_INVERTER_L_SEND_DEVICETYPE_BAMOCAR_400_250_CHOICE (206u)
#define PRIMARY_INVERTER_L_SEND_DEVICETYPE_KOEPFER_V1_700_400_CHOICE (240u)
#define PRIMARY_INVERTER_L_SEND_DEVICETYPE_KOEPFER_V2_700_400_CHOICE (241u)

#define PRIMARY_INVERTER_L_SEND_CAN_NBT_1000_KBPS_CHOICE (16386u)
#define PRIMARY_INVERTER_L_SEND_CAN_NBT_625_KBPS_CHOICE (16404u)
#define PRIMARY_INVERTER_L_SEND_CAN_NBT_500_KBPS_CHOICE (16421u)
#define PRIMARY_INVERTER_L_SEND_CAN_NBT_250_KBPS_CHOICE (16476u)
#define PRIMARY_INVERTER_L_SEND_CAN_NBT_100_KBPS_CHOICE (17445u)

#define PRIMARY_INVERTER_L_SEND_EPROM131_SECTOR_0_CHOICE (0u)
#define PRIMARY_INVERTER_L_SEND_EPROM131_SECTOR_1_CHOICE (1u)
#define PRIMARY_INVERTER_L_SEND_EPROM131_SECTOR_2_CHOICE (2u)

#define PRIMARY_INVERTER_L_SEND_EPROM132_SECTOR_0_CHOICE (0u)
#define PRIMARY_INVERTER_L_SEND_EPROM132_SECTOR_1_CHOICE (1u)
#define PRIMARY_INVERTER_L_SEND_EPROM132_SECTOR_2_CHOICE (2u)

#define PRIMARY_INVERTER_L_SEND_MO_FEEDBACK_1_ROT_ENC_TTL_CHOICE (0u)
#define PRIMARY_INVERTER_L_SEND_MO_FEEDBACK_1_RESOLVER_CHOICE (1u)
#define PRIMARY_INVERTER_L_SEND_MO_FEEDBACK_1_ABS_ENC_SC_CHOICE (2u)
#define PRIMARY_INVERTER_L_SEND_MO_FEEDBACK_1_ROT_TACHO_CHOICE (3u)
#define PRIMARY_INVERTER_L_SEND_MO_FEEDBACK_1_ROT_CHOICE (4u)
#define PRIMARY_INVERTER_L_SEND_MO_FEEDBACK_1_DC_TACHO_CHOICE (5u)
#define PRIMARY_INVERTER_L_SEND_MO_FEEDBACK_1_DC_ARM_CHOICE (6u)
#define PRIMARY_INVERTER_L_SEND_MO_FEEDBACK_1_BL_ARM_CHOICE (7u)
#define PRIMARY_INVERTER_L_SEND_MO_FEEDBACK_1_ENC_TTL_CHOICE (8u)
#define PRIMARY_INVERTER_L_SEND_MO_FEEDBACK_1_ENC_SC_CHOICE (9u)
#define PRIMARY_INVERTER_L_SEND_MO_FEEDBACK_1_ABS_SC_CHOICE (10u)
#define PRIMARY_INVERTER_L_SEND_MO_FEEDBACK_1_DC_ARM_VIR_CHOICE (11u)
#define PRIMARY_INVERTER_L_SEND_MO_FEEDBACK_1_SLS_CHOICE (12u)
#define PRIMARY_INVERTER_L_SEND_MO_FEEDBACK_1_SLS_SMO_CHOICE (13u)
#define PRIMARY_INVERTER_L_SEND_MO_FEEDBACK_1_SLS_USENS_CHOICE (14u)
#define PRIMARY_INVERTER_L_SEND_MO_FEEDBACK_1_ANAIN1_CALC_CHOICE (15u)
#define PRIMARY_INVERTER_L_SEND_MO_FEEDBACK_1_ANAIN2_CALC_CHOICE (16u)
#define PRIMARY_INVERTER_L_SEND_MO_FEEDBACK_1_PANASONIC_CHOICE (17u)
#define PRIMARY_INVERTER_L_SEND_MO_FEEDBACK_1_DC_BUS_CHOICE (18u)

#define PRIMARY_INVERTER_L_SEND_DEF_END_1__OFF__CHOICE (0u)
#define PRIMARY_INVERTER_L_SEND_DEF_END_1_REF_AND_LIMIT_PLUS_CHOICE (1u)
#define PRIMARY_INVERTER_L_SEND_DEF_END_1_REF_AND_LIMIT_MINUS_CHOICE (2u)
#define PRIMARY_INVERTER_L_SEND_DEF_END_1_REF_PLUS_CHOICE (3u)
#define PRIMARY_INVERTER_L_SEND_DEF_END_1_LIMIT_PLUS_CHOICE (4u)
#define PRIMARY_INVERTER_L_SEND_DEF_END_1_LIMIT_MINUS_CHOICE (5u)
#define PRIMARY_INVERTER_L_SEND_DEF_END_1_LIMIT_PLUS_AND_MINUS_CHOICE (6u)
#define PRIMARY_INVERTER_L_SEND_DEF_END_1_CANCEL_ERROR_S__CHOICE (7u)
#define PRIMARY_INVERTER_L_SEND_DEF_END_1__START_REF_DRIVE_CHOICE (8u)
#define PRIMARY_INVERTER_L_SEND_DEF_END_1_SPEED_RAMP_0_CHOICE (9u)
#define PRIMARY_INVERTER_L_SEND_DEF_END_1__START_DEST_VAR_1_CHOICE (10u)
#define PRIMARY_INVERTER_L_SEND_DEF_END_1__START_DEST_VAR_2_CHOICE (11u)
#define PRIMARY_INVERTER_L_SEND_DEF_END_1_N_CMD_REVERSE_CHOICE (12u)
#define PRIMARY_INVERTER_L_SEND_DEF_END_1__PRESET_POS_VAR_3_CHOICE (13u)
#define PRIMARY_INVERTER_L_SEND_DEF_END_1__CAPTURE_VAR_3_POS_CHOICE (14u)
#define PRIMARY_INVERTER_L_SEND_DEF_END_1__CAPTURE_VAR_4_POS_CHOICE (15u)
#define PRIMARY_INVERTER_L_SEND_DEF_END_1__SWITCH_SPD_AIN1_AIN2_CHOICE (16u)
#define PRIMARY_INVERTER_L_SEND_DEF_END_1__SWITCH_SPD_VAR1_VAR2_CHOICE (17u)
#define PRIMARY_INVERTER_L_SEND_DEF_END_1_I_LIMIT_DIG__CHOICE (18u)
#define PRIMARY_INVERTER_L_SEND_DEF_END_1_N_CLIP_NEG_POS__CHOICE (19u)
#define PRIMARY_INVERTER_L_SEND_DEF_END_1__SWITCH_CMD_DIG_ANA_CHOICE (20u)
#define PRIMARY_INVERTER_L_SEND_DEF_END_1_SPEED_RAMP_0_POS_CHOICE (21u)
#define PRIMARY_INVERTER_L_SEND_DEF_END_1_HANDWHEEL_CHOICE (22u)
#define PRIMARY_INVERTER_L_SEND_DEF_END_1_BRAKE_CAR_CHOICE (23u)
#define PRIMARY_INVERTER_L_SEND_DEF_END_1_RECUP_DISABLED_CHOICE (24u)
#define PRIMARY_INVERTER_L_SEND_DEF_END_1_RISING_BANK_1,_FALLING_BANK_0_CHOICE (25u)
#define PRIMARY_INVERTER_L_SEND_DEF_END_1__START_DEST_VAR_1,_2,_3,_4_CHOICE (26u)
#define PRIMARY_INVERTER_L_SEND_DEF_END_1__START_CW_VAR_1,_2,_3,_4_CHOICE (27u)
#define PRIMARY_INVERTER_L_SEND_DEF_END_1_BRAKE_CAR_NR2_CHOICE (28u)

#define PRIMARY_INVERTER_L_SEND_DEF_END_2__OFF__CHOICE (0u)
#define PRIMARY_INVERTER_L_SEND_DEF_END_2_REF_AND_LIMIT_PLUS_CHOICE (1u)
#define PRIMARY_INVERTER_L_SEND_DEF_END_2_REF_AND_LIMIT_MINUS_CHOICE (2u)
#define PRIMARY_INVERTER_L_SEND_DEF_END_2_REF_PLUS_CHOICE (3u)
#define PRIMARY_INVERTER_L_SEND_DEF_END_2_LIMIT_PLUS_CHOICE (4u)
#define PRIMARY_INVERTER_L_SEND_DEF_END_2_LIMIT_MINUS_CHOICE (5u)
#define PRIMARY_INVERTER_L_SEND_DEF_END_2_LIMIT_PLUS_AND_MINUS_CHOICE (6u)
#define PRIMARY_INVERTER_L_SEND_DEF_END_2_CANCEL_ERROR_S__CHOICE (7u)
#define PRIMARY_INVERTER_L_SEND_DEF_END_2__START_REF_DRIVE_CHOICE (8u)
#define PRIMARY_INVERTER_L_SEND_DEF_END_2_SPEED_RAMP_0_CHOICE (9u)
#define PRIMARY_INVERTER_L_SEND_DEF_END_2__START_DEST_VAR_1_CHOICE (10u)
#define PRIMARY_INVERTER_L_SEND_DEF_END_2__START_DEST_VAR_2_CHOICE (11u)
#define PRIMARY_INVERTER_L_SEND_DEF_END_2_N_CMD_REVERSE_CHOICE (12u)
#define PRIMARY_INVERTER_L_SEND_DEF_END_2__PRESET_POS_VAR_3_CHOICE (13u)
#define PRIMARY_INVERTER_L_SEND_DEF_END_2__CAPTURE_VAR_3_POS_CHOICE (14u)
#define PRIMARY_INVERTER_L_SEND_DEF_END_2__CAPTURE_VAR_4_POS_CHOICE (15u)
#define PRIMARY_INVERTER_L_SEND_DEF_END_2__SWITCH_SPD_AIN1_AIN2_CHOICE (16u)
#define PRIMARY_INVERTER_L_SEND_DEF_END_2__SWITCH_SPD_VAR1_VAR2_CHOICE (17u)
#define PRIMARY_INVERTER_L_SEND_DEF_END_2_I_LIMIT_DIG__CHOICE (18u)
#define PRIMARY_INVERTER_L_SEND_DEF_END_2_N_CLIP_NEG_POS__CHOICE (19u)
#define PRIMARY_INVERTER_L_SEND_DEF_END_2__SWITCH_CMD_DIG_ANA_CHOICE (20u)
#define PRIMARY_INVERTER_L_SEND_DEF_END_2_SPEED_RAMP_0_POS_CHOICE (21u)
#define PRIMARY_INVERTER_L_SEND_DEF_END_2_HANDWHEEL_CHOICE (22u)
#define PRIMARY_INVERTER_L_SEND_DEF_END_2_BRAKE_CAR_CHOICE (23u)
#define PRIMARY_INVERTER_L_SEND_DEF_END_2_RECUP_DISABLED_CHOICE (24u)
#define PRIMARY_INVERTER_L_SEND_DEF_END_2_RISING_BANK_1,_FALLING_BANK_0_CHOICE (25u)
#define PRIMARY_INVERTER_L_SEND_DEF_END_2__START_DEST_VAR_1,_2,_3,_4_CHOICE (26u)
#define PRIMARY_INVERTER_L_SEND_DEF_END_2__START_CW_VAR_1,_2,_3,_4_CHOICE (27u)
#define PRIMARY_INVERTER_L_SEND_DEF_END_2_BRAKE_CAR_NR2_CHOICE (28u)

#define PRIMARY_INVERTER_L_SEND_DEF_DIN_1__OFF__CHOICE (0u)
#define PRIMARY_INVERTER_L_SEND_DEF_DIN_1_REF_AND_LIMIT_PLUS_CHOICE (1u)
#define PRIMARY_INVERTER_L_SEND_DEF_DIN_1_REF_AND_LIMIT_MINUS_CHOICE (2u)
#define PRIMARY_INVERTER_L_SEND_DEF_DIN_1_REF_PLUS_CHOICE (3u)
#define PRIMARY_INVERTER_L_SEND_DEF_DIN_1_LIMIT_PLUS_CHOICE (4u)
#define PRIMARY_INVERTER_L_SEND_DEF_DIN_1_LIMIT_MINUS_CHOICE (5u)
#define PRIMARY_INVERTER_L_SEND_DEF_DIN_1_LIMIT_PLUS_AND_MINUS_CHOICE (6u)
#define PRIMARY_INVERTER_L_SEND_DEF_DIN_1_CANCEL_ERROR_S__CHOICE (7u)
#define PRIMARY_INVERTER_L_SEND_DEF_DIN_1__START_REF_DRIVE_CHOICE (8u)
#define PRIMARY_INVERTER_L_SEND_DEF_DIN_1_SPEED_RAMP_0_CHOICE (9u)
#define PRIMARY_INVERTER_L_SEND_DEF_DIN_1__START_DEST_VAR_1_CHOICE (10u)
#define PRIMARY_INVERTER_L_SEND_DEF_DIN_1__START_DEST_VAR_2_CHOICE (11u)
#define PRIMARY_INVERTER_L_SEND_DEF_DIN_1_N_CMD_REVERSE_CHOICE (12u)
#define PRIMARY_INVERTER_L_SEND_DEF_DIN_1__PRESET_POS_VAR_3_CHOICE (13u)
#define PRIMARY_INVERTER_L_SEND_DEF_DIN_1__CAPTURE_VAR_3_POS_CHOICE (14u)
#define PRIMARY_INVERTER_L_SEND_DEF_DIN_1__CAPTURE_VAR_4_POS_CHOICE (15u)
#define PRIMARY_INVERTER_L_SEND_DEF_DIN_1__SWITCH_SPD_AIN1_AIN2_CHOICE (16u)
#define PRIMARY_INVERTER_L_SEND_DEF_DIN_1__SWITCH_SPD_VAR1_VAR2_CHOICE (17u)
#define PRIMARY_INVERTER_L_SEND_DEF_DIN_1_I_LIMIT_DIG__CHOICE (18u)
#define PRIMARY_INVERTER_L_SEND_DEF_DIN_1_N_CLIP_NEG_POS__CHOICE (19u)
#define PRIMARY_INVERTER_L_SEND_DEF_DIN_1__SWITCH_CMD_DIG_ANA_CHOICE (20u)
#define PRIMARY_INVERTER_L_SEND_DEF_DIN_1_SPEED_RAMP_0_POS_CHOICE (21u)
#define PRIMARY_INVERTER_L_SEND_DEF_DIN_1_HANDWHEEL_CHOICE (22u)
#define PRIMARY_INVERTER_L_SEND_DEF_DIN_1_BRAKE_CAR_CHOICE (23u)
#define PRIMARY_INVERTER_L_SEND_DEF_DIN_1_RECUP_DISABLED_CHOICE (24u)
#define PRIMARY_INVERTER_L_SEND_DEF_DIN_1_RISING_BANK_1,_FALLING_BANK_0_CHOICE (25u)
#define PRIMARY_INVERTER_L_SEND_DEF_DIN_1__START_DEST_VAR_1,_2,_3,_4_CHOICE (26u)
#define PRIMARY_INVERTER_L_SEND_DEF_DIN_1__START_CW_VAR_1,_2,_3,_4_CHOICE (27u)
#define PRIMARY_INVERTER_L_SEND_DEF_DIN_1_BRAKE_CAR_NR2_CHOICE (28u)

#define PRIMARY_INVERTER_L_SEND_DEF_DIN_2__OFF__CHOICE (0u)
#define PRIMARY_INVERTER_L_SEND_DEF_DIN_2_REF_AND_LIMIT_PLUS_CHOICE (1u)
#define PRIMARY_INVERTER_L_SEND_DEF_DIN_2_REF_AND_LIMIT_MINUS_CHOICE (2u)
#define PRIMARY_INVERTER_L_SEND_DEF_DIN_2_REF_PLUS_CHOICE (3u)
#define PRIMARY_INVERTER_L_SEND_DEF_DIN_2_LIMIT_PLUS_CHOICE (4u)
#define PRIMARY_INVERTER_L_SEND_DEF_DIN_2_LIMIT_MINUS_CHOICE (5u)
#define PRIMARY_INVERTER_L_SEND_DEF_DIN_2_LIMIT_PLUS_AND_MINUS_CHOICE (6u)
#define PRIMARY_INVERTER_L_SEND_DEF_DIN_2_CANCEL_ERROR_S__CHOICE (7u)
#define PRIMARY_INVERTER_L_SEND_DEF_DIN_2__START_REF_DRIVE_CHOICE (8u)
#define PRIMARY_INVERTER_L_SEND_DEF_DIN_2_SPEED_RAMP_0_CHOICE (9u)
#define PRIMARY_INVERTER_L_SEND_DEF_DIN_2__START_DEST_VAR_1_CHOICE (10u)
#define PRIMARY_INVERTER_L_SEND_DEF_DIN_2__START_DEST_VAR_2_CHOICE (11u)
#define PRIMARY_INVERTER_L_SEND_DEF_DIN_2_N_CMD_REVERSE_CHOICE (12u)
#define PRIMARY_INVERTER_L_SEND_DEF_DIN_2__PRESET_POS_VAR_3_CHOICE (13u)
#define PRIMARY_INVERTER_L_SEND_DEF_DIN_2__CAPTURE_VAR_3_POS_CHOICE (14u)
#define PRIMARY_INVERTER_L_SEND_DEF_DIN_2__CAPTURE_VAR_4_POS_CHOICE (15u)
#define PRIMARY_INVERTER_L_SEND_DEF_DIN_2__SWITCH_SPD_AIN1_AIN2_CHOICE (16u)
#define PRIMARY_INVERTER_L_SEND_DEF_DIN_2__SWITCH_SPD_VAR1_VAR2_CHOICE (17u)
#define PRIMARY_INVERTER_L_SEND_DEF_DIN_2_I_LIMIT_DIG__CHOICE (18u)
#define PRIMARY_INVERTER_L_SEND_DEF_DIN_2_N_CLIP_NEG_POS__CHOICE (19u)
#define PRIMARY_INVERTER_L_SEND_DEF_DIN_2__SWITCH_CMD_DIG_ANA_CHOICE (20u)
#define PRIMARY_INVERTER_L_SEND_DEF_DIN_2_SPEED_RAMP_0_POS_CHOICE (21u)
#define PRIMARY_INVERTER_L_SEND_DEF_DIN_2_HANDWHEEL_CHOICE (22u)
#define PRIMARY_INVERTER_L_SEND_DEF_DIN_2_BRAKE_CAR_CHOICE (23u)
#define PRIMARY_INVERTER_L_SEND_DEF_DIN_2_RECUP_DISABLED_CHOICE (24u)
#define PRIMARY_INVERTER_L_SEND_DEF_DIN_2_RISING_BANK_1,_FALLING_BANK_0_CHOICE (25u)
#define PRIMARY_INVERTER_L_SEND_DEF_DIN_2__START_DEST_VAR_1,_2,_3,_4_CHOICE (26u)
#define PRIMARY_INVERTER_L_SEND_DEF_DIN_2__START_CW_VAR_1,_2,_3,_4_CHOICE (27u)
#define PRIMARY_INVERTER_L_SEND_DEF_DIN_2_BRAKE_CAR_NR2_CHOICE (28u)

#define PRIMARY_INVERTER_L_SEND_OPERAND194_OFF_CHOICE (0u)
#define PRIMARY_INVERTER_L_SEND_OPERAND194_ON_CHOICE (1u)
#define PRIMARY_INVERTER_L_SEND_OPERAND194_1_HZ_CHOICE (2u)
#define PRIMARY_INVERTER_L_SEND_OPERAND194___3_CHOICE (3u)
#define PRIMARY_INVERTER_L_SEND_OPERAND194___4_CHOICE (4u)
#define PRIMARY_INVERTER_L_SEND_OPERAND194__>__5_CHOICE (5u)
#define PRIMARY_INVERTER_L_SEND_OPERAND194__<__6_CHOICE (6u)
#define PRIMARY_INVERTER_L_SEND_OPERAND194__ABS_>__CHOICE (7u)
#define PRIMARY_INVERTER_L_SEND_OPERAND194__ABS_<__CHOICE (8u)
#define PRIMARY_INVERTER_L_SEND_OPERAND194__TOL_>__CHOICE (9u)
#define PRIMARY_INVERTER_L_SEND_OPERAND194__TOL_<__CHOICE (10u)
#define PRIMARY_INVERTER_L_SEND_OPERAND194__>__11_CHOICE (11u)
#define PRIMARY_INVERTER_L_SEND_OPERAND194__<__12_CHOICE (12u)
#define PRIMARY_INVERTER_L_SEND_OPERAND194__HYST_>__CHOICE (13u)
#define PRIMARY_INVERTER_L_SEND_OPERAND194__HYST_<__CHOICE (14u)
#define PRIMARY_INVERTER_L_SEND_OPERAND194__WINDOW__CHOICE (15u)

#define PRIMARY_INVERTER_L_SEND_OPERAND195_OFF_CHOICE (0u)
#define PRIMARY_INVERTER_L_SEND_OPERAND195_ON_CHOICE (1u)
#define PRIMARY_INVERTER_L_SEND_OPERAND195_1_HZ_CHOICE (2u)
#define PRIMARY_INVERTER_L_SEND_OPERAND195___3_CHOICE (3u)
#define PRIMARY_INVERTER_L_SEND_OPERAND195___4_CHOICE (4u)
#define PRIMARY_INVERTER_L_SEND_OPERAND195__>__5_CHOICE (5u)
#define PRIMARY_INVERTER_L_SEND_OPERAND195__<__6_CHOICE (6u)
#define PRIMARY_INVERTER_L_SEND_OPERAND195__ABS_>__CHOICE (7u)
#define PRIMARY_INVERTER_L_SEND_OPERAND195__ABS_<__CHOICE (8u)
#define PRIMARY_INVERTER_L_SEND_OPERAND195__TOL_>__CHOICE (9u)
#define PRIMARY_INVERTER_L_SEND_OPERAND195__TOL_<__CHOICE (10u)
#define PRIMARY_INVERTER_L_SEND_OPERAND195__>__11_CHOICE (11u)
#define PRIMARY_INVERTER_L_SEND_OPERAND195__<__12_CHOICE (12u)
#define PRIMARY_INVERTER_L_SEND_OPERAND195__HYST_>__CHOICE (13u)
#define PRIMARY_INVERTER_L_SEND_OPERAND195__HYST_<__CHOICE (14u)
#define PRIMARY_INVERTER_L_SEND_OPERAND195__WINDOW__CHOICE (15u)

#define PRIMARY_INVERTER_L_SEND_OPERAND218_OFF_CHOICE (0u)
#define PRIMARY_INVERTER_L_SEND_OPERAND218_ON_CHOICE (1u)
#define PRIMARY_INVERTER_L_SEND_OPERAND218_1_HZ_CHOICE (2u)
#define PRIMARY_INVERTER_L_SEND_OPERAND218___3_CHOICE (3u)
#define PRIMARY_INVERTER_L_SEND_OPERAND218___4_CHOICE (4u)
#define PRIMARY_INVERTER_L_SEND_OPERAND218__>__5_CHOICE (5u)
#define PRIMARY_INVERTER_L_SEND_OPERAND218__<__6_CHOICE (6u)
#define PRIMARY_INVERTER_L_SEND_OPERAND218__ABS_>__CHOICE (7u)
#define PRIMARY_INVERTER_L_SEND_OPERAND218__ABS_<__CHOICE (8u)
#define PRIMARY_INVERTER_L_SEND_OPERAND218__TOL_>__CHOICE (9u)
#define PRIMARY_INVERTER_L_SEND_OPERAND218__TOL_<__CHOICE (10u)
#define PRIMARY_INVERTER_L_SEND_OPERAND218__>__11_CHOICE (11u)
#define PRIMARY_INVERTER_L_SEND_OPERAND218__<__12_CHOICE (12u)
#define PRIMARY_INVERTER_L_SEND_OPERAND218__HYST_>__CHOICE (13u)
#define PRIMARY_INVERTER_L_SEND_OPERAND218__HYST_<__CHOICE (14u)
#define PRIMARY_INVERTER_L_SEND_OPERAND218__WINDOW__CHOICE (15u)

#define PRIMARY_INVERTER_L_SEND_OPERAND219_OFF_CHOICE (0u)
#define PRIMARY_INVERTER_L_SEND_OPERAND219_ON_CHOICE (1u)
#define PRIMARY_INVERTER_L_SEND_OPERAND219_1_HZ_CHOICE (2u)
#define PRIMARY_INVERTER_L_SEND_OPERAND219___3_CHOICE (3u)
#define PRIMARY_INVERTER_L_SEND_OPERAND219___4_CHOICE (4u)
#define PRIMARY_INVERTER_L_SEND_OPERAND219__>__5_CHOICE (5u)
#define PRIMARY_INVERTER_L_SEND_OPERAND219__<__6_CHOICE (6u)
#define PRIMARY_INVERTER_L_SEND_OPERAND219__ABS_>__CHOICE (7u)
#define PRIMARY_INVERTER_L_SEND_OPERAND219__ABS_<__CHOICE (8u)
#define PRIMARY_INVERTER_L_SEND_OPERAND219__TOL_>__CHOICE (9u)
#define PRIMARY_INVERTER_L_SEND_OPERAND219__TOL_<__CHOICE (10u)
#define PRIMARY_INVERTER_L_SEND_OPERAND219__>__11_CHOICE (11u)
#define PRIMARY_INVERTER_L_SEND_OPERAND219__<__12_CHOICE (12u)
#define PRIMARY_INVERTER_L_SEND_OPERAND219__HYST_>__CHOICE (13u)
#define PRIMARY_INVERTER_L_SEND_OPERAND219__HYST_<__CHOICE (14u)
#define PRIMARY_INVERTER_L_SEND_OPERAND219__WINDOW__CHOICE (15u)

#define PRIMARY_INVERTER_L_SEND_CS_AIN_2_FORMAT_OFF_CHOICE (0u)
#define PRIMARY_INVERTER_L_SEND_CS_AIN_2_FORMAT__CMD_1_CHOICE (1u)
#define PRIMARY_INVERTER_L_SEND_CS_AIN_2_FORMAT__CMD_2_CHOICE (2u)
#define PRIMARY_INVERTER_L_SEND_CS_AIN_2_FORMAT__CMD_3_CHOICE (3u)

#define PRIMARY_INVERTER_L_SEND_CS_AIN_1_MODE__10_10V__CHOICE (0u)
#define PRIMARY_INVERTER_L_SEND_CS_AIN_1_MODE__0_10V__CHOICE (1u)
#define PRIMARY_INVERTER_L_SEND_CS_AIN_1_MODE__4_20MA__CHOICE (2u)
#define PRIMARY_INVERTER_L_SEND_CS_AIN_1_MODE__1_9V__CHOICE (3u)

#define PRIMARY_INVERTER_L_SEND_COMPARE_VAR194__0__CHOICE (0u)
#define PRIMARY_INVERTER_L_SEND_COMPARE_VAR194__1__CHOICE (1u)
#define PRIMARY_INVERTER_L_SEND_COMPARE_VAR194__VAR_1__CHOICE (2u)
#define PRIMARY_INVERTER_L_SEND_COMPARE_VAR194__VAR_2__CHOICE (3u)
#define PRIMARY_INVERTER_L_SEND_COMPARE_VAR194__VAR_3__CHOICE (4u)
#define PRIMARY_INVERTER_L_SEND_COMPARE_VAR194__VAR_4__CHOICE (5u)
#define PRIMARY_INVERTER_L_SEND_COMPARE_VAR194__AIN_1__CHOICE (6u)
#define PRIMARY_INVERTER_L_SEND_COMPARE_VAR194__AIN_2__CHOICE (7u)

#define PRIMARY_INVERTER_L_SEND_COMPARE_VAR195__0__CHOICE (0u)
#define PRIMARY_INVERTER_L_SEND_COMPARE_VAR195__1__CHOICE (1u)
#define PRIMARY_INVERTER_L_SEND_COMPARE_VAR195__VAR_1__CHOICE (2u)
#define PRIMARY_INVERTER_L_SEND_COMPARE_VAR195__VAR_2__CHOICE (3u)
#define PRIMARY_INVERTER_L_SEND_COMPARE_VAR195__VAR_3__CHOICE (4u)
#define PRIMARY_INVERTER_L_SEND_COMPARE_VAR195__VAR_4__CHOICE (5u)
#define PRIMARY_INVERTER_L_SEND_COMPARE_VAR195__AIN_1__CHOICE (6u)
#define PRIMARY_INVERTER_L_SEND_COMPARE_VAR195__AIN_2__CHOICE (7u)

#define PRIMARY_INVERTER_L_SEND_COMPARE_VAR218__0__CHOICE (0u)
#define PRIMARY_INVERTER_L_SEND_COMPARE_VAR218__1__CHOICE (1u)
#define PRIMARY_INVERTER_L_SEND_COMPARE_VAR218__VAR_1__CHOICE (2u)
#define PRIMARY_INVERTER_L_SEND_COMPARE_VAR218__VAR_2__CHOICE (3u)
#define PRIMARY_INVERTER_L_SEND_COMPARE_VAR218__VAR_3__CHOICE (4u)
#define PRIMARY_INVERTER_L_SEND_COMPARE_VAR218__VAR_4__CHOICE (5u)
#define PRIMARY_INVERTER_L_SEND_COMPARE_VAR218__AIN_1__CHOICE (6u)
#define PRIMARY_INVERTER_L_SEND_COMPARE_VAR218__AIN_2__CHOICE (7u)

#define PRIMARY_INVERTER_L_SEND_COMPARE_VAR219__0__CHOICE (0u)
#define PRIMARY_INVERTER_L_SEND_COMPARE_VAR219__1__CHOICE (1u)
#define PRIMARY_INVERTER_L_SEND_COMPARE_VAR219__VAR_1__CHOICE (2u)
#define PRIMARY_INVERTER_L_SEND_COMPARE_VAR219__VAR_2__CHOICE (3u)
#define PRIMARY_INVERTER_L_SEND_COMPARE_VAR219__VAR_3__CHOICE (4u)
#define PRIMARY_INVERTER_L_SEND_COMPARE_VAR219__VAR_4__CHOICE (5u)
#define PRIMARY_INVERTER_L_SEND_COMPARE_VAR219__AIN_1__CHOICE (6u)
#define PRIMARY_INVERTER_L_SEND_COMPARE_VAR219__AIN_2__CHOICE (7u)

#define PRIMARY_INVERTER_L_SEND_MO_FEEDBACK_2___CHOICE (0u)
#define PRIMARY_INVERTER_L_SEND_MO_FEEDBACK_2_ENC_POSITION_CHOICE (1u)
#define PRIMARY_INVERTER_L_SEND_MO_FEEDBACK_2_ENC_INFO_CHOICE (2u)
#define PRIMARY_INVERTER_L_SEND_MO_FEEDBACK_2_ENC_HAND__CHOICE (3u)
#define PRIMARY_INVERTER_L_SEND_MO_FEEDBACK_2_SSI_CHOICE (4u)

#define PRIMARY_INVERTER_L_SEND_CS_AIN_2_MODE__10_10V__CHOICE (0u)
#define PRIMARY_INVERTER_L_SEND_CS_AIN_2_MODE__0_10V__CHOICE (1u)
#define PRIMARY_INVERTER_L_SEND_CS_AIN_2_MODE__4_20MA__CHOICE (2u)
#define PRIMARY_INVERTER_L_SEND_CS_AIN_2_MODE__1_9V__CHOICE (3u)

#define PRIMARY_INVERTER_L_SEND_RET_INTERVAL_SINGLE_CHOICE (0u)
#define PRIMARY_INVERTER_L_SEND_RET_INTERVAL_STOP_CHOICE (255u)

#define PRIMARY_INVERTER_L_SEND_MO_SC1_RESO_14_BIT_CHOICE (1u)
#define PRIMARY_INVERTER_L_SEND_MO_SC1_RESO_12_BIT_CHOICE (2u)
#define PRIMARY_INVERTER_L_SEND_MO_SC1_RESO_10_BIT_CHOICE (3u)

#define PRIMARY_INVERTER_L_SEND_SOURCE_ID194__OFF__CHOICE (0u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID194_02H_SC_INFO_CHOICE (2u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID194_11H_CONTROL_STATUS_CHOICE (17u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID194_20H_I_ACTUAL_CHOICE (32u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID194_22H_I_CMD_RAMP__CHOICE (34u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID194_23H_ID_REF_CHOICE (35u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID194_24H_I_MAX_INUSE_CHOICE (36u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID194_26H_I_CMD_CHOICE (38u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID194_27H_IQ_ACTUAL_CHOICE (39u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID194_28H_ID_ACTUAL_CHOICE (40u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID194_29H_VQ_OUTPUT_CHOICE (41u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID194_2AH_VD_OUTPUT_CHOICE (42u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID194_30H_N_ACTUAL_CHOICE (48u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID194_31H_N_SET_DIG__CHOICE (49u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID194_32H_N_CMD_RAMP__CHOICE (50u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID194_33H_N_ERROR_CHOICE (51u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID194_34H_N_LIM_CHOICE (52u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID194_38H_IQ_ERROR_CHOICE (56u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID194_39H_ID_ERROR_CHOICE (57u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID194_40H_STATUS_MAP_CHOICE (64u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID194_41H_INCR_DELTA_CHOICE (65u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID194_42H_MOTORPOS_MECH_CHOICE (66u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID194_43H_MOTORPOS_ELEC_CHOICE (67u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID194_45H_IT_RG_MONITOR_CHOICE (69u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID194_48H_I_LIMIT_INUSE_CHOICE (72u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID194_49H_T_MOTOR_CHOICE (73u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID194_4AH_T_IGBT_CHOICE (74u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID194_4BH_T_AIR_INSIDE_CHOICE (75u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID194_51_KERN_MODE_STATE_CHOICE (81u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID194_54H_I1_ACTUAL_CHOICE (84u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID194_55H_I2_ACTUAL_CHOICE (85u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID194_56H_I3_ACTUAL_CHOICE (86u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID194_57H_I_LIMIT_INUSE_RAMP__CHOICE (87u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID194_5CH_ROTOR_SIGNALS_CHOICE (92u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID194_5DH_N_CMD_INT__CHOICE (93u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID194_5FH_I_ACTUAL_FILT_CHOICE (95u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID194_61H_IXT_MONITOR_CHOICE (97u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID194_63H_FPGA_STATUS_CHOICE (99u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID194_66H_VDC_BUS_FILT_CHOICE (102u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID194_6DH_POS_ACTUAL_CHOICE (109u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID194_6EH_POS_DESTINATION_CHOICE (110u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID194_6FH_POS_ACTUAL_2_CHOICE (111u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID194_70H_POS_ERROR_CHOICE (112u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID194_74H_POS_ZEROCAPTURE_CHOICE (116u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID194_8AH_V_OUTPUT_CHOICE (138u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID194_8BH_V_RED_REF__CHOICE (139u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID194_8CH_V_CONTROL_KP_CHOICE (140u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID194_8DH_V_CONTROL_TI_CHOICE (141u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID194_8FH_ERRORWARNING_MAP_CHOICE (143u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID194_90H_M_SET_DIG__CHOICE (144u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID194_91H_POS_CMD_CHOICE (145u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID194_98H_LOGIC_O_BLOCK_CHOICE (152u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID194_99H_INFO_TIMER_DIFF_CHOICE (153u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID194_9AH_TEMP_DEBUG_CHOICE (154u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID194_9BH_LOGIC_I_BLOCK_CHOICE (155u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID194_A0H_M_OUT_DIG__CHOICE (160u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID194_A1H_BALLAST_CNTR_CHOICE (161u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID194_A8H_N_ACTUAL_FILT_CHOICE (168u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID194_A9H_I3_ADC_VALUE_CHOICE (169u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID194_AAH_I2_ADC_VALUE_CHOICE (170u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID194_ABH_LOGIC_FREQ_CHOICE (171u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID194_ACH_PWM_1_5_6__CHOICE (172u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID194_ADH_PWM_2_3_4__CHOICE (173u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID194_AEH_PWM_3_1_2__CHOICE (174u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID194_B5H_ID_MIN_CHOICE (181u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID194_B8H_PTR_1_DEBUG_CHOICE (184u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID194_BAH_PTR_2_DEBUG_CHOICE (186u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID194_D1H_VAR_1_CHOICE (209u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID194_D2H_VAR_2_CHOICE (210u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID194_D3H_VAR_3_CHOICE (211u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID194_D4H_VAR_4_CHOICE (212u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID194_D5H_AIN_IN_1_CHOICE (213u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID194_D6H_AIN_IN_2_CHOICE (214u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID194_DEH_DIGOUTPUT_DOUT_3_CHOICE (222u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID194_DFH_DIGOUTPUT_DOUT_4_CHOICE (223u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID194_E0H_DIGOUTPUT_DOUT_1_CHOICE (224u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID194_E1H_DIGOUTPUT_DOUT_2_CHOICE (225u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID194_E2H_DIGOUTPUT_RDY_BTB_CHOICE (226u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID194_E3H_DIGSIGNAL_GO_CHOICE (227u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID194_E4H_DIGINPUT_END_1_CHOICE (228u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID194_E5H_DIGINPUT_END_2_CHOICE (229u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID194_E6H_DIGINPUT_DIN_1_CHOICE (230u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID194_E7H_DIGINPUT_DIN_2_CHOICE (231u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID194_E8H_DIGINPUT_RUN_CHOICE (232u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID194_E9H_ERROR_I_FAULT_CHOICE (233u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID194_EAH_I_BALLAST_ACT_CHOICE (234u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID194_EBH_VDC_BUS_CHOICE (235u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID194_ECH_FB_LOSSOFSIGNAL_CHOICE (236u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID194_F2H_DIGSIGNAL_BRAKE_CHOICE (242u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID194_F3H_DIGSIGNAL_ICNS_CHOICE (243u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID194_F4H_DIGSIGNAL_POSTOLER_SET_CHOICE (244u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID194_F5H_DIGSIGNAL_LESSN0_CHOICE (245u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID194_FBH_AIN_1_CALC_CHOICE (251u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID194_FCH_AIN_2_CALC_CHOICE (252u)

#define PRIMARY_INVERTER_L_SEND_SOURCE_ID195__OFF__CHOICE (0u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID195_02H_SC_INFO_CHOICE (2u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID195_11H_CONTROL_STATUS_CHOICE (17u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID195_20H_I_ACTUAL_CHOICE (32u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID195_22H_I_CMD_RAMP__CHOICE (34u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID195_23H_ID_REF_CHOICE (35u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID195_24H_I_MAX_INUSE_CHOICE (36u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID195_26H_I_CMD_CHOICE (38u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID195_27H_IQ_ACTUAL_CHOICE (39u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID195_28H_ID_ACTUAL_CHOICE (40u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID195_29H_VQ_OUTPUT_CHOICE (41u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID195_2AH_VD_OUTPUT_CHOICE (42u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID195_30H_N_ACTUAL_CHOICE (48u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID195_31H_N_SET_DIG__CHOICE (49u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID195_32H_N_CMD_RAMP__CHOICE (50u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID195_33H_N_ERROR_CHOICE (51u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID195_34H_N_LIM_CHOICE (52u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID195_38H_IQ_ERROR_CHOICE (56u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID195_39H_ID_ERROR_CHOICE (57u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID195_40H_STATUS_MAP_CHOICE (64u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID195_41H_INCR_DELTA_CHOICE (65u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID195_42H_MOTORPOS_MECH_CHOICE (66u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID195_43H_MOTORPOS_ELEC_CHOICE (67u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID195_45H_IT_RG_MONITOR_CHOICE (69u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID195_48H_I_LIMIT_INUSE_CHOICE (72u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID195_49H_T_MOTOR_CHOICE (73u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID195_4AH_T_IGBT_CHOICE (74u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID195_4BH_T_AIR_INSIDE_CHOICE (75u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID195_51_KERN_MODE_STATE_CHOICE (81u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID195_54H_I1_ACTUAL_CHOICE (84u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID195_55H_I2_ACTUAL_CHOICE (85u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID195_56H_I3_ACTUAL_CHOICE (86u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID195_57H_I_LIMIT_INUSE_RAMP__CHOICE (87u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID195_5CH_ROTOR_SIGNALS_CHOICE (92u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID195_5DH_N_CMD_INT__CHOICE (93u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID195_5FH_I_ACTUAL_FILT_CHOICE (95u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID195_61H_IXT_MONITOR_CHOICE (97u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID195_63H_FPGA_STATUS_CHOICE (99u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID195_66H_VDC_BUS_FILT_CHOICE (102u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID195_6DH_POS_ACTUAL_CHOICE (109u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID195_6EH_POS_DESTINATION_CHOICE (110u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID195_6FH_POS_ACTUAL_2_CHOICE (111u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID195_70H_POS_ERROR_CHOICE (112u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID195_74H_POS_ZEROCAPTURE_CHOICE (116u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID195_8AH_V_OUTPUT_CHOICE (138u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID195_8BH_V_RED_REF__CHOICE (139u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID195_8CH_V_CONTROL_KP_CHOICE (140u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID195_8DH_V_CONTROL_TI_CHOICE (141u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID195_8FH_ERRORWARNING_MAP_CHOICE (143u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID195_90H_M_SET_DIG__CHOICE (144u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID195_91H_POS_CMD_CHOICE (145u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID195_98H_LOGIC_O_BLOCK_CHOICE (152u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID195_99H_INFO_TIMER_DIFF_CHOICE (153u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID195_9AH_TEMP_DEBUG_CHOICE (154u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID195_9BH_LOGIC_I_BLOCK_CHOICE (155u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID195_A0H_M_OUT_DIG__CHOICE (160u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID195_A1H_BALLAST_CNTR_CHOICE (161u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID195_A8H_N_ACTUAL_FILT_CHOICE (168u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID195_A9H_I3_ADC_VALUE_CHOICE (169u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID195_AAH_I2_ADC_VALUE_CHOICE (170u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID195_ABH_LOGIC_FREQ_CHOICE (171u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID195_ACH_PWM_1_5_6__CHOICE (172u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID195_ADH_PWM_2_3_4__CHOICE (173u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID195_AEH_PWM_3_1_2__CHOICE (174u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID195_B5H_ID_MIN_CHOICE (181u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID195_B8H_PTR_1_DEBUG_CHOICE (184u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID195_BAH_PTR_2_DEBUG_CHOICE (186u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID195_D1H_VAR_1_CHOICE (209u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID195_D2H_VAR_2_CHOICE (210u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID195_D3H_VAR_3_CHOICE (211u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID195_D4H_VAR_4_CHOICE (212u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID195_D5H_AIN_IN_1_CHOICE (213u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID195_D6H_AIN_IN_2_CHOICE (214u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID195_DEH_DIGOUTPUT_DOUT_3_CHOICE (222u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID195_DFH_DIGOUTPUT_DOUT_4_CHOICE (223u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID195_E0H_DIGOUTPUT_DOUT_1_CHOICE (224u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID195_E1H_DIGOUTPUT_DOUT_2_CHOICE (225u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID195_E2H_DIGOUTPUT_RDY_BTB_CHOICE (226u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID195_E3H_DIGSIGNAL_GO_CHOICE (227u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID195_E4H_DIGINPUT_END_1_CHOICE (228u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID195_E5H_DIGINPUT_END_2_CHOICE (229u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID195_E6H_DIGINPUT_DIN_1_CHOICE (230u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID195_E7H_DIGINPUT_DIN_2_CHOICE (231u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID195_E8H_DIGINPUT_RUN_CHOICE (232u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID195_E9H_ERROR_I_FAULT_CHOICE (233u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID195_EAH_I_BALLAST_ACT_CHOICE (234u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID195_EBH_VDC_BUS_CHOICE (235u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID195_ECH_FB_LOSSOFSIGNAL_CHOICE (236u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID195_F2H_DIGSIGNAL_BRAKE_CHOICE (242u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID195_F3H_DIGSIGNAL_ICNS_CHOICE (243u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID195_F4H_DIGSIGNAL_POSTOLER_SET_CHOICE (244u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID195_F5H_DIGSIGNAL_LESSN0_CHOICE (245u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID195_FBH_AIN_1_CALC_CHOICE (251u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID195_FCH_AIN_2_CALC_CHOICE (252u)

#define PRIMARY_INVERTER_L_SEND_SOURCE_ID218__OFF__CHOICE (0u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID218_02H_SC_INFO_CHOICE (2u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID218_11H_CONTROL_STATUS_CHOICE (17u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID218_20H_I_ACTUAL_CHOICE (32u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID218_22H_I_CMD_RAMP__CHOICE (34u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID218_23H_ID_REF_CHOICE (35u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID218_24H_I_MAX_INUSE_CHOICE (36u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID218_26H_I_CMD_CHOICE (38u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID218_27H_IQ_ACTUAL_CHOICE (39u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID218_28H_ID_ACTUAL_CHOICE (40u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID218_29H_VQ_OUTPUT_CHOICE (41u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID218_2AH_VD_OUTPUT_CHOICE (42u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID218_30H_N_ACTUAL_CHOICE (48u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID218_31H_N_SET_DIG__CHOICE (49u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID218_32H_N_CMD_RAMP__CHOICE (50u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID218_33H_N_ERROR_CHOICE (51u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID218_34H_N_LIM_CHOICE (52u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID218_38H_IQ_ERROR_CHOICE (56u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID218_39H_ID_ERROR_CHOICE (57u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID218_40H_STATUS_MAP_CHOICE (64u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID218_41H_INCR_DELTA_CHOICE (65u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID218_42H_MOTORPOS_MECH_CHOICE (66u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID218_43H_MOTORPOS_ELEC_CHOICE (67u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID218_45H_IT_RG_MONITOR_CHOICE (69u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID218_48H_I_LIMIT_INUSE_CHOICE (72u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID218_49H_T_MOTOR_CHOICE (73u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID218_4AH_T_IGBT_CHOICE (74u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID218_4BH_T_AIR_INSIDE_CHOICE (75u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID218_51_KERN_MODE_STATE_CHOICE (81u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID218_54H_I1_ACTUAL_CHOICE (84u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID218_55H_I2_ACTUAL_CHOICE (85u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID218_56H_I3_ACTUAL_CHOICE (86u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID218_57H_I_LIMIT_INUSE_RAMP__CHOICE (87u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID218_5CH_ROTOR_SIGNALS_CHOICE (92u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID218_5DH_N_CMD_INT__CHOICE (93u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID218_5FH_I_ACTUAL_FILT_CHOICE (95u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID218_61H_IXT_MONITOR_CHOICE (97u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID218_63H_FPGA_STATUS_CHOICE (99u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID218_66H_VDC_BUS_FILT_CHOICE (102u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID218_6DH_POS_ACTUAL_CHOICE (109u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID218_6EH_POS_DESTINATION_CHOICE (110u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID218_6FH_POS_ACTUAL_2_CHOICE (111u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID218_70H_POS_ERROR_CHOICE (112u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID218_74H_POS_ZEROCAPTURE_CHOICE (116u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID218_8AH_V_OUTPUT_CHOICE (138u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID218_8BH_V_RED_REF__CHOICE (139u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID218_8CH_V_CONTROL_KP_CHOICE (140u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID218_8DH_V_CONTROL_TI_CHOICE (141u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID218_8FH_ERRORWARNING_MAP_CHOICE (143u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID218_90H_M_SET_DIG__CHOICE (144u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID218_91H_POS_CMD_CHOICE (145u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID218_98H_LOGIC_O_BLOCK_CHOICE (152u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID218_99H_INFO_TIMER_DIFF_CHOICE (153u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID218_9AH_TEMP_DEBUG_CHOICE (154u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID218_9BH_LOGIC_I_BLOCK_CHOICE (155u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID218_A0H_M_OUT_DIG__CHOICE (160u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID218_A1H_BALLAST_CNTR_CHOICE (161u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID218_A8H_N_ACTUAL_FILT_CHOICE (168u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID218_A9H_I3_ADC_VALUE_CHOICE (169u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID218_AAH_I2_ADC_VALUE_CHOICE (170u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID218_ABH_LOGIC_FREQ_CHOICE (171u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID218_ACH_PWM_1_5_6__CHOICE (172u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID218_ADH_PWM_2_3_4__CHOICE (173u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID218_AEH_PWM_3_1_2__CHOICE (174u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID218_B5H_ID_MIN_CHOICE (181u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID218_B8H_PTR_1_DEBUG_CHOICE (184u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID218_BAH_PTR_2_DEBUG_CHOICE (186u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID218_D1H_VAR_1_CHOICE (209u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID218_D2H_VAR_2_CHOICE (210u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID218_D3H_VAR_3_CHOICE (211u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID218_D4H_VAR_4_CHOICE (212u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID218_D5H_AIN_IN_1_CHOICE (213u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID218_D6H_AIN_IN_2_CHOICE (214u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID218_DEH_DIGOUTPUT_DOUT_3_CHOICE (222u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID218_DFH_DIGOUTPUT_DOUT_4_CHOICE (223u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID218_E0H_DIGOUTPUT_DOUT_1_CHOICE (224u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID218_E1H_DIGOUTPUT_DOUT_2_CHOICE (225u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID218_E2H_DIGOUTPUT_RDY_BTB_CHOICE (226u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID218_E3H_DIGSIGNAL_GO_CHOICE (227u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID218_E4H_DIGINPUT_END_1_CHOICE (228u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID218_E5H_DIGINPUT_END_2_CHOICE (229u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID218_E6H_DIGINPUT_DIN_1_CHOICE (230u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID218_E7H_DIGINPUT_DIN_2_CHOICE (231u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID218_E8H_DIGINPUT_RUN_CHOICE (232u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID218_E9H_ERROR_I_FAULT_CHOICE (233u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID218_EAH_I_BALLAST_ACT_CHOICE (234u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID218_EBH_VDC_BUS_CHOICE (235u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID218_ECH_FB_LOSSOFSIGNAL_CHOICE (236u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID218_F2H_DIGSIGNAL_BRAKE_CHOICE (242u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID218_F3H_DIGSIGNAL_ICNS_CHOICE (243u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID218_F4H_DIGSIGNAL_POSTOLER_SET_CHOICE (244u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID218_F5H_DIGSIGNAL_LESSN0_CHOICE (245u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID218_FBH_AIN_1_CALC_CHOICE (251u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID218_FCH_AIN_2_CALC_CHOICE (252u)

#define PRIMARY_INVERTER_L_SEND_SOURCE_ID219__OFF__CHOICE (0u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID219_02H_SC_INFO_CHOICE (2u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID219_11H_CONTROL_STATUS_CHOICE (17u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID219_20H_I_ACTUAL_CHOICE (32u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID219_22H_I_CMD_RAMP__CHOICE (34u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID219_23H_ID_REF_CHOICE (35u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID219_24H_I_MAX_INUSE_CHOICE (36u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID219_26H_I_CMD_CHOICE (38u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID219_27H_IQ_ACTUAL_CHOICE (39u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID219_28H_ID_ACTUAL_CHOICE (40u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID219_29H_VQ_OUTPUT_CHOICE (41u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID219_2AH_VD_OUTPUT_CHOICE (42u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID219_30H_N_ACTUAL_CHOICE (48u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID219_31H_N_SET_DIG__CHOICE (49u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID219_32H_N_CMD_RAMP__CHOICE (50u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID219_33H_N_ERROR_CHOICE (51u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID219_34H_N_LIM_CHOICE (52u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID219_38H_IQ_ERROR_CHOICE (56u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID219_39H_ID_ERROR_CHOICE (57u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID219_40H_STATUS_MAP_CHOICE (64u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID219_41H_INCR_DELTA_CHOICE (65u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID219_42H_MOTORPOS_MECH_CHOICE (66u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID219_43H_MOTORPOS_ELEC_CHOICE (67u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID219_45H_IT_RG_MONITOR_CHOICE (69u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID219_48H_I_LIMIT_INUSE_CHOICE (72u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID219_49H_T_MOTOR_CHOICE (73u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID219_4AH_T_IGBT_CHOICE (74u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID219_4BH_T_AIR_INSIDE_CHOICE (75u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID219_51_KERN_MODE_STATE_CHOICE (81u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID219_54H_I1_ACTUAL_CHOICE (84u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID219_55H_I2_ACTUAL_CHOICE (85u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID219_56H_I3_ACTUAL_CHOICE (86u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID219_57H_I_LIMIT_INUSE_RAMP__CHOICE (87u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID219_5CH_ROTOR_SIGNALS_CHOICE (92u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID219_5DH_N_CMD_INT__CHOICE (93u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID219_5FH_I_ACTUAL_FILT_CHOICE (95u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID219_61H_IXT_MONITOR_CHOICE (97u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID219_63H_FPGA_STATUS_CHOICE (99u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID219_66H_VDC_BUS_FILT_CHOICE (102u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID219_6DH_POS_ACTUAL_CHOICE (109u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID219_6EH_POS_DESTINATION_CHOICE (110u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID219_6FH_POS_ACTUAL_2_CHOICE (111u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID219_70H_POS_ERROR_CHOICE (112u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID219_74H_POS_ZEROCAPTURE_CHOICE (116u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID219_8AH_V_OUTPUT_CHOICE (138u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID219_8BH_V_RED_REF__CHOICE (139u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID219_8CH_V_CONTROL_KP_CHOICE (140u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID219_8DH_V_CONTROL_TI_CHOICE (141u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID219_8FH_ERRORWARNING_MAP_CHOICE (143u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID219_90H_M_SET_DIG__CHOICE (144u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID219_91H_POS_CMD_CHOICE (145u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID219_98H_LOGIC_O_BLOCK_CHOICE (152u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID219_99H_INFO_TIMER_DIFF_CHOICE (153u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID219_9AH_TEMP_DEBUG_CHOICE (154u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID219_9BH_LOGIC_I_BLOCK_CHOICE (155u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID219_A0H_M_OUT_DIG__CHOICE (160u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID219_A1H_BALLAST_CNTR_CHOICE (161u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID219_A8H_N_ACTUAL_FILT_CHOICE (168u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID219_A9H_I3_ADC_VALUE_CHOICE (169u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID219_AAH_I2_ADC_VALUE_CHOICE (170u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID219_ABH_LOGIC_FREQ_CHOICE (171u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID219_ACH_PWM_1_5_6__CHOICE (172u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID219_ADH_PWM_2_3_4__CHOICE (173u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID219_AEH_PWM_3_1_2__CHOICE (174u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID219_B5H_ID_MIN_CHOICE (181u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID219_B8H_PTR_1_DEBUG_CHOICE (184u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID219_BAH_PTR_2_DEBUG_CHOICE (186u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID219_D1H_VAR_1_CHOICE (209u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID219_D2H_VAR_2_CHOICE (210u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID219_D3H_VAR_3_CHOICE (211u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID219_D4H_VAR_4_CHOICE (212u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID219_D5H_AIN_IN_1_CHOICE (213u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID219_D6H_AIN_IN_2_CHOICE (214u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID219_DEH_DIGOUTPUT_DOUT_3_CHOICE (222u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID219_DFH_DIGOUTPUT_DOUT_4_CHOICE (223u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID219_E0H_DIGOUTPUT_DOUT_1_CHOICE (224u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID219_E1H_DIGOUTPUT_DOUT_2_CHOICE (225u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID219_E2H_DIGOUTPUT_RDY_BTB_CHOICE (226u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID219_E3H_DIGSIGNAL_GO_CHOICE (227u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID219_E4H_DIGINPUT_END_1_CHOICE (228u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID219_E5H_DIGINPUT_END_2_CHOICE (229u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID219_E6H_DIGINPUT_DIN_1_CHOICE (230u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID219_E7H_DIGINPUT_DIN_2_CHOICE (231u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID219_E8H_DIGINPUT_RUN_CHOICE (232u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID219_E9H_ERROR_I_FAULT_CHOICE (233u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID219_EAH_I_BALLAST_ACT_CHOICE (234u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID219_EBH_VDC_BUS_CHOICE (235u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID219_ECH_FB_LOSSOFSIGNAL_CHOICE (236u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID219_F2H_DIGSIGNAL_BRAKE_CHOICE (242u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID219_F3H_DIGSIGNAL_ICNS_CHOICE (243u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID219_F4H_DIGSIGNAL_POSTOLER_SET_CHOICE (244u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID219_F5H_DIGSIGNAL_LESSN0_CHOICE (245u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID219_FBH_AIN_1_CALC_CHOICE (251u)
#define PRIMARY_INVERTER_L_SEND_SOURCE_ID219_FCH_AIN_2_CALC_CHOICE (252u)

#define PRIMARY_INVERTER_L_SEND_CS_CMD_TYPE_DIGITAL_COMMANDS_CHOICE (0u)
#define PRIMARY_INVERTER_L_SEND_CS_CMD_TYPE_DIG_ANA_SPEED_CHOICE (1u)
#define PRIMARY_INVERTER_L_SEND_CS_CMD_TYPE_ANALOG_SPEED_CHOICE (2u)
#define PRIMARY_INVERTER_L_SEND_CS_CMD_TYPE_ANALOG_TORQUE_CHOICE (3u)

#define PRIMARY_INVERTER_L_SEND_MOTORTYPE_EC_SERVO_CHOICE (0u)
#define PRIMARY_INVERTER_L_SEND_MOTORTYPE_ACI_V_F_CHOICE (1u)
#define PRIMARY_INVERTER_L_SEND_MOTORTYPE_ACI_SERVO_CHOICE (2u)
#define PRIMARY_INVERTER_L_SEND_MOTORTYPE_DC_CHOICE (3u)

#define PRIMARY_INVERTER_L_SEND_MO_SC2_RESO_14_BIT_CHOICE (1u)
#define PRIMARY_INVERTER_L_SEND_MO_SC2_RESO_12_BIT_CHOICE (2u)
#define PRIMARY_INVERTER_L_SEND_MO_SC2_RESO_10_BIT_CHOICE (3u)

#define PRIMARY_INVERTER_L_SEND_ACTIVE190_LOW_CHOICE (0u)
#define PRIMARY_INVERTER_L_SEND_ACTIVE190_HIGH_CHOICE (1u)

#define PRIMARY_INVERTER_L_SEND_ACTIVE191_LOW_CHOICE (0u)
#define PRIMARY_INVERTER_L_SEND_ACTIVE191_HIGH_CHOICE (1u)

#define PRIMARY_INVERTER_L_SEND_ACTIVE192_LOW_CHOICE (0u)
#define PRIMARY_INVERTER_L_SEND_ACTIVE192_HIGH_CHOICE (1u)

#define PRIMARY_INVERTER_L_SEND_ACTIVE193_LOW_CHOICE (0u)
#define PRIMARY_INVERTER_L_SEND_ACTIVE193_HIGH_CHOICE (1u)

#define PRIMARY_INVERTER_L_SEND_PWM_FREQ_8_KHZ_CHOICE (0u)
#define PRIMARY_INVERTER_L_SEND_PWM_FREQ_24_KHZ_CHOICE (1u)
#define PRIMARY_INVERTER_L_SEND_PWM_FREQ_20_KHZ_CHOICE (2u)
#define PRIMARY_INVERTER_L_SEND_PWM_FREQ_16_KHZ_CHOICE (3u)
#define PRIMARY_INVERTER_L_SEND_PWM_FREQ_12_KHZ_CHOICE (4u)
#define PRIMARY_INVERTER_L_SEND_PWM_FREQ_8_KHZ_I16_CHOICE (5u)
#define PRIMARY_INVERTER_L_SEND_PWM_FREQ_6_KHZ_I12_CHOICE (6u)
#define PRIMARY_INVERTER_L_SEND_PWM_FREQ_4_KHZ_I12_CHOICE (7u)

#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_05_MOTOR_F_NOM_CHOICE (5u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_06_MOTOR_V_NOM_CHOICE (6u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_07_FU_T_DC_CHOICE (7u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_08_FU_V_DC_CHOICE (8u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_0F_FU_EXTRA_CHOICE (9u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_0A_FU_U_MIN_CHOICE (10u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_0B_FU_F_MIN_CHOICE (11u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_0C_FU_V_CORNER_CHOICE (12u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_0D_FU_F_CORNER_CHOICE (13u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_0E_MOTOR_COS_PHI_CHOICE (14u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_10_OSZI_CHANNEL_CHOICE (16u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_11_CONTROL_STATUS_CHOICE (17u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_12_OSZI_TRIGER_LEVEL_CHOICE (18u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_13_OSZI_TRIGER_EDGE_CHOICE (19u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_14_OSZI_TRIGER_SOURCE_CHOICE (20u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_15_OSZI_SOURCE_CHOICE (21u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_16_OSZI_SKIP_CHOICE (22u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_17_OSZI_READ_CMD_CHOICE (23u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_18_OSZI_RUN_CMD_CHOICE (24u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_19_PWM_ENUM_CHOICE (25u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_1A_CALIB_REF_VALUE_CHOICE (26u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_1B_FW_NR_CHOICE (27u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_1C_PID_I_KP_CHOICE (28u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_1D_PID_I_TI_CHOICE (29u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_1E_CUTOFFDIG_CHOICE (30u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_1F_I3_OFFSET_CHOICE (31u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_20_I_ACTUAL_CHOICE (32u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_21_ID_SETDIG_CHOICE (33u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_22_I_CMD_RAMP_CHOICE (34u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_23_ID_REF_CHOICE (35u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_24_I_MAX_INUSE_CHOICE (36u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_25_I_DELTA_RAMP_CHOICE (37u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_26_I_CMD_CHOICE (38u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_27_IQ_ACTUAL_CHOICE (39u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_28_ID_ACTUAL_CHOICE (40u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_29_VQ_OUTPUT_CHOICE (41u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_2A_VD_OUTPUT_CHOICE (42u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_2B_PID_I_TIM_CHOICE (43u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_2C_PID_N_KP_CHOICE (44u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_2D_PID_N_TI_CHOICE (45u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_2E_PID_N_TD_CHOICE (46u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_2F_AIN_IN_1_OFFSSCALE_CHOICE (47u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_30_N_ACTUAL_CHOICE (48u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_31_N_SETDIG_CHOICE (49u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_32_N_CMD_RAMP_CHOICE (50u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_33_N_ERROR_CHOICE (51u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_34_N_LIM_CHOICE (52u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_35_ACC_RAMPS_CHOICE (53u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_36_COMMANDSOURCE_CHOICE (54u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_37_DZR_SEQUENCER_VALUE_CHOICE (55u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_38_IQ_ERROR_CHOICE (56u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_39_ID_ERROR_CHOICE (57u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_3A_M_CMD_RAMP_CHOICE (58u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_3B_PID_N_TIM_CHOICE (59u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_3C_I_DERATING_N_PERC_CHOICE (60u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_3E_N_LIM_MINUS_CHOICE (62u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_3F_N_LIM_PLUS_CHOICE (63u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_40_STATUS_MAP_CHOICE (64u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_41_INCR_DELTA_CHOICE (65u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_42_MOTORPOSITION_MECH_CHOICE (66u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_43_MOTORPOSITION_ELEC_CHOICE (67u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_44_FEEDBACK_OFFSET_ANGLE_CHOICE (68u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_45_IXT_AND_REGENE_MONITOR_CHOICE (69u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_46_I_LIM_DIG_PERC_CHOICE (70u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_48_I_LIMIT_INUSE_CHOICE (72u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_49_T_MOTOR_CHOICE (73u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_4A_T_IGBT_CHOICE (74u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_4B_T_AIR_INSIDE_CHOICE (75u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_4C_I_DERATING_TE_CHOICE (76u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_4D_MOTOR_I_MAX_EFF_ARMS_CHOICE (77u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_4E_MOTOR_I_NOM_EFF_ARMS_CHOICE (78u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_4F_MOTOR_POLE_NUMBER_CHOICE (79u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_50_AIN_IN_1_CUTOFF_CHOICE (80u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_51_KERN_MODE_STATE_CHOICE (81u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_52_STATUS_MASK_CHOICE (82u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_53_AIN_IN_2_CUTOFF_CHOICE (83u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_54_I1_ACTUAL_CHOICE (84u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_55_I2_ACTUAL_CHOICE (85u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_56_I3_ACTUAL_CHOICE (86u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_57_I_LIMIT_INUSE_RAMP_CHOICE (87u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_58_I_DERATING_TD_CHOICE (88u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_59_MOTOR_NOMINAL_SPEED_CHOICE (89u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_5A_DEVICE_OPTIONS_CHOICE (90u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_5B_SPEEDCONTROL_KACC_CHOICE (91u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_5C_ROTOR_SIGNALS_CHOICE (92u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_5D_N_CMD_CHOICE (93u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_5E_SPEED_FILTER_CHOICE (94u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_5F_I_ACTUAL_FILT_CHOICE (95u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_60_AIN_IN_X_FILTER_CHOICE (96u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_61_IXT_MONITOR_CHOICE (97u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_62_SERIALNUMBER_CHOICE (98u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_63_ECODE_STATUS_CHOICE (99u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_64_DEVICE_MAINS_SUPPLY_V_CHOICE (100u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_65_REGEN_RESISTOR_P_AND_R_CHOICE (101u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_66_DC_BUS_VOLTAGE_CHOICE (102u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_67_DEVICE_TYPE_CHOICE (103u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_68_CAN_ID_RX_CHOICE (104u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_69_CAN_ID_TX_CHOICE (105u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_6A_POS_PID_KP_CHOICE (106u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_6B_POS_PID_TI_CHOICE (107u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_6C_POS_PID_TD_CHOICE (108u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_6D_POS_ACTUAL_CHOICE (109u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_6E_POS_DESTINATION_CHOICE (110u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_6F_POS_ACTUAL_2_CHOICE (111u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_70_POS_ERROR_CHOICE (112u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_71_POS_PID_TIM_CHOICE (113u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_72_POS_OFFSETREFERENCE_CHOICE (114u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_73_CAN_NBT_CHOICE (115u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_74_POS_ZERO_CAPTURE_CHOICE (116u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_75_POS_REF_RESO_EDGE_CHOICE (117u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_76_POS_CALIB_SPEED_1_CHOICE (118u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_77_POS_CALIB_SPEED_2_CHOICE (119u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_78_POS_REF_START_CHOICE (120u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_79_POS_TOL_WINDOW_CHOICE (121u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_7A_POS_PRESET_VALUE_CHOICE (122u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_7B_POS_ZERO_OFFSET_CHOICE (123u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_7C_POS_NDRIVE_SCALE_CHOICE (124u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_7D_POS_NDRIVE_OFFSET_CHOICE (125u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_7E_POS_FB2_SCALE_FAC_EXT_CHOICE (126u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_7F_POS_OFFSET_SLACK_CHOICE (127u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_80_POS_DIFF_SLACK_CHOICE (128u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_83_FUNCTION_PARAMETER_READ_CHOICE (131u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_84_FUNCTION_PARAMETER_WRITE_CHOICE (132u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_85_FUNCTION_SPECIAL_CHOICE (133u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_88_CAN_ID_2_RX_CHOICE (136u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_89_CAN_ID_2_TX_CHOICE (137u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_8A_V_OUTPUT_CHOICE (138u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_8B_VOLTAGECONTROL_REF_CHOICE (139u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_8C_VOLTAGECONTROL_KP_CHOICE (140u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_8D_VOLTAGECONTROL_TI_CHOICE (141u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_8E_CLEAR_ERROR_LIST_CHOICE (142u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_8F_ERRORWARNING_MAP_CHOICE (143u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_90_M_SETDIG_CHOICE (144u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_91_POS_CMD_INT_CHOICE (145u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_92_CAN_ERROR_BUSOFF_CNTR_CHOICE (146u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_93_CAN_ERROR_WRITETIME_CNTR_CHOICE (147u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_94_ECODE_1STERROR_CHOICE (148u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_95_CAN_ERROR_NOACK_CNTR_CHOICE (149u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_96_CAN_ERROR_CRC_CHECK_CNTR_CHOICE (150u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_97_CAN_ERROR_BIT_CNTR_CHOICE (151u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_97_LOGICOUTBLOCK_CHOICE (152u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_99_INFO_TIMER_DIFF_CHOICE (153u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_9A_TEMP_DEBUG_CHOICE (154u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_9B_LOGICINBLOCK_CHOICE (155u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_A0_M_OUTDIG_CHOICE (160u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_A1_BALLAST_CNTR_CHOICE (161u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_A2_I_DERATING_TM_CHOICE (162u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_A3_MOTOR_TEMP_ERROR_LIM_CHOICE (163u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_A4_MOTOR_OPTIONS_CHOICE (164u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_A5_DEVICE_DC_BUS_MINMAX_LIM_CHOICE (165u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_A6_FB_INCREMENTSPERROT_CHOICE (166u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_A7_FB_POLE_NUMBER_CHOICE (167u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_A8_N_ACTUAL_FILT_CHOICE (168u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_A9_I3_ADC_VALUE_CHOICE (169u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_AA_I2_ADC_VALUE_CHOICE (170u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_AB_LOGIC_FREQUENCY_CHOICE (171u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_AC_PWM_1_56_CHOICE (172u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_AD_PWM_2_34_CHOICE (173u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_AE_PWM_3_12_CHOICE (174u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_AF_TIMER_DELTA_CHOICE (175u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_B1_MOTOR_L_SIGMA_Q_CHOICE (177u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_B2_ID_NOMINAL_CHOICE (178u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_B3_MOTOR_MAGN_INDUCTANCE_CHOICE (179u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_B4_MOTOR_ROTOR_RESISTANCE_CHOICE (180u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_B5_ID_MINIMUM_CHOICE (181u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_B6_TIME_CONSTANT_ROTOR_CHOICE (182u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_B8_PTR_1_DEBUG_CHOICE (184u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_BA_PTR_2_DEBUG_CHOICE (186u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_BB_MOTOR_L_SIGMA_D_CHOICE (187u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_BC_MOTOR_STATOR_RESISTANCE_CHOICE (188u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_BD_TIME_CONSTANT_STATOR_CHOICE (189u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_BE_LOGICDEFINE_OF_END_1_CHOICE (190u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_BF_LOGICDEFINE_OF_END_2_CHOICE (191u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_C0_LOGICDEFINE_OF_DIN_1_CHOICE (192u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_C1_LOGICDEFINE_OF_DIN_2_CHOICE (193u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_C2_LOGICDEFINE_OF_OUT_1_CHOICE (194u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_C3_LOGICDEFINE_OF_OUT_2_CHOICE (195u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_C4_I_MAX_PK_PERC_CHOICE (196u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_C5_I_CON_EFF_PERC_CHOICE (197u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_C6_I_DEVICE_CHOICE (198u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_C7_RLIM_MRCP_RAMP_CHOICE (199u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_C8_NMAX100PERC_CHOICE (200u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_C9_PID_I_XKP_CHOICE (201u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_CA_BAT_OPR_LIMITS_CHOICE (202u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_CB_PID_I_KF_CHOICE (203u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_CC_CAR_MODE_STATUS_CHOICE (204u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_CD_CAR_MODE_CONFIG_CHOICE (205u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_CE_N_RPM_MAXINT_CHOICE (206u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_D0_CAN_TIMEOUT_CHOICE (208u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_D1_VAR_1_CHOICE (209u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_D2_VAR_2_CHOICE (210u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_D3_VAR_3_CHOICE (211u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_D4_VAR_4_CHOICE (212u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_D5_AIN_IN_1_CHOICE (213u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_D6_AIN_IN_2_CHOICE (214u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_D7_AIN_IN_2_OFFSSCALE_CHOICE (215u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_D8_LOGICREADBITSIN_OUT_CHOICE (216u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_D9_I_200PERC_CHOICE (217u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_DA_LOGICDEFINE_OF_OUT_3_CHOICE (218u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_DB_LOGICDEFINE_OF_OUT_4_CHOICE (219u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_DC_DAC_SOURCE_ID_CHOICE (220u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_DE_DIGOUTPUT_DOUT_3_CHOICE (222u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_DF_DIGOUTPUT_DOUT_4_CHOICE (223u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_E0_DIGOUTPUT_DOUT_1_CHOICE (224u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_E1_DIGOUTPUT_DOUT_2_CHOICE (225u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_E2_DIGOUTPUT_RDY_BTB_CHOICE (226u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_E3_DIGSIGNAL_GO_CHOICE (227u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_E4_DIGINPUT_END_1_CHOICE (228u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_E5_DIGINPUT_END_2_CHOICE (229u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_E6_DIGINPUT_DIN_1_CHOICE (230u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_E7_DIGINPUT_DIN_2_CHOICE (231u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_E8_DIGINPUT_RUN_CHOICE (232u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_E9_ERROR_I_FAULT_CHOICE (233u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_EB_DC_BUS_VOLTAGE_FILT_CHOICE (235u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_EC_DIGSIGNAL_FB_LOSSOFSIG_CHOICE (236u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_ED_DEC_RAMPS_CHOICE (237u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_EE_V_SHUNT_CHOICE (238u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_EF_DIGSIGNAL_NOHWFAULT_CHOICE (239u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_F0_TIME_I_PEAK_CHOICE (240u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_F1_BRAKE_DELAY_CHOICE (241u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_F2_DIGSIGNAL_BRAKE_CHOICE (242u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_F3_DIGSIGNAL_ICNS_CHOICE (243u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_F4_DIGSIGNAL_POS_TOLERANCE_CHOICE (244u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_F5_DIGSIGNAL_LESSN0_CHOICE (245u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_F6_INVERTER_OUTPUT_POWER_CHOICE (246u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_F7_INVERTER_OUTPUT_WORK_CHOICE (247u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_F8_AXIS_LABEL_CHOICE (248u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_FB_AIN_IN_1_CALC_CHOICE (251u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_FC_AIN_IN_2_CALC_CHOICE (252u)
#define PRIMARY_INVERTER_L_RCV_RCV_MUX_ID_FE_FW_SUBV_REVIS_NR_CHOICE (254u)

#define PRIMARY_INVERTER_L_RCV_DEVICETYPE_HOMEMADE_CHOICE (0u)
#define PRIMARY_INVERTER_L_RCV_DEVICETYPE_DS205_2PH_230V_CHOICE (14u)
#define PRIMARY_INVERTER_L_RCV_DEVICETYPE_DS403_2PH_400V_CHOICE (15u)
#define PRIMARY_INVERTER_L_RCV_DEVICETYPE_DS205_NEU_230V_CHOICE (16u)
#define PRIMARY_INVERTER_L_RCV_DEVICETYPE_DS403_NEU_400V_CHOICE (17u)
#define PRIMARY_INVERTER_L_RCV_DEVICETYPE_DS405_CHOICE (19u)
#define PRIMARY_INVERTER_L_RCV_DEVICETYPE_DS412_CHOICE (21u)
#define PRIMARY_INVERTER_L_RCV_DEVICETYPE_DS420_CHOICE (23u)
#define PRIMARY_INVERTER_L_RCV_DEVICETYPE_DS450_CHOICE (25u)
#define PRIMARY_INVERTER_L_RCV_DEVICETYPE_DS475_CHOICE (27u)
#define PRIMARY_INVERTER_L_RCV_DEVICETYPE_DS4100_CHOICE (29u)
#define PRIMARY_INVERTER_L_RCV_DEVICETYPE_DS4820_CHOICE (48u)
#define PRIMARY_INVERTER_L_RCV_DEVICETYPE_DS451_CHOICE (49u)
#define PRIMARY_INVERTER_L_RCV_DEVICETYPE_DS476_CHOICE (51u)
#define PRIMARY_INVERTER_L_RCV_DEVICETYPE_DS8020_CHOICE (56u)
#define PRIMARY_INVERTER_L_RCV_DEVICETYPE_DPC440_CHOICE (60u)
#define PRIMARY_INVERTER_L_RCV_DEVICETYPE_DPC460_CHOICE (65u)
#define PRIMARY_INVERTER_L_RCV_DEVICETYPE_DPC460_DC1Q_3P_CHOICE (67u)
#define PRIMARY_INVERTER_L_RCV_DEVICETYPE_BAMO_160_60_CHOICE (81u)
#define PRIMARY_INVERTER_L_RCV_DEVICETYPE_BAMO_160_120_CHOICE (83u)
#define PRIMARY_INVERTER_L_RCV_DEVICETYPE_BAMO_160_180_CHOICE (85u)
#define PRIMARY_INVERTER_L_RCV_DEVICETYPE_BAMO_360_60_CHOICE (87u)
#define PRIMARY_INVERTER_L_RCV_DEVICETYPE_BAMO_360_120_CHOICE (89u)
#define PRIMARY_INVERTER_L_RCV_DEVICETYPE_BAMO_360_180_CHOICE (91u)
#define PRIMARY_INVERTER_L_RCV_DEVICETYPE_BAMO_360_240_CHOICE (93u)
#define PRIMARY_INVERTER_L_RCV_DEVICETYPE_BAMOBIL_D3_3_62_80_CHOICE (112u)
#define PRIMARY_INVERTER_L_RCV_DEVICETYPE_BAMOBIL_D3_2_62_80_CHOICE (113u)
#define PRIMARY_INVERTER_L_RCV_DEVICETYPE_BAMOBIL_D3_3_62_120_CHOICE (114u)
#define PRIMARY_INVERTER_L_RCV_DEVICETYPE_BAMOBIL_D3_2_62_120_CHOICE (115u)
#define PRIMARY_INVERTER_L_RCV_DEVICETYPE_BAMOBIL_D3_3_62_250_CHOICE (116u)
#define PRIMARY_INVERTER_L_RCV_DEVICETYPE_BAMOBIL_D3_2_62_250_CHOICE (117u)
#define PRIMARY_INVERTER_L_RCV_DEVICETYPE_BAMOBIL_D3_3_62_350_CHOICE (118u)
#define PRIMARY_INVERTER_L_RCV_DEVICETYPE_BAMOBIL_D3_2_62_350_CHOICE (119u)
#define PRIMARY_INVERTER_L_RCV_DEVICETYPE_BAMOBIL_D3_3_62_450_CHOICE (120u)
#define PRIMARY_INVERTER_L_RCV_DEVICETYPE_BAMOBIL_D3_2_62_450_CHOICE (121u)
#define PRIMARY_INVERTER_L_RCV_DEVICETYPE_BAMOBIL_D3_3_160_50_CHOICE (122u)
#define PRIMARY_INVERTER_L_RCV_DEVICETYPE_BAMOBIL_D3_2_160_50_CHOICE (123u)
#define PRIMARY_INVERTER_L_RCV_DEVICETYPE_BAMOBIL_D3_3_160_100_CHOICE (124u)
#define PRIMARY_INVERTER_L_RCV_DEVICETYPE_BAMOBIL_D3_2_160_100_CHOICE (125u)
#define PRIMARY_INVERTER_L_RCV_DEVICETYPE_BAMOBIL_D3_3_160_200_CHOICE (126u)
#define PRIMARY_INVERTER_L_RCV_DEVICETYPE_BAMOBIL_D3_2_160_200_CHOICE (127u)
#define PRIMARY_INVERTER_L_RCV_DEVICETYPE_BAMOCAR_700_160_CHOICE (192u)
#define PRIMARY_INVERTER_L_RCV_DEVICETYPE_BAMOCAR_700_100_CHOICE (193u)
#define PRIMARY_INVERTER_L_RCV_DEVICETYPE_BAMOCAR_700_900_CHOICE (194u)
#define PRIMARY_INVERTER_L_RCV_DEVICETYPE_BAMOCAR_700_200_DC_CHOICE (203u)
#define PRIMARY_INVERTER_L_RCV_DEVICETYPE_BAMOCAR_400_400_CHOICE (204u)
#define PRIMARY_INVERTER_L_RCV_DEVICETYPE_BAMOCAR_700_400_CHOICE (205u)
#define PRIMARY_INVERTER_L_RCV_DEVICETYPE_BAMOCAR_400_250_CHOICE (206u)
#define PRIMARY_INVERTER_L_RCV_DEVICETYPE_KOEPFER_V1_700_400_CHOICE (240u)
#define PRIMARY_INVERTER_L_RCV_DEVICETYPE_KOEPFER_V2_700_400_CHOICE (241u)

#define PRIMARY_INVERTER_L_RCV_CS_AIN_1_FORMAT_OFF_CHOICE (0u)
#define PRIMARY_INVERTER_L_RCV_CS_AIN_1_FORMAT__CMD__1_CHOICE (1u)
#define PRIMARY_INVERTER_L_RCV_CS_AIN_1_FORMAT__CMD__2_CHOICE (2u)
#define PRIMARY_INVERTER_L_RCV_CS_AIN_1_FORMAT_SQ_CMD_CHOICE (3u)

#define PRIMARY_INVERTER_L_RCV_ACTIVECONTROLMODE_TURNED_OFF_CHOICE (0u)
#define PRIMARY_INVERTER_L_RCV_ACTIVECONTROLMODE_CURRENT_DIGITAL_CHOICE (1u)
#define PRIMARY_INVERTER_L_RCV_ACTIVECONTROLMODE_SPEED_ANALOG_CHOICE (2u)
#define PRIMARY_INVERTER_L_RCV_ACTIVECONTROLMODE_SPEED_CALIBRATION_CHOICE (3u)
#define PRIMARY_INVERTER_L_RCV_ACTIVECONTROLMODE_SPEED_DIGITAL_CHOICE (4u)
#define PRIMARY_INVERTER_L_RCV_ACTIVECONTROLMODE_SPEED_MIXED_CHOICE (5u)
#define PRIMARY_INVERTER_L_RCV_ACTIVECONTROLMODE_SPEED_HOLD_CHOICE (6u)
#define PRIMARY_INVERTER_L_RCV_ACTIVECONTROLMODE_TORQUE_ANALOG_CHOICE (7u)
#define PRIMARY_INVERTER_L_RCV_ACTIVECONTROLMODE_TORQUE_DIGITAL_CHOICE (8u)
#define PRIMARY_INVERTER_L_RCV_ACTIVECONTROLMODE_POSITION_DIGITAL_CHOICE (9u)
#define PRIMARY_INVERTER_L_RCV_ACTIVECONTROLMODE_POSITION_HANDWHEEL_CHOICE (10u)
#define PRIMARY_INVERTER_L_RCV_ACTIVECONTROLMODE_RES2_CHOICE (11u)
#define PRIMARY_INVERTER_L_RCV_ACTIVECONTROLMODE_TUNING1_CHOICE (12u)
#define PRIMARY_INVERTER_L_RCV_ACTIVECONTROLMODE_PHASING_CHOICE (14u)
#define PRIMARY_INVERTER_L_RCV_ACTIVECONTROLMODE_DC_INJ_CHOICE (15u)
#define PRIMARY_INVERTER_L_RCV_ACTIVECONTROLMODE_TACHO_OFFS_CHOICE (16u)
#define PRIMARY_INVERTER_L_RCV_ACTIVECONTROLMODE_CALC_CHOICE (17u)
#define PRIMARY_INVERTER_L_RCV_ACTIVECONTROLMODE_MEASURE_CHOICE (18u)
#define PRIMARY_INVERTER_L_RCV_ACTIVECONTROLMODE_WAIT_CHOICE (21u)

#define PRIMARY_INVERTER_L_RCV_CAN_NBT_1000_KBPS_CHOICE (16386u)
#define PRIMARY_INVERTER_L_RCV_CAN_NBT_625_KBPS_CHOICE (16404u)
#define PRIMARY_INVERTER_L_RCV_CAN_NBT_500_KBPS_CHOICE (16421u)
#define PRIMARY_INVERTER_L_RCV_CAN_NBT_250_KBPS_CHOICE (16476u)
#define PRIMARY_INVERTER_L_RCV_CAN_NBT_100_KBPS_CHOICE (17445u)

#define PRIMARY_INVERTER_L_RCV_MO_FEEDBACK_1_ROT_ENC_TTL_CHOICE (0u)
#define PRIMARY_INVERTER_L_RCV_MO_FEEDBACK_1_RESOLVER_CHOICE (1u)
#define PRIMARY_INVERTER_L_RCV_MO_FEEDBACK_1_ABS_ENC_SC_CHOICE (2u)
#define PRIMARY_INVERTER_L_RCV_MO_FEEDBACK_1_ROT_TACHO_CHOICE (3u)
#define PRIMARY_INVERTER_L_RCV_MO_FEEDBACK_1_ROT_CHOICE (4u)
#define PRIMARY_INVERTER_L_RCV_MO_FEEDBACK_1_DC_TACHO_CHOICE (5u)
#define PRIMARY_INVERTER_L_RCV_MO_FEEDBACK_1_DC_ARM_CHOICE (6u)
#define PRIMARY_INVERTER_L_RCV_MO_FEEDBACK_1_BL_ARM_CHOICE (7u)
#define PRIMARY_INVERTER_L_RCV_MO_FEEDBACK_1_ENC_TTL_CHOICE (8u)
#define PRIMARY_INVERTER_L_RCV_MO_FEEDBACK_1_ENC_SC_CHOICE (9u)
#define PRIMARY_INVERTER_L_RCV_MO_FEEDBACK_1_ABS_SC_CHOICE (10u)
#define PRIMARY_INVERTER_L_RCV_MO_FEEDBACK_1_DC_ARM_VIR_CHOICE (11u)
#define PRIMARY_INVERTER_L_RCV_MO_FEEDBACK_1_SLS_CHOICE (12u)
#define PRIMARY_INVERTER_L_RCV_MO_FEEDBACK_1_SLS_SMO_CHOICE (13u)
#define PRIMARY_INVERTER_L_RCV_MO_FEEDBACK_1_SLS_USENS_CHOICE (14u)
#define PRIMARY_INVERTER_L_RCV_MO_FEEDBACK_1_ANAIN1_CALC_CHOICE (15u)
#define PRIMARY_INVERTER_L_RCV_MO_FEEDBACK_1_ANAIN2_CALC_CHOICE (16u)
#define PRIMARY_INVERTER_L_RCV_MO_FEEDBACK_1_PANASONIC_CHOICE (17u)
#define PRIMARY_INVERTER_L_RCV_MO_FEEDBACK_1_DC_BUS_CHOICE (18u)

#define PRIMARY_INVERTER_L_RCV_DEF_END_1__OFF__CHOICE (0u)
#define PRIMARY_INVERTER_L_RCV_DEF_END_1_REF_AND_LIMIT_PLUS_CHOICE (1u)
#define PRIMARY_INVERTER_L_RCV_DEF_END_1_REF_AND_LIMIT_MINUS_CHOICE (2u)
#define PRIMARY_INVERTER_L_RCV_DEF_END_1_REF_PLUS_CHOICE (3u)
#define PRIMARY_INVERTER_L_RCV_DEF_END_1_LIMIT_PLUS_CHOICE (4u)
#define PRIMARY_INVERTER_L_RCV_DEF_END_1_LIMIT_MINUS_CHOICE (5u)
#define PRIMARY_INVERTER_L_RCV_DEF_END_1_LIMIT_PLUS_AND_MINUS_CHOICE (6u)
#define PRIMARY_INVERTER_L_RCV_DEF_END_1_CANCEL_ERROR_S__CHOICE (7u)
#define PRIMARY_INVERTER_L_RCV_DEF_END_1__START_REF_DRIVE_CHOICE (8u)
#define PRIMARY_INVERTER_L_RCV_DEF_END_1_SPEED_RAMP_0_CHOICE (9u)
#define PRIMARY_INVERTER_L_RCV_DEF_END_1__START_DEST_VAR_1_CHOICE (10u)
#define PRIMARY_INVERTER_L_RCV_DEF_END_1__START_DEST_VAR_2_CHOICE (11u)
#define PRIMARY_INVERTER_L_RCV_DEF_END_1_N_CMD_REVERSE_CHOICE (12u)
#define PRIMARY_INVERTER_L_RCV_DEF_END_1__PRESET_POS_VAR_3_CHOICE (13u)
#define PRIMARY_INVERTER_L_RCV_DEF_END_1__CAPTURE_VAR_3_POS_CHOICE (14u)
#define PRIMARY_INVERTER_L_RCV_DEF_END_1__CAPTURE_VAR_4_POS_CHOICE (15u)
#define PRIMARY_INVERTER_L_RCV_DEF_END_1__SWITCH_SPD_AIN1_AIN2_CHOICE (16u)
#define PRIMARY_INVERTER_L_RCV_DEF_END_1__SWITCH_SPD_VAR1_VAR2_CHOICE (17u)
#define PRIMARY_INVERTER_L_RCV_DEF_END_1_I_LIMIT_DIG__CHOICE (18u)
#define PRIMARY_INVERTER_L_RCV_DEF_END_1_N_CLIP_NEG_POS__CHOICE (19u)
#define PRIMARY_INVERTER_L_RCV_DEF_END_1__SWITCH_CMD_DIG_ANA_CHOICE (20u)
#define PRIMARY_INVERTER_L_RCV_DEF_END_1_SPEED_RAMP_0_POS_CHOICE (21u)
#define PRIMARY_INVERTER_L_RCV_DEF_END_1_HANDWHEEL_CHOICE (22u)
#define PRIMARY_INVERTER_L_RCV_DEF_END_1_BRAKE_CAR_CHOICE (23u)
#define PRIMARY_INVERTER_L_RCV_DEF_END_1_RECUP_DISABLED_CHOICE (24u)
#define PRIMARY_INVERTER_L_RCV_DEF_END_1_RISING_BANK_1,_FALLING_BANK_0_CHOICE (25u)
#define PRIMARY_INVERTER_L_RCV_DEF_END_1__START_DEST_VAR_1,_2,_3,_4_CHOICE (26u)
#define PRIMARY_INVERTER_L_RCV_DEF_END_1__START_CW_VAR_1,_2,_3,_4_CHOICE (27u)
#define PRIMARY_INVERTER_L_RCV_DEF_END_1_BRAKE_CAR_NR2_CHOICE (28u)

#define PRIMARY_INVERTER_L_RCV_DEF_END_2__OFF__CHOICE (0u)
#define PRIMARY_INVERTER_L_RCV_DEF_END_2_REF_AND_LIMIT_PLUS_CHOICE (1u)
#define PRIMARY_INVERTER_L_RCV_DEF_END_2_REF_AND_LIMIT_MINUS_CHOICE (2u)
#define PRIMARY_INVERTER_L_RCV_DEF_END_2_REF_PLUS_CHOICE (3u)
#define PRIMARY_INVERTER_L_RCV_DEF_END_2_LIMIT_PLUS_CHOICE (4u)
#define PRIMARY_INVERTER_L_RCV_DEF_END_2_LIMIT_MINUS_CHOICE (5u)
#define PRIMARY_INVERTER_L_RCV_DEF_END_2_LIMIT_PLUS_AND_MINUS_CHOICE (6u)
#define PRIMARY_INVERTER_L_RCV_DEF_END_2_CANCEL_ERROR_S__CHOICE (7u)
#define PRIMARY_INVERTER_L_RCV_DEF_END_2__START_REF_DRIVE_CHOICE (8u)
#define PRIMARY_INVERTER_L_RCV_DEF_END_2_SPEED_RAMP_0_CHOICE (9u)
#define PRIMARY_INVERTER_L_RCV_DEF_END_2__START_DEST_VAR_1_CHOICE (10u)
#define PRIMARY_INVERTER_L_RCV_DEF_END_2__START_DEST_VAR_2_CHOICE (11u)
#define PRIMARY_INVERTER_L_RCV_DEF_END_2_N_CMD_REVERSE_CHOICE (12u)
#define PRIMARY_INVERTER_L_RCV_DEF_END_2__PRESET_POS_VAR_3_CHOICE (13u)
#define PRIMARY_INVERTER_L_RCV_DEF_END_2__CAPTURE_VAR_3_POS_CHOICE (14u)
#define PRIMARY_INVERTER_L_RCV_DEF_END_2__CAPTURE_VAR_4_POS_CHOICE (15u)
#define PRIMARY_INVERTER_L_RCV_DEF_END_2__SWITCH_SPD_AIN1_AIN2_CHOICE (16u)
#define PRIMARY_INVERTER_L_RCV_DEF_END_2__SWITCH_SPD_VAR1_VAR2_CHOICE (17u)
#define PRIMARY_INVERTER_L_RCV_DEF_END_2_I_LIMIT_DIG__CHOICE (18u)
#define PRIMARY_INVERTER_L_RCV_DEF_END_2_N_CLIP_NEG_POS__CHOICE (19u)
#define PRIMARY_INVERTER_L_RCV_DEF_END_2__SWITCH_CMD_DIG_ANA_CHOICE (20u)
#define PRIMARY_INVERTER_L_RCV_DEF_END_2_SPEED_RAMP_0_POS_CHOICE (21u)
#define PRIMARY_INVERTER_L_RCV_DEF_END_2_HANDWHEEL_CHOICE (22u)
#define PRIMARY_INVERTER_L_RCV_DEF_END_2_BRAKE_CAR_CHOICE (23u)
#define PRIMARY_INVERTER_L_RCV_DEF_END_2_RECUP_DISABLED_CHOICE (24u)
#define PRIMARY_INVERTER_L_RCV_DEF_END_2_RISING_BANK_1,_FALLING_BANK_0_CHOICE (25u)
#define PRIMARY_INVERTER_L_RCV_DEF_END_2__START_DEST_VAR_1,_2,_3,_4_CHOICE (26u)
#define PRIMARY_INVERTER_L_RCV_DEF_END_2__START_CW_VAR_1,_2,_3,_4_CHOICE (27u)
#define PRIMARY_INVERTER_L_RCV_DEF_END_2_BRAKE_CAR_NR2_CHOICE (28u)

#define PRIMARY_INVERTER_L_RCV_DEF_DIN_1__OFF__CHOICE (0u)
#define PRIMARY_INVERTER_L_RCV_DEF_DIN_1_REF_AND_LIMIT_PLUS_CHOICE (1u)
#define PRIMARY_INVERTER_L_RCV_DEF_DIN_1_REF_AND_LIMIT_MINUS_CHOICE (2u)
#define PRIMARY_INVERTER_L_RCV_DEF_DIN_1_REF_PLUS_CHOICE (3u)
#define PRIMARY_INVERTER_L_RCV_DEF_DIN_1_LIMIT_PLUS_CHOICE (4u)
#define PRIMARY_INVERTER_L_RCV_DEF_DIN_1_LIMIT_MINUS_CHOICE (5u)
#define PRIMARY_INVERTER_L_RCV_DEF_DIN_1_LIMIT_PLUS_AND_MINUS_CHOICE (6u)
#define PRIMARY_INVERTER_L_RCV_DEF_DIN_1_CANCEL_ERROR_S__CHOICE (7u)
#define PRIMARY_INVERTER_L_RCV_DEF_DIN_1__START_REF_DRIVE_CHOICE (8u)
#define PRIMARY_INVERTER_L_RCV_DEF_DIN_1_SPEED_RAMP_0_CHOICE (9u)
#define PRIMARY_INVERTER_L_RCV_DEF_DIN_1__START_DEST_VAR_1_CHOICE (10u)
#define PRIMARY_INVERTER_L_RCV_DEF_DIN_1__START_DEST_VAR_2_CHOICE (11u)
#define PRIMARY_INVERTER_L_RCV_DEF_DIN_1_N_CMD_REVERSE_CHOICE (12u)
#define PRIMARY_INVERTER_L_RCV_DEF_DIN_1__PRESET_POS_VAR_3_CHOICE (13u)
#define PRIMARY_INVERTER_L_RCV_DEF_DIN_1__CAPTURE_VAR_3_POS_CHOICE (14u)
#define PRIMARY_INVERTER_L_RCV_DEF_DIN_1__CAPTURE_VAR_4_POS_CHOICE (15u)
#define PRIMARY_INVERTER_L_RCV_DEF_DIN_1__SWITCH_SPD_AIN1_AIN2_CHOICE (16u)
#define PRIMARY_INVERTER_L_RCV_DEF_DIN_1__SWITCH_SPD_VAR1_VAR2_CHOICE (17u)
#define PRIMARY_INVERTER_L_RCV_DEF_DIN_1_I_LIMIT_DIG__CHOICE (18u)
#define PRIMARY_INVERTER_L_RCV_DEF_DIN_1_N_CLIP_NEG_POS__CHOICE (19u)
#define PRIMARY_INVERTER_L_RCV_DEF_DIN_1__SWITCH_CMD_DIG_ANA_CHOICE (20u)
#define PRIMARY_INVERTER_L_RCV_DEF_DIN_1_SPEED_RAMP_0_POS_CHOICE (21u)
#define PRIMARY_INVERTER_L_RCV_DEF_DIN_1_HANDWHEEL_CHOICE (22u)
#define PRIMARY_INVERTER_L_RCV_DEF_DIN_1_BRAKE_CAR_CHOICE (23u)
#define PRIMARY_INVERTER_L_RCV_DEF_DIN_1_RECUP_DISABLED_CHOICE (24u)
#define PRIMARY_INVERTER_L_RCV_DEF_DIN_1_RISING_BANK_1,_FALLING_BANK_0_CHOICE (25u)
#define PRIMARY_INVERTER_L_RCV_DEF_DIN_1__START_DEST_VAR_1,_2,_3,_4_CHOICE (26u)
#define PRIMARY_INVERTER_L_RCV_DEF_DIN_1__START_CW_VAR_1,_2,_3,_4_CHOICE (27u)
#define PRIMARY_INVERTER_L_RCV_DEF_DIN_1_BRAKE_CAR_NR2_CHOICE (28u)

#define PRIMARY_INVERTER_L_RCV_DEF_DIN_2__OFF__CHOICE (0u)
#define PRIMARY_INVERTER_L_RCV_DEF_DIN_2_REF_AND_LIMIT_PLUS_CHOICE (1u)
#define PRIMARY_INVERTER_L_RCV_DEF_DIN_2_REF_AND_LIMIT_MINUS_CHOICE (2u)
#define PRIMARY_INVERTER_L_RCV_DEF_DIN_2_REF_PLUS_CHOICE (3u)
#define PRIMARY_INVERTER_L_RCV_DEF_DIN_2_LIMIT_PLUS_CHOICE (4u)
#define PRIMARY_INVERTER_L_RCV_DEF_DIN_2_LIMIT_MINUS_CHOICE (5u)
#define PRIMARY_INVERTER_L_RCV_DEF_DIN_2_LIMIT_PLUS_AND_MINUS_CHOICE (6u)
#define PRIMARY_INVERTER_L_RCV_DEF_DIN_2_CANCEL_ERROR_S__CHOICE (7u)
#define PRIMARY_INVERTER_L_RCV_DEF_DIN_2__START_REF_DRIVE_CHOICE (8u)
#define PRIMARY_INVERTER_L_RCV_DEF_DIN_2_SPEED_RAMP_0_CHOICE (9u)
#define PRIMARY_INVERTER_L_RCV_DEF_DIN_2__START_DEST_VAR_1_CHOICE (10u)
#define PRIMARY_INVERTER_L_RCV_DEF_DIN_2__START_DEST_VAR_2_CHOICE (11u)
#define PRIMARY_INVERTER_L_RCV_DEF_DIN_2_N_CMD_REVERSE_CHOICE (12u)
#define PRIMARY_INVERTER_L_RCV_DEF_DIN_2__PRESET_POS_VAR_3_CHOICE (13u)
#define PRIMARY_INVERTER_L_RCV_DEF_DIN_2__CAPTURE_VAR_3_POS_CHOICE (14u)
#define PRIMARY_INVERTER_L_RCV_DEF_DIN_2__CAPTURE_VAR_4_POS_CHOICE (15u)
#define PRIMARY_INVERTER_L_RCV_DEF_DIN_2__SWITCH_SPD_AIN1_AIN2_CHOICE (16u)
#define PRIMARY_INVERTER_L_RCV_DEF_DIN_2__SWITCH_SPD_VAR1_VAR2_CHOICE (17u)
#define PRIMARY_INVERTER_L_RCV_DEF_DIN_2_I_LIMIT_DIG__CHOICE (18u)
#define PRIMARY_INVERTER_L_RCV_DEF_DIN_2_N_CLIP_NEG_POS__CHOICE (19u)
#define PRIMARY_INVERTER_L_RCV_DEF_DIN_2__SWITCH_CMD_DIG_ANA_CHOICE (20u)
#define PRIMARY_INVERTER_L_RCV_DEF_DIN_2_SPEED_RAMP_0_POS_CHOICE (21u)
#define PRIMARY_INVERTER_L_RCV_DEF_DIN_2_HANDWHEEL_CHOICE (22u)
#define PRIMARY_INVERTER_L_RCV_DEF_DIN_2_BRAKE_CAR_CHOICE (23u)
#define PRIMARY_INVERTER_L_RCV_DEF_DIN_2_RECUP_DISABLED_CHOICE (24u)
#define PRIMARY_INVERTER_L_RCV_DEF_DIN_2_RISING_BANK_1,_FALLING_BANK_0_CHOICE (25u)
#define PRIMARY_INVERTER_L_RCV_DEF_DIN_2__START_DEST_VAR_1,_2,_3,_4_CHOICE (26u)
#define PRIMARY_INVERTER_L_RCV_DEF_DIN_2__START_CW_VAR_1,_2,_3,_4_CHOICE (27u)
#define PRIMARY_INVERTER_L_RCV_DEF_DIN_2_BRAKE_CAR_NR2_CHOICE (28u)

#define PRIMARY_INVERTER_L_RCV_OPERAND194_OFF_CHOICE (0u)
#define PRIMARY_INVERTER_L_RCV_OPERAND194_ON_CHOICE (1u)
#define PRIMARY_INVERTER_L_RCV_OPERAND194_1_HZ_CHOICE (2u)
#define PRIMARY_INVERTER_L_RCV_OPERAND194___3_CHOICE (3u)
#define PRIMARY_INVERTER_L_RCV_OPERAND194___4_CHOICE (4u)
#define PRIMARY_INVERTER_L_RCV_OPERAND194__>__5_CHOICE (5u)
#define PRIMARY_INVERTER_L_RCV_OPERAND194__<__6_CHOICE (6u)
#define PRIMARY_INVERTER_L_RCV_OPERAND194__ABS_>__CHOICE (7u)
#define PRIMARY_INVERTER_L_RCV_OPERAND194__ABS_<__CHOICE (8u)
#define PRIMARY_INVERTER_L_RCV_OPERAND194__TOL_>__CHOICE (9u)
#define PRIMARY_INVERTER_L_RCV_OPERAND194__TOL_<__CHOICE (10u)
#define PRIMARY_INVERTER_L_RCV_OPERAND194__>__11_CHOICE (11u)
#define PRIMARY_INVERTER_L_RCV_OPERAND194__<__12_CHOICE (12u)
#define PRIMARY_INVERTER_L_RCV_OPERAND194__HYST_>__CHOICE (13u)
#define PRIMARY_INVERTER_L_RCV_OPERAND194__HYST_<__CHOICE (14u)
#define PRIMARY_INVERTER_L_RCV_OPERAND194__WINDOW__CHOICE (15u)

#define PRIMARY_INVERTER_L_RCV_OPERAND195_OFF_CHOICE (0u)
#define PRIMARY_INVERTER_L_RCV_OPERAND195_ON_CHOICE (1u)
#define PRIMARY_INVERTER_L_RCV_OPERAND195_1_HZ_CHOICE (2u)
#define PRIMARY_INVERTER_L_RCV_OPERAND195___3_CHOICE (3u)
#define PRIMARY_INVERTER_L_RCV_OPERAND195___4_CHOICE (4u)
#define PRIMARY_INVERTER_L_RCV_OPERAND195__>__5_CHOICE (5u)
#define PRIMARY_INVERTER_L_RCV_OPERAND195__<__6_CHOICE (6u)
#define PRIMARY_INVERTER_L_RCV_OPERAND195__ABS_>__CHOICE (7u)
#define PRIMARY_INVERTER_L_RCV_OPERAND195__ABS_<__CHOICE (8u)
#define PRIMARY_INVERTER_L_RCV_OPERAND195__TOL_>__CHOICE (9u)
#define PRIMARY_INVERTER_L_RCV_OPERAND195__TOL_<__CHOICE (10u)
#define PRIMARY_INVERTER_L_RCV_OPERAND195__>__11_CHOICE (11u)
#define PRIMARY_INVERTER_L_RCV_OPERAND195__<__12_CHOICE (12u)
#define PRIMARY_INVERTER_L_RCV_OPERAND195__HYST_>__CHOICE (13u)
#define PRIMARY_INVERTER_L_RCV_OPERAND195__HYST_<__CHOICE (14u)
#define PRIMARY_INVERTER_L_RCV_OPERAND195__WINDOW__CHOICE (15u)

#define PRIMARY_INVERTER_L_RCV_OPERAND218_OFF_CHOICE (0u)
#define PRIMARY_INVERTER_L_RCV_OPERAND218_ON_CHOICE (1u)
#define PRIMARY_INVERTER_L_RCV_OPERAND218_1_HZ_CHOICE (2u)
#define PRIMARY_INVERTER_L_RCV_OPERAND218___3_CHOICE (3u)
#define PRIMARY_INVERTER_L_RCV_OPERAND218___4_CHOICE (4u)
#define PRIMARY_INVERTER_L_RCV_OPERAND218__>__5_CHOICE (5u)
#define PRIMARY_INVERTER_L_RCV_OPERAND218__<__6_CHOICE (6u)
#define PRIMARY_INVERTER_L_RCV_OPERAND218__ABS_>__CHOICE (7u)
#define PRIMARY_INVERTER_L_RCV_OPERAND218__ABS_<__CHOICE (8u)
#define PRIMARY_INVERTER_L_RCV_OPERAND218__TOL_>__CHOICE (9u)
#define PRIMARY_INVERTER_L_RCV_OPERAND218__TOL_<__CHOICE (10u)
#define PRIMARY_INVERTER_L_RCV_OPERAND218__>__11_CHOICE (11u)
#define PRIMARY_INVERTER_L_RCV_OPERAND218__<__12_CHOICE (12u)
#define PRIMARY_INVERTER_L_RCV_OPERAND218__HYST_>__CHOICE (13u)
#define PRIMARY_INVERTER_L_RCV_OPERAND218__HYST_<__CHOICE (14u)
#define PRIMARY_INVERTER_L_RCV_OPERAND218__WINDOW__CHOICE (15u)

#define PRIMARY_INVERTER_L_RCV_OPERAND219_OFF_CHOICE (0u)
#define PRIMARY_INVERTER_L_RCV_OPERAND219_ON_CHOICE (1u)
#define PRIMARY_INVERTER_L_RCV_OPERAND219_1_HZ_CHOICE (2u)
#define PRIMARY_INVERTER_L_RCV_OPERAND219___3_CHOICE (3u)
#define PRIMARY_INVERTER_L_RCV_OPERAND219___4_CHOICE (4u)
#define PRIMARY_INVERTER_L_RCV_OPERAND219__>__5_CHOICE (5u)
#define PRIMARY_INVERTER_L_RCV_OPERAND219__<__6_CHOICE (6u)
#define PRIMARY_INVERTER_L_RCV_OPERAND219__ABS_>__CHOICE (7u)
#define PRIMARY_INVERTER_L_RCV_OPERAND219__ABS_<__CHOICE (8u)
#define PRIMARY_INVERTER_L_RCV_OPERAND219__TOL_>__CHOICE (9u)
#define PRIMARY_INVERTER_L_RCV_OPERAND219__TOL_<__CHOICE (10u)
#define PRIMARY_INVERTER_L_RCV_OPERAND219__>__11_CHOICE (11u)
#define PRIMARY_INVERTER_L_RCV_OPERAND219__<__12_CHOICE (12u)
#define PRIMARY_INVERTER_L_RCV_OPERAND219__HYST_>__CHOICE (13u)
#define PRIMARY_INVERTER_L_RCV_OPERAND219__HYST_<__CHOICE (14u)
#define PRIMARY_INVERTER_L_RCV_OPERAND219__WINDOW__CHOICE (15u)

#define PRIMARY_INVERTER_L_RCV_CS_AIN_2_FORMAT_OFF_CHOICE (0u)
#define PRIMARY_INVERTER_L_RCV_CS_AIN_2_FORMAT__CMD__1_CHOICE (1u)
#define PRIMARY_INVERTER_L_RCV_CS_AIN_2_FORMAT__CMD__2_CHOICE (2u)
#define PRIMARY_INVERTER_L_RCV_CS_AIN_2_FORMAT__CMD_CHOICE (3u)

#define PRIMARY_INVERTER_L_RCV_CS_AIN_1_MODE__10_10V__CHOICE (0u)
#define PRIMARY_INVERTER_L_RCV_CS_AIN_1_MODE__0_10V__CHOICE (1u)
#define PRIMARY_INVERTER_L_RCV_CS_AIN_1_MODE__4_20MA__CHOICE (2u)
#define PRIMARY_INVERTER_L_RCV_CS_AIN_1_MODE__1_9V__CHOICE (3u)

#define PRIMARY_INVERTER_L_RCV_COMPARE_VAR194__0__CHOICE (0u)
#define PRIMARY_INVERTER_L_RCV_COMPARE_VAR194__1__CHOICE (1u)
#define PRIMARY_INVERTER_L_RCV_COMPARE_VAR194__VAR_1__CHOICE (2u)
#define PRIMARY_INVERTER_L_RCV_COMPARE_VAR194__VAR_2__CHOICE (3u)
#define PRIMARY_INVERTER_L_RCV_COMPARE_VAR194__VAR_3__CHOICE (4u)
#define PRIMARY_INVERTER_L_RCV_COMPARE_VAR194__VAR_4__CHOICE (5u)
#define PRIMARY_INVERTER_L_RCV_COMPARE_VAR194__AIN_1__CHOICE (6u)
#define PRIMARY_INVERTER_L_RCV_COMPARE_VAR194__AIN_2__CHOICE (7u)

#define PRIMARY_INVERTER_L_RCV_COMPARE_VAR195__0__CHOICE (0u)
#define PRIMARY_INVERTER_L_RCV_COMPARE_VAR195__1__CHOICE (1u)
#define PRIMARY_INVERTER_L_RCV_COMPARE_VAR195__VAR_1__CHOICE (2u)
#define PRIMARY_INVERTER_L_RCV_COMPARE_VAR195__VAR_2__CHOICE (3u)
#define PRIMARY_INVERTER_L_RCV_COMPARE_VAR195__VAR_3__CHOICE (4u)
#define PRIMARY_INVERTER_L_RCV_COMPARE_VAR195__VAR_4__CHOICE (5u)
#define PRIMARY_INVERTER_L_RCV_COMPARE_VAR195__AIN_1__CHOICE (6u)
#define PRIMARY_INVERTER_L_RCV_COMPARE_VAR195__AIN_2__CHOICE (7u)

#define PRIMARY_INVERTER_L_RCV_COMPARE_VAR218__0__CHOICE (0u)
#define PRIMARY_INVERTER_L_RCV_COMPARE_VAR218__1__CHOICE (1u)
#define PRIMARY_INVERTER_L_RCV_COMPARE_VAR218__VAR_1__CHOICE (2u)
#define PRIMARY_INVERTER_L_RCV_COMPARE_VAR218__VAR_2__CHOICE (3u)
#define PRIMARY_INVERTER_L_RCV_COMPARE_VAR218__VAR_3__CHOICE (4u)
#define PRIMARY_INVERTER_L_RCV_COMPARE_VAR218__VAR_4__CHOICE (5u)
#define PRIMARY_INVERTER_L_RCV_COMPARE_VAR218__AIN_1__CHOICE (6u)
#define PRIMARY_INVERTER_L_RCV_COMPARE_VAR218__AIN_2__CHOICE (7u)

#define PRIMARY_INVERTER_L_RCV_COMPARE_VAR219__0__CHOICE (0u)
#define PRIMARY_INVERTER_L_RCV_COMPARE_VAR219__1__CHOICE (1u)
#define PRIMARY_INVERTER_L_RCV_COMPARE_VAR219__VAR_1__CHOICE (2u)
#define PRIMARY_INVERTER_L_RCV_COMPARE_VAR219__VAR_2__CHOICE (3u)
#define PRIMARY_INVERTER_L_RCV_COMPARE_VAR219__VAR_3__CHOICE (4u)
#define PRIMARY_INVERTER_L_RCV_COMPARE_VAR219__VAR_4__CHOICE (5u)
#define PRIMARY_INVERTER_L_RCV_COMPARE_VAR219__AIN_1__CHOICE (6u)
#define PRIMARY_INVERTER_L_RCV_COMPARE_VAR219__AIN_2__CHOICE (7u)

#define PRIMARY_INVERTER_L_RCV_MO_FEEDBACK_2___CHOICE (0u)
#define PRIMARY_INVERTER_L_RCV_MO_FEEDBACK_2_ENC_POSITION_CHOICE (1u)
#define PRIMARY_INVERTER_L_RCV_MO_FEEDBACK_2_ENC_INFO_CHOICE (2u)
#define PRIMARY_INVERTER_L_RCV_MO_FEEDBACK_2_ENC_HAND__CHOICE (3u)
#define PRIMARY_INVERTER_L_RCV_MO_FEEDBACK_2_SSI_CHOICE (4u)

#define PRIMARY_INVERTER_L_RCV_CS_AIN_2_MODE__10_10V__CHOICE (0u)
#define PRIMARY_INVERTER_L_RCV_CS_AIN_2_MODE__0_10V__CHOICE (1u)
#define PRIMARY_INVERTER_L_RCV_CS_AIN_2_MODE__4_20MA__CHOICE (2u)
#define PRIMARY_INVERTER_L_RCV_CS_AIN_2_MODE__1_9V__CHOICE (3u)

#define PRIMARY_INVERTER_L_RCV_CTRLSUBMODE_UNASSIGNED_CHOICE (0u)
#define PRIMARY_INVERTER_L_RCV_CTRLSUBMODE_SPEED_NI_CHOICE (1u)
#define PRIMARY_INVERTER_L_RCV_CTRLSUBMODE_SPEED_PNI_CHOICE (2u)
#define PRIMARY_INVERTER_L_RCV_CTRLSUBMODE_POSITION_PNI_CHOICE (3u)

#define PRIMARY_INVERTER_L_RCV_MO_SC1_RESO_14_BIT_CHOICE (1u)
#define PRIMARY_INVERTER_L_RCV_MO_SC1_RESO_12_BIT_CHOICE (2u)
#define PRIMARY_INVERTER_L_RCV_MO_SC1_RESO_10_BIT_CHOICE (3u)

#define PRIMARY_INVERTER_L_RCV_SOURCE_ID194__OFF__CHOICE (0u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID194_02H_SC_INFO_CHOICE (2u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID194_11H_CONTROL_STATUS_CHOICE (17u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID194_20H_I_ACTUAL_CHOICE (32u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID194_22H_I_CMD_RAMP__CHOICE (34u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID194_23H_ID_REF_CHOICE (35u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID194_24H_I_MAX_INUSE_CHOICE (36u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID194_26H_I_CMD_CHOICE (38u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID194_27H_IQ_ACTUAL_CHOICE (39u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID194_28H_ID_ACTUAL_CHOICE (40u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID194_29H_VQ_OUTPUT_CHOICE (41u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID194_2AH_VD_OUTPUT_CHOICE (42u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID194_30H_N_ACTUAL_CHOICE (48u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID194_31H_N_SET_DIG__CHOICE (49u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID194_32H_N_CMD_RAMP__CHOICE (50u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID194_33H_N_ERROR_CHOICE (51u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID194_34H_N_LIM_CHOICE (52u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID194_38H_IQ_ERROR_CHOICE (56u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID194_39H_ID_ERROR_CHOICE (57u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID194_40H_STATUS_MAP_CHOICE (64u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID194_41H_INCR_DELTA_CHOICE (65u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID194_42H_MOTORPOS_MECH_CHOICE (66u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID194_43H_MOTORPOS_ELEC_CHOICE (67u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID194_45H_IT_RG_MONITOR_CHOICE (69u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID194_48H_I_LIMIT_INUSE_CHOICE (72u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID194_49H_T_MOTOR_CHOICE (73u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID194_4AH_T_IGBT_CHOICE (74u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID194_4BH_T_AIR_INSIDE_CHOICE (75u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID194_51_KERN_MODE_STATE_CHOICE (81u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID194_54H_I1_ACTUAL_CHOICE (84u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID194_55H_I2_ACTUAL_CHOICE (85u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID194_56H_I3_ACTUAL_CHOICE (86u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID194_57H_I_LIMIT_INUSE_RAMP__CHOICE (87u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID194_5CH_ROTOR_SIGNALS_CHOICE (92u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID194_5DH_N_CMD_INT__CHOICE (93u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID194_5FH_I_ACTUAL_FILT_CHOICE (95u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID194_61H_IXT_MONITOR_CHOICE (97u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID194_63H_FPGA_STATUS_CHOICE (99u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID194_66H_VDC_BUS_FILT_CHOICE (102u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID194_6DH_POS_ACTUAL_CHOICE (109u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID194_6EH_POS_DESTINATION_CHOICE (110u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID194_6FH_POS_ACTUAL_2_CHOICE (111u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID194_70H_POS_ERROR_CHOICE (112u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID194_74H_POS_ZEROCAPTURE_CHOICE (116u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID194_8AH_V_OUTPUT_CHOICE (138u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID194_8BH_V_RED_REF__CHOICE (139u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID194_8CH_V_CONTROL_KP_CHOICE (140u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID194_8DH_V_CONTROL_TI_CHOICE (141u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID194_8FH_ERRORWARNING_MAP_CHOICE (143u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID194_90H_M_SET_DIG__CHOICE (144u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID194_91H_POS_CMD_CHOICE (145u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID194_98H_LOGIC_O_BLOCK_CHOICE (152u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID194_99H_INFO_TIMER_DIFF_CHOICE (153u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID194_9AH_TEMP_DEBUG_CHOICE (154u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID194_9BH_LOGIC_I_BLOCK_CHOICE (155u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID194_A0H_M_OUT_DIG__CHOICE (160u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID194_A1H_BALLAST_CNTR_CHOICE (161u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID194_A8H_N_ACTUAL_FILT_CHOICE (168u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID194_A9H_I3_ADC_VALUE_CHOICE (169u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID194_AAH_I2_ADC_VALUE_CHOICE (170u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID194_ABH_LOGIC_FREQ_CHOICE (171u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID194_ACH_PWM_1_5_6__CHOICE (172u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID194_ADH_PWM_2_3_4__CHOICE (173u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID194_AEH_PWM_3_1_2__CHOICE (174u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID194_B5H_ID_MIN_CHOICE (181u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID194_B8H_PTR_1_DEBUG_CHOICE (184u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID194_BAH_PTR_2_DEBUG_CHOICE (186u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID194_D1H_VAR_1_CHOICE (209u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID194_D2H_VAR_2_CHOICE (210u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID194_D3H_VAR_3_CHOICE (211u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID194_D4H_VAR_4_CHOICE (212u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID194_D5H_AIN_IN_1_CHOICE (213u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID194_D6H_AIN_IN_2_CHOICE (214u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID194_DEH_DIGOUTPUT_DOUT_3_CHOICE (222u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID194_DFH_DIGOUTPUT_DOUT_4_CHOICE (223u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID194_E0H_DIGOUTPUT_DOUT_1_CHOICE (224u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID194_E1H_DIGOUTPUT_DOUT_2_CHOICE (225u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID194_E2H_DIGOUTPUT_RDY_BTB_CHOICE (226u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID194_E3H_DIGSIGNAL_GO_CHOICE (227u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID194_E4H_DIGINPUT_END_1_CHOICE (228u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID194_E5H_DIGINPUT_END_2_CHOICE (229u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID194_E6H_DIGINPUT_DIN_1_CHOICE (230u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID194_E7H_DIGINPUT_DIN_2_CHOICE (231u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID194_E8H_DIGINPUT_RUN_CHOICE (232u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID194_E9H_ERROR_I_FAULT_CHOICE (233u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID194_EAH_I_BALLAST_ACT_CHOICE (234u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID194_EBH_VDC_BUS_CHOICE (235u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID194_ECH_FB_LOSSOFSIGNAL_CHOICE (236u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID194_F2H_DIGSIGNAL_BRAKE_CHOICE (242u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID194_F3H_DIGSIGNAL_ICNS_CHOICE (243u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID194_F4H_DIGSIGNAL_POSTOLER_SET_CHOICE (244u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID194_F5H_DIGSIGNAL_LESSN0_CHOICE (245u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID194_FBH_AIN_1_CALC_CHOICE (251u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID194_FCH_AIN_2_CALC_CHOICE (252u)

#define PRIMARY_INVERTER_L_RCV_SOURCE_ID195__OFF__CHOICE (0u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID195_02H_SC_INFO_CHOICE (2u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID195_11H_CONTROL_STATUS_CHOICE (17u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID195_20H_I_ACTUAL_CHOICE (32u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID195_22H_I_CMD_RAMP__CHOICE (34u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID195_23H_ID_REF_CHOICE (35u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID195_24H_I_MAX_INUSE_CHOICE (36u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID195_26H_I_CMD_CHOICE (38u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID195_27H_IQ_ACTUAL_CHOICE (39u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID195_28H_ID_ACTUAL_CHOICE (40u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID195_29H_VQ_OUTPUT_CHOICE (41u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID195_2AH_VD_OUTPUT_CHOICE (42u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID195_30H_N_ACTUAL_CHOICE (48u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID195_31H_N_SET_DIG__CHOICE (49u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID195_32H_N_CMD_RAMP__CHOICE (50u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID195_33H_N_ERROR_CHOICE (51u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID195_34H_N_LIM_CHOICE (52u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID195_38H_IQ_ERROR_CHOICE (56u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID195_39H_ID_ERROR_CHOICE (57u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID195_40H_STATUS_MAP_CHOICE (64u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID195_41H_INCR_DELTA_CHOICE (65u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID195_42H_MOTORPOS_MECH_CHOICE (66u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID195_43H_MOTORPOS_ELEC_CHOICE (67u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID195_45H_IT_RG_MONITOR_CHOICE (69u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID195_48H_I_LIMIT_INUSE_CHOICE (72u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID195_49H_T_MOTOR_CHOICE (73u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID195_4AH_T_IGBT_CHOICE (74u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID195_4BH_T_AIR_INSIDE_CHOICE (75u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID195_51_KERN_MODE_STATE_CHOICE (81u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID195_54H_I1_ACTUAL_CHOICE (84u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID195_55H_I2_ACTUAL_CHOICE (85u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID195_56H_I3_ACTUAL_CHOICE (86u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID195_57H_I_LIMIT_INUSE_RAMP__CHOICE (87u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID195_5CH_ROTOR_SIGNALS_CHOICE (92u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID195_5DH_N_CMD_INT__CHOICE (93u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID195_5FH_I_ACTUAL_FILT_CHOICE (95u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID195_61H_IXT_MONITOR_CHOICE (97u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID195_63H_FPGA_STATUS_CHOICE (99u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID195_66H_VDC_BUS_FILT_CHOICE (102u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID195_6DH_POS_ACTUAL_CHOICE (109u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID195_6EH_POS_DESTINATION_CHOICE (110u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID195_6FH_POS_ACTUAL_2_CHOICE (111u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID195_70H_POS_ERROR_CHOICE (112u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID195_74H_POS_ZEROCAPTURE_CHOICE (116u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID195_8AH_V_OUTPUT_CHOICE (138u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID195_8BH_V_RED_REF__CHOICE (139u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID195_8CH_V_CONTROL_KP_CHOICE (140u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID195_8DH_V_CONTROL_TI_CHOICE (141u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID195_8FH_ERRORWARNING_MAP_CHOICE (143u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID195_90H_M_SET_DIG__CHOICE (144u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID195_91H_POS_CMD_CHOICE (145u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID195_98H_LOGIC_O_BLOCK_CHOICE (152u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID195_99H_INFO_TIMER_DIFF_CHOICE (153u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID195_9AH_TEMP_DEBUG_CHOICE (154u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID195_9BH_LOGIC_I_BLOCK_CHOICE (155u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID195_A0H_M_OUT_DIG__CHOICE (160u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID195_A1H_BALLAST_CNTR_CHOICE (161u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID195_A8H_N_ACTUAL_FILT_CHOICE (168u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID195_A9H_I3_ADC_VALUE_CHOICE (169u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID195_AAH_I2_ADC_VALUE_CHOICE (170u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID195_ABH_LOGIC_FREQ_CHOICE (171u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID195_ACH_PWM_1_5_6__CHOICE (172u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID195_ADH_PWM_2_3_4__CHOICE (173u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID195_AEH_PWM_3_1_2__CHOICE (174u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID195_B5H_ID_MIN_CHOICE (181u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID195_B8H_PTR_1_DEBUG_CHOICE (184u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID195_BAH_PTR_2_DEBUG_CHOICE (186u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID195_D1H_VAR_1_CHOICE (209u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID195_D2H_VAR_2_CHOICE (210u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID195_D3H_VAR_3_CHOICE (211u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID195_D4H_VAR_4_CHOICE (212u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID195_D5H_AIN_IN_1_CHOICE (213u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID195_D6H_AIN_IN_2_CHOICE (214u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID195_DEH_DIGOUTPUT_DOUT_3_CHOICE (222u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID195_DFH_DIGOUTPUT_DOUT_4_CHOICE (223u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID195_E0H_DIGOUTPUT_DOUT_1_CHOICE (224u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID195_E1H_DIGOUTPUT_DOUT_2_CHOICE (225u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID195_E2H_DIGOUTPUT_RDY_BTB_CHOICE (226u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID195_E3H_DIGSIGNAL_GO_CHOICE (227u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID195_E4H_DIGINPUT_END_1_CHOICE (228u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID195_E5H_DIGINPUT_END_2_CHOICE (229u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID195_E6H_DIGINPUT_DIN_1_CHOICE (230u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID195_E7H_DIGINPUT_DIN_2_CHOICE (231u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID195_E8H_DIGINPUT_RUN_CHOICE (232u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID195_E9H_ERROR_I_FAULT_CHOICE (233u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID195_EAH_I_BALLAST_ACT_CHOICE (234u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID195_EBH_VDC_BUS_CHOICE (235u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID195_ECH_FB_LOSSOFSIGNAL_CHOICE (236u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID195_F2H_DIGSIGNAL_BRAKE_CHOICE (242u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID195_F3H_DIGSIGNAL_ICNS_CHOICE (243u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID195_F4H_DIGSIGNAL_POSTOLER_SET_CHOICE (244u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID195_F5H_DIGSIGNAL_LESSN0_CHOICE (245u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID195_FBH_AIN_1_CALC_CHOICE (251u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID195_FCH_AIN_2_CALC_CHOICE (252u)

#define PRIMARY_INVERTER_L_RCV_SOURCE_ID218__OFF__CHOICE (0u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID218_02H_SC_INFO_CHOICE (2u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID218_11H_CONTROL_STATUS_CHOICE (17u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID218_20H_I_ACTUAL_CHOICE (32u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID218_22H_I_CMD_RAMP__CHOICE (34u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID218_23H_ID_REF_CHOICE (35u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID218_24H_I_MAX_INUSE_CHOICE (36u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID218_26H_I_CMD_CHOICE (38u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID218_27H_IQ_ACTUAL_CHOICE (39u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID218_28H_ID_ACTUAL_CHOICE (40u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID218_29H_VQ_OUTPUT_CHOICE (41u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID218_2AH_VD_OUTPUT_CHOICE (42u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID218_30H_N_ACTUAL_CHOICE (48u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID218_31H_N_SET_DIG__CHOICE (49u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID218_32H_N_CMD_RAMP__CHOICE (50u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID218_33H_N_ERROR_CHOICE (51u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID218_34H_N_LIM_CHOICE (52u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID218_38H_IQ_ERROR_CHOICE (56u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID218_39H_ID_ERROR_CHOICE (57u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID218_40H_STATUS_MAP_CHOICE (64u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID218_41H_INCR_DELTA_CHOICE (65u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID218_42H_MOTORPOS_MECH_CHOICE (66u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID218_43H_MOTORPOS_ELEC_CHOICE (67u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID218_45H_IT_RG_MONITOR_CHOICE (69u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID218_48H_I_LIMIT_INUSE_CHOICE (72u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID218_49H_T_MOTOR_CHOICE (73u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID218_4AH_T_IGBT_CHOICE (74u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID218_4BH_T_AIR_INSIDE_CHOICE (75u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID218_51_KERN_MODE_STATE_CHOICE (81u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID218_54H_I1_ACTUAL_CHOICE (84u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID218_55H_I2_ACTUAL_CHOICE (85u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID218_56H_I3_ACTUAL_CHOICE (86u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID218_57H_I_LIMIT_INUSE_RAMP__CHOICE (87u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID218_5CH_ROTOR_SIGNALS_CHOICE (92u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID218_5DH_N_CMD_INT__CHOICE (93u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID218_5FH_I_ACTUAL_FILT_CHOICE (95u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID218_61H_IXT_MONITOR_CHOICE (97u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID218_63H_FPGA_STATUS_CHOICE (99u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID218_66H_VDC_BUS_FILT_CHOICE (102u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID218_6DH_POS_ACTUAL_CHOICE (109u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID218_6EH_POS_DESTINATION_CHOICE (110u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID218_6FH_POS_ACTUAL_2_CHOICE (111u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID218_70H_POS_ERROR_CHOICE (112u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID218_74H_POS_ZEROCAPTURE_CHOICE (116u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID218_8AH_V_OUTPUT_CHOICE (138u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID218_8BH_V_RED_REF__CHOICE (139u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID218_8CH_V_CONTROL_KP_CHOICE (140u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID218_8DH_V_CONTROL_TI_CHOICE (141u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID218_8FH_ERRORWARNING_MAP_CHOICE (143u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID218_90H_M_SET_DIG__CHOICE (144u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID218_91H_POS_CMD_CHOICE (145u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID218_98H_LOGIC_O_BLOCK_CHOICE (152u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID218_99H_INFO_TIMER_DIFF_CHOICE (153u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID218_9AH_TEMP_DEBUG_CHOICE (154u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID218_9BH_LOGIC_I_BLOCK_CHOICE (155u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID218_A0H_M_OUT_DIG__CHOICE (160u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID218_A1H_BALLAST_CNTR_CHOICE (161u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID218_A8H_N_ACTUAL_FILT_CHOICE (168u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID218_A9H_I3_ADC_VALUE_CHOICE (169u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID218_AAH_I2_ADC_VALUE_CHOICE (170u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID218_ABH_LOGIC_FREQ_CHOICE (171u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID218_ACH_PWM_1_5_6__CHOICE (172u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID218_ADH_PWM_2_3_4__CHOICE (173u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID218_AEH_PWM_3_1_2__CHOICE (174u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID218_B5H_ID_MIN_CHOICE (181u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID218_B8H_PTR_1_DEBUG_CHOICE (184u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID218_BAH_PTR_2_DEBUG_CHOICE (186u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID218_D1H_VAR_1_CHOICE (209u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID218_D2H_VAR_2_CHOICE (210u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID218_D3H_VAR_3_CHOICE (211u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID218_D4H_VAR_4_CHOICE (212u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID218_D5H_AIN_IN_1_CHOICE (213u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID218_D6H_AIN_IN_2_CHOICE (214u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID218_DEH_DIGOUTPUT_DOUT_3_CHOICE (222u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID218_DFH_DIGOUTPUT_DOUT_4_CHOICE (223u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID218_E0H_DIGOUTPUT_DOUT_1_CHOICE (224u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID218_E1H_DIGOUTPUT_DOUT_2_CHOICE (225u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID218_E2H_DIGOUTPUT_RDY_BTB_CHOICE (226u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID218_E3H_DIGSIGNAL_GO_CHOICE (227u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID218_E4H_DIGINPUT_END_1_CHOICE (228u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID218_E5H_DIGINPUT_END_2_CHOICE (229u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID218_E6H_DIGINPUT_DIN_1_CHOICE (230u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID218_E7H_DIGINPUT_DIN_2_CHOICE (231u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID218_E8H_DIGINPUT_RUN_CHOICE (232u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID218_E9H_ERROR_I_FAULT_CHOICE (233u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID218_EAH_I_BALLAST_ACT_CHOICE (234u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID218_EBH_VDC_BUS_CHOICE (235u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID218_ECH_FB_LOSSOFSIGNAL_CHOICE (236u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID218_F2H_DIGSIGNAL_BRAKE_CHOICE (242u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID218_F3H_DIGSIGNAL_ICNS_CHOICE (243u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID218_F4H_DIGSIGNAL_POSTOLER_SET_CHOICE (244u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID218_F5H_DIGSIGNAL_LESSN0_CHOICE (245u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID218_FBH_AIN_1_CALC_CHOICE (251u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID218_FCH_AIN_2_CALC_CHOICE (252u)

#define PRIMARY_INVERTER_L_RCV_SOURCE_ID219__OFF__CHOICE (0u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID219_02H_SC_INFO_CHOICE (2u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID219_11H_CONTROL_STATUS_CHOICE (17u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID219_20H_I_ACTUAL_CHOICE (32u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID219_22H_I_CMD_RAMP__CHOICE (34u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID219_23H_ID_REF_CHOICE (35u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID219_24H_I_MAX_INUSE_CHOICE (36u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID219_26H_I_CMD_CHOICE (38u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID219_27H_IQ_ACTUAL_CHOICE (39u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID219_28H_ID_ACTUAL_CHOICE (40u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID219_29H_VQ_OUTPUT_CHOICE (41u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID219_2AH_VD_OUTPUT_CHOICE (42u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID219_30H_N_ACTUAL_CHOICE (48u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID219_31H_N_SET_DIG__CHOICE (49u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID219_32H_N_CMD_RAMP__CHOICE (50u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID219_33H_N_ERROR_CHOICE (51u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID219_34H_N_LIM_CHOICE (52u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID219_38H_IQ_ERROR_CHOICE (56u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID219_39H_ID_ERROR_CHOICE (57u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID219_40H_STATUS_MAP_CHOICE (64u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID219_41H_INCR_DELTA_CHOICE (65u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID219_42H_MOTORPOS_MECH_CHOICE (66u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID219_43H_MOTORPOS_ELEC_CHOICE (67u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID219_45H_IT_RG_MONITOR_CHOICE (69u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID219_48H_I_LIMIT_INUSE_CHOICE (72u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID219_49H_T_MOTOR_CHOICE (73u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID219_4AH_T_IGBT_CHOICE (74u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID219_4BH_T_AIR_INSIDE_CHOICE (75u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID219_51_KERN_MODE_STATE_CHOICE (81u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID219_54H_I1_ACTUAL_CHOICE (84u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID219_55H_I2_ACTUAL_CHOICE (85u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID219_56H_I3_ACTUAL_CHOICE (86u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID219_57H_I_LIMIT_INUSE_RAMP__CHOICE (87u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID219_5CH_ROTOR_SIGNALS_CHOICE (92u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID219_5DH_N_CMD_INT__CHOICE (93u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID219_5FH_I_ACTUAL_FILT_CHOICE (95u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID219_61H_IXT_MONITOR_CHOICE (97u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID219_63H_FPGA_STATUS_CHOICE (99u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID219_66H_VDC_BUS_FILT_CHOICE (102u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID219_6DH_POS_ACTUAL_CHOICE (109u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID219_6EH_POS_DESTINATION_CHOICE (110u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID219_6FH_POS_ACTUAL_2_CHOICE (111u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID219_70H_POS_ERROR_CHOICE (112u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID219_74H_POS_ZEROCAPTURE_CHOICE (116u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID219_8AH_V_OUTPUT_CHOICE (138u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID219_8BH_V_RED_REF__CHOICE (139u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID219_8CH_V_CONTROL_KP_CHOICE (140u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID219_8DH_V_CONTROL_TI_CHOICE (141u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID219_8FH_ERRORWARNING_MAP_CHOICE (143u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID219_90H_M_SET_DIG__CHOICE (144u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID219_91H_POS_CMD_CHOICE (145u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID219_98H_LOGIC_O_BLOCK_CHOICE (152u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID219_99H_INFO_TIMER_DIFF_CHOICE (153u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID219_9AH_TEMP_DEBUG_CHOICE (154u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID219_9BH_LOGIC_I_BLOCK_CHOICE (155u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID219_A0H_M_OUT_DIG__CHOICE (160u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID219_A1H_BALLAST_CNTR_CHOICE (161u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID219_A8H_N_ACTUAL_FILT_CHOICE (168u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID219_A9H_I3_ADC_VALUE_CHOICE (169u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID219_AAH_I2_ADC_VALUE_CHOICE (170u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID219_ABH_LOGIC_FREQ_CHOICE (171u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID219_ACH_PWM_1_5_6__CHOICE (172u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID219_ADH_PWM_2_3_4__CHOICE (173u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID219_AEH_PWM_3_1_2__CHOICE (174u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID219_B5H_ID_MIN_CHOICE (181u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID219_B8H_PTR_1_DEBUG_CHOICE (184u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID219_BAH_PTR_2_DEBUG_CHOICE (186u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID219_D1H_VAR_1_CHOICE (209u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID219_D2H_VAR_2_CHOICE (210u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID219_D3H_VAR_3_CHOICE (211u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID219_D4H_VAR_4_CHOICE (212u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID219_D5H_AIN_IN_1_CHOICE (213u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID219_D6H_AIN_IN_2_CHOICE (214u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID219_DEH_DIGOUTPUT_DOUT_3_CHOICE (222u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID219_DFH_DIGOUTPUT_DOUT_4_CHOICE (223u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID219_E0H_DIGOUTPUT_DOUT_1_CHOICE (224u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID219_E1H_DIGOUTPUT_DOUT_2_CHOICE (225u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID219_E2H_DIGOUTPUT_RDY_BTB_CHOICE (226u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID219_E3H_DIGSIGNAL_GO_CHOICE (227u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID219_E4H_DIGINPUT_END_1_CHOICE (228u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID219_E5H_DIGINPUT_END_2_CHOICE (229u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID219_E6H_DIGINPUT_DIN_1_CHOICE (230u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID219_E7H_DIGINPUT_DIN_2_CHOICE (231u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID219_E8H_DIGINPUT_RUN_CHOICE (232u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID219_E9H_ERROR_I_FAULT_CHOICE (233u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID219_EAH_I_BALLAST_ACT_CHOICE (234u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID219_EBH_VDC_BUS_CHOICE (235u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID219_ECH_FB_LOSSOFSIGNAL_CHOICE (236u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID219_F2H_DIGSIGNAL_BRAKE_CHOICE (242u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID219_F3H_DIGSIGNAL_ICNS_CHOICE (243u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID219_F4H_DIGSIGNAL_POSTOLER_SET_CHOICE (244u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID219_F5H_DIGSIGNAL_LESSN0_CHOICE (245u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID219_FBH_AIN_1_CALC_CHOICE (251u)
#define PRIMARY_INVERTER_L_RCV_SOURCE_ID219_FCH_AIN_2_CALC_CHOICE (252u)

#define PRIMARY_INVERTER_L_RCV_MOTORTYPE_EC_SERVO_CHOICE (0u)
#define PRIMARY_INVERTER_L_RCV_MOTORTYPE_ACI_V_F_CHOICE (1u)
#define PRIMARY_INVERTER_L_RCV_MOTORTYPE_ACI_SERVO_CHOICE (2u)
#define PRIMARY_INVERTER_L_RCV_MOTORTYPE_DC_CHOICE (3u)

#define PRIMARY_INVERTER_L_RCV_CS_CMD_TYPE_DIGITAL_COMMANDS_CHOICE (0u)
#define PRIMARY_INVERTER_L_RCV_CS_CMD_TYPE_DIG_ANA_SPEED_CHOICE (1u)
#define PRIMARY_INVERTER_L_RCV_CS_CMD_TYPE_ANALOG_SPEED_CHOICE (2u)
#define PRIMARY_INVERTER_L_RCV_CS_CMD_TYPE_ANALOG_TORQUE_CHOICE (3u)

#define PRIMARY_INVERTER_L_RCV_CURRENTMODE_PWM_FIX_CHOICE (0u)
#define PRIMARY_INVERTER_L_RCV_CURRENTMODE_BOTTOM_W_CHOICE (1u)
#define PRIMARY_INVERTER_L_RCV_CURRENTMODE_BOTTOM_V_CHOICE (2u)
#define PRIMARY_INVERTER_L_RCV_CURRENTMODE_BOTTOM_U_CHOICE (3u)
#define PRIMARY_INVERTER_L_RCV_CURRENTMODE_DEFINE_CMD_CHOICE (4u)
#define PRIMARY_INVERTER_L_RCV_CURRENTMODE_CURRENT_RAMP_CHOICE (5u)

#define PRIMARY_INVERTER_L_RCV_MO_SC2_RESO_14_BIT_CHOICE (1u)
#define PRIMARY_INVERTER_L_RCV_MO_SC2_RESO_12_BIT_CHOICE (2u)
#define PRIMARY_INVERTER_L_RCV_MO_SC2_RESO_10_BIT_CHOICE (3u)

#define PRIMARY_INVERTER_L_RCV_ACTIVE190_LOW_CHOICE (0u)
#define PRIMARY_INVERTER_L_RCV_ACTIVE190_HIGH_CHOICE (1u)

#define PRIMARY_INVERTER_L_RCV_ACTIVE191_LOW_CHOICE (0u)
#define PRIMARY_INVERTER_L_RCV_ACTIVE191_HIGH_CHOICE (1u)

#define PRIMARY_INVERTER_L_RCV_ACTIVE192_LOW_CHOICE (0u)
#define PRIMARY_INVERTER_L_RCV_ACTIVE192_HIGH_CHOICE (1u)

#define PRIMARY_INVERTER_L_RCV_ACTIVE193_LOW_CHOICE (0u)
#define PRIMARY_INVERTER_L_RCV_ACTIVE193_HIGH_CHOICE (1u)

#define PRIMARY_INVERTER_L_RCV_PWM_FREQ_8_KHZ_CHOICE (0u)
#define PRIMARY_INVERTER_L_RCV_PWM_FREQ_24_KHZ_CHOICE (1u)
#define PRIMARY_INVERTER_L_RCV_PWM_FREQ_20_KHZ_CHOICE (2u)
#define PRIMARY_INVERTER_L_RCV_PWM_FREQ_16_KHZ_CHOICE (3u)
#define PRIMARY_INVERTER_L_RCV_PWM_FREQ_12_KHZ_CHOICE (4u)
#define PRIMARY_INVERTER_L_RCV_PWM_FREQ_8_KHZ_I16_CHOICE (5u)
#define PRIMARY_INVERTER_L_RCV_PWM_FREQ_6_KHZ_I12_CHOICE (6u)
#define PRIMARY_INVERTER_L_RCV_PWM_FREQ_4_KHZ_I12_CHOICE (7u)

#define PRIMARY_SET_TLM_STATUS_TLM_STATUS_OFF_CHOICE (0u)
#define PRIMARY_SET_TLM_STATUS_TLM_STATUS_ON_CHOICE (1u)

#define PRIMARY_TLM_STATUS_TLM_STATUS_OFF_CHOICE (0u)
#define PRIMARY_TLM_STATUS_TLM_STATUS_ON_CHOICE (1u)

#define PRIMARY_HV_CAN_FORWARD_CAN_FORWARD_SET_OFF_CHOICE (0u)
#define PRIMARY_HV_CAN_FORWARD_CAN_FORWARD_SET_ON_CHOICE (1u)

#define PRIMARY_HV_FANS_OVERRIDE_FANS_OVERRIDE_OFF_CHOICE (0u)
#define PRIMARY_HV_FANS_OVERRIDE_FANS_OVERRIDE_ON_CHOICE (1u)

#define PRIMARY_HV_CAN_FORWARD_STATUS_CAN_FORWARD_STATUS_OFF_CHOICE (0u)
#define PRIMARY_HV_CAN_FORWARD_STATUS_CAN_FORWARD_STATUS_ON_CHOICE (1u)

#define PRIMARY_HV_FANS_OVERRIDE_STATUS_FANS_OVERRIDE_OFF_CHOICE (0u)
#define PRIMARY_HV_FANS_OVERRIDE_STATUS_FANS_OVERRIDE_ON_CHOICE (1u)

#define PRIMARY_HV_IMD_STATUS_IMD_STATUS_IMD_SC_CHOICE (0u)
#define PRIMARY_HV_IMD_STATUS_IMD_STATUS_IMD_NORMAL_CHOICE (1u)
#define PRIMARY_HV_IMD_STATUS_IMD_STATUS_IMD_UNDER_VOLTAGE_CHOICE (2u)
#define PRIMARY_HV_IMD_STATUS_IMD_STATUS_IMD_START_MEASURE_CHOICE (3u)
#define PRIMARY_HV_IMD_STATUS_IMD_STATUS_IMD_DEVICE_ERROR_CHOICE (4u)
#define PRIMARY_HV_IMD_STATUS_IMD_STATUS_IMD_EARTH_FAULT_CHOICE (5u)

#define PRIMARY_TS_STATUS_DAS_TS_STATUS_OFF_CHOICE (0u)
#define PRIMARY_TS_STATUS_DAS_TS_STATUS_PRECHARGE_CHOICE (1u)
#define PRIMARY_TS_STATUS_DAS_TS_STATUS_ON_CHOICE (2u)
#define PRIMARY_TS_STATUS_DAS_TS_STATUS_FATAL_CHOICE (3u)

#define PRIMARY_TS_STATUS_STEER_TS_STATUS_OFF_CHOICE (0u)
#define PRIMARY_TS_STATUS_STEER_TS_STATUS_PRECHARGE_CHOICE (1u)
#define PRIMARY_TS_STATUS_STEER_TS_STATUS_ON_CHOICE (2u)
#define PRIMARY_TS_STATUS_STEER_TS_STATUS_FATAL_CHOICE (3u)

#define PRIMARY_TS_STATUS_HANDCART_TS_STATUS_OFF_CHOICE (0u)
#define PRIMARY_TS_STATUS_HANDCART_TS_STATUS_PRECHARGE_CHOICE (1u)
#define PRIMARY_TS_STATUS_HANDCART_TS_STATUS_ON_CHOICE (2u)
#define PRIMARY_TS_STATUS_HANDCART_TS_STATUS_FATAL_CHOICE (3u)

#define PRIMARY_SET_TS_STATUS_DAS_TS_STATUS_SET_OFF_CHOICE (0u)
#define PRIMARY_SET_TS_STATUS_DAS_TS_STATUS_SET_ON_CHOICE (1u)

#define PRIMARY_SET_TS_STATUS_HANDCART_TS_STATUS_SET_OFF_CHOICE (0u)
#define PRIMARY_SET_TS_STATUS_HANDCART_TS_STATUS_SET_ON_CHOICE (1u)

#define PRIMARY_SET_CAR_STATUS_CAR_STATUS_SET_IDLE_CHOICE (0u)
#define PRIMARY_SET_CAR_STATUS_CAR_STATUS_SET_READY_CHOICE (1u)
#define PRIMARY_SET_CAR_STATUS_CAR_STATUS_SET_DRIVE_CHOICE (2u)

#define PRIMARY_SET_PEDALS_RANGE_BOUND_SET_MAX_CHOICE (0u)
#define PRIMARY_SET_PEDALS_RANGE_BOUND_SET_MIN_CHOICE (1u)

#define PRIMARY_SET_PEDALS_RANGE_PEDAL_ACCELERATOR_CHOICE (0u)
#define PRIMARY_SET_PEDALS_RANGE_PEDAL_BRAKE_CHOICE (1u)

#define PRIMARY_SET_STEERING_ANGLE_RANGE_BOUND_SET_MAX_CHOICE (0u)
#define PRIMARY_SET_STEERING_ANGLE_RANGE_BOUND_SET_MIN_CHOICE (1u)

#define PRIMARY_CAR_STATUS_INVERTER_L_OFF_CHOICE (0u)
#define PRIMARY_CAR_STATUS_INVERTER_L_IDLE_CHOICE (1u)
#define PRIMARY_CAR_STATUS_INVERTER_L_ON_CHOICE (2u)

#define PRIMARY_CAR_STATUS_INVERTER_R_OFF_CHOICE (0u)
#define PRIMARY_CAR_STATUS_INVERTER_R_IDLE_CHOICE (1u)
#define PRIMARY_CAR_STATUS_INVERTER_R_ON_CHOICE (2u)

#define PRIMARY_CAR_STATUS_CAR_STATUS_IDLE_CHOICE (0u)
#define PRIMARY_CAR_STATUS_CAR_STATUS_PRE_SETUP_CHOICE (1u)
#define PRIMARY_CAR_STATUS_CAR_STATUS_TS_ON_CHOICE (2u)
#define PRIMARY_CAR_STATUS_CAR_STATUS_POST_SETUP_CHOICE (3u)
#define PRIMARY_CAR_STATUS_CAR_STATUS_DRIVE_CHOICE (4u)
#define PRIMARY_CAR_STATUS_CAR_STATUS_TEARDOWN_CHOICE (5u)

#define PRIMARY_SET_INVERTER_CONNECTION_STATUS_STATUS_OFF_CHOICE (0u)
#define PRIMARY_SET_INVERTER_CONNECTION_STATUS_STATUS_ON_CHOICE (1u)

#define PRIMARY_INVERTER_CONNECTION_STATUS_STATUS_OFF_CHOICE (0u)
#define PRIMARY_INVERTER_CONNECTION_STATUS_STATUS_ON_CHOICE (1u)

#define PRIMARY_HV_CELL_BALANCING_STATUS_BALANCING_STATUS_OFF_CHOICE (0u)
#define PRIMARY_HV_CELL_BALANCING_STATUS_BALANCING_STATUS_ON_CHOICE (1u)

#define PRIMARY_SET_CELL_BALANCING_STATUS_SET_BALANCING_STATUS_OFF_CHOICE (0u)
#define PRIMARY_SET_CELL_BALANCING_STATUS_SET_BALANCING_STATUS_ON_CHOICE (1u)

/* Indexes */
#define primary_inverter_l_send_INDEX 0
#define primary_inverter_l_rcv_INDEX 1
#define primary_inverter_r_send_INDEX 2
#define primary_inverter_r_rcv_INDEX 3
#define primary_bms_hv_jmp_to_blt_INDEX 4
#define primary_bms_lv_jmp_to_blt_INDEX 5
#define primary_steer_version_INDEX 6
#define primary_das_version_INDEX 7
#define primary_hv_version_INDEX 8
#define primary_lv_version_INDEX 9
#define primary_tlm_version_INDEX 10
#define primary_timestamp_INDEX 11
#define primary_ambient_temperature_INDEX 12
#define primary_data_logger_INDEX 13
#define primary_set_tlm_status_INDEX 14
#define primary_tlm_status_INDEX 15
#define primary_steer_system_status_INDEX 16
#define primary_hv_voltage_INDEX 17
#define primary_hv_current_INDEX 18
#define primary_hv_temp_INDEX 19
#define primary_hv_errors_INDEX 20
#define primary_hv_can_forward_INDEX 21
#define primary_hv_fans_override_INDEX 22
#define primary_hv_can_forward_status_INDEX 23
#define primary_hv_fans_override_status_INDEX 24
#define primary_hv_feedbacks_status_INDEX 25
#define primary_hv_imd_status_INDEX 26
#define primary_ts_status_das_INDEX 27
#define primary_ts_status_steer_INDEX 28
#define primary_ts_status_handcart_INDEX 29
#define primary_set_ts_status_das_INDEX 30
#define primary_set_ts_status_handcart_INDEX 31
#define primary_steer_status_INDEX 32
#define primary_set_car_status_INDEX 33
#define primary_set_pedals_range_INDEX 34
#define primary_set_steering_angle_range_INDEX 35
#define primary_car_status_INDEX 36
#define primary_das_errors_INDEX 37
#define primary_lv_current_INDEX 38
#define primary_lv_voltage_INDEX 39
#define primary_lv_total_voltage_INDEX 40
#define primary_lv_temperature_INDEX 41
#define primary_cooling_status_INDEX 42
#define primary_set_radiator_speed_INDEX 43
#define primary_set_pumps_speed_INDEX 44
#define primary_set_inverter_connection_status_INDEX 45
#define primary_inverter_connection_status_INDEX 46
#define primary_lv_errors_INDEX 47
#define primary_shutdown_status_INDEX 48
#define primary_marker_INDEX 49
#define primary_hv_cells_voltage_INDEX 50
#define primary_hv_cells_temp_INDEX 51
#define primary_hv_cell_balancing_status_INDEX 52
#define primary_set_cell_balancing_status_INDEX 53
#define primary_handcart_status_INDEX 54
#define primary_speed_INDEX 55
#define primary_inv_l_request_INDEX 56
#define primary_inv_r_request_INDEX 57
#define primary_inv_l_response_INDEX 58
#define primary_inv_r_response_INDEX 59
#define primary_flash_cellboard_0_tx_INDEX 60
#define primary_flash_cellboard_0_rx_INDEX 61
#define primary_flash_cellboard_1_tx_INDEX 62
#define primary_flash_cellboard_1_rx_INDEX 63
#define primary_flash_cellboard_2_tx_INDEX 64
#define primary_flash_cellboard_2_rx_INDEX 65
#define primary_flash_cellboard_3_tx_INDEX 66
#define primary_flash_cellboard_3_rx_INDEX 67
#define primary_flash_cellboard_4_tx_INDEX 68
#define primary_flash_cellboard_4_rx_INDEX 69
#define primary_flash_cellboard_5_tx_INDEX 70
#define primary_flash_cellboard_5_rx_INDEX 71
#define primary_flash_bms_hv_tx_INDEX 72
#define primary_flash_bms_hv_rx_INDEX 73
#define primary_flash_bms_lv_tx_INDEX 74
#define primary_flash_bms_lv_rx_INDEX 75
#define primary_brusa_nlg5_ctl_INDEX 76
#define primary_brusa_st_INDEX 77
#define primary_brusa_act_i_INDEX 78
#define primary_brusa_act_ii_INDEX 79
#define primary_brusa_temp_INDEX 80
#define primary_brusa_err_INDEX 81
#define primary_control_output_INDEX 82
#define primary_lc_reset_INDEX 83


#define primary_MESSAGE_COUNT 84

#ifndef CANLIB_DEVICES_STRUCT
#define CANLIB_DEVICES_STRUCT
typedef struct {
    uint16_t id;
    void* message_raw;
    void* message_conversion;
} devices_t;
#endif // CANLIB_DEVICES_STRUCT

typedef devices_t primary_devices[primary_MESSAGE_COUNT];


primary_devices* primary_devices_new();
void primary_devices_free(primary_devices* devices);
void primary_devices_deserialize_from_id(
    primary_devices* devices,
    uint16_t message_id,
    uint8_t* data
#ifdef CANLIB_TIMESTAMP
    , uint64_t timestamp
#endif // CANLIB_TIMESTAMP
);

int primary_message_name_from_id(uint16_t id, char* buffer);
int primary_index_from_id(uint16_t id);
int primary_id_from_index(int index);

typedef enum {
	primary_inverter_l_send_send_mux_ID_04_USER_Key = 4,
	primary_inverter_l_send_send_mux_ID_05_Motor_F_nom = 5,
	primary_inverter_l_send_send_mux_ID_07_FU_T_dc = 7,
	primary_inverter_l_send_send_mux_ID_08_FU_V_dc = 8,
	primary_inverter_l_send_send_mux_ID_09_FU_Special = 9,
	primary_inverter_l_send_send_mux_ID_0A_FU_U_min = 10,
	primary_inverter_l_send_send_mux_ID_0B_FU_F_min = 11,
	primary_inverter_l_send_send_mux_ID_0C_FU_V_corner = 12,
	primary_inverter_l_send_send_mux_ID_0D_FU_F_corner = 13,
	primary_inverter_l_send_send_mux_ID_0E_Motor_Cos_Phi = 14,
	primary_inverter_l_send_send_mux_ID_0F_FU_Extra = 15,
	primary_inverter_l_send_send_mux_ID_10_Oszi_Channel = 16,
	primary_inverter_l_send_send_mux_ID_12_Oszi_Triger_Level = 18,
	primary_inverter_l_send_send_mux_ID_13_Oszi_Triger_Edge = 19,
	primary_inverter_l_send_send_mux_ID_14_Oszi_Triger_Source = 20,
	primary_inverter_l_send_send_mux_ID_15_Oszi_Source = 21,
	primary_inverter_l_send_send_mux_ID_16_Oszi_Skip = 22,
	primary_inverter_l_send_send_mux_ID_17_Oszi_Read_cmd = 23,
	primary_inverter_l_send_send_mux_ID_18_Oszi_Run_cmd = 24,
	primary_inverter_l_send_send_mux_ID_1A_Calib_Ref_Value = 26,
	primary_inverter_l_send_send_mux_ID_1C_PID_I_Kp = 28,
	primary_inverter_l_send_send_mux_ID_1D_PID_I_Ti = 29,
	primary_inverter_l_send_send_mux_ID_1E_Cutoffdig = 30,
	primary_inverter_l_send_send_mux_ID_21_Id_setdig = 33,
	primary_inverter_l_send_send_mux_ID_25_I_Delta_Ramp = 37,
	primary_inverter_l_send_send_mux_ID_2B_PID_I_TiM = 43,
	primary_inverter_l_send_send_mux_ID_2C_PID_n_Kp = 44,
	primary_inverter_l_send_send_mux_ID_2D_PID_n_Ti = 45,
	primary_inverter_l_send_send_mux_ID_2E_PID_n_Td = 46,
	primary_inverter_l_send_send_mux_ID_2F_Ain_in_1_OffsScale = 47,
	primary_inverter_l_send_send_mux_ID_31_N_setdig = 49,
	primary_inverter_l_send_send_mux_ID_34_N_Lim = 52,
	primary_inverter_l_send_send_mux_ID_35_Acc_Ramps = 53,
	primary_inverter_l_send_send_mux_ID_36_CommandSource = 54,
	primary_inverter_l_send_send_mux_ID_3B_PID_n_TiM = 59,
	primary_inverter_l_send_send_mux_ID_3C_I_Derating_N_perc = 60,
	primary_inverter_l_send_send_mux_ID_3E_N_Lim_minus = 62,
	primary_inverter_l_send_send_mux_ID_3F_N_Lim_plus = 63,
	primary_inverter_l_send_send_mux_ID_44_FeedBack_Offset_Angle = 68,
	primary_inverter_l_send_send_mux_ID_3D_Read_Cmd = 61,
	primary_inverter_l_send_send_mux_ID_46_I_lim_dig_perc = 70,
	primary_inverter_l_send_send_mux_ID_4C_I_Derating_TE = 76,
	primary_inverter_l_send_send_mux_ID_4D_Motor_I_max_eff_Arms = 77,
	primary_inverter_l_send_send_mux_ID_4E_Motor_I_nom_eff_Arms = 78,
	primary_inverter_l_send_send_mux_ID_4F_Motor_Pole_Number = 79,
	primary_inverter_l_send_send_mux_ID_50_Ain_in_1_Cutoff = 80,
	primary_inverter_l_send_send_mux_ID_51_Kern_Mode_State = 81,
	primary_inverter_l_send_send_mux_ID_53_Ain_in_2_Cutoff = 83,
	primary_inverter_l_send_send_mux_ID_58_I_Derating_TD = 88,
	primary_inverter_l_send_send_mux_ID_59_Motor_Nominal_Speed = 89,
	primary_inverter_l_send_send_mux_ID_5A_Device_Options = 90,
	primary_inverter_l_send_send_mux_ID_5B_PID_n_Kacc = 91,
	primary_inverter_l_send_send_mux_ID_5E_Speed_Filter = 94,
	primary_inverter_l_send_send_mux_ID_60_Ain_in_X_Filter = 96,
	primary_inverter_l_send_send_mux_ID_62_SerialNumber = 98,
	primary_inverter_l_send_send_mux_ID_64_Device_Mains_Supply_V = 100,
	primary_inverter_l_send_send_mux_ID_65_Regen_Resistor_P_and_R = 101,
	primary_inverter_l_send_send_mux_ID_67_Device_Type = 103,
	primary_inverter_l_send_send_mux_ID_68_CAN_ID_Rx = 104,
	primary_inverter_l_send_send_mux_ID_69_CAN_ID_Tx = 105,
	primary_inverter_l_send_send_mux_ID_6A_Pos_PID_Kp = 106,
	primary_inverter_l_send_send_mux_ID_6B_Pos_PID_Ti = 107,
	primary_inverter_l_send_send_mux_ID_6C_Pos_PID_Td = 108,
	primary_inverter_l_send_send_mux_ID_6E_Pos_Destination = 110,
	primary_inverter_l_send_send_mux_ID_71_Pos_PID_TiM = 113,
	primary_inverter_l_send_send_mux_ID_72_Pos_OffsetReference = 114,
	primary_inverter_l_send_send_mux_ID_73_CAN_NBT = 115,
	primary_inverter_l_send_send_mux_ID_75_Pos_Ref_Reso_Edge = 117,
	primary_inverter_l_send_send_mux_ID_76_Pos_Calib_Speed_1 = 118,
	primary_inverter_l_send_send_mux_ID_77_Pos_Calib_Speed_2 = 119,
	primary_inverter_l_send_send_mux_ID_79_Pos_Tol_Window = 121,
	primary_inverter_l_send_send_mux_ID_7A_Pos_Preset_Value = 122,
	primary_inverter_l_send_send_mux_ID_7C_Pos_NDrive_Scale = 124,
	primary_inverter_l_send_send_mux_ID_7D_Pos_NDrive_Offset = 125,
	primary_inverter_l_send_send_mux_ID_7E_Pos_FB2_Scale_Fac_Ext = 126,
	primary_inverter_l_send_send_mux_ID_7F_Pos_Offset_Slack = 127,
	primary_inverter_l_send_send_mux_ID_80_Pos_Diff_Slack = 128,
	primary_inverter_l_send_send_mux_ID_83_Function_Parameter_Read = 131,
	primary_inverter_l_send_send_mux_ID_84_Function_Parameter_Write = 132,
	primary_inverter_l_send_send_mux_ID_85_Function_Special = 133,
	primary_inverter_l_send_send_mux_ID_88_CAN_ID_2_Rx = 136,
	primary_inverter_l_send_send_mux_ID_89_CAN_ID_2_Tx = 137,
	primary_inverter_l_send_send_mux_ID_8B_VoltageControl_Ref = 139,
	primary_inverter_l_send_send_mux_ID_8C_VoltageControl_Kp = 140,
	primary_inverter_l_send_send_mux_ID_8D_VoltageControl_Ti = 141,
	primary_inverter_l_send_send_mux_ID_8E_Clear_Error_List = 142,
	primary_inverter_l_send_send_mux_ID_90_M_setdig = 144,
	primary_inverter_l_send_send_mux_ID_A2_I_Derating_TM = 162,
	primary_inverter_l_send_send_mux_ID_A3_Motor_Temp_Error_Lim = 163,
	primary_inverter_l_send_send_mux_ID_A4_Motor_Options = 164,
	primary_inverter_l_send_send_mux_ID_A5_Device_DC_Bus_MinMax_Lim = 165,
	primary_inverter_l_send_send_mux_ID_A6_FB_IncrementsPerRot = 166,
	primary_inverter_l_send_send_mux_ID_A7_FB_Pole_Number = 167,
	primary_inverter_l_send_send_mux_ID_B1_Motor_L_Sigma_Q = 177,
	primary_inverter_l_send_send_mux_ID_B2_Id_Nominal = 178,
	primary_inverter_l_send_send_mux_ID_B3_Motor_Magn_Inductance = 179,
	primary_inverter_l_send_send_mux_ID_B4_Motor_Rotor_Resistance = 180,
	primary_inverter_l_send_send_mux_ID_B5_Id_Minimum = 181,
	primary_inverter_l_send_send_mux_ID_B6_Time_Constant_Rotor = 182,
	primary_inverter_l_send_send_mux_ID_BB_Motor_L_Sigma_D = 187,
	primary_inverter_l_send_send_mux_ID_BC_Motor_Stator_Resistance = 188,
	primary_inverter_l_send_send_mux_ID_BD_Time_Constant_Stator = 189,
	primary_inverter_l_send_send_mux_ID_BE_LogicDefine_of_END_1 = 190,
	primary_inverter_l_send_send_mux_ID_BF_LogicDefine_of_END_2 = 191,
	primary_inverter_l_send_send_mux_ID_C0_LogicDefine_of_DIN_1 = 192,
	primary_inverter_l_send_send_mux_ID_C1_LogicDefine_of_DIN_2 = 193,
	primary_inverter_l_send_send_mux_ID_C2_LogicDefine_of_OUT_1 = 194,
	primary_inverter_l_send_send_mux_ID_C3_LogicDefine_of_OUT_2 = 195,
	primary_inverter_l_send_send_mux_ID_DA_LogicDefine_of_OUT_3 = 218,
	primary_inverter_l_send_send_mux_ID_DB_LogicDefine_of_OUT_4 = 219,
	primary_inverter_l_send_send_mux_ID_C4_I_max_pk_perc = 196,
	primary_inverter_l_send_send_mux_ID_C5_I_con_eff_perc = 197,
	primary_inverter_l_send_send_mux_ID_C6_I_device = 198,
	primary_inverter_l_send_send_mux_ID_C7_RLim_MRcp_Ramp = 199,
	primary_inverter_l_send_send_mux_ID_C8_Nmax100perc = 200,
	primary_inverter_l_send_send_mux_ID_C9_CurrentControl_xKp = 201,
	primary_inverter_l_send_send_mux_ID_CA_Bat_Opr_Limits = 202,
	primary_inverter_l_send_send_mux_ID_CB_PID_I_Kf = 203,
	primary_inverter_l_send_send_mux_ID_CD_Car_Mode_Config = 205,
	primary_inverter_l_send_send_mux_ID_D0_CAN_Timeout = 208,
	primary_inverter_l_send_send_mux_ID_D1_Var_1 = 209,
	primary_inverter_l_send_send_mux_ID_D2_Var_2 = 210,
	primary_inverter_l_send_send_mux_ID_D3_Var_3 = 211,
	primary_inverter_l_send_send_mux_ID_D4_Var_4 = 212,
	primary_inverter_l_send_send_mux_ID_D7_Ain_in_2_OffsScale = 215,
	primary_inverter_l_send_send_mux_ID_DC_DAC_Source_ID = 220,
	primary_inverter_l_send_send_mux_ID_ED_Dec_Ramps = 237,
	primary_inverter_l_send_send_mux_ID_EE_V_Shunt = 238,
	primary_inverter_l_send_send_mux_ID_F0_Time_I_Peak = 240,
	primary_inverter_l_send_send_mux_ID_F1_Brake_Delay = 241,
	primary_inverter_l_send_send_mux_ID_F8_Axis_Label = 248,
} primary_inverter_l_send_send_mux;

typedef enum {
	primary_inverter_l_send_cs_ain_1_format_Off = 0,
	primary_inverter_l_send_cs_ain_1_format__Cmd = 1,
	primary_inverter_l_send_cs_ain_1_format__Cmd = 2,
	primary_inverter_l_send_cs_ain_1_format_sq_Cmd_ = 3,
} primary_inverter_l_send_cs_ain_1_format;

typedef enum {
	primary_inverter_l_send_read_id_05h_Motor_F_nom = 5,
	primary_inverter_l_send_read_id_06h_Motor_V_nom = 6,
	primary_inverter_l_send_read_id_07h_FU_T_dc = 7,
	primary_inverter_l_send_read_id_08h_FU_V_dc = 8,
	primary_inverter_l_send_read_id_09h_FU_Special = 9,
	primary_inverter_l_send_read_id_0Ah_FU_U_min = 10,
	primary_inverter_l_send_read_id_0Bh_FU_F_min = 11,
	primary_inverter_l_send_read_id_0Ch_FU_V_corner = 12,
	primary_inverter_l_send_read_id_0Dh_FU_F_corner = 13,
	primary_inverter_l_send_read_id_0Eh_Motor_Cos_Phi = 14,
	primary_inverter_l_send_read_id_0Fh_FU_Extra = 15,
	primary_inverter_l_send_read_id_10h_Oszi_Channel = 16,
	primary_inverter_l_send_read_id_11h_Control_Status = 17,
	primary_inverter_l_send_read_id_12h_Oszi_Triger_Level = 18,
	primary_inverter_l_send_read_id_13h_Oszi_Triger_Edge = 19,
	primary_inverter_l_send_read_id_14h_Oszi_Triger_Source = 20,
	primary_inverter_l_send_read_id_15h_Oszi_Source = 21,
	primary_inverter_l_send_read_id_16h_Oszi_Skip = 22,
	primary_inverter_l_send_read_id_17h_Oszi_Read_cmd = 23,
	primary_inverter_l_send_read_id_18h_Oszi_Run_cmd = 24,
	primary_inverter_l_send_read_id_19h_PWM_Enum = 25,
	primary_inverter_l_send_read_id_1Ah_Calib_Ref_Value = 26,
	primary_inverter_l_send_read_id_1Bh_FW_Nr = 27,
	primary_inverter_l_send_read_id_1Ch_I_Kp = 28,
	primary_inverter_l_send_read_id_1Dh_I_Ti = 29,
	primary_inverter_l_send_read_id_1Eh_Cutoffdig = 30,
	primary_inverter_l_send_read_id_1Fh_I3_Offset = 31,
	primary_inverter_l_send_read_id_20h_I_Actual = 32,
	primary_inverter_l_send_read_id_21h_Id_setdig = 33,
	primary_inverter_l_send_read_id_22h_I_cmd_ramp = 34,
	primary_inverter_l_send_read_id_23h_Id_Ref = 35,
	primary_inverter_l_send_read_id_24h_I_Max_Inuse = 36,
	primary_inverter_l_send_read_id_25h_I_Delta_Ramp = 37,
	primary_inverter_l_send_read_id_26h_I_cmd = 38,
	primary_inverter_l_send_read_id_27h_Iq_Actual = 39,
	primary_inverter_l_send_read_id_28h_Id_Actual = 40,
	primary_inverter_l_send_read_id_29h_Vq_Output = 41,
	primary_inverter_l_send_read_id_2Ah_Vd_Output = 42,
	primary_inverter_l_send_read_id_2Bh_I_TiM = 43,
	primary_inverter_l_send_read_id_2Ch_n_Kp = 44,
	primary_inverter_l_send_read_id_2Dh_n_Ti = 45,
	primary_inverter_l_send_read_id_2Eh_n_Td = 46,
	primary_inverter_l_send_read_id_2Fh_Ain_in_1_OffsScale = 47,
	primary_inverter_l_send_read_id_30h_N_Actual = 48,
	primary_inverter_l_send_read_id_31h_N_setdig = 49,
	primary_inverter_l_send_read_id_32h_N_cmd_ramp = 50,
	primary_inverter_l_send_read_id_33h_N_Error = 51,
	primary_inverter_l_send_read_id_34h_N_Lim = 52,
	primary_inverter_l_send_read_id_35h_Acc_Ramps = 53,
	primary_inverter_l_send_read_id_36h_CommandSource = 54,
	primary_inverter_l_send_read_id_37h_DZR_Sequencer_Value = 55,
	primary_inverter_l_send_read_id_38h_Iq_Error = 56,
	primary_inverter_l_send_read_id_39h_Id_Error = 57,
	primary_inverter_l_send_read_id_3Bh_n_TiM = 59,
	primary_inverter_l_send_read_id_3Ch_I_Derating_N_perc = 60,
	primary_inverter_l_send_read_id_3Eh_N_Lim_minus = 62,
	primary_inverter_l_send_read_id_3Fh_N_Lim_plus = 63,
	primary_inverter_l_send_read_id_40h_Status_Map = 64,
	primary_inverter_l_send_read_id_41h_Incr_Delta = 65,
	primary_inverter_l_send_read_id_42h_MotorPosition_Mech = 66,
	primary_inverter_l_send_read_id_43h_MotorPosition_Elec = 67,
	primary_inverter_l_send_read_id_44h_FeedBack_Offset_Angle = 68,
	primary_inverter_l_send_read_id_45h_Ixt_and_RegenE_Monitor = 69,
	primary_inverter_l_send_read_id_46h_I_lim_dig_perc = 70,
	primary_inverter_l_send_read_id_48h_I_Limit_Inuse = 72,
	primary_inverter_l_send_read_id_49h_T_Motor = 73,
	primary_inverter_l_send_read_id_4Ah_T_Igbt = 74,
	primary_inverter_l_send_read_id_4Bh_T_Air_Inside = 75,
	primary_inverter_l_send_read_id_4Ch_I_Derating_TE = 76,
	primary_inverter_l_send_read_id_4Dh_Motor_I_max_eff = 77,
	primary_inverter_l_send_read_id_4Eh_Motor_I_nom_eff = 78,
	primary_inverter_l_send_read_id_4Fh_Motor_Pole = 79,
	primary_inverter_l_send_read_id_50h_Ain_in_1_Cutoff = 80,
	primary_inverter_l_send_read_id_51h_Kern_Mode_State = 81,
	primary_inverter_l_send_read_id_52h_Status_Mask = 82,
	primary_inverter_l_send_read_id_53h_Ain_in_2_Cutoff = 83,
	primary_inverter_l_send_read_id_54h_I1_Actual = 84,
	primary_inverter_l_send_read_id_55h_I2_Actual = 85,
	primary_inverter_l_send_read_id_56h_I3_Actual = 86,
	primary_inverter_l_send_read_id_57h_I_Limit_Inuse_ramp = 87,
	primary_inverter_l_send_read_id_58h_I_Derating_TD = 88,
	primary_inverter_l_send_read_id_59h_Motor_Nom = 89,
	primary_inverter_l_send_read_id_5Ah_Device_Options = 90,
	primary_inverter_l_send_read_id_5Bh_SpeedControl_Kacc = 91,
	primary_inverter_l_send_read_id_5Ch_Rotor_Signals = 92,
	primary_inverter_l_send_read_id_5Dh_N_cmd = 93,
	primary_inverter_l_send_read_id_5Eh_Speed_Filter = 94,
	primary_inverter_l_send_read_id_5Fh_I_Actual_Filt = 95,
	primary_inverter_l_send_read_id_60h_Ain_in_X_Filter = 96,
	primary_inverter_l_send_read_id_61h_Ixt_Monitor = 97,
	primary_inverter_l_send_read_id_62h_SerialNumber = 98,
	primary_inverter_l_send_read_id_63h_FPGA_Status = 99,
	primary_inverter_l_send_read_id_64h_Device_Mains = 100,
	primary_inverter_l_send_read_id_65h_Regen_P_R = 101,
	primary_inverter_l_send_read_id_67h_Device_Type = 103,
	primary_inverter_l_send_read_id_68h_CAN_ID_Rx = 104,
	primary_inverter_l_send_read_id_69h_CAN_ID_Tx = 105,
	primary_inverter_l_send_read_id_6Ah_Pos_Kp = 106,
	primary_inverter_l_send_read_id_6Bh_Pos_Ti = 107,
	primary_inverter_l_send_read_id_6Ch_Pos_Td = 108,
	primary_inverter_l_send_read_id_6Dh_Pos_Actual = 109,
	primary_inverter_l_send_read_id_6Eh_Pos_Dest = 110,
	primary_inverter_l_send_read_id_6Fh_Pos_Actual_2 = 111,
	primary_inverter_l_send_read_id_70h_Pos_Err = 112,
	primary_inverter_l_send_read_id_71h_Pos_TiM = 113,
	primary_inverter_l_send_read_id_72h_Pos_OffsetRef = 114,
	primary_inverter_l_send_read_id_73h_CAN_NBT = 115,
	primary_inverter_l_send_read_id_74h_Pos_Zero_Capture = 116,
	primary_inverter_l_send_read_id_75h_Pos_Ref_Reso_Edge = 117,
	primary_inverter_l_send_read_id_76h_Pos_Speed_1 = 118,
	primary_inverter_l_send_read_id_77h_Pos_Speed_2 = 119,
	primary_inverter_l_send_read_id_78h_Pos_Ref_Start = 120,
	primary_inverter_l_send_read_id_79h_Pos_Tol_Win = 121,
	primary_inverter_l_send_read_id_7Ah_Pos_Preset = 122,
	primary_inverter_l_send_read_id_7Bh_Pos_Zero_Offset = 123,
	primary_inverter_l_send_read_id_7Ch_Pos_ND_Scale = 124,
	primary_inverter_l_send_read_id_7Dh_Pos_ND_Offset = 125,
	primary_inverter_l_send_read_id_7Eh_Pos_FB2_Scale_Fac_Ext = 126,
	primary_inverter_l_send_read_id_7Fh_Pos_Offset_Slack = 127,
	primary_inverter_l_send_read_id_80h_Pos_Diff_Slack = 128,
	primary_inverter_l_send_read_id_83h_Func_Para_Read = 131,
	primary_inverter_l_send_read_id_84h_Func_Para_Write = 132,
	primary_inverter_l_send_read_id_85h_Func_Special = 133,
	primary_inverter_l_send_read_id_88h_CAN_ID_2_Rx = 136,
	primary_inverter_l_send_read_id_89h_CAN_ID_2_Tx = 137,
	primary_inverter_l_send_read_id_8Ah_Vout = 138,
	primary_inverter_l_send_read_id_8Bh_V_Ref = 139,
	primary_inverter_l_send_read_id_8Ch_V_Kp = 140,
	primary_inverter_l_send_read_id_8Dh_V_Ti = 141,
	primary_inverter_l_send_read_id_8Eh_Clear_Error_List = 142,
	primary_inverter_l_send_read_id_8Fh_ErrorWarning_Map = 143,
	primary_inverter_l_send_read_id_90h_M_setdig = 144,
	primary_inverter_l_send_read_id_91h_Pos_cmd_int = 145,
	primary_inverter_l_send_read_id_92h_CAN_Error_BusOff_cntr = 146,
	primary_inverter_l_send_read_id_93h_CAN_Error_WriteTime_cntr = 147,
	primary_inverter_l_send_read_id_94h_CAN_Error_RxMsgLost_cntr = 148,
	primary_inverter_l_send_read_id_95h_CAN_Error_NoAck_cntr = 149,
	primary_inverter_l_send_read_id_96h_CAN_Error_CRC_Check_cntr = 150,
	primary_inverter_l_send_read_id_97h_CAN_Error_Bit_cntr = 151,
	primary_inverter_l_send_read_id_99h_Info_Timer_Diff = 153,
	primary_inverter_l_send_read_id_9Ah_Temp_DEBUG = 154,
	primary_inverter_l_send_read_id_A0h_Mout = 160,
	primary_inverter_l_send_read_id_A1h_Ballast_cntr = 161,
	primary_inverter_l_send_read_id_A2h_I_Derating_TM = 162,
	primary_inverter_l_send_read_id_A3h_M_Temp = 163,
	primary_inverter_l_send_read_id_A4h_Motor_Options = 164,
	primary_inverter_l_send_read_id_A5h_DC_Bus_MinMax_Lim = 165,
	primary_inverter_l_send_read_id_A6h_FB_IncPerRot = 166,
	primary_inverter_l_send_read_id_A7h_FB_Pole = 167,
	primary_inverter_l_send_read_id_A8h_N_Actual_Filt = 168,
	primary_inverter_l_send_read_id_A9h_I3_ADC = 169,
	primary_inverter_l_send_read_id_AAh_I2_ADC = 170,
	primary_inverter_l_send_read_id_ABh_Logic_Freq = 171,
	primary_inverter_l_send_read_id_ACh_PWM_1_56 = 172,
	primary_inverter_l_send_read_id_ADh_PWM_2_34 = 173,
	primary_inverter_l_send_read_id_AEh_PWM_3_12 = 174,
	primary_inverter_l_send_read_id_AFh_Timer_Delta = 175,
	primary_inverter_l_send_read_id_B1h_Motor_Lsq = 177,
	primary_inverter_l_send_read_id_B2h_Id_Nom = 178,
	primary_inverter_l_send_read_id_B3h_Motor_Lm = 179,
	primary_inverter_l_send_read_id_B4h_Motor_Rr = 180,
	primary_inverter_l_send_read_id_B5h_Id_Min = 181,
	primary_inverter_l_send_read_id_B6h_Motor_Tr = 182,
	primary_inverter_l_send_read_id_B8h_Ptr_1_DEBUG = 184,
	primary_inverter_l_send_read_id_BAh_Ptr_2_DEBUG = 186,
	primary_inverter_l_send_read_id_BBh_Motor_Lsd = 187,
	primary_inverter_l_send_read_id_BCh_Motor_Rs = 188,
	primary_inverter_l_send_read_id_BDh_Motor_Ts = 189,
	primary_inverter_l_send_read_id_BEh_def_END_1 = 190,
	primary_inverter_l_send_read_id_BFh_def_END_2 = 191,
	primary_inverter_l_send_read_id_C0h_def_DIN_1 = 192,
	primary_inverter_l_send_read_id_C1h_def_DIN_2 = 193,
	primary_inverter_l_send_read_id_C2h_def_OUT_1 = 194,
	primary_inverter_l_send_read_id_C3h_def_OUT_2 = 195,
	primary_inverter_l_send_read_id_C4h_I_max_pk = 196,
	primary_inverter_l_send_read_id_C5h_I_con_eff = 197,
	primary_inverter_l_send_read_id_C6h_I_device = 198,
	primary_inverter_l_send_read_id_C7h_RLim_MRcp_Ramp = 199,
	primary_inverter_l_send_read_id_C8h_Nmax100perc = 200,
	primary_inverter_l_send_read_id_C9h_I_xKp = 201,
	primary_inverter_l_send_read_id_CAh_Bat_Opr_Limits = 202,
	primary_inverter_l_send_read_id_CBh_I_Kf = 203,
	primary_inverter_l_send_read_id_CCh_Car_Mode_Status = 204,
	primary_inverter_l_send_read_id_CDh_Car_Mode_Config = 205,
	primary_inverter_l_send_read_id_CEh_N_Rpm_MaxInt = 206,
	primary_inverter_l_send_read_id_D0h_CAN_Timeout = 208,
	primary_inverter_l_send_read_id_D1h_Var_1 = 209,
	primary_inverter_l_send_read_id_D2h_Var_2 = 210,
	primary_inverter_l_send_read_id_D3h_Var_3 = 211,
	primary_inverter_l_send_read_id_D4h_Var_4 = 212,
	primary_inverter_l_send_read_id_D5h_Ain_in_1 = 213,
	primary_inverter_l_send_read_id_D6h_Ain_in_2 = 214,
	primary_inverter_l_send_read_id_D7h_Ain_in_2_OffsScale = 215,
	primary_inverter_l_send_read_id_D8h_LogicReadBitsIN_OUT = 216,
	primary_inverter_l_send_read_id_D9h_I_200perc = 217,
	primary_inverter_l_send_read_id_DAh_def_OUT_3 = 218,
	primary_inverter_l_send_read_id_DBh_def_OUT_4 = 219,
	primary_inverter_l_send_read_id_DCh_DAC_Source_ID = 220,
	primary_inverter_l_send_read_id_DEh_DS_DOUT_3 = 222,
	primary_inverter_l_send_read_id_DFh_DS_DOUT_4 = 223,
	primary_inverter_l_send_read_id_E0h_DS_DOUT_1 = 224,
	primary_inverter_l_send_read_id_E1h_DS_DOUT_2 = 225,
	primary_inverter_l_send_read_id_E2h_DS_Rdy_BTB = 226,
	primary_inverter_l_send_read_id_E3h_DS_GO = 227,
	primary_inverter_l_send_read_id_E4h_DS_END_1 = 228,
	primary_inverter_l_send_read_id_E5h_DS_END_2 = 229,
	primary_inverter_l_send_read_id_E6h_DS_DIN_1 = 230,
	primary_inverter_l_send_read_id_E7h_DS_DIN_2 = 231,
	primary_inverter_l_send_read_id_E8h_DS_RUN = 232,
	primary_inverter_l_send_read_id_E9h_DS_I_Fault = 233,
	primary_inverter_l_send_read_id_EBh_Vdc_Bus = 235,
	primary_inverter_l_send_read_id_ECh_DS_FB_LossOfSignal = 236,
	primary_inverter_l_send_read_id_EDh_Dec_Ramps = 237,
	primary_inverter_l_send_read_id_EEh_V_Shunt = 238,
	primary_inverter_l_send_read_id_EFh_DS_NoHWFault = 239,
	primary_inverter_l_send_read_id_F0h_T_peak = 240,
	primary_inverter_l_send_read_id_F1h_Brake_Delay = 241,
	primary_inverter_l_send_read_id_F2h_DS_Brake = 242,
	primary_inverter_l_send_read_id_F3h_DS_Icns = 243,
	primary_inverter_l_send_read_id_F4h_DS_PosTolerance = 244,
	primary_inverter_l_send_read_id_F5h_DS_LessN0 = 245,
	primary_inverter_l_send_read_id_F6h_Inverter_Power = 246,
	primary_inverter_l_send_read_id_F7h_Inverter_Work = 247,
	primary_inverter_l_send_read_id_F8h_Axis = 248,
	primary_inverter_l_send_read_id_FBh_Ain_in_1_Calc = 251,
	primary_inverter_l_send_read_id_FCh_Ain_in_2_Calc = 252,
	primary_inverter_l_send_read_id_66h_DC_Bus_Voltage = 102,
	primary_inverter_l_send_read_id_3Ah_M_cmd_ramp = 58,
	primary_inverter_l_send_read_id_FEh_Subv_SVNRev_Nr = 254,
} primary_inverter_l_send_read_id;

typedef enum {
	primary_inverter_l_send_devicetype_Homemade = 0,
	primary_inverter_l_send_devicetype_DS205_2ph_230V = 14,
	primary_inverter_l_send_devicetype_DS403_2ph_400V = 15,
	primary_inverter_l_send_devicetype_DS205_neu_230V = 16,
	primary_inverter_l_send_devicetype_DS403_neu_400V = 17,
	primary_inverter_l_send_devicetype_DS405 = 19,
	primary_inverter_l_send_devicetype_DS412 = 21,
	primary_inverter_l_send_devicetype_DS420 = 23,
	primary_inverter_l_send_devicetype_DS450 = 25,
	primary_inverter_l_send_devicetype_DS475 = 27,
	primary_inverter_l_send_devicetype_DS4100 = 29,
	primary_inverter_l_send_devicetype_DS4820 = 48,
	primary_inverter_l_send_devicetype_DS451 = 49,
	primary_inverter_l_send_devicetype_DS476 = 51,
	primary_inverter_l_send_devicetype_DS8020 = 56,
	primary_inverter_l_send_devicetype_DPC440 = 60,
	primary_inverter_l_send_devicetype_DPC460 = 65,
	primary_inverter_l_send_devicetype_DPC460_DC1Q_3P = 67,
	primary_inverter_l_send_devicetype_BAMO_160_60 = 81,
	primary_inverter_l_send_devicetype_BAMO_160_120 = 83,
	primary_inverter_l_send_devicetype_BAMO_160_180 = 85,
	primary_inverter_l_send_devicetype_BAMO_360_60 = 87,
	primary_inverter_l_send_devicetype_BAMO_360_120 = 89,
	primary_inverter_l_send_devicetype_BAMO_360_180 = 91,
	primary_inverter_l_send_devicetype_BAMO_360_240 = 93,
	primary_inverter_l_send_devicetype_BAMOBIL_D3_3_62_80 = 112,
	primary_inverter_l_send_devicetype_BAMOBIL_D3_2_62_80 = 113,
	primary_inverter_l_send_devicetype_BAMOBIL_D3_3_62_120 = 114,
	primary_inverter_l_send_devicetype_BAMOBIL_D3_2_62_120 = 115,
	primary_inverter_l_send_devicetype_BAMOBIL_D3_3_62_250 = 116,
	primary_inverter_l_send_devicetype_BAMOBIL_D3_2_62_250 = 117,
	primary_inverter_l_send_devicetype_BAMOBIL_D3_3_62_350 = 118,
	primary_inverter_l_send_devicetype_BAMOBIL_D3_2_62_350 = 119,
	primary_inverter_l_send_devicetype_BAMOBIL_D3_3_62_450 = 120,
	primary_inverter_l_send_devicetype_BAMOBIL_D3_2_62_450 = 121,
	primary_inverter_l_send_devicetype_BAMOBIL_D3_3_160_50 = 122,
	primary_inverter_l_send_devicetype_BAMOBIL_D3_2_160_50 = 123,
	primary_inverter_l_send_devicetype_BAMOBIL_D3_3_160_100 = 124,
	primary_inverter_l_send_devicetype_BAMOBIL_D3_2_160_100 = 125,
	primary_inverter_l_send_devicetype_BAMOBIL_D3_3_160_200 = 126,
	primary_inverter_l_send_devicetype_BAMOBIL_D3_2_160_200 = 127,
	primary_inverter_l_send_devicetype_Bamocar_700_160 = 192,
	primary_inverter_l_send_devicetype_Bamocar_700_100 = 193,
	primary_inverter_l_send_devicetype_Bamocar_700_900 = 194,
	primary_inverter_l_send_devicetype_Bamocar_700_200_DC = 203,
	primary_inverter_l_send_devicetype_Bamocar_400_400 = 204,
	primary_inverter_l_send_devicetype_Bamocar_700_400 = 205,
	primary_inverter_l_send_devicetype_Bamocar_400_250 = 206,
	primary_inverter_l_send_devicetype_Koepfer_V1_700_400 = 240,
	primary_inverter_l_send_devicetype_Koepfer_V2_700_400 = 241,
} primary_inverter_l_send_devicetype;

typedef enum {
	primary_inverter_l_send_can_nbt_1000_kbps = 16386,
	primary_inverter_l_send_can_nbt_500_kbps = 16421,
	primary_inverter_l_send_can_nbt_625_kbps = 16404,
	primary_inverter_l_send_can_nbt_250_kbps = 16476,
	primary_inverter_l_send_can_nbt_100_kbps = 17445,
} primary_inverter_l_send_can_nbt;

typedef enum {
	primary_inverter_l_send_eprom131_Sector_0 = 0,
	primary_inverter_l_send_eprom131_Sector_1 = 1,
	primary_inverter_l_send_eprom131_Sector_2 = 2,
} primary_inverter_l_send_eprom131;

typedef enum {
	primary_inverter_l_send_eprom132_Sector_0 = 0,
	primary_inverter_l_send_eprom132_Sector_1 = 1,
	primary_inverter_l_send_eprom132_Sector_2 = 2,
} primary_inverter_l_send_eprom132;

typedef enum {
	primary_inverter_l_send_mo_feedback_1_Rot_Enc_TTL = 0,
	primary_inverter_l_send_mo_feedback_1_Resolver = 1,
	primary_inverter_l_send_mo_feedback_1_Abs_Enc_SC = 2,
	primary_inverter_l_send_mo_feedback_1_Rot_Tacho = 3,
	primary_inverter_l_send_mo_feedback_1_Rot = 4,
	primary_inverter_l_send_mo_feedback_1_DC_Tacho = 5,
	primary_inverter_l_send_mo_feedback_1_DC_Arm = 6,
	primary_inverter_l_send_mo_feedback_1_BL_Arm = 7,
	primary_inverter_l_send_mo_feedback_1_Enc_TTL = 8,
	primary_inverter_l_send_mo_feedback_1_Enc_SC = 9,
	primary_inverter_l_send_mo_feedback_1_Abs_SC = 10,
	primary_inverter_l_send_mo_feedback_1_DC_Arm_Vir = 11,
	primary_inverter_l_send_mo_feedback_1_SLS = 12,
	primary_inverter_l_send_mo_feedback_1_SLS_SMO = 13,
	primary_inverter_l_send_mo_feedback_1_SLS_Usens = 14,
	primary_inverter_l_send_mo_feedback_1_AnaIn1_calc = 15,
	primary_inverter_l_send_mo_feedback_1_AnaIn2_calc = 16,
	primary_inverter_l_send_mo_feedback_1_Panasonic = 17,
	primary_inverter_l_send_mo_feedback_1_DC_Bus = 18,
} primary_inverter_l_send_mo_feedback_1;

typedef enum {
	primary_inverter_l_send_def_end_1__Off_ = 0,
	primary_inverter_l_send_def_end_1_Ref_and_Limit_Plus = 1,
	primary_inverter_l_send_def_end_1_Ref_and_Limit_Minus = 2,
	primary_inverter_l_send_def_end_1_Ref_Plus = 3,
	primary_inverter_l_send_def_end_1_Limit_Plus = 4,
	primary_inverter_l_send_def_end_1_Limit_Minus = 5,
	primary_inverter_l_send_def_end_1_Limit_Plus_and_Minus = 6,
	primary_inverter_l_send_def_end_1_Cancel_Error_s_ = 7,
	primary_inverter_l_send_def_end_1__Start_Ref_Drive = 8,
	primary_inverter_l_send_def_end_1_Speed_Ramp_0 = 9,
	primary_inverter_l_send_def_end_1__Start_Dest_Var_1 = 10,
	primary_inverter_l_send_def_end_1__Start_Dest_Var_2 = 11,
	primary_inverter_l_send_def_end_1_N_cmd_Reverse = 12,
	primary_inverter_l_send_def_end_1__Preset_Pos_Var_3 = 13,
	primary_inverter_l_send_def_end_1__Capture_Var_3_Pos = 14,
	primary_inverter_l_send_def_end_1__Capture_Var_4_Pos = 15,
	primary_inverter_l_send_def_end_1__Switch_Spd_Ain1_Ain2 = 16,
	primary_inverter_l_send_def_end_1__Switch_Spd_Var1_Var2 = 17,
	primary_inverter_l_send_def_end_1_I_limit_dig_ = 18,
	primary_inverter_l_send_def_end_1_N_clip_neg_pos_ = 19,
	primary_inverter_l_send_def_end_1__Switch_Cmd_Dig_Ana = 20,
	primary_inverter_l_send_def_end_1_Speed_Ramp_0_Pos = 21,
	primary_inverter_l_send_def_end_1_Handwheel = 22,
	primary_inverter_l_send_def_end_1_Brake_Car = 23,
	primary_inverter_l_send_def_end_1_Recup_Disabled = 24,
	primary_inverter_l_send_def_end_1_Rising_Bank_1,_Falling_Bank_0 = 25,
	primary_inverter_l_send_def_end_1__Start_Dest_Var_1,_2,_3,_4 = 26,
	primary_inverter_l_send_def_end_1__Start_CW_Var_1,_2,_3,_4 = 27,
	primary_inverter_l_send_def_end_1_Brake_Car_Nr2 = 28,
} primary_inverter_l_send_def_end_1;

typedef enum {
	primary_inverter_l_send_def_end_2__Off_ = 0,
	primary_inverter_l_send_def_end_2_Ref_and_Limit_Plus = 1,
	primary_inverter_l_send_def_end_2_Ref_and_Limit_Minus = 2,
	primary_inverter_l_send_def_end_2_Ref_Plus = 3,
	primary_inverter_l_send_def_end_2_Limit_Plus = 4,
	primary_inverter_l_send_def_end_2_Limit_Minus = 5,
	primary_inverter_l_send_def_end_2_Limit_Plus_and_Minus = 6,
	primary_inverter_l_send_def_end_2_Cancel_Error_s_ = 7,
	primary_inverter_l_send_def_end_2__Start_Ref_Drive = 8,
	primary_inverter_l_send_def_end_2_Speed_Ramp_0 = 9,
	primary_inverter_l_send_def_end_2__Start_Dest_Var_1 = 10,
	primary_inverter_l_send_def_end_2__Start_Dest_Var_2 = 11,
	primary_inverter_l_send_def_end_2_N_cmd_Reverse = 12,
	primary_inverter_l_send_def_end_2__Preset_Pos_Var_3 = 13,
	primary_inverter_l_send_def_end_2__Capture_Var_3_Pos = 14,
	primary_inverter_l_send_def_end_2__Capture_Var_4_Pos = 15,
	primary_inverter_l_send_def_end_2__Switch_Spd_Ain1_Ain2 = 16,
	primary_inverter_l_send_def_end_2__Switch_Spd_Var1_Var2 = 17,
	primary_inverter_l_send_def_end_2_I_limit_dig_ = 18,
	primary_inverter_l_send_def_end_2_N_clip_neg_pos_ = 19,
	primary_inverter_l_send_def_end_2__Switch_Cmd_Dig_Ana = 20,
	primary_inverter_l_send_def_end_2_Speed_Ramp_0_Pos = 21,
	primary_inverter_l_send_def_end_2_Handwheel = 22,
	primary_inverter_l_send_def_end_2_Brake_Car = 23,
	primary_inverter_l_send_def_end_2_Recup_Disabled = 24,
	primary_inverter_l_send_def_end_2_Rising_Bank_1,_Falling_Bank_0 = 25,
	primary_inverter_l_send_def_end_2__Start_Dest_Var_1,_2,_3,_4 = 26,
	primary_inverter_l_send_def_end_2__Start_CW_Var_1,_2,_3,_4 = 27,
	primary_inverter_l_send_def_end_2_Brake_Car_Nr2 = 28,
} primary_inverter_l_send_def_end_2;

typedef enum {
	primary_inverter_l_send_def_din_1__Off_ = 0,
	primary_inverter_l_send_def_din_1_Ref_and_Limit_Plus = 1,
	primary_inverter_l_send_def_din_1_Ref_and_Limit_Minus = 2,
	primary_inverter_l_send_def_din_1_Ref_Plus = 3,
	primary_inverter_l_send_def_din_1_Limit_Plus = 4,
	primary_inverter_l_send_def_din_1_Limit_Minus = 5,
	primary_inverter_l_send_def_din_1_Limit_Plus_and_Minus = 6,
	primary_inverter_l_send_def_din_1_Cancel_Error_s_ = 7,
	primary_inverter_l_send_def_din_1__Start_Ref_Drive = 8,
	primary_inverter_l_send_def_din_1_Speed_Ramp_0 = 9,
	primary_inverter_l_send_def_din_1__Start_Dest_Var_1 = 10,
	primary_inverter_l_send_def_din_1__Start_Dest_Var_2 = 11,
	primary_inverter_l_send_def_din_1_N_cmd_Reverse = 12,
	primary_inverter_l_send_def_din_1__Preset_Pos_Var_3 = 13,
	primary_inverter_l_send_def_din_1__Capture_Var_3_Pos = 14,
	primary_inverter_l_send_def_din_1__Capture_Var_4_Pos = 15,
	primary_inverter_l_send_def_din_1__Switch_Spd_Ain1_Ain2 = 16,
	primary_inverter_l_send_def_din_1__Switch_Spd_Var1_Var2 = 17,
	primary_inverter_l_send_def_din_1_I_limit_dig_ = 18,
	primary_inverter_l_send_def_din_1_N_clip_neg_pos_ = 19,
	primary_inverter_l_send_def_din_1__Switch_Cmd_Dig_Ana = 20,
	primary_inverter_l_send_def_din_1_Speed_Ramp_0_Pos = 21,
	primary_inverter_l_send_def_din_1_Handwheel = 22,
	primary_inverter_l_send_def_din_1_Brake_Car = 23,
	primary_inverter_l_send_def_din_1_Recup_Disabled = 24,
	primary_inverter_l_send_def_din_1_Rising_Bank_1,_Falling_Bank_0 = 25,
	primary_inverter_l_send_def_din_1__Start_Dest_Var_1,_2,_3,_4 = 26,
	primary_inverter_l_send_def_din_1__Start_CW_Var_1,_2,_3,_4 = 27,
	primary_inverter_l_send_def_din_1_Brake_Car_Nr2 = 28,
} primary_inverter_l_send_def_din_1;

typedef enum {
	primary_inverter_l_send_def_din_2__Off_ = 0,
	primary_inverter_l_send_def_din_2_Ref_and_Limit_Plus = 1,
	primary_inverter_l_send_def_din_2_Ref_and_Limit_Minus = 2,
	primary_inverter_l_send_def_din_2_Ref_Plus = 3,
	primary_inverter_l_send_def_din_2_Limit_Plus = 4,
	primary_inverter_l_send_def_din_2_Limit_Minus = 5,
	primary_inverter_l_send_def_din_2_Limit_Plus_and_Minus = 6,
	primary_inverter_l_send_def_din_2_Cancel_Error_s_ = 7,
	primary_inverter_l_send_def_din_2__Start_Ref_Drive = 8,
	primary_inverter_l_send_def_din_2_Speed_Ramp_0 = 9,
	primary_inverter_l_send_def_din_2__Start_Dest_Var_1 = 10,
	primary_inverter_l_send_def_din_2__Start_Dest_Var_2 = 11,
	primary_inverter_l_send_def_din_2_N_cmd_Reverse = 12,
	primary_inverter_l_send_def_din_2__Preset_Pos_Var_3 = 13,
	primary_inverter_l_send_def_din_2__Capture_Var_3_Pos = 14,
	primary_inverter_l_send_def_din_2__Capture_Var_4_Pos = 15,
	primary_inverter_l_send_def_din_2__Switch_Spd_Ain1_Ain2 = 16,
	primary_inverter_l_send_def_din_2__Switch_Spd_Var1_Var2 = 17,
	primary_inverter_l_send_def_din_2_I_limit_dig_ = 18,
	primary_inverter_l_send_def_din_2_N_clip_neg_pos_ = 19,
	primary_inverter_l_send_def_din_2__Switch_Cmd_Dig_Ana = 20,
	primary_inverter_l_send_def_din_2_Speed_Ramp_0_Pos = 21,
	primary_inverter_l_send_def_din_2_Handwheel = 22,
	primary_inverter_l_send_def_din_2_Brake_Car = 23,
	primary_inverter_l_send_def_din_2_Recup_Disabled = 24,
	primary_inverter_l_send_def_din_2_Rising_Bank_1,_Falling_Bank_0 = 25,
	primary_inverter_l_send_def_din_2__Start_Dest_Var_1,_2,_3,_4 = 26,
	primary_inverter_l_send_def_din_2__Start_CW_Var_1,_2,_3,_4 = 27,
	primary_inverter_l_send_def_din_2_Brake_Car_Nr2 = 28,
} primary_inverter_l_send_def_din_2;

typedef enum {
	primary_inverter_l_send_operand194_Off = 0,
	primary_inverter_l_send_operand194_On = 1,
	primary_inverter_l_send_operand194_1_Hz = 2,
	primary_inverter_l_send_operand194__ = 3,
	primary_inverter_l_send_operand194__ = 4,
	primary_inverter_l_send_operand194__>_ = 5,
	primary_inverter_l_send_operand194__<_ = 6,
	primary_inverter_l_send_operand194__abs_>_ = 7,
	primary_inverter_l_send_operand194__abs_<_ = 8,
	primary_inverter_l_send_operand194__tol_>_ = 9,
	primary_inverter_l_send_operand194__tol_<_ = 10,
	primary_inverter_l_send_operand194__>_ = 11,
	primary_inverter_l_send_operand194__<_ = 12,
	primary_inverter_l_send_operand194__hyst_>_ = 13,
	primary_inverter_l_send_operand194__hyst_<_ = 14,
	primary_inverter_l_send_operand194__window_ = 15,
} primary_inverter_l_send_operand194;

typedef enum {
	primary_inverter_l_send_operand195_Off = 0,
	primary_inverter_l_send_operand195_On = 1,
	primary_inverter_l_send_operand195_1_Hz = 2,
	primary_inverter_l_send_operand195__ = 3,
	primary_inverter_l_send_operand195__ = 4,
	primary_inverter_l_send_operand195__>_ = 5,
	primary_inverter_l_send_operand195__<_ = 6,
	primary_inverter_l_send_operand195__abs_>_ = 7,
	primary_inverter_l_send_operand195__abs_<_ = 8,
	primary_inverter_l_send_operand195__tol_>_ = 9,
	primary_inverter_l_send_operand195__tol_<_ = 10,
	primary_inverter_l_send_operand195__>_ = 11,
	primary_inverter_l_send_operand195__<_ = 12,
	primary_inverter_l_send_operand195__hyst_>_ = 13,
	primary_inverter_l_send_operand195__hyst_<_ = 14,
	primary_inverter_l_send_operand195__window_ = 15,
} primary_inverter_l_send_operand195;

typedef enum {
	primary_inverter_l_send_operand218_Off = 0,
	primary_inverter_l_send_operand218_On = 1,
	primary_inverter_l_send_operand218_1_Hz = 2,
	primary_inverter_l_send_operand218__ = 3,
	primary_inverter_l_send_operand218__ = 4,
	primary_inverter_l_send_operand218__>_ = 5,
	primary_inverter_l_send_operand218__<_ = 6,
	primary_inverter_l_send_operand218__abs_>_ = 7,
	primary_inverter_l_send_operand218__abs_<_ = 8,
	primary_inverter_l_send_operand218__tol_>_ = 9,
	primary_inverter_l_send_operand218__tol_<_ = 10,
	primary_inverter_l_send_operand218__>_ = 11,
	primary_inverter_l_send_operand218__<_ = 12,
	primary_inverter_l_send_operand218__hyst_>_ = 13,
	primary_inverter_l_send_operand218__hyst_<_ = 14,
	primary_inverter_l_send_operand218__window_ = 15,
} primary_inverter_l_send_operand218;

typedef enum {
	primary_inverter_l_send_operand219_Off = 0,
	primary_inverter_l_send_operand219_On = 1,
	primary_inverter_l_send_operand219_1_Hz = 2,
	primary_inverter_l_send_operand219__ = 3,
	primary_inverter_l_send_operand219__ = 4,
	primary_inverter_l_send_operand219__>_ = 5,
	primary_inverter_l_send_operand219__<_ = 6,
	primary_inverter_l_send_operand219__abs_>_ = 7,
	primary_inverter_l_send_operand219__abs_<_ = 8,
	primary_inverter_l_send_operand219__tol_>_ = 9,
	primary_inverter_l_send_operand219__tol_<_ = 10,
	primary_inverter_l_send_operand219__>_ = 11,
	primary_inverter_l_send_operand219__<_ = 12,
	primary_inverter_l_send_operand219__hyst_>_ = 13,
	primary_inverter_l_send_operand219__hyst_<_ = 14,
	primary_inverter_l_send_operand219__window_ = 15,
} primary_inverter_l_send_operand219;

typedef enum {
	primary_inverter_l_send_cs_ain_2_format_Off = 0,
	primary_inverter_l_send_cs_ain_2_format__Cmd = 1,
	primary_inverter_l_send_cs_ain_2_format__Cmd = 2,
	primary_inverter_l_send_cs_ain_2_format__Cmd = 3,
} primary_inverter_l_send_cs_ain_2_format;

typedef enum {
	primary_inverter_l_send_cs_ain_1_mode__10_10V_ = 0,
	primary_inverter_l_send_cs_ain_1_mode__0_10V_ = 1,
	primary_inverter_l_send_cs_ain_1_mode__4_20mA_ = 2,
	primary_inverter_l_send_cs_ain_1_mode__1_9V_ = 3,
} primary_inverter_l_send_cs_ain_1_mode;

typedef enum {
	primary_inverter_l_send_compare_var194__0_ = 0,
	primary_inverter_l_send_compare_var194__1_ = 1,
	primary_inverter_l_send_compare_var194__Var_1_ = 2,
	primary_inverter_l_send_compare_var194__Var_2_ = 3,
	primary_inverter_l_send_compare_var194__Var_3_ = 4,
	primary_inverter_l_send_compare_var194__Var_4_ = 5,
	primary_inverter_l_send_compare_var194__Ain_1_ = 6,
	primary_inverter_l_send_compare_var194__Ain_2_ = 7,
} primary_inverter_l_send_compare_var194;

typedef enum {
	primary_inverter_l_send_compare_var195__0_ = 0,
	primary_inverter_l_send_compare_var195__1_ = 1,
	primary_inverter_l_send_compare_var195__Var_1_ = 2,
	primary_inverter_l_send_compare_var195__Var_2_ = 3,
	primary_inverter_l_send_compare_var195__Var_3_ = 4,
	primary_inverter_l_send_compare_var195__Var_4_ = 5,
	primary_inverter_l_send_compare_var195__Ain_1_ = 6,
	primary_inverter_l_send_compare_var195__Ain_2_ = 7,
} primary_inverter_l_send_compare_var195;

typedef enum {
	primary_inverter_l_send_compare_var218__0_ = 0,
	primary_inverter_l_send_compare_var218__1_ = 1,
	primary_inverter_l_send_compare_var218__Var_1_ = 2,
	primary_inverter_l_send_compare_var218__Var_2_ = 3,
	primary_inverter_l_send_compare_var218__Var_3_ = 4,
	primary_inverter_l_send_compare_var218__Var_4_ = 5,
	primary_inverter_l_send_compare_var218__Ain_1_ = 6,
	primary_inverter_l_send_compare_var218__Ain_2_ = 7,
} primary_inverter_l_send_compare_var218;

typedef enum {
	primary_inverter_l_send_compare_var219__0_ = 0,
	primary_inverter_l_send_compare_var219__1_ = 1,
	primary_inverter_l_send_compare_var219__Var_1_ = 2,
	primary_inverter_l_send_compare_var219__Var_2_ = 3,
	primary_inverter_l_send_compare_var219__Var_3_ = 4,
	primary_inverter_l_send_compare_var219__Var_4_ = 5,
	primary_inverter_l_send_compare_var219__Ain_1_ = 6,
	primary_inverter_l_send_compare_var219__Ain_2_ = 7,
} primary_inverter_l_send_compare_var219;

typedef enum {
	primary_inverter_l_send_mo_feedback_2__ = 0,
	primary_inverter_l_send_mo_feedback_2_Enc_Position = 1,
	primary_inverter_l_send_mo_feedback_2_Enc_Info = 2,
	primary_inverter_l_send_mo_feedback_2_Enc_Hand_ = 3,
	primary_inverter_l_send_mo_feedback_2_SSI = 4,
} primary_inverter_l_send_mo_feedback_2;

typedef enum {
	primary_inverter_l_send_cs_ain_2_mode__10_10V_ = 0,
	primary_inverter_l_send_cs_ain_2_mode__0_10V_ = 1,
	primary_inverter_l_send_cs_ain_2_mode__4_20mA_ = 2,
	primary_inverter_l_send_cs_ain_2_mode__1_9V_ = 3,
} primary_inverter_l_send_cs_ain_2_mode;

typedef enum {
	primary_inverter_l_send_ret_interval_Stop = 255,
	primary_inverter_l_send_ret_interval_Single = 0,
} primary_inverter_l_send_ret_interval;

typedef enum {
	primary_inverter_l_send_mo_sc1_reso_14_bit = 1,
	primary_inverter_l_send_mo_sc1_reso_12_bit = 2,
	primary_inverter_l_send_mo_sc1_reso_10_bit = 3,
} primary_inverter_l_send_mo_sc1_reso;

typedef enum {
	primary_inverter_l_send_source_id194_5Dh_N_cmd_int_ = 93,
	primary_inverter_l_send_source_id194_32h_N_cmd_ramp_ = 50,
	primary_inverter_l_send_source_id194_30h_N_Actual = 48,
	primary_inverter_l_send_source_id194_A8h_N_Actual_Filt = 168,
	primary_inverter_l_send_source_id194_33h_N_Error = 51,
	primary_inverter_l_send_source_id194_26h_I_cmd = 38,
	primary_inverter_l_send_source_id194_22h_I_cmd_ramp_ = 34,
	primary_inverter_l_send_source_id194_20h_I_Actual = 32,
	primary_inverter_l_send_source_id194_5Fh_I_Actual_Filt = 95,
	primary_inverter_l_send_source_id194_6Eh_Pos_Destination = 110,
	primary_inverter_l_send_source_id194_91h_Pos_cmd = 145,
	primary_inverter_l_send_source_id194_6Dh_Pos_Actual = 109,
	primary_inverter_l_send_source_id194_70h_Pos_Error = 112,
	primary_inverter_l_send_source_id194_74h_Pos_ZeroCapture = 116,
	primary_inverter_l_send_source_id194_E4h_DigInput_END_1 = 228,
	primary_inverter_l_send_source_id194_E5h_DigInput_END_2 = 229,
	primary_inverter_l_send_source_id194_E6h_DigInput_DIN_1 = 230,
	primary_inverter_l_send_source_id194_E7h_DigInput_DIN_2 = 231,
	primary_inverter_l_send_source_id194_E8h_DigInput_RUN = 232,
	primary_inverter_l_send_source_id194_E0h_DigOutput_DOUT_1 = 224,
	primary_inverter_l_send_source_id194_E1h_DigOutput_DOUT_2 = 225,
	primary_inverter_l_send_source_id194_DEh_DigOutput_DOUT_3 = 222,
	primary_inverter_l_send_source_id194_DFh_DigOutput_DOUT_4 = 223,
	primary_inverter_l_send_source_id194_E2h_DigOutput_Rdy_BTB = 226,
	primary_inverter_l_send_source_id194_E9h_Error_I_Fault = 233,
	primary_inverter_l_send_source_id194_EAh_I_Ballast_Act = 234,
	primary_inverter_l_send_source_id194_24h_I_Max_Inuse = 36,
	primary_inverter_l_send_source_id194_ECh_FB_LossOfSignal = 236,
	primary_inverter_l_send_source_id194__Off_ = 0,
	primary_inverter_l_send_source_id194_E3h_DigSignal_GO = 227,
	primary_inverter_l_send_source_id194_F2h_DigSignal_Brake = 242,
	primary_inverter_l_send_source_id194_F3h_DigSignal_Icns = 243,
	primary_inverter_l_send_source_id194_F5h_DigSignal_LessN0 = 245,
	primary_inverter_l_send_source_id194_F4h_DigSignal_PosToler_Set = 244,
	primary_inverter_l_send_source_id194_5Ch_Rotor_Signals = 92,
	primary_inverter_l_send_source_id194_D1h_Var_1 = 209,
	primary_inverter_l_send_source_id194_D2h_Var_2 = 210,
	primary_inverter_l_send_source_id194_D3h_Var_3 = 211,
	primary_inverter_l_send_source_id194_D4h_Var_4 = 212,
	primary_inverter_l_send_source_id194_D5h_Ain_In_1 = 213,
	primary_inverter_l_send_source_id194_D6h_Ain_In_2 = 214,
	primary_inverter_l_send_source_id194_42h_MotorPos_Mech = 66,
	primary_inverter_l_send_source_id194_43h_MotorPos_Elec = 67,
	primary_inverter_l_send_source_id194_A9h_I3_Adc_Value = 169,
	primary_inverter_l_send_source_id194_AAh_I2_Adc_Value = 170,
	primary_inverter_l_send_source_id194_54h_I1_Actual = 84,
	primary_inverter_l_send_source_id194_55h_I2_Actual = 85,
	primary_inverter_l_send_source_id194_56h_I3_Actual = 86,
	primary_inverter_l_send_source_id194_27h_Iq_Actual = 39,
	primary_inverter_l_send_source_id194_28h_Id_Actual = 40,
	primary_inverter_l_send_source_id194_38h_Iq_Error = 56,
	primary_inverter_l_send_source_id194_39h_Id_Error = 57,
	primary_inverter_l_send_source_id194_23h_Id_Ref = 35,
	primary_inverter_l_send_source_id194_B5h_Id_Min = 181,
	primary_inverter_l_send_source_id194_61h_Ixt_Monitor = 97,
	primary_inverter_l_send_source_id194_48h_I_Limit_Inuse = 72,
	primary_inverter_l_send_source_id194_57h_I_Limit_Inuse_ramp_ = 87,
	primary_inverter_l_send_source_id194_FBh_Ain_1_Calc = 251,
	primary_inverter_l_send_source_id194_FCh_Ain_2_Calc = 252,
	primary_inverter_l_send_source_id194_29h_Vq_Output = 41,
	primary_inverter_l_send_source_id194_2Ah_Vd_Output = 42,
	primary_inverter_l_send_source_id194_8Ah_V_Output = 138,
	primary_inverter_l_send_source_id194_8Bh_V_Red_Ref_ = 139,
	primary_inverter_l_send_source_id194_8Ch_V_Control_Kp = 140,
	primary_inverter_l_send_source_id194_8Dh_V_Control_Ti = 141,
	primary_inverter_l_send_source_id194_ACh_PWM_1_5_6_ = 172,
	primary_inverter_l_send_source_id194_ADh_PWM_2_3_4_ = 173,
	primary_inverter_l_send_source_id194_AEh_PWM_3_1_2_ = 174,
	primary_inverter_l_send_source_id194_49h_T_Motor = 73,
	primary_inverter_l_send_source_id194_4Ah_T_Igbt = 74,
	primary_inverter_l_send_source_id194_4Bh_T_Air_Inside = 75,
	primary_inverter_l_send_source_id194_45h_It_Rg_Monitor = 69,
	primary_inverter_l_send_source_id194_9Ah_Temp_DEBUG = 154,
	primary_inverter_l_send_source_id194_ABh_Logic_Freq = 171,
	primary_inverter_l_send_source_id194_B8h_Ptr_1_DEBUG = 184,
	primary_inverter_l_send_source_id194_BAh_Ptr_2_DEBUG = 186,
	primary_inverter_l_send_source_id194_8Fh_ErrorWarning_Map = 143,
	primary_inverter_l_send_source_id194_40h_Status_Map = 64,
	primary_inverter_l_send_source_id194_41h_Incr_Delta = 65,
	primary_inverter_l_send_source_id194_34h_N_Lim = 52,
	primary_inverter_l_send_source_id194_63h_FPGA_Status = 99,
	primary_inverter_l_send_source_id194_31h_N_set_dig_ = 49,
	primary_inverter_l_send_source_id194_90h_M_set_dig_ = 144,
	primary_inverter_l_send_source_id194_A0h_M_out_dig_ = 160,
	primary_inverter_l_send_source_id194_6Fh_Pos_Actual_2 = 111,
	primary_inverter_l_send_source_id194_98h_Logic_O_Block = 152,
	primary_inverter_l_send_source_id194_9Bh_Logic_I_Block = 155,
	primary_inverter_l_send_source_id194_02h_SC_Info = 2,
	primary_inverter_l_send_source_id194_EBh_Vdc_Bus = 235,
	primary_inverter_l_send_source_id194_66h_Vdc_Bus_Filt = 102,
	primary_inverter_l_send_source_id194_99h_Info_Timer_Diff = 153,
	primary_inverter_l_send_source_id194_A1h_Ballast_cntr = 161,
	primary_inverter_l_send_source_id194_51_Kern_Mode_State = 81,
	primary_inverter_l_send_source_id194_11h_Control_Status = 17,
} primary_inverter_l_send_source_id194;

typedef enum {
	primary_inverter_l_send_source_id195_5Dh_N_cmd_int_ = 93,
	primary_inverter_l_send_source_id195_32h_N_cmd_ramp_ = 50,
	primary_inverter_l_send_source_id195_30h_N_Actual = 48,
	primary_inverter_l_send_source_id195_A8h_N_Actual_Filt = 168,
	primary_inverter_l_send_source_id195_33h_N_Error = 51,
	primary_inverter_l_send_source_id195_26h_I_cmd = 38,
	primary_inverter_l_send_source_id195_22h_I_cmd_ramp_ = 34,
	primary_inverter_l_send_source_id195_20h_I_Actual = 32,
	primary_inverter_l_send_source_id195_5Fh_I_Actual_Filt = 95,
	primary_inverter_l_send_source_id195_6Eh_Pos_Destination = 110,
	primary_inverter_l_send_source_id195_91h_Pos_cmd = 145,
	primary_inverter_l_send_source_id195_6Dh_Pos_Actual = 109,
	primary_inverter_l_send_source_id195_70h_Pos_Error = 112,
	primary_inverter_l_send_source_id195_74h_Pos_ZeroCapture = 116,
	primary_inverter_l_send_source_id195_E4h_DigInput_END_1 = 228,
	primary_inverter_l_send_source_id195_E5h_DigInput_END_2 = 229,
	primary_inverter_l_send_source_id195_E6h_DigInput_DIN_1 = 230,
	primary_inverter_l_send_source_id195_E7h_DigInput_DIN_2 = 231,
	primary_inverter_l_send_source_id195_E8h_DigInput_RUN = 232,
	primary_inverter_l_send_source_id195_E0h_DigOutput_DOUT_1 = 224,
	primary_inverter_l_send_source_id195_E1h_DigOutput_DOUT_2 = 225,
	primary_inverter_l_send_source_id195_DEh_DigOutput_DOUT_3 = 222,
	primary_inverter_l_send_source_id195_DFh_DigOutput_DOUT_4 = 223,
	primary_inverter_l_send_source_id195_E2h_DigOutput_Rdy_BTB = 226,
	primary_inverter_l_send_source_id195_E9h_Error_I_Fault = 233,
	primary_inverter_l_send_source_id195_EAh_I_Ballast_Act = 234,
	primary_inverter_l_send_source_id195_24h_I_Max_Inuse = 36,
	primary_inverter_l_send_source_id195_ECh_FB_LossOfSignal = 236,
	primary_inverter_l_send_source_id195__Off_ = 0,
	primary_inverter_l_send_source_id195_E3h_DigSignal_GO = 227,
	primary_inverter_l_send_source_id195_F2h_DigSignal_Brake = 242,
	primary_inverter_l_send_source_id195_F3h_DigSignal_Icns = 243,
	primary_inverter_l_send_source_id195_F5h_DigSignal_LessN0 = 245,
	primary_inverter_l_send_source_id195_F4h_DigSignal_PosToler_Set = 244,
	primary_inverter_l_send_source_id195_5Ch_Rotor_Signals = 92,
	primary_inverter_l_send_source_id195_D1h_Var_1 = 209,
	primary_inverter_l_send_source_id195_D2h_Var_2 = 210,
	primary_inverter_l_send_source_id195_D3h_Var_3 = 211,
	primary_inverter_l_send_source_id195_D4h_Var_4 = 212,
	primary_inverter_l_send_source_id195_D5h_Ain_In_1 = 213,
	primary_inverter_l_send_source_id195_D6h_Ain_In_2 = 214,
	primary_inverter_l_send_source_id195_42h_MotorPos_Mech = 66,
	primary_inverter_l_send_source_id195_43h_MotorPos_Elec = 67,
	primary_inverter_l_send_source_id195_A9h_I3_Adc_Value = 169,
	primary_inverter_l_send_source_id195_AAh_I2_Adc_Value = 170,
	primary_inverter_l_send_source_id195_54h_I1_Actual = 84,
	primary_inverter_l_send_source_id195_55h_I2_Actual = 85,
	primary_inverter_l_send_source_id195_56h_I3_Actual = 86,
	primary_inverter_l_send_source_id195_27h_Iq_Actual = 39,
	primary_inverter_l_send_source_id195_28h_Id_Actual = 40,
	primary_inverter_l_send_source_id195_38h_Iq_Error = 56,
	primary_inverter_l_send_source_id195_39h_Id_Error = 57,
	primary_inverter_l_send_source_id195_23h_Id_Ref = 35,
	primary_inverter_l_send_source_id195_B5h_Id_Min = 181,
	primary_inverter_l_send_source_id195_61h_Ixt_Monitor = 97,
	primary_inverter_l_send_source_id195_48h_I_Limit_Inuse = 72,
	primary_inverter_l_send_source_id195_57h_I_Limit_Inuse_ramp_ = 87,
	primary_inverter_l_send_source_id195_FBh_Ain_1_Calc = 251,
	primary_inverter_l_send_source_id195_FCh_Ain_2_Calc = 252,
	primary_inverter_l_send_source_id195_29h_Vq_Output = 41,
	primary_inverter_l_send_source_id195_2Ah_Vd_Output = 42,
	primary_inverter_l_send_source_id195_8Ah_V_Output = 138,
	primary_inverter_l_send_source_id195_8Bh_V_Red_Ref_ = 139,
	primary_inverter_l_send_source_id195_8Ch_V_Control_Kp = 140,
	primary_inverter_l_send_source_id195_8Dh_V_Control_Ti = 141,
	primary_inverter_l_send_source_id195_ACh_PWM_1_5_6_ = 172,
	primary_inverter_l_send_source_id195_ADh_PWM_2_3_4_ = 173,
	primary_inverter_l_send_source_id195_AEh_PWM_3_1_2_ = 174,
	primary_inverter_l_send_source_id195_49h_T_Motor = 73,
	primary_inverter_l_send_source_id195_4Ah_T_Igbt = 74,
	primary_inverter_l_send_source_id195_4Bh_T_Air_Inside = 75,
	primary_inverter_l_send_source_id195_45h_It_Rg_Monitor = 69,
	primary_inverter_l_send_source_id195_9Ah_Temp_DEBUG = 154,
	primary_inverter_l_send_source_id195_ABh_Logic_Freq = 171,
	primary_inverter_l_send_source_id195_B8h_Ptr_1_DEBUG = 184,
	primary_inverter_l_send_source_id195_BAh_Ptr_2_DEBUG = 186,
	primary_inverter_l_send_source_id195_8Fh_ErrorWarning_Map = 143,
	primary_inverter_l_send_source_id195_40h_Status_Map = 64,
	primary_inverter_l_send_source_id195_41h_Incr_Delta = 65,
	primary_inverter_l_send_source_id195_34h_N_Lim = 52,
	primary_inverter_l_send_source_id195_63h_FPGA_Status = 99,
	primary_inverter_l_send_source_id195_31h_N_set_dig_ = 49,
	primary_inverter_l_send_source_id195_90h_M_set_dig_ = 144,
	primary_inverter_l_send_source_id195_A0h_M_out_dig_ = 160,
	primary_inverter_l_send_source_id195_6Fh_Pos_Actual_2 = 111,
	primary_inverter_l_send_source_id195_98h_Logic_O_Block = 152,
	primary_inverter_l_send_source_id195_9Bh_Logic_I_Block = 155,
	primary_inverter_l_send_source_id195_02h_SC_Info = 2,
	primary_inverter_l_send_source_id195_EBh_Vdc_Bus = 235,
	primary_inverter_l_send_source_id195_66h_Vdc_Bus_Filt = 102,
	primary_inverter_l_send_source_id195_99h_Info_Timer_Diff = 153,
	primary_inverter_l_send_source_id195_A1h_Ballast_cntr = 161,
	primary_inverter_l_send_source_id195_51_Kern_Mode_State = 81,
	primary_inverter_l_send_source_id195_11h_Control_Status = 17,
} primary_inverter_l_send_source_id195;

typedef enum {
	primary_inverter_l_send_source_id218_5Dh_N_cmd_int_ = 93,
	primary_inverter_l_send_source_id218_32h_N_cmd_ramp_ = 50,
	primary_inverter_l_send_source_id218_30h_N_Actual = 48,
	primary_inverter_l_send_source_id218_A8h_N_Actual_Filt = 168,
	primary_inverter_l_send_source_id218_33h_N_Error = 51,
	primary_inverter_l_send_source_id218_26h_I_cmd = 38,
	primary_inverter_l_send_source_id218_22h_I_cmd_ramp_ = 34,
	primary_inverter_l_send_source_id218_20h_I_Actual = 32,
	primary_inverter_l_send_source_id218_5Fh_I_Actual_Filt = 95,
	primary_inverter_l_send_source_id218_6Eh_Pos_Destination = 110,
	primary_inverter_l_send_source_id218_91h_Pos_cmd = 145,
	primary_inverter_l_send_source_id218_6Dh_Pos_Actual = 109,
	primary_inverter_l_send_source_id218_70h_Pos_Error = 112,
	primary_inverter_l_send_source_id218_74h_Pos_ZeroCapture = 116,
	primary_inverter_l_send_source_id218_E4h_DigInput_END_1 = 228,
	primary_inverter_l_send_source_id218_E5h_DigInput_END_2 = 229,
	primary_inverter_l_send_source_id218_E6h_DigInput_DIN_1 = 230,
	primary_inverter_l_send_source_id218_E7h_DigInput_DIN_2 = 231,
	primary_inverter_l_send_source_id218_E8h_DigInput_RUN = 232,
	primary_inverter_l_send_source_id218_E0h_DigOutput_DOUT_1 = 224,
	primary_inverter_l_send_source_id218_E1h_DigOutput_DOUT_2 = 225,
	primary_inverter_l_send_source_id218_DEh_DigOutput_DOUT_3 = 222,
	primary_inverter_l_send_source_id218_DFh_DigOutput_DOUT_4 = 223,
	primary_inverter_l_send_source_id218_E2h_DigOutput_Rdy_BTB = 226,
	primary_inverter_l_send_source_id218_E9h_Error_I_Fault = 233,
	primary_inverter_l_send_source_id218_EAh_I_Ballast_Act = 234,
	primary_inverter_l_send_source_id218_24h_I_Max_Inuse = 36,
	primary_inverter_l_send_source_id218_ECh_FB_LossOfSignal = 236,
	primary_inverter_l_send_source_id218__Off_ = 0,
	primary_inverter_l_send_source_id218_E3h_DigSignal_GO = 227,
	primary_inverter_l_send_source_id218_F2h_DigSignal_Brake = 242,
	primary_inverter_l_send_source_id218_F3h_DigSignal_Icns = 243,
	primary_inverter_l_send_source_id218_F5h_DigSignal_LessN0 = 245,
	primary_inverter_l_send_source_id218_F4h_DigSignal_PosToler_Set = 244,
	primary_inverter_l_send_source_id218_5Ch_Rotor_Signals = 92,
	primary_inverter_l_send_source_id218_D1h_Var_1 = 209,
	primary_inverter_l_send_source_id218_D2h_Var_2 = 210,
	primary_inverter_l_send_source_id218_D3h_Var_3 = 211,
	primary_inverter_l_send_source_id218_D4h_Var_4 = 212,
	primary_inverter_l_send_source_id218_D5h_Ain_In_1 = 213,
	primary_inverter_l_send_source_id218_D6h_Ain_In_2 = 214,
	primary_inverter_l_send_source_id218_42h_MotorPos_Mech = 66,
	primary_inverter_l_send_source_id218_43h_MotorPos_Elec = 67,
	primary_inverter_l_send_source_id218_A9h_I3_Adc_Value = 169,
	primary_inverter_l_send_source_id218_AAh_I2_Adc_Value = 170,
	primary_inverter_l_send_source_id218_54h_I1_Actual = 84,
	primary_inverter_l_send_source_id218_55h_I2_Actual = 85,
	primary_inverter_l_send_source_id218_56h_I3_Actual = 86,
	primary_inverter_l_send_source_id218_27h_Iq_Actual = 39,
	primary_inverter_l_send_source_id218_28h_Id_Actual = 40,
	primary_inverter_l_send_source_id218_38h_Iq_Error = 56,
	primary_inverter_l_send_source_id218_39h_Id_Error = 57,
	primary_inverter_l_send_source_id218_23h_Id_Ref = 35,
	primary_inverter_l_send_source_id218_B5h_Id_Min = 181,
	primary_inverter_l_send_source_id218_61h_Ixt_Monitor = 97,
	primary_inverter_l_send_source_id218_48h_I_Limit_Inuse = 72,
	primary_inverter_l_send_source_id218_57h_I_Limit_Inuse_ramp_ = 87,
	primary_inverter_l_send_source_id218_FBh_Ain_1_Calc = 251,
	primary_inverter_l_send_source_id218_FCh_Ain_2_Calc = 252,
	primary_inverter_l_send_source_id218_29h_Vq_Output = 41,
	primary_inverter_l_send_source_id218_2Ah_Vd_Output = 42,
	primary_inverter_l_send_source_id218_8Ah_V_Output = 138,
	primary_inverter_l_send_source_id218_8Bh_V_Red_Ref_ = 139,
	primary_inverter_l_send_source_id218_8Ch_V_Control_Kp = 140,
	primary_inverter_l_send_source_id218_8Dh_V_Control_Ti = 141,
	primary_inverter_l_send_source_id218_ACh_PWM_1_5_6_ = 172,
	primary_inverter_l_send_source_id218_ADh_PWM_2_3_4_ = 173,
	primary_inverter_l_send_source_id218_AEh_PWM_3_1_2_ = 174,
	primary_inverter_l_send_source_id218_49h_T_Motor = 73,
	primary_inverter_l_send_source_id218_4Ah_T_Igbt = 74,
	primary_inverter_l_send_source_id218_4Bh_T_Air_Inside = 75,
	primary_inverter_l_send_source_id218_45h_It_Rg_Monitor = 69,
	primary_inverter_l_send_source_id218_9Ah_Temp_DEBUG = 154,
	primary_inverter_l_send_source_id218_ABh_Logic_Freq = 171,
	primary_inverter_l_send_source_id218_B8h_Ptr_1_DEBUG = 184,
	primary_inverter_l_send_source_id218_BAh_Ptr_2_DEBUG = 186,
	primary_inverter_l_send_source_id218_8Fh_ErrorWarning_Map = 143,
	primary_inverter_l_send_source_id218_40h_Status_Map = 64,
	primary_inverter_l_send_source_id218_41h_Incr_Delta = 65,
	primary_inverter_l_send_source_id218_34h_N_Lim = 52,
	primary_inverter_l_send_source_id218_63h_FPGA_Status = 99,
	primary_inverter_l_send_source_id218_31h_N_set_dig_ = 49,
	primary_inverter_l_send_source_id218_90h_M_set_dig_ = 144,
	primary_inverter_l_send_source_id218_A0h_M_out_dig_ = 160,
	primary_inverter_l_send_source_id218_6Fh_Pos_Actual_2 = 111,
	primary_inverter_l_send_source_id218_98h_Logic_O_Block = 152,
	primary_inverter_l_send_source_id218_9Bh_Logic_I_Block = 155,
	primary_inverter_l_send_source_id218_02h_SC_Info = 2,
	primary_inverter_l_send_source_id218_EBh_Vdc_Bus = 235,
	primary_inverter_l_send_source_id218_66h_Vdc_Bus_Filt = 102,
	primary_inverter_l_send_source_id218_99h_Info_Timer_Diff = 153,
	primary_inverter_l_send_source_id218_A1h_Ballast_cntr = 161,
	primary_inverter_l_send_source_id218_51_Kern_Mode_State = 81,
	primary_inverter_l_send_source_id218_11h_Control_Status = 17,
} primary_inverter_l_send_source_id218;

typedef enum {
	primary_inverter_l_send_source_id219_5Dh_N_cmd_int_ = 93,
	primary_inverter_l_send_source_id219_32h_N_cmd_ramp_ = 50,
	primary_inverter_l_send_source_id219_30h_N_Actual = 48,
	primary_inverter_l_send_source_id219_A8h_N_Actual_Filt = 168,
	primary_inverter_l_send_source_id219_33h_N_Error = 51,
	primary_inverter_l_send_source_id219_26h_I_cmd = 38,
	primary_inverter_l_send_source_id219_22h_I_cmd_ramp_ = 34,
	primary_inverter_l_send_source_id219_20h_I_Actual = 32,
	primary_inverter_l_send_source_id219_5Fh_I_Actual_Filt = 95,
	primary_inverter_l_send_source_id219_6Eh_Pos_Destination = 110,
	primary_inverter_l_send_source_id219_91h_Pos_cmd = 145,
	primary_inverter_l_send_source_id219_6Dh_Pos_Actual = 109,
	primary_inverter_l_send_source_id219_70h_Pos_Error = 112,
	primary_inverter_l_send_source_id219_74h_Pos_ZeroCapture = 116,
	primary_inverter_l_send_source_id219_E4h_DigInput_END_1 = 228,
	primary_inverter_l_send_source_id219_E5h_DigInput_END_2 = 229,
	primary_inverter_l_send_source_id219_E6h_DigInput_DIN_1 = 230,
	primary_inverter_l_send_source_id219_E7h_DigInput_DIN_2 = 231,
	primary_inverter_l_send_source_id219_E8h_DigInput_RUN = 232,
	primary_inverter_l_send_source_id219_E0h_DigOutput_DOUT_1 = 224,
	primary_inverter_l_send_source_id219_E1h_DigOutput_DOUT_2 = 225,
	primary_inverter_l_send_source_id219_DEh_DigOutput_DOUT_3 = 222,
	primary_inverter_l_send_source_id219_DFh_DigOutput_DOUT_4 = 223,
	primary_inverter_l_send_source_id219_E2h_DigOutput_Rdy_BTB = 226,
	primary_inverter_l_send_source_id219_E9h_Error_I_Fault = 233,
	primary_inverter_l_send_source_id219_EAh_I_Ballast_Act = 234,
	primary_inverter_l_send_source_id219_24h_I_Max_Inuse = 36,
	primary_inverter_l_send_source_id219_ECh_FB_LossOfSignal = 236,
	primary_inverter_l_send_source_id219__Off_ = 0,
	primary_inverter_l_send_source_id219_E3h_DigSignal_GO = 227,
	primary_inverter_l_send_source_id219_F2h_DigSignal_Brake = 242,
	primary_inverter_l_send_source_id219_F3h_DigSignal_Icns = 243,
	primary_inverter_l_send_source_id219_F5h_DigSignal_LessN0 = 245,
	primary_inverter_l_send_source_id219_F4h_DigSignal_PosToler_Set = 244,
	primary_inverter_l_send_source_id219_5Ch_Rotor_Signals = 92,
	primary_inverter_l_send_source_id219_D1h_Var_1 = 209,
	primary_inverter_l_send_source_id219_D2h_Var_2 = 210,
	primary_inverter_l_send_source_id219_D3h_Var_3 = 211,
	primary_inverter_l_send_source_id219_D4h_Var_4 = 212,
	primary_inverter_l_send_source_id219_D5h_Ain_In_1 = 213,
	primary_inverter_l_send_source_id219_D6h_Ain_In_2 = 214,
	primary_inverter_l_send_source_id219_42h_MotorPos_Mech = 66,
	primary_inverter_l_send_source_id219_43h_MotorPos_Elec = 67,
	primary_inverter_l_send_source_id219_A9h_I3_Adc_Value = 169,
	primary_inverter_l_send_source_id219_AAh_I2_Adc_Value = 170,
	primary_inverter_l_send_source_id219_54h_I1_Actual = 84,
	primary_inverter_l_send_source_id219_55h_I2_Actual = 85,
	primary_inverter_l_send_source_id219_56h_I3_Actual = 86,
	primary_inverter_l_send_source_id219_27h_Iq_Actual = 39,
	primary_inverter_l_send_source_id219_28h_Id_Actual = 40,
	primary_inverter_l_send_source_id219_38h_Iq_Error = 56,
	primary_inverter_l_send_source_id219_39h_Id_Error = 57,
	primary_inverter_l_send_source_id219_23h_Id_Ref = 35,
	primary_inverter_l_send_source_id219_B5h_Id_Min = 181,
	primary_inverter_l_send_source_id219_61h_Ixt_Monitor = 97,
	primary_inverter_l_send_source_id219_48h_I_Limit_Inuse = 72,
	primary_inverter_l_send_source_id219_57h_I_Limit_Inuse_ramp_ = 87,
	primary_inverter_l_send_source_id219_FBh_Ain_1_Calc = 251,
	primary_inverter_l_send_source_id219_FCh_Ain_2_Calc = 252,
	primary_inverter_l_send_source_id219_29h_Vq_Output = 41,
	primary_inverter_l_send_source_id219_2Ah_Vd_Output = 42,
	primary_inverter_l_send_source_id219_8Ah_V_Output = 138,
	primary_inverter_l_send_source_id219_8Bh_V_Red_Ref_ = 139,
	primary_inverter_l_send_source_id219_8Ch_V_Control_Kp = 140,
	primary_inverter_l_send_source_id219_8Dh_V_Control_Ti = 141,
	primary_inverter_l_send_source_id219_ACh_PWM_1_5_6_ = 172,
	primary_inverter_l_send_source_id219_ADh_PWM_2_3_4_ = 173,
	primary_inverter_l_send_source_id219_AEh_PWM_3_1_2_ = 174,
	primary_inverter_l_send_source_id219_49h_T_Motor = 73,
	primary_inverter_l_send_source_id219_4Ah_T_Igbt = 74,
	primary_inverter_l_send_source_id219_4Bh_T_Air_Inside = 75,
	primary_inverter_l_send_source_id219_45h_It_Rg_Monitor = 69,
	primary_inverter_l_send_source_id219_9Ah_Temp_DEBUG = 154,
	primary_inverter_l_send_source_id219_ABh_Logic_Freq = 171,
	primary_inverter_l_send_source_id219_B8h_Ptr_1_DEBUG = 184,
	primary_inverter_l_send_source_id219_BAh_Ptr_2_DEBUG = 186,
	primary_inverter_l_send_source_id219_8Fh_ErrorWarning_Map = 143,
	primary_inverter_l_send_source_id219_40h_Status_Map = 64,
	primary_inverter_l_send_source_id219_41h_Incr_Delta = 65,
	primary_inverter_l_send_source_id219_34h_N_Lim = 52,
	primary_inverter_l_send_source_id219_63h_FPGA_Status = 99,
	primary_inverter_l_send_source_id219_31h_N_set_dig_ = 49,
	primary_inverter_l_send_source_id219_90h_M_set_dig_ = 144,
	primary_inverter_l_send_source_id219_A0h_M_out_dig_ = 160,
	primary_inverter_l_send_source_id219_6Fh_Pos_Actual_2 = 111,
	primary_inverter_l_send_source_id219_98h_Logic_O_Block = 152,
	primary_inverter_l_send_source_id219_9Bh_Logic_I_Block = 155,
	primary_inverter_l_send_source_id219_02h_SC_Info = 2,
	primary_inverter_l_send_source_id219_EBh_Vdc_Bus = 235,
	primary_inverter_l_send_source_id219_66h_Vdc_Bus_Filt = 102,
	primary_inverter_l_send_source_id219_99h_Info_Timer_Diff = 153,
	primary_inverter_l_send_source_id219_A1h_Ballast_cntr = 161,
	primary_inverter_l_send_source_id219_51_Kern_Mode_State = 81,
	primary_inverter_l_send_source_id219_11h_Control_Status = 17,
} primary_inverter_l_send_source_id219;

typedef enum {
	primary_inverter_l_send_cs_cmd_type_Digital_Commands = 0,
	primary_inverter_l_send_cs_cmd_type_Dig_Ana_Speed = 1,
	primary_inverter_l_send_cs_cmd_type_Analog_Speed = 2,
	primary_inverter_l_send_cs_cmd_type_Analog_Torque = 3,
} primary_inverter_l_send_cs_cmd_type;

typedef enum {
	primary_inverter_l_send_motortype_EC_Servo = 0,
	primary_inverter_l_send_motortype_ACI_V_f = 1,
	primary_inverter_l_send_motortype_ACI_Servo = 2,
	primary_inverter_l_send_motortype_DC = 3,
} primary_inverter_l_send_motortype;

typedef enum {
	primary_inverter_l_send_mo_sc2_reso_14_bit = 1,
	primary_inverter_l_send_mo_sc2_reso_12_bit = 2,
	primary_inverter_l_send_mo_sc2_reso_10_bit = 3,
} primary_inverter_l_send_mo_sc2_reso;

typedef enum {
	primary_inverter_l_send_active190_Low = 0,
	primary_inverter_l_send_active190_High = 1,
} primary_inverter_l_send_active190;

typedef enum {
	primary_inverter_l_send_active191_Low = 0,
	primary_inverter_l_send_active191_High = 1,
} primary_inverter_l_send_active191;

typedef enum {
	primary_inverter_l_send_active192_Low = 0,
	primary_inverter_l_send_active192_High = 1,
} primary_inverter_l_send_active192;

typedef enum {
	primary_inverter_l_send_active193_Low = 0,
	primary_inverter_l_send_active193_High = 1,
} primary_inverter_l_send_active193;

typedef enum {
	primary_inverter_l_send_pwm_freq_8_kHz = 0,
	primary_inverter_l_send_pwm_freq_24_kHz = 1,
	primary_inverter_l_send_pwm_freq_20_kHz = 2,
	primary_inverter_l_send_pwm_freq_16_kHz = 3,
	primary_inverter_l_send_pwm_freq_12_kHz = 4,
	primary_inverter_l_send_pwm_freq_8_kHz_i16 = 5,
	primary_inverter_l_send_pwm_freq_6_kHz_i12 = 6,
	primary_inverter_l_send_pwm_freq_4_kHz_i12 = 7,
} primary_inverter_l_send_pwm_freq;

typedef enum {
	primary_inverter_l_rcv_rcv_mux_ID_30_N_Actual = 48,
	primary_inverter_l_rcv_rcv_mux_ID_35_Acc_Ramps = 53,
	primary_inverter_l_rcv_rcv_mux_ID_ED_Dec_Ramps = 237,
	primary_inverter_l_rcv_rcv_mux_ID_C7_RLim_MRcp_Ramp = 199,
	primary_inverter_l_rcv_rcv_mux_ID_A8_N_Actual_Filt = 168,
	primary_inverter_l_rcv_rcv_mux_ID_1B_FW_Nr = 27,
	primary_inverter_l_rcv_rcv_mux_ID_67_Device_Type = 103,
	primary_inverter_l_rcv_rcv_mux_ID_62_SerialNumber = 98,
	primary_inverter_l_rcv_rcv_mux_ID_F8_Axis_Label = 248,
	primary_inverter_l_rcv_rcv_mux_ID_C6_I_device = 198,
	primary_inverter_l_rcv_rcv_mux_ID_EE_V_Shunt = 238,
	primary_inverter_l_rcv_rcv_mux_ID_D9_I_200perc = 217,
	primary_inverter_l_rcv_rcv_mux_ID_5A_Device_Options = 90,
	primary_inverter_l_rcv_rcv_mux_ID_40_Status_Map = 64,
	primary_inverter_l_rcv_rcv_mux_ID_8F_ErrorWarning_Map = 143,
	primary_inverter_l_rcv_rcv_mux_ID_D8_LogicReadBitsIN_OUT = 216,
	primary_inverter_l_rcv_rcv_mux_ID_D5_Ain_in_1 = 213,
	primary_inverter_l_rcv_rcv_mux_ID_D6_Ain_in_2 = 214,
	primary_inverter_l_rcv_rcv_mux_ID_C8_Nmax100perc = 200,
	primary_inverter_l_rcv_rcv_mux_ID_31_N_setdig = 49,
	primary_inverter_l_rcv_rcv_mux_ID_5D_N_cmd = 93,
	primary_inverter_l_rcv_rcv_mux_ID_32_N_cmd_ramp = 50,
	primary_inverter_l_rcv_rcv_mux_ID_34_N_Lim = 52,
	primary_inverter_l_rcv_rcv_mux_ID_33_N_Error = 51,
	primary_inverter_l_rcv_rcv_mux_ID_90_M_setdig = 144,
	primary_inverter_l_rcv_rcv_mux_ID_21_Id_setdig = 33,
	primary_inverter_l_rcv_rcv_mux_ID_C4_I_max_pk_perc = 196,
	primary_inverter_l_rcv_rcv_mux_ID_C5_I_con_eff_perc = 197,
	primary_inverter_l_rcv_rcv_mux_ID_4D_Motor_I_max_eff_Arms = 77,
	primary_inverter_l_rcv_rcv_mux_ID_4E_Motor_I_nom_eff_Arms = 78,
	primary_inverter_l_rcv_rcv_mux_ID_48_I_Limit_Inuse = 72,
	primary_inverter_l_rcv_rcv_mux_ID_26_I_cmd = 38,
	primary_inverter_l_rcv_rcv_mux_ID_22_I_cmd_ramp = 34,
	primary_inverter_l_rcv_rcv_mux_ID_20_I_Actual = 32,
	primary_inverter_l_rcv_rcv_mux_ID_5F_I_Actual_Filt = 95,
	primary_inverter_l_rcv_rcv_mux_ID_27_Iq_Actual = 39,
	primary_inverter_l_rcv_rcv_mux_ID_28_Id_Actual = 40,
	primary_inverter_l_rcv_rcv_mux_ID_38_Iq_Error = 56,
	primary_inverter_l_rcv_rcv_mux_ID_39_Id_Error = 57,
	primary_inverter_l_rcv_rcv_mux_ID_54_I1_Actual = 84,
	primary_inverter_l_rcv_rcv_mux_ID_55_I2_Actual = 85,
	primary_inverter_l_rcv_rcv_mux_ID_56_I3_Actual = 86,
	primary_inverter_l_rcv_rcv_mux_ID_A9_I3_ADC_Value = 169,
	primary_inverter_l_rcv_rcv_mux_ID_AA_I2_ADC_Value = 170,
	primary_inverter_l_rcv_rcv_mux_ID_29_Vq_Output = 41,
	primary_inverter_l_rcv_rcv_mux_ID_2A_Vd_Output = 42,
	primary_inverter_l_rcv_rcv_mux_ID_8A_V_Output = 138,
	primary_inverter_l_rcv_rcv_mux_ID_49_T_Motor = 73,
	primary_inverter_l_rcv_rcv_mux_ID_4A_T_Igbt = 74,
	primary_inverter_l_rcv_rcv_mux_ID_4B_T_Air_Inside = 75,
	primary_inverter_l_rcv_rcv_mux_ID_EB_DC_Bus_Voltage_Filt = 235,
	primary_inverter_l_rcv_rcv_mux_ID_E4_DigInput_END_1 = 228,
	primary_inverter_l_rcv_rcv_mux_ID_E6_DigInput_DIN_1 = 230,
	primary_inverter_l_rcv_rcv_mux_ID_E5_DigInput_END_2 = 229,
	primary_inverter_l_rcv_rcv_mux_ID_E7_DigInput_DIN_2 = 231,
	primary_inverter_l_rcv_rcv_mux_ID_E8_DigInput_RUN = 232,
	primary_inverter_l_rcv_rcv_mux_ID_E0_DigOutput_DOUT_1 = 224,
	primary_inverter_l_rcv_rcv_mux_ID_E1_DigOutput_DOUT_2 = 225,
	primary_inverter_l_rcv_rcv_mux_ID_DE_DigOutput_DOUT_3 = 222,
	primary_inverter_l_rcv_rcv_mux_ID_E2_DigOutput_Rdy_BTB = 226,
	primary_inverter_l_rcv_rcv_mux_ID_E9_Error_I_Fault = 233,
	primary_inverter_l_rcv_rcv_mux_ID_DF_DigOutput_DOUT_4 = 223,
	primary_inverter_l_rcv_rcv_mux_ID_46_I_lim_dig_perc = 70,
	primary_inverter_l_rcv_rcv_mux_ID_3C_I_Derating_N_perc = 60,
	primary_inverter_l_rcv_rcv_mux_ID_58_I_Derating_TD = 88,
	primary_inverter_l_rcv_rcv_mux_ID_4C_I_Derating_TE = 76,
	primary_inverter_l_rcv_rcv_mux_ID_A2_I_Derating_TM = 162,
	primary_inverter_l_rcv_rcv_mux_ID_36_CommandSource = 54,
	primary_inverter_l_rcv_rcv_mux_ID_23_Id_Ref = 35,
	primary_inverter_l_rcv_rcv_mux_ID_A0_M_outdig = 160,
	primary_inverter_l_rcv_rcv_mux_ID_B8_Ptr_1_DEBUG = 184,
	primary_inverter_l_rcv_rcv_mux_ID_BA_Ptr_2_DEBUG = 186,
	primary_inverter_l_rcv_rcv_mux_ID_9A_Temp_DEBUG = 154,
	primary_inverter_l_rcv_rcv_mux_ID_05_Motor_F_nom = 5,
	primary_inverter_l_rcv_rcv_mux_ID_06_Motor_V_nom = 6,
	primary_inverter_l_rcv_rcv_mux_ID_07_FU_T_dc = 7,
	primary_inverter_l_rcv_rcv_mux_ID_08_FU_V_dc = 8,
	primary_inverter_l_rcv_rcv_mux_ID_0A_FU_U_min = 10,
	primary_inverter_l_rcv_rcv_mux_ID_0B_FU_F_min = 11,
	primary_inverter_l_rcv_rcv_mux_ID_0C_FU_V_corner = 12,
	primary_inverter_l_rcv_rcv_mux_ID_0D_FU_F_corner = 13,
	primary_inverter_l_rcv_rcv_mux_ID_0E_Motor_Cos_Phi = 14,
	primary_inverter_l_rcv_rcv_mux_ID_19_PWM_Enum = 25,
	primary_inverter_l_rcv_rcv_mux_ID_1A_Calib_Ref_Value = 26,
	primary_inverter_l_rcv_rcv_mux_ID_1C_PID_I_Kp = 28,
	primary_inverter_l_rcv_rcv_mux_ID_1D_PID_I_Ti = 29,
	primary_inverter_l_rcv_rcv_mux_ID_1E_Cutoffdig = 30,
	primary_inverter_l_rcv_rcv_mux_ID_1F_I3_Offset = 31,
	primary_inverter_l_rcv_rcv_mux_ID_25_I_Delta_Ramp = 37,
	primary_inverter_l_rcv_rcv_mux_ID_2B_PID_I_TiM = 43,
	primary_inverter_l_rcv_rcv_mux_ID_2C_PID_n_Kp = 44,
	primary_inverter_l_rcv_rcv_mux_ID_8D_VoltageControl_Ti = 141,
	primary_inverter_l_rcv_rcv_mux_ID_2E_PID_n_Td = 46,
	primary_inverter_l_rcv_rcv_mux_ID_2F_Ain_in_1_OffsScale = 47,
	primary_inverter_l_rcv_rcv_mux_ID_D7_Ain_in_2_OffsScale = 215,
	primary_inverter_l_rcv_rcv_mux_ID_37_DZR_Sequencer_Value = 55,
	primary_inverter_l_rcv_rcv_mux_ID_3B_PID_n_TiM = 59,
	primary_inverter_l_rcv_rcv_mux_ID_3F_N_Lim_plus = 63,
	primary_inverter_l_rcv_rcv_mux_ID_3E_N_Lim_minus = 62,
	primary_inverter_l_rcv_rcv_mux_ID_41_Incr_Delta = 65,
	primary_inverter_l_rcv_rcv_mux_ID_42_MotorPosition_Mech = 66,
	primary_inverter_l_rcv_rcv_mux_ID_43_MotorPosition_Elec = 67,
	primary_inverter_l_rcv_rcv_mux_ID_44_FeedBack_Offset_Angle = 68,
	primary_inverter_l_rcv_rcv_mux_ID_45_Ixt_and_RegenE_Monitor = 69,
	primary_inverter_l_rcv_rcv_mux_ID_4F_Motor_Pole_Number = 79,
	primary_inverter_l_rcv_rcv_mux_ID_50_Ain_in_1_Cutoff = 80,
	primary_inverter_l_rcv_rcv_mux_ID_11_Control_Status = 17,
	primary_inverter_l_rcv_rcv_mux_ID_51_Kern_Mode_State = 81,
	primary_inverter_l_rcv_rcv_mux_ID_52_Status_Mask = 82,
	primary_inverter_l_rcv_rcv_mux_ID_53_Ain_in_2_Cutoff = 83,
	primary_inverter_l_rcv_rcv_mux_ID_57_I_Limit_Inuse_ramp = 87,
	primary_inverter_l_rcv_rcv_mux_ID_59_Motor_Nominal_Speed = 89,
	primary_inverter_l_rcv_rcv_mux_ID_5B_SpeedControl_Kacc = 91,
	primary_inverter_l_rcv_rcv_mux_ID_5C_Rotor_Signals = 92,
	primary_inverter_l_rcv_rcv_mux_ID_5E_Speed_Filter = 94,
	primary_inverter_l_rcv_rcv_mux_ID_60_Ain_in_X_Filter = 96,
	primary_inverter_l_rcv_rcv_mux_ID_61_Ixt_Monitor = 97,
	primary_inverter_l_rcv_rcv_mux_ID_63_ECODE_Status = 99,
	primary_inverter_l_rcv_rcv_mux_ID_64_Device_Mains_Supply_V = 100,
	primary_inverter_l_rcv_rcv_mux_ID_65_Regen_Resistor_P_and_R = 101,
	primary_inverter_l_rcv_rcv_mux_ID_68_CAN_ID_Rx = 104,
	primary_inverter_l_rcv_rcv_mux_ID_69_CAN_ID_Tx = 105,
	primary_inverter_l_rcv_rcv_mux_ID_6A_Pos_PID_Kp = 106,
	primary_inverter_l_rcv_rcv_mux_ID_6B_Pos_PID_Ti = 107,
	primary_inverter_l_rcv_rcv_mux_ID_6C_Pos_PID_Td = 108,
	primary_inverter_l_rcv_rcv_mux_ID_6D_Pos_Actual = 109,
	primary_inverter_l_rcv_rcv_mux_ID_6E_Pos_Destination = 110,
	primary_inverter_l_rcv_rcv_mux_ID_6F_Pos_Actual_2 = 111,
	primary_inverter_l_rcv_rcv_mux_ID_70_Pos_Error = 112,
	primary_inverter_l_rcv_rcv_mux_ID_71_Pos_PID_TiM = 113,
	primary_inverter_l_rcv_rcv_mux_ID_72_Pos_OffsetReference = 114,
	primary_inverter_l_rcv_rcv_mux_ID_73_CAN_NBT = 115,
	primary_inverter_l_rcv_rcv_mux_ID_74_Pos_Zero_Capture = 116,
	primary_inverter_l_rcv_rcv_mux_ID_75_Pos_Ref_Reso_Edge = 117,
	primary_inverter_l_rcv_rcv_mux_ID_76_Pos_Calib_Speed_1 = 118,
	primary_inverter_l_rcv_rcv_mux_ID_77_Pos_Calib_Speed_2 = 119,
	primary_inverter_l_rcv_rcv_mux_ID_79_Pos_Tol_Window = 121,
	primary_inverter_l_rcv_rcv_mux_ID_7A_Pos_Preset_Value = 122,
	primary_inverter_l_rcv_rcv_mux_ID_7B_Pos_Zero_Offset = 123,
	primary_inverter_l_rcv_rcv_mux_ID_7C_Pos_NDrive_Scale = 124,
	primary_inverter_l_rcv_rcv_mux_ID_7D_Pos_NDrive_Offset = 125,
	primary_inverter_l_rcv_rcv_mux_ID_7E_Pos_FB2_Scale_Fac_Ext = 126,
	primary_inverter_l_rcv_rcv_mux_ID_7F_Pos_Offset_Slack = 127,
	primary_inverter_l_rcv_rcv_mux_ID_80_Pos_Diff_Slack = 128,
	primary_inverter_l_rcv_rcv_mux_ID_83_Function_Parameter_Read = 131,
	primary_inverter_l_rcv_rcv_mux_ID_84_Function_Parameter_Write = 132,
	primary_inverter_l_rcv_rcv_mux_ID_85_Function_Special = 133,
	primary_inverter_l_rcv_rcv_mux_ID_88_CAN_ID_2_Rx = 136,
	primary_inverter_l_rcv_rcv_mux_ID_89_CAN_ID_2_Tx = 137,
	primary_inverter_l_rcv_rcv_mux_ID_8B_VoltageControl_Ref = 139,
	primary_inverter_l_rcv_rcv_mux_ID_8C_VoltageControl_Kp = 140,
	primary_inverter_l_rcv_rcv_mux_ID_2D_PID_n_Ti = 45,
	primary_inverter_l_rcv_rcv_mux_ID_8E_Clear_Error_List = 142,
	primary_inverter_l_rcv_rcv_mux_ID_91_Pos_cmd_int = 145,
	primary_inverter_l_rcv_rcv_mux_ID_92_CAN_Error_BusOff_cntr = 146,
	primary_inverter_l_rcv_rcv_mux_ID_93_CAN_Error_WriteTime_cntr = 147,
	primary_inverter_l_rcv_rcv_mux_ID_94_ECODE_1stError = 148,
	primary_inverter_l_rcv_rcv_mux_ID_95_CAN_Error_NoAck_cntr = 149,
	primary_inverter_l_rcv_rcv_mux_ID_96_CAN_Error_CRC_Check_cntr = 150,
	primary_inverter_l_rcv_rcv_mux_ID_97_CAN_Error_Bit_cntr = 151,
	primary_inverter_l_rcv_rcv_mux_ID_99_Info_Timer_Diff = 153,
	primary_inverter_l_rcv_rcv_mux_ID_A1_Ballast_cntr = 161,
	primary_inverter_l_rcv_rcv_mux_ID_A3_Motor_Temp_Error_Lim = 163,
	primary_inverter_l_rcv_rcv_mux_ID_A4_Motor_Options = 164,
	primary_inverter_l_rcv_rcv_mux_ID_A5_Device_DC_Bus_MinMax_Lim = 165,
	primary_inverter_l_rcv_rcv_mux_ID_A6_FB_IncrementsPerRot = 166,
	primary_inverter_l_rcv_rcv_mux_ID_A7_FB_Pole_Number = 167,
	primary_inverter_l_rcv_rcv_mux_ID_AB_Logic_Frequency = 171,
	primary_inverter_l_rcv_rcv_mux_ID_AC_PWM_1_56 = 172,
	primary_inverter_l_rcv_rcv_mux_ID_AD_PWM_2_34 = 173,
	primary_inverter_l_rcv_rcv_mux_ID_AE_PWM_3_12 = 174,
	primary_inverter_l_rcv_rcv_mux_ID_AF_Timer_Delta = 175,
	primary_inverter_l_rcv_rcv_mux_ID_B1_Motor_L_Sigma_Q = 177,
	primary_inverter_l_rcv_rcv_mux_ID_BB_Motor_L_Sigma_D = 187,
	primary_inverter_l_rcv_rcv_mux_ID_B2_Id_Nominal = 178,
	primary_inverter_l_rcv_rcv_mux_ID_B3_Motor_Magn_Inductance = 179,
	primary_inverter_l_rcv_rcv_mux_ID_B4_Motor_Rotor_Resistance = 180,
	primary_inverter_l_rcv_rcv_mux_ID_B5_Id_Minimum = 181,
	primary_inverter_l_rcv_rcv_mux_ID_B6_Time_Constant_Rotor = 182,
	primary_inverter_l_rcv_rcv_mux_ID_BC_Motor_Stator_Resistance = 188,
	primary_inverter_l_rcv_rcv_mux_ID_BD_Time_Constant_Stator = 189,
	primary_inverter_l_rcv_rcv_mux_ID_BE_LogicDefine_of_END_1 = 190,
	primary_inverter_l_rcv_rcv_mux_ID_BF_LogicDefine_of_END_2 = 191,
	primary_inverter_l_rcv_rcv_mux_ID_C0_LogicDefine_of_DIN_1 = 192,
	primary_inverter_l_rcv_rcv_mux_ID_C1_LogicDefine_of_DIN_2 = 193,
	primary_inverter_l_rcv_rcv_mux_ID_C2_LogicDefine_of_OUT_1 = 194,
	primary_inverter_l_rcv_rcv_mux_ID_24_I_Max_Inuse = 36,
	primary_inverter_l_rcv_rcv_mux_ID_E3_DigSignal_GO = 227,
	primary_inverter_l_rcv_rcv_mux_ID_F2_DigSignal_Brake = 242,
	primary_inverter_l_rcv_rcv_mux_ID_F3_DigSignal_Icns = 243,
	primary_inverter_l_rcv_rcv_mux_ID_F5_DigSignal_LessN0 = 245,
	primary_inverter_l_rcv_rcv_mux_ID_F4_DigSignal_Pos_Tolerance = 244,
	primary_inverter_l_rcv_rcv_mux_ID_FB_Ain_in_1_Calc = 251,
	primary_inverter_l_rcv_rcv_mux_ID_FC_Ain_in_2_Calc = 252,
	primary_inverter_l_rcv_rcv_mux_ID_C3_LogicDefine_of_OUT_2 = 195,
	primary_inverter_l_rcv_rcv_mux_ID_DA_LogicDefine_of_OUT_3 = 218,
	primary_inverter_l_rcv_rcv_mux_ID_DB_LogicDefine_of_OUT_4 = 219,
	primary_inverter_l_rcv_rcv_mux_ID_C9_PID_I_xKp = 201,
	primary_inverter_l_rcv_rcv_mux_ID_CA_Bat_Opr_Limits = 202,
	primary_inverter_l_rcv_rcv_mux_ID_CB_PID_I_Kf = 203,
	primary_inverter_l_rcv_rcv_mux_ID_CC_Car_Mode_Status = 204,
	primary_inverter_l_rcv_rcv_mux_ID_CD_Car_Mode_Config = 205,
	primary_inverter_l_rcv_rcv_mux_ID_CE_N_Rpm_MaxInt = 206,
	primary_inverter_l_rcv_rcv_mux_ID_D1_Var_1 = 209,
	primary_inverter_l_rcv_rcv_mux_ID_D0_CAN_Timeout = 208,
	primary_inverter_l_rcv_rcv_mux_ID_D2_Var_2 = 210,
	primary_inverter_l_rcv_rcv_mux_ID_D3_Var_3 = 211,
	primary_inverter_l_rcv_rcv_mux_ID_D4_Var_4 = 212,
	primary_inverter_l_rcv_rcv_mux_ID_DC_DAC_Source_ID = 220,
	primary_inverter_l_rcv_rcv_mux_ID_EC_DigSignal_FB_LossOfSig = 236,
	primary_inverter_l_rcv_rcv_mux_ID_EF_DigSignal_NoHWFault = 239,
	primary_inverter_l_rcv_rcv_mux_ID_F0_Time_I_Peak = 240,
	primary_inverter_l_rcv_rcv_mux_ID_F1_Brake_Delay = 241,
	primary_inverter_l_rcv_rcv_mux_ID_F6_Inverter_Output_Power = 246,
	primary_inverter_l_rcv_rcv_mux_ID_F7_Inverter_Output_Work = 247,
	primary_inverter_l_rcv_rcv_mux_ID_0F_FU_Extra = 9,
	primary_inverter_l_rcv_rcv_mux_ID_10_Oszi_Channel = 16,
	primary_inverter_l_rcv_rcv_mux_ID_12_Oszi_Triger_Level = 18,
	primary_inverter_l_rcv_rcv_mux_ID_13_Oszi_Triger_Edge = 19,
	primary_inverter_l_rcv_rcv_mux_ID_14_Oszi_Triger_Source = 20,
	primary_inverter_l_rcv_rcv_mux_ID_15_Oszi_Source = 21,
	primary_inverter_l_rcv_rcv_mux_ID_16_Oszi_Skip = 22,
	primary_inverter_l_rcv_rcv_mux_ID_18_Oszi_Run_cmd = 24,
	primary_inverter_l_rcv_rcv_mux_ID_17_Oszi_Read_cmd = 23,
	primary_inverter_l_rcv_rcv_mux_ID_78_Pos_Ref_Start = 120,
	primary_inverter_l_rcv_rcv_mux_ID_66_DC_Bus_Voltage = 102,
	primary_inverter_l_rcv_rcv_mux_ID_3A_M_cmd_ramp = 58,
	primary_inverter_l_rcv_rcv_mux_ID_97_LogicOutBlock = 152,
	primary_inverter_l_rcv_rcv_mux_ID_9B_LogicInBlock = 155,
	primary_inverter_l_rcv_rcv_mux_ID_FE_FW_Subv_Revis_Nr = 254,
} primary_inverter_l_rcv_rcv_mux;

typedef enum {
	primary_inverter_l_rcv_devicetype_Homemade = 0,
	primary_inverter_l_rcv_devicetype_DS205_2ph_230V = 14,
	primary_inverter_l_rcv_devicetype_DS403_2ph_400V = 15,
	primary_inverter_l_rcv_devicetype_DS205_neu_230V = 16,
	primary_inverter_l_rcv_devicetype_DS403_neu_400V = 17,
	primary_inverter_l_rcv_devicetype_DS405 = 19,
	primary_inverter_l_rcv_devicetype_DS412 = 21,
	primary_inverter_l_rcv_devicetype_DS420 = 23,
	primary_inverter_l_rcv_devicetype_DS450 = 25,
	primary_inverter_l_rcv_devicetype_DS475 = 27,
	primary_inverter_l_rcv_devicetype_DS4100 = 29,
	primary_inverter_l_rcv_devicetype_DS4820 = 48,
	primary_inverter_l_rcv_devicetype_DS451 = 49,
	primary_inverter_l_rcv_devicetype_DS476 = 51,
	primary_inverter_l_rcv_devicetype_DS8020 = 56,
	primary_inverter_l_rcv_devicetype_DPC440 = 60,
	primary_inverter_l_rcv_devicetype_DPC460 = 65,
	primary_inverter_l_rcv_devicetype_DPC460_DC1Q_3P = 67,
	primary_inverter_l_rcv_devicetype_BAMO_160_60 = 81,
	primary_inverter_l_rcv_devicetype_BAMO_160_120 = 83,
	primary_inverter_l_rcv_devicetype_BAMO_160_180 = 85,
	primary_inverter_l_rcv_devicetype_BAMO_360_60 = 87,
	primary_inverter_l_rcv_devicetype_BAMO_360_120 = 89,
	primary_inverter_l_rcv_devicetype_BAMO_360_180 = 91,
	primary_inverter_l_rcv_devicetype_BAMO_360_240 = 93,
	primary_inverter_l_rcv_devicetype_BAMOBIL_D3_3_62_80 = 112,
	primary_inverter_l_rcv_devicetype_BAMOBIL_D3_2_62_80 = 113,
	primary_inverter_l_rcv_devicetype_BAMOBIL_D3_3_62_120 = 114,
	primary_inverter_l_rcv_devicetype_BAMOBIL_D3_2_62_120 = 115,
	primary_inverter_l_rcv_devicetype_BAMOBIL_D3_3_62_250 = 116,
	primary_inverter_l_rcv_devicetype_BAMOBIL_D3_2_62_250 = 117,
	primary_inverter_l_rcv_devicetype_BAMOBIL_D3_3_62_350 = 118,
	primary_inverter_l_rcv_devicetype_BAMOBIL_D3_2_62_350 = 119,
	primary_inverter_l_rcv_devicetype_BAMOBIL_D3_3_62_450 = 120,
	primary_inverter_l_rcv_devicetype_BAMOBIL_D3_2_62_450 = 121,
	primary_inverter_l_rcv_devicetype_BAMOBIL_D3_3_160_50 = 122,
	primary_inverter_l_rcv_devicetype_BAMOBIL_D3_2_160_50 = 123,
	primary_inverter_l_rcv_devicetype_BAMOBIL_D3_3_160_100 = 124,
	primary_inverter_l_rcv_devicetype_BAMOBIL_D3_2_160_100 = 125,
	primary_inverter_l_rcv_devicetype_BAMOBIL_D3_3_160_200 = 126,
	primary_inverter_l_rcv_devicetype_BAMOBIL_D3_2_160_200 = 127,
	primary_inverter_l_rcv_devicetype_Bamocar_700_160 = 192,
	primary_inverter_l_rcv_devicetype_Bamocar_700_100 = 193,
	primary_inverter_l_rcv_devicetype_Bamocar_700_900 = 194,
	primary_inverter_l_rcv_devicetype_Bamocar_700_200_DC = 203,
	primary_inverter_l_rcv_devicetype_Bamocar_400_400 = 204,
	primary_inverter_l_rcv_devicetype_Bamocar_700_400 = 205,
	primary_inverter_l_rcv_devicetype_Bamocar_400_250 = 206,
	primary_inverter_l_rcv_devicetype_Koepfer_V1_700_400 = 240,
	primary_inverter_l_rcv_devicetype_Koepfer_V2_700_400 = 241,
} primary_inverter_l_rcv_devicetype;

typedef enum {
	primary_inverter_l_rcv_cs_ain_1_format_Off = 0,
	primary_inverter_l_rcv_cs_ain_1_format__Cmd_ = 1,
	primary_inverter_l_rcv_cs_ain_1_format__Cmd_ = 2,
	primary_inverter_l_rcv_cs_ain_1_format_sq_Cmd = 3,
} primary_inverter_l_rcv_cs_ain_1_format;

typedef enum {
	primary_inverter_l_rcv_activecontrolmode_TURNED_OFF = 0,
	primary_inverter_l_rcv_activecontrolmode_CURRENT_DIGITAL = 1,
	primary_inverter_l_rcv_activecontrolmode_SPEED_ANALOG = 2,
	primary_inverter_l_rcv_activecontrolmode_SPEED_CALIBRATION = 3,
	primary_inverter_l_rcv_activecontrolmode_SPEED_DIGITAL = 4,
	primary_inverter_l_rcv_activecontrolmode_SPEED_MIXED = 5,
	primary_inverter_l_rcv_activecontrolmode_SPEED_HOLD = 6,
	primary_inverter_l_rcv_activecontrolmode_TORQUE_ANALOG = 7,
	primary_inverter_l_rcv_activecontrolmode_TORQUE_DIGITAL = 8,
	primary_inverter_l_rcv_activecontrolmode_POSITION_DIGITAL = 9,
	primary_inverter_l_rcv_activecontrolmode_POSITION_HANDWHEEL = 10,
	primary_inverter_l_rcv_activecontrolmode_RES2 = 11,
	primary_inverter_l_rcv_activecontrolmode_TUNING1 = 12,
	primary_inverter_l_rcv_activecontrolmode_PHASING = 14,
	primary_inverter_l_rcv_activecontrolmode_DC_INJ = 15,
	primary_inverter_l_rcv_activecontrolmode_TACHO_OFFS = 16,
	primary_inverter_l_rcv_activecontrolmode_CALC = 17,
	primary_inverter_l_rcv_activecontrolmode_MEASURE = 18,
	primary_inverter_l_rcv_activecontrolmode_WAIT = 21,
} primary_inverter_l_rcv_activecontrolmode;

typedef enum {
	primary_inverter_l_rcv_can_nbt_1000_kbps = 16386,
	primary_inverter_l_rcv_can_nbt_500_kbps = 16421,
	primary_inverter_l_rcv_can_nbt_625_kbps = 16404,
	primary_inverter_l_rcv_can_nbt_250_kbps = 16476,
	primary_inverter_l_rcv_can_nbt_100_kbps = 17445,
} primary_inverter_l_rcv_can_nbt;

typedef enum {
	primary_inverter_l_rcv_mo_feedback_1_Rot_Enc_TTL = 0,
	primary_inverter_l_rcv_mo_feedback_1_Resolver = 1,
	primary_inverter_l_rcv_mo_feedback_1_Abs_Enc_SC = 2,
	primary_inverter_l_rcv_mo_feedback_1_Rot_Tacho = 3,
	primary_inverter_l_rcv_mo_feedback_1_Rot = 4,
	primary_inverter_l_rcv_mo_feedback_1_DC_Tacho = 5,
	primary_inverter_l_rcv_mo_feedback_1_DC_Arm = 6,
	primary_inverter_l_rcv_mo_feedback_1_BL_Arm = 7,
	primary_inverter_l_rcv_mo_feedback_1_Enc_TTL = 8,
	primary_inverter_l_rcv_mo_feedback_1_Enc_SC = 9,
	primary_inverter_l_rcv_mo_feedback_1_Abs_SC = 10,
	primary_inverter_l_rcv_mo_feedback_1_DC_Arm_Vir = 11,
	primary_inverter_l_rcv_mo_feedback_1_SLS = 12,
	primary_inverter_l_rcv_mo_feedback_1_SLS_SMO = 13,
	primary_inverter_l_rcv_mo_feedback_1_SLS_Usens = 14,
	primary_inverter_l_rcv_mo_feedback_1_AnaIn1_calc = 15,
	primary_inverter_l_rcv_mo_feedback_1_AnaIn2_calc = 16,
	primary_inverter_l_rcv_mo_feedback_1_Panasonic = 17,
	primary_inverter_l_rcv_mo_feedback_1_DC_Bus = 18,
} primary_inverter_l_rcv_mo_feedback_1;

typedef enum {
	primary_inverter_l_rcv_def_end_1__Off_ = 0,
	primary_inverter_l_rcv_def_end_1_Ref_and_Limit_Plus = 1,
	primary_inverter_l_rcv_def_end_1_Ref_and_Limit_Minus = 2,
	primary_inverter_l_rcv_def_end_1_Ref_Plus = 3,
	primary_inverter_l_rcv_def_end_1_Limit_Plus = 4,
	primary_inverter_l_rcv_def_end_1_Limit_Minus = 5,
	primary_inverter_l_rcv_def_end_1_Limit_Plus_and_Minus = 6,
	primary_inverter_l_rcv_def_end_1_Cancel_Error_s_ = 7,
	primary_inverter_l_rcv_def_end_1__Start_Ref_Drive = 8,
	primary_inverter_l_rcv_def_end_1_Speed_Ramp_0 = 9,
	primary_inverter_l_rcv_def_end_1__Start_Dest_Var_1 = 10,
	primary_inverter_l_rcv_def_end_1__Start_Dest_Var_2 = 11,
	primary_inverter_l_rcv_def_end_1_N_cmd_Reverse = 12,
	primary_inverter_l_rcv_def_end_1__Preset_Pos_Var_3 = 13,
	primary_inverter_l_rcv_def_end_1__Capture_Var_3_Pos = 14,
	primary_inverter_l_rcv_def_end_1__Capture_Var_4_Pos = 15,
	primary_inverter_l_rcv_def_end_1__Switch_Spd_Ain1_Ain2 = 16,
	primary_inverter_l_rcv_def_end_1__Switch_Spd_Var1_Var2 = 17,
	primary_inverter_l_rcv_def_end_1_I_limit_dig_ = 18,
	primary_inverter_l_rcv_def_end_1_N_clip_neg_pos_ = 19,
	primary_inverter_l_rcv_def_end_1__Switch_Cmd_Dig_Ana = 20,
	primary_inverter_l_rcv_def_end_1_Speed_Ramp_0_Pos = 21,
	primary_inverter_l_rcv_def_end_1_Handwheel = 22,
	primary_inverter_l_rcv_def_end_1_Brake_Car = 23,
	primary_inverter_l_rcv_def_end_1_Recup_Disabled = 24,
	primary_inverter_l_rcv_def_end_1_Rising_Bank_1,_Falling_Bank_0 = 25,
	primary_inverter_l_rcv_def_end_1__Start_Dest_Var_1,_2,_3,_4 = 26,
	primary_inverter_l_rcv_def_end_1__Start_CW_Var_1,_2,_3,_4 = 27,
	primary_inverter_l_rcv_def_end_1_Brake_Car_Nr2 = 28,
} primary_inverter_l_rcv_def_end_1;

typedef enum {
	primary_inverter_l_rcv_def_end_2__Off_ = 0,
	primary_inverter_l_rcv_def_end_2_Ref_and_Limit_Plus = 1,
	primary_inverter_l_rcv_def_end_2_Ref_and_Limit_Minus = 2,
	primary_inverter_l_rcv_def_end_2_Ref_Plus = 3,
	primary_inverter_l_rcv_def_end_2_Limit_Plus = 4,
	primary_inverter_l_rcv_def_end_2_Limit_Minus = 5,
	primary_inverter_l_rcv_def_end_2_Limit_Plus_and_Minus = 6,
	primary_inverter_l_rcv_def_end_2_Cancel_Error_s_ = 7,
	primary_inverter_l_rcv_def_end_2__Start_Ref_Drive = 8,
	primary_inverter_l_rcv_def_end_2_Speed_Ramp_0 = 9,
	primary_inverter_l_rcv_def_end_2__Start_Dest_Var_1 = 10,
	primary_inverter_l_rcv_def_end_2__Start_Dest_Var_2 = 11,
	primary_inverter_l_rcv_def_end_2_N_cmd_Reverse = 12,
	primary_inverter_l_rcv_def_end_2__Preset_Pos_Var_3 = 13,
	primary_inverter_l_rcv_def_end_2__Capture_Var_3_Pos = 14,
	primary_inverter_l_rcv_def_end_2__Capture_Var_4_Pos = 15,
	primary_inverter_l_rcv_def_end_2__Switch_Spd_Ain1_Ain2 = 16,
	primary_inverter_l_rcv_def_end_2__Switch_Spd_Var1_Var2 = 17,
	primary_inverter_l_rcv_def_end_2_I_limit_dig_ = 18,
	primary_inverter_l_rcv_def_end_2_N_clip_neg_pos_ = 19,
	primary_inverter_l_rcv_def_end_2__Switch_Cmd_Dig_Ana = 20,
	primary_inverter_l_rcv_def_end_2_Speed_Ramp_0_Pos = 21,
	primary_inverter_l_rcv_def_end_2_Handwheel = 22,
	primary_inverter_l_rcv_def_end_2_Brake_Car = 23,
	primary_inverter_l_rcv_def_end_2_Recup_Disabled = 24,
	primary_inverter_l_rcv_def_end_2_Rising_Bank_1,_Falling_Bank_0 = 25,
	primary_inverter_l_rcv_def_end_2__Start_Dest_Var_1,_2,_3,_4 = 26,
	primary_inverter_l_rcv_def_end_2__Start_CW_Var_1,_2,_3,_4 = 27,
	primary_inverter_l_rcv_def_end_2_Brake_Car_Nr2 = 28,
} primary_inverter_l_rcv_def_end_2;

typedef enum {
	primary_inverter_l_rcv_def_din_1__Off_ = 0,
	primary_inverter_l_rcv_def_din_1_Ref_and_Limit_Plus = 1,
	primary_inverter_l_rcv_def_din_1_Ref_and_Limit_Minus = 2,
	primary_inverter_l_rcv_def_din_1_Ref_Plus = 3,
	primary_inverter_l_rcv_def_din_1_Limit_Plus = 4,
	primary_inverter_l_rcv_def_din_1_Limit_Minus = 5,
	primary_inverter_l_rcv_def_din_1_Limit_Plus_and_Minus = 6,
	primary_inverter_l_rcv_def_din_1_Cancel_Error_s_ = 7,
	primary_inverter_l_rcv_def_din_1__Start_Ref_Drive = 8,
	primary_inverter_l_rcv_def_din_1_Speed_Ramp_0 = 9,
	primary_inverter_l_rcv_def_din_1__Start_Dest_Var_1 = 10,
	primary_inverter_l_rcv_def_din_1__Start_Dest_Var_2 = 11,
	primary_inverter_l_rcv_def_din_1_N_cmd_Reverse = 12,
	primary_inverter_l_rcv_def_din_1__Preset_Pos_Var_3 = 13,
	primary_inverter_l_rcv_def_din_1__Capture_Var_3_Pos = 14,
	primary_inverter_l_rcv_def_din_1__Capture_Var_4_Pos = 15,
	primary_inverter_l_rcv_def_din_1__Switch_Spd_Ain1_Ain2 = 16,
	primary_inverter_l_rcv_def_din_1__Switch_Spd_Var1_Var2 = 17,
	primary_inverter_l_rcv_def_din_1_I_limit_dig_ = 18,
	primary_inverter_l_rcv_def_din_1_N_clip_neg_pos_ = 19,
	primary_inverter_l_rcv_def_din_1__Switch_Cmd_Dig_Ana = 20,
	primary_inverter_l_rcv_def_din_1_Speed_Ramp_0_Pos = 21,
	primary_inverter_l_rcv_def_din_1_Handwheel = 22,
	primary_inverter_l_rcv_def_din_1_Brake_Car = 23,
	primary_inverter_l_rcv_def_din_1_Recup_Disabled = 24,
	primary_inverter_l_rcv_def_din_1_Rising_Bank_1,_Falling_Bank_0 = 25,
	primary_inverter_l_rcv_def_din_1__Start_Dest_Var_1,_2,_3,_4 = 26,
	primary_inverter_l_rcv_def_din_1__Start_CW_Var_1,_2,_3,_4 = 27,
	primary_inverter_l_rcv_def_din_1_Brake_Car_Nr2 = 28,
} primary_inverter_l_rcv_def_din_1;

typedef enum {
	primary_inverter_l_rcv_def_din_2__Off_ = 0,
	primary_inverter_l_rcv_def_din_2_Ref_and_Limit_Plus = 1,
	primary_inverter_l_rcv_def_din_2_Ref_and_Limit_Minus = 2,
	primary_inverter_l_rcv_def_din_2_Ref_Plus = 3,
	primary_inverter_l_rcv_def_din_2_Limit_Plus = 4,
	primary_inverter_l_rcv_def_din_2_Limit_Minus = 5,
	primary_inverter_l_rcv_def_din_2_Limit_Plus_and_Minus = 6,
	primary_inverter_l_rcv_def_din_2_Cancel_Error_s_ = 7,
	primary_inverter_l_rcv_def_din_2__Start_Ref_Drive = 8,
	primary_inverter_l_rcv_def_din_2_Speed_Ramp_0 = 9,
	primary_inverter_l_rcv_def_din_2__Start_Dest_Var_1 = 10,
	primary_inverter_l_rcv_def_din_2__Start_Dest_Var_2 = 11,
	primary_inverter_l_rcv_def_din_2_N_cmd_Reverse = 12,
	primary_inverter_l_rcv_def_din_2__Preset_Pos_Var_3 = 13,
	primary_inverter_l_rcv_def_din_2__Capture_Var_3_Pos = 14,
	primary_inverter_l_rcv_def_din_2__Capture_Var_4_Pos = 15,
	primary_inverter_l_rcv_def_din_2__Switch_Spd_Ain1_Ain2 = 16,
	primary_inverter_l_rcv_def_din_2__Switch_Spd_Var1_Var2 = 17,
	primary_inverter_l_rcv_def_din_2_I_limit_dig_ = 18,
	primary_inverter_l_rcv_def_din_2_N_clip_neg_pos_ = 19,
	primary_inverter_l_rcv_def_din_2__Switch_Cmd_Dig_Ana = 20,
	primary_inverter_l_rcv_def_din_2_Speed_Ramp_0_Pos = 21,
	primary_inverter_l_rcv_def_din_2_Handwheel = 22,
	primary_inverter_l_rcv_def_din_2_Brake_Car = 23,
	primary_inverter_l_rcv_def_din_2_Recup_Disabled = 24,
	primary_inverter_l_rcv_def_din_2_Rising_Bank_1,_Falling_Bank_0 = 25,
	primary_inverter_l_rcv_def_din_2__Start_Dest_Var_1,_2,_3,_4 = 26,
	primary_inverter_l_rcv_def_din_2__Start_CW_Var_1,_2,_3,_4 = 27,
	primary_inverter_l_rcv_def_din_2_Brake_Car_Nr2 = 28,
} primary_inverter_l_rcv_def_din_2;

typedef enum {
	primary_inverter_l_rcv_operand194_Off = 0,
	primary_inverter_l_rcv_operand194_On = 1,
	primary_inverter_l_rcv_operand194_1_Hz = 2,
	primary_inverter_l_rcv_operand194__ = 3,
	primary_inverter_l_rcv_operand194__ = 4,
	primary_inverter_l_rcv_operand194__>_ = 5,
	primary_inverter_l_rcv_operand194__<_ = 6,
	primary_inverter_l_rcv_operand194__abs_>_ = 7,
	primary_inverter_l_rcv_operand194__abs_<_ = 8,
	primary_inverter_l_rcv_operand194__tol_>_ = 9,
	primary_inverter_l_rcv_operand194__tol_<_ = 10,
	primary_inverter_l_rcv_operand194__>_ = 11,
	primary_inverter_l_rcv_operand194__<_ = 12,
	primary_inverter_l_rcv_operand194__hyst_>_ = 13,
	primary_inverter_l_rcv_operand194__hyst_<_ = 14,
	primary_inverter_l_rcv_operand194__window_ = 15,
} primary_inverter_l_rcv_operand194;

typedef enum {
	primary_inverter_l_rcv_operand195_Off = 0,
	primary_inverter_l_rcv_operand195_On = 1,
	primary_inverter_l_rcv_operand195_1_Hz = 2,
	primary_inverter_l_rcv_operand195__ = 3,
	primary_inverter_l_rcv_operand195__ = 4,
	primary_inverter_l_rcv_operand195__>_ = 5,
	primary_inverter_l_rcv_operand195__<_ = 6,
	primary_inverter_l_rcv_operand195__abs_>_ = 7,
	primary_inverter_l_rcv_operand195__abs_<_ = 8,
	primary_inverter_l_rcv_operand195__tol_>_ = 9,
	primary_inverter_l_rcv_operand195__tol_<_ = 10,
	primary_inverter_l_rcv_operand195__>_ = 11,
	primary_inverter_l_rcv_operand195__<_ = 12,
	primary_inverter_l_rcv_operand195__hyst_>_ = 13,
	primary_inverter_l_rcv_operand195__hyst_<_ = 14,
	primary_inverter_l_rcv_operand195__window_ = 15,
} primary_inverter_l_rcv_operand195;

typedef enum {
	primary_inverter_l_rcv_operand218_Off = 0,
	primary_inverter_l_rcv_operand218_On = 1,
	primary_inverter_l_rcv_operand218_1_Hz = 2,
	primary_inverter_l_rcv_operand218__ = 3,
	primary_inverter_l_rcv_operand218__ = 4,
	primary_inverter_l_rcv_operand218__>_ = 5,
	primary_inverter_l_rcv_operand218__<_ = 6,
	primary_inverter_l_rcv_operand218__abs_>_ = 7,
	primary_inverter_l_rcv_operand218__abs_<_ = 8,
	primary_inverter_l_rcv_operand218__tol_>_ = 9,
	primary_inverter_l_rcv_operand218__tol_<_ = 10,
	primary_inverter_l_rcv_operand218__>_ = 11,
	primary_inverter_l_rcv_operand218__<_ = 12,
	primary_inverter_l_rcv_operand218__hyst_>_ = 13,
	primary_inverter_l_rcv_operand218__hyst_<_ = 14,
	primary_inverter_l_rcv_operand218__window_ = 15,
} primary_inverter_l_rcv_operand218;

typedef enum {
	primary_inverter_l_rcv_operand219_Off = 0,
	primary_inverter_l_rcv_operand219_On = 1,
	primary_inverter_l_rcv_operand219_1_Hz = 2,
	primary_inverter_l_rcv_operand219__ = 3,
	primary_inverter_l_rcv_operand219__ = 4,
	primary_inverter_l_rcv_operand219__>_ = 5,
	primary_inverter_l_rcv_operand219__<_ = 6,
	primary_inverter_l_rcv_operand219__abs_>_ = 7,
	primary_inverter_l_rcv_operand219__abs_<_ = 8,
	primary_inverter_l_rcv_operand219__tol_>_ = 9,
	primary_inverter_l_rcv_operand219__tol_<_ = 10,
	primary_inverter_l_rcv_operand219__>_ = 11,
	primary_inverter_l_rcv_operand219__<_ = 12,
	primary_inverter_l_rcv_operand219__hyst_>_ = 13,
	primary_inverter_l_rcv_operand219__hyst_<_ = 14,
	primary_inverter_l_rcv_operand219__window_ = 15,
} primary_inverter_l_rcv_operand219;

typedef enum {
	primary_inverter_l_rcv_cs_ain_2_format_Off = 0,
	primary_inverter_l_rcv_cs_ain_2_format__Cmd_ = 1,
	primary_inverter_l_rcv_cs_ain_2_format__Cmd_ = 2,
	primary_inverter_l_rcv_cs_ain_2_format__Cmd = 3,
} primary_inverter_l_rcv_cs_ain_2_format;

typedef enum {
	primary_inverter_l_rcv_cs_ain_1_mode__10_10V_ = 0,
	primary_inverter_l_rcv_cs_ain_1_mode__0_10V_ = 1,
	primary_inverter_l_rcv_cs_ain_1_mode__4_20mA_ = 2,
	primary_inverter_l_rcv_cs_ain_1_mode__1_9V_ = 3,
} primary_inverter_l_rcv_cs_ain_1_mode;

typedef enum {
	primary_inverter_l_rcv_compare_var194__0_ = 0,
	primary_inverter_l_rcv_compare_var194__1_ = 1,
	primary_inverter_l_rcv_compare_var194__Var_1_ = 2,
	primary_inverter_l_rcv_compare_var194__Var_2_ = 3,
	primary_inverter_l_rcv_compare_var194__Var_3_ = 4,
	primary_inverter_l_rcv_compare_var194__Var_4_ = 5,
	primary_inverter_l_rcv_compare_var194__Ain_1_ = 6,
	primary_inverter_l_rcv_compare_var194__Ain_2_ = 7,
} primary_inverter_l_rcv_compare_var194;

typedef enum {
	primary_inverter_l_rcv_compare_var195__0_ = 0,
	primary_inverter_l_rcv_compare_var195__1_ = 1,
	primary_inverter_l_rcv_compare_var195__Var_1_ = 2,
	primary_inverter_l_rcv_compare_var195__Var_2_ = 3,
	primary_inverter_l_rcv_compare_var195__Var_3_ = 4,
	primary_inverter_l_rcv_compare_var195__Var_4_ = 5,
	primary_inverter_l_rcv_compare_var195__Ain_1_ = 6,
	primary_inverter_l_rcv_compare_var195__Ain_2_ = 7,
} primary_inverter_l_rcv_compare_var195;

typedef enum {
	primary_inverter_l_rcv_compare_var218__0_ = 0,
	primary_inverter_l_rcv_compare_var218__1_ = 1,
	primary_inverter_l_rcv_compare_var218__Var_1_ = 2,
	primary_inverter_l_rcv_compare_var218__Var_2_ = 3,
	primary_inverter_l_rcv_compare_var218__Var_3_ = 4,
	primary_inverter_l_rcv_compare_var218__Var_4_ = 5,
	primary_inverter_l_rcv_compare_var218__Ain_1_ = 6,
	primary_inverter_l_rcv_compare_var218__Ain_2_ = 7,
} primary_inverter_l_rcv_compare_var218;

typedef enum {
	primary_inverter_l_rcv_compare_var219__0_ = 0,
	primary_inverter_l_rcv_compare_var219__1_ = 1,
	primary_inverter_l_rcv_compare_var219__Var_1_ = 2,
	primary_inverter_l_rcv_compare_var219__Var_2_ = 3,
	primary_inverter_l_rcv_compare_var219__Var_3_ = 4,
	primary_inverter_l_rcv_compare_var219__Var_4_ = 5,
	primary_inverter_l_rcv_compare_var219__Ain_1_ = 6,
	primary_inverter_l_rcv_compare_var219__Ain_2_ = 7,
} primary_inverter_l_rcv_compare_var219;

typedef enum {
	primary_inverter_l_rcv_mo_feedback_2__ = 0,
	primary_inverter_l_rcv_mo_feedback_2_Enc_Position = 1,
	primary_inverter_l_rcv_mo_feedback_2_Enc_Info = 2,
	primary_inverter_l_rcv_mo_feedback_2_Enc_Hand_ = 3,
	primary_inverter_l_rcv_mo_feedback_2_SSI = 4,
} primary_inverter_l_rcv_mo_feedback_2;

typedef enum {
	primary_inverter_l_rcv_cs_ain_2_mode__10_10V_ = 0,
	primary_inverter_l_rcv_cs_ain_2_mode__0_10V_ = 1,
	primary_inverter_l_rcv_cs_ain_2_mode__4_20mA_ = 2,
	primary_inverter_l_rcv_cs_ain_2_mode__1_9V_ = 3,
} primary_inverter_l_rcv_cs_ain_2_mode;

typedef enum {
	primary_inverter_l_rcv_ctrlsubmode_UNASSIGNED = 0,
	primary_inverter_l_rcv_ctrlsubmode_SPEED_NI = 1,
	primary_inverter_l_rcv_ctrlsubmode_SPEED_PNI = 2,
	primary_inverter_l_rcv_ctrlsubmode_POSITION_PNI = 3,
} primary_inverter_l_rcv_ctrlsubmode;

typedef enum {
	primary_inverter_l_rcv_mo_sc1_reso_14_bit = 1,
	primary_inverter_l_rcv_mo_sc1_reso_12_bit = 2,
	primary_inverter_l_rcv_mo_sc1_reso_10_bit = 3,
} primary_inverter_l_rcv_mo_sc1_reso;

typedef enum {
	primary_inverter_l_rcv_source_id194_5Dh_N_cmd_int_ = 93,
	primary_inverter_l_rcv_source_id194_32h_N_cmd_ramp_ = 50,
	primary_inverter_l_rcv_source_id194_30h_N_Actual = 48,
	primary_inverter_l_rcv_source_id194_A8h_N_Actual_Filt = 168,
	primary_inverter_l_rcv_source_id194_33h_N_Error = 51,
	primary_inverter_l_rcv_source_id194_26h_I_cmd = 38,
	primary_inverter_l_rcv_source_id194_22h_I_cmd_ramp_ = 34,
	primary_inverter_l_rcv_source_id194_20h_I_Actual = 32,
	primary_inverter_l_rcv_source_id194_5Fh_I_Actual_Filt = 95,
	primary_inverter_l_rcv_source_id194_6Eh_Pos_Destination = 110,
	primary_inverter_l_rcv_source_id194_91h_Pos_cmd = 145,
	primary_inverter_l_rcv_source_id194_6Dh_Pos_Actual = 109,
	primary_inverter_l_rcv_source_id194_70h_Pos_Error = 112,
	primary_inverter_l_rcv_source_id194_74h_Pos_ZeroCapture = 116,
	primary_inverter_l_rcv_source_id194_E4h_DigInput_END_1 = 228,
	primary_inverter_l_rcv_source_id194_E5h_DigInput_END_2 = 229,
	primary_inverter_l_rcv_source_id194_E6h_DigInput_DIN_1 = 230,
	primary_inverter_l_rcv_source_id194_E7h_DigInput_DIN_2 = 231,
	primary_inverter_l_rcv_source_id194_E8h_DigInput_RUN = 232,
	primary_inverter_l_rcv_source_id194_E0h_DigOutput_DOUT_1 = 224,
	primary_inverter_l_rcv_source_id194_E1h_DigOutput_DOUT_2 = 225,
	primary_inverter_l_rcv_source_id194_DEh_DigOutput_DOUT_3 = 222,
	primary_inverter_l_rcv_source_id194_DFh_DigOutput_DOUT_4 = 223,
	primary_inverter_l_rcv_source_id194_E2h_DigOutput_Rdy_BTB = 226,
	primary_inverter_l_rcv_source_id194_E9h_Error_I_Fault = 233,
	primary_inverter_l_rcv_source_id194_EAh_I_Ballast_Act = 234,
	primary_inverter_l_rcv_source_id194_24h_I_Max_Inuse = 36,
	primary_inverter_l_rcv_source_id194_ECh_FB_LossOfSignal = 236,
	primary_inverter_l_rcv_source_id194__Off_ = 0,
	primary_inverter_l_rcv_source_id194_E3h_DigSignal_GO = 227,
	primary_inverter_l_rcv_source_id194_F2h_DigSignal_Brake = 242,
	primary_inverter_l_rcv_source_id194_F3h_DigSignal_Icns = 243,
	primary_inverter_l_rcv_source_id194_F5h_DigSignal_LessN0 = 245,
	primary_inverter_l_rcv_source_id194_F4h_DigSignal_PosToler_Set = 244,
	primary_inverter_l_rcv_source_id194_5Ch_Rotor_Signals = 92,
	primary_inverter_l_rcv_source_id194_D1h_Var_1 = 209,
	primary_inverter_l_rcv_source_id194_D2h_Var_2 = 210,
	primary_inverter_l_rcv_source_id194_D3h_Var_3 = 211,
	primary_inverter_l_rcv_source_id194_D4h_Var_4 = 212,
	primary_inverter_l_rcv_source_id194_D5h_Ain_In_1 = 213,
	primary_inverter_l_rcv_source_id194_D6h_Ain_In_2 = 214,
	primary_inverter_l_rcv_source_id194_42h_MotorPos_Mech = 66,
	primary_inverter_l_rcv_source_id194_43h_MotorPos_Elec = 67,
	primary_inverter_l_rcv_source_id194_A9h_I3_Adc_Value = 169,
	primary_inverter_l_rcv_source_id194_AAh_I2_Adc_Value = 170,
	primary_inverter_l_rcv_source_id194_54h_I1_Actual = 84,
	primary_inverter_l_rcv_source_id194_55h_I2_Actual = 85,
	primary_inverter_l_rcv_source_id194_56h_I3_Actual = 86,
	primary_inverter_l_rcv_source_id194_27h_Iq_Actual = 39,
	primary_inverter_l_rcv_source_id194_28h_Id_Actual = 40,
	primary_inverter_l_rcv_source_id194_38h_Iq_Error = 56,
	primary_inverter_l_rcv_source_id194_39h_Id_Error = 57,
	primary_inverter_l_rcv_source_id194_23h_Id_Ref = 35,
	primary_inverter_l_rcv_source_id194_B5h_Id_Min = 181,
	primary_inverter_l_rcv_source_id194_61h_Ixt_Monitor = 97,
	primary_inverter_l_rcv_source_id194_48h_I_Limit_Inuse = 72,
	primary_inverter_l_rcv_source_id194_57h_I_Limit_Inuse_ramp_ = 87,
	primary_inverter_l_rcv_source_id194_FBh_Ain_1_Calc = 251,
	primary_inverter_l_rcv_source_id194_FCh_Ain_2_Calc = 252,
	primary_inverter_l_rcv_source_id194_29h_Vq_Output = 41,
	primary_inverter_l_rcv_source_id194_2Ah_Vd_Output = 42,
	primary_inverter_l_rcv_source_id194_8Ah_V_Output = 138,
	primary_inverter_l_rcv_source_id194_8Bh_V_Red_Ref_ = 139,
	primary_inverter_l_rcv_source_id194_8Ch_V_Control_Kp = 140,
	primary_inverter_l_rcv_source_id194_8Dh_V_Control_Ti = 141,
	primary_inverter_l_rcv_source_id194_ACh_PWM_1_5_6_ = 172,
	primary_inverter_l_rcv_source_id194_ADh_PWM_2_3_4_ = 173,
	primary_inverter_l_rcv_source_id194_AEh_PWM_3_1_2_ = 174,
	primary_inverter_l_rcv_source_id194_49h_T_Motor = 73,
	primary_inverter_l_rcv_source_id194_4Ah_T_Igbt = 74,
	primary_inverter_l_rcv_source_id194_4Bh_T_Air_Inside = 75,
	primary_inverter_l_rcv_source_id194_45h_It_Rg_Monitor = 69,
	primary_inverter_l_rcv_source_id194_9Ah_Temp_DEBUG = 154,
	primary_inverter_l_rcv_source_id194_ABh_Logic_Freq = 171,
	primary_inverter_l_rcv_source_id194_B8h_Ptr_1_DEBUG = 184,
	primary_inverter_l_rcv_source_id194_BAh_Ptr_2_DEBUG = 186,
	primary_inverter_l_rcv_source_id194_8Fh_ErrorWarning_Map = 143,
	primary_inverter_l_rcv_source_id194_40h_Status_Map = 64,
	primary_inverter_l_rcv_source_id194_41h_Incr_Delta = 65,
	primary_inverter_l_rcv_source_id194_34h_N_Lim = 52,
	primary_inverter_l_rcv_source_id194_63h_FPGA_Status = 99,
	primary_inverter_l_rcv_source_id194_31h_N_set_dig_ = 49,
	primary_inverter_l_rcv_source_id194_90h_M_set_dig_ = 144,
	primary_inverter_l_rcv_source_id194_A0h_M_out_dig_ = 160,
	primary_inverter_l_rcv_source_id194_6Fh_Pos_Actual_2 = 111,
	primary_inverter_l_rcv_source_id194_98h_Logic_O_Block = 152,
	primary_inverter_l_rcv_source_id194_9Bh_Logic_I_Block = 155,
	primary_inverter_l_rcv_source_id194_02h_SC_Info = 2,
	primary_inverter_l_rcv_source_id194_EBh_Vdc_Bus = 235,
	primary_inverter_l_rcv_source_id194_66h_Vdc_Bus_Filt = 102,
	primary_inverter_l_rcv_source_id194_99h_Info_Timer_Diff = 153,
	primary_inverter_l_rcv_source_id194_A1h_Ballast_cntr = 161,
	primary_inverter_l_rcv_source_id194_51_Kern_Mode_State = 81,
	primary_inverter_l_rcv_source_id194_11h_Control_Status = 17,
} primary_inverter_l_rcv_source_id194;

typedef enum {
	primary_inverter_l_rcv_source_id195_5Dh_N_cmd_int_ = 93,
	primary_inverter_l_rcv_source_id195_32h_N_cmd_ramp_ = 50,
	primary_inverter_l_rcv_source_id195_30h_N_Actual = 48,
	primary_inverter_l_rcv_source_id195_A8h_N_Actual_Filt = 168,
	primary_inverter_l_rcv_source_id195_33h_N_Error = 51,
	primary_inverter_l_rcv_source_id195_26h_I_cmd = 38,
	primary_inverter_l_rcv_source_id195_22h_I_cmd_ramp_ = 34,
	primary_inverter_l_rcv_source_id195_20h_I_Actual = 32,
	primary_inverter_l_rcv_source_id195_5Fh_I_Actual_Filt = 95,
	primary_inverter_l_rcv_source_id195_6Eh_Pos_Destination = 110,
	primary_inverter_l_rcv_source_id195_91h_Pos_cmd = 145,
	primary_inverter_l_rcv_source_id195_6Dh_Pos_Actual = 109,
	primary_inverter_l_rcv_source_id195_70h_Pos_Error = 112,
	primary_inverter_l_rcv_source_id195_74h_Pos_ZeroCapture = 116,
	primary_inverter_l_rcv_source_id195_E4h_DigInput_END_1 = 228,
	primary_inverter_l_rcv_source_id195_E5h_DigInput_END_2 = 229,
	primary_inverter_l_rcv_source_id195_E6h_DigInput_DIN_1 = 230,
	primary_inverter_l_rcv_source_id195_E7h_DigInput_DIN_2 = 231,
	primary_inverter_l_rcv_source_id195_E8h_DigInput_RUN = 232,
	primary_inverter_l_rcv_source_id195_E0h_DigOutput_DOUT_1 = 224,
	primary_inverter_l_rcv_source_id195_E1h_DigOutput_DOUT_2 = 225,
	primary_inverter_l_rcv_source_id195_DEh_DigOutput_DOUT_3 = 222,
	primary_inverter_l_rcv_source_id195_DFh_DigOutput_DOUT_4 = 223,
	primary_inverter_l_rcv_source_id195_E2h_DigOutput_Rdy_BTB = 226,
	primary_inverter_l_rcv_source_id195_E9h_Error_I_Fault = 233,
	primary_inverter_l_rcv_source_id195_EAh_I_Ballast_Act = 234,
	primary_inverter_l_rcv_source_id195_24h_I_Max_Inuse = 36,
	primary_inverter_l_rcv_source_id195_ECh_FB_LossOfSignal = 236,
	primary_inverter_l_rcv_source_id195__Off_ = 0,
	primary_inverter_l_rcv_source_id195_E3h_DigSignal_GO = 227,
	primary_inverter_l_rcv_source_id195_F2h_DigSignal_Brake = 242,
	primary_inverter_l_rcv_source_id195_F3h_DigSignal_Icns = 243,
	primary_inverter_l_rcv_source_id195_F5h_DigSignal_LessN0 = 245,
	primary_inverter_l_rcv_source_id195_F4h_DigSignal_PosToler_Set = 244,
	primary_inverter_l_rcv_source_id195_5Ch_Rotor_Signals = 92,
	primary_inverter_l_rcv_source_id195_D1h_Var_1 = 209,
	primary_inverter_l_rcv_source_id195_D2h_Var_2 = 210,
	primary_inverter_l_rcv_source_id195_D3h_Var_3 = 211,
	primary_inverter_l_rcv_source_id195_D4h_Var_4 = 212,
	primary_inverter_l_rcv_source_id195_D5h_Ain_In_1 = 213,
	primary_inverter_l_rcv_source_id195_D6h_Ain_In_2 = 214,
	primary_inverter_l_rcv_source_id195_42h_MotorPos_Mech = 66,
	primary_inverter_l_rcv_source_id195_43h_MotorPos_Elec = 67,
	primary_inverter_l_rcv_source_id195_A9h_I3_Adc_Value = 169,
	primary_inverter_l_rcv_source_id195_AAh_I2_Adc_Value = 170,
	primary_inverter_l_rcv_source_id195_54h_I1_Actual = 84,
	primary_inverter_l_rcv_source_id195_55h_I2_Actual = 85,
	primary_inverter_l_rcv_source_id195_56h_I3_Actual = 86,
	primary_inverter_l_rcv_source_id195_27h_Iq_Actual = 39,
	primary_inverter_l_rcv_source_id195_28h_Id_Actual = 40,
	primary_inverter_l_rcv_source_id195_38h_Iq_Error = 56,
	primary_inverter_l_rcv_source_id195_39h_Id_Error = 57,
	primary_inverter_l_rcv_source_id195_23h_Id_Ref = 35,
	primary_inverter_l_rcv_source_id195_B5h_Id_Min = 181,
	primary_inverter_l_rcv_source_id195_61h_Ixt_Monitor = 97,
	primary_inverter_l_rcv_source_id195_48h_I_Limit_Inuse = 72,
	primary_inverter_l_rcv_source_id195_57h_I_Limit_Inuse_ramp_ = 87,
	primary_inverter_l_rcv_source_id195_FBh_Ain_1_Calc = 251,
	primary_inverter_l_rcv_source_id195_FCh_Ain_2_Calc = 252,
	primary_inverter_l_rcv_source_id195_29h_Vq_Output = 41,
	primary_inverter_l_rcv_source_id195_2Ah_Vd_Output = 42,
	primary_inverter_l_rcv_source_id195_8Ah_V_Output = 138,
	primary_inverter_l_rcv_source_id195_8Bh_V_Red_Ref_ = 139,
	primary_inverter_l_rcv_source_id195_8Ch_V_Control_Kp = 140,
	primary_inverter_l_rcv_source_id195_8Dh_V_Control_Ti = 141,
	primary_inverter_l_rcv_source_id195_ACh_PWM_1_5_6_ = 172,
	primary_inverter_l_rcv_source_id195_ADh_PWM_2_3_4_ = 173,
	primary_inverter_l_rcv_source_id195_AEh_PWM_3_1_2_ = 174,
	primary_inverter_l_rcv_source_id195_49h_T_Motor = 73,
	primary_inverter_l_rcv_source_id195_4Ah_T_Igbt = 74,
	primary_inverter_l_rcv_source_id195_4Bh_T_Air_Inside = 75,
	primary_inverter_l_rcv_source_id195_45h_It_Rg_Monitor = 69,
	primary_inverter_l_rcv_source_id195_9Ah_Temp_DEBUG = 154,
	primary_inverter_l_rcv_source_id195_ABh_Logic_Freq = 171,
	primary_inverter_l_rcv_source_id195_B8h_Ptr_1_DEBUG = 184,
	primary_inverter_l_rcv_source_id195_BAh_Ptr_2_DEBUG = 186,
	primary_inverter_l_rcv_source_id195_8Fh_ErrorWarning_Map = 143,
	primary_inverter_l_rcv_source_id195_40h_Status_Map = 64,
	primary_inverter_l_rcv_source_id195_41h_Incr_Delta = 65,
	primary_inverter_l_rcv_source_id195_34h_N_Lim = 52,
	primary_inverter_l_rcv_source_id195_63h_FPGA_Status = 99,
	primary_inverter_l_rcv_source_id195_31h_N_set_dig_ = 49,
	primary_inverter_l_rcv_source_id195_90h_M_set_dig_ = 144,
	primary_inverter_l_rcv_source_id195_A0h_M_out_dig_ = 160,
	primary_inverter_l_rcv_source_id195_6Fh_Pos_Actual_2 = 111,
	primary_inverter_l_rcv_source_id195_98h_Logic_O_Block = 152,
	primary_inverter_l_rcv_source_id195_9Bh_Logic_I_Block = 155,
	primary_inverter_l_rcv_source_id195_02h_SC_Info = 2,
	primary_inverter_l_rcv_source_id195_EBh_Vdc_Bus = 235,
	primary_inverter_l_rcv_source_id195_66h_Vdc_Bus_Filt = 102,
	primary_inverter_l_rcv_source_id195_99h_Info_Timer_Diff = 153,
	primary_inverter_l_rcv_source_id195_A1h_Ballast_cntr = 161,
	primary_inverter_l_rcv_source_id195_51_Kern_Mode_State = 81,
	primary_inverter_l_rcv_source_id195_11h_Control_Status = 17,
} primary_inverter_l_rcv_source_id195;

typedef enum {
	primary_inverter_l_rcv_source_id218_5Dh_N_cmd_int_ = 93,
	primary_inverter_l_rcv_source_id218_32h_N_cmd_ramp_ = 50,
	primary_inverter_l_rcv_source_id218_30h_N_Actual = 48,
	primary_inverter_l_rcv_source_id218_A8h_N_Actual_Filt = 168,
	primary_inverter_l_rcv_source_id218_33h_N_Error = 51,
	primary_inverter_l_rcv_source_id218_26h_I_cmd = 38,
	primary_inverter_l_rcv_source_id218_22h_I_cmd_ramp_ = 34,
	primary_inverter_l_rcv_source_id218_20h_I_Actual = 32,
	primary_inverter_l_rcv_source_id218_5Fh_I_Actual_Filt = 95,
	primary_inverter_l_rcv_source_id218_6Eh_Pos_Destination = 110,
	primary_inverter_l_rcv_source_id218_91h_Pos_cmd = 145,
	primary_inverter_l_rcv_source_id218_6Dh_Pos_Actual = 109,
	primary_inverter_l_rcv_source_id218_70h_Pos_Error = 112,
	primary_inverter_l_rcv_source_id218_74h_Pos_ZeroCapture = 116,
	primary_inverter_l_rcv_source_id218_E4h_DigInput_END_1 = 228,
	primary_inverter_l_rcv_source_id218_E5h_DigInput_END_2 = 229,
	primary_inverter_l_rcv_source_id218_E6h_DigInput_DIN_1 = 230,
	primary_inverter_l_rcv_source_id218_E7h_DigInput_DIN_2 = 231,
	primary_inverter_l_rcv_source_id218_E8h_DigInput_RUN = 232,
	primary_inverter_l_rcv_source_id218_E0h_DigOutput_DOUT_1 = 224,
	primary_inverter_l_rcv_source_id218_E1h_DigOutput_DOUT_2 = 225,
	primary_inverter_l_rcv_source_id218_DEh_DigOutput_DOUT_3 = 222,
	primary_inverter_l_rcv_source_id218_DFh_DigOutput_DOUT_4 = 223,
	primary_inverter_l_rcv_source_id218_E2h_DigOutput_Rdy_BTB = 226,
	primary_inverter_l_rcv_source_id218_E9h_Error_I_Fault = 233,
	primary_inverter_l_rcv_source_id218_EAh_I_Ballast_Act = 234,
	primary_inverter_l_rcv_source_id218_24h_I_Max_Inuse = 36,
	primary_inverter_l_rcv_source_id218_ECh_FB_LossOfSignal = 236,
	primary_inverter_l_rcv_source_id218__Off_ = 0,
	primary_inverter_l_rcv_source_id218_E3h_DigSignal_GO = 227,
	primary_inverter_l_rcv_source_id218_F2h_DigSignal_Brake = 242,
	primary_inverter_l_rcv_source_id218_F3h_DigSignal_Icns = 243,
	primary_inverter_l_rcv_source_id218_F5h_DigSignal_LessN0 = 245,
	primary_inverter_l_rcv_source_id218_F4h_DigSignal_PosToler_Set = 244,
	primary_inverter_l_rcv_source_id218_5Ch_Rotor_Signals = 92,
	primary_inverter_l_rcv_source_id218_D1h_Var_1 = 209,
	primary_inverter_l_rcv_source_id218_D2h_Var_2 = 210,
	primary_inverter_l_rcv_source_id218_D3h_Var_3 = 211,
	primary_inverter_l_rcv_source_id218_D4h_Var_4 = 212,
	primary_inverter_l_rcv_source_id218_D5h_Ain_In_1 = 213,
	primary_inverter_l_rcv_source_id218_D6h_Ain_In_2 = 214,
	primary_inverter_l_rcv_source_id218_42h_MotorPos_Mech = 66,
	primary_inverter_l_rcv_source_id218_43h_MotorPos_Elec = 67,
	primary_inverter_l_rcv_source_id218_A9h_I3_Adc_Value = 169,
	primary_inverter_l_rcv_source_id218_AAh_I2_Adc_Value = 170,
	primary_inverter_l_rcv_source_id218_54h_I1_Actual = 84,
	primary_inverter_l_rcv_source_id218_55h_I2_Actual = 85,
	primary_inverter_l_rcv_source_id218_56h_I3_Actual = 86,
	primary_inverter_l_rcv_source_id218_27h_Iq_Actual = 39,
	primary_inverter_l_rcv_source_id218_28h_Id_Actual = 40,
	primary_inverter_l_rcv_source_id218_38h_Iq_Error = 56,
	primary_inverter_l_rcv_source_id218_39h_Id_Error = 57,
	primary_inverter_l_rcv_source_id218_23h_Id_Ref = 35,
	primary_inverter_l_rcv_source_id218_B5h_Id_Min = 181,
	primary_inverter_l_rcv_source_id218_61h_Ixt_Monitor = 97,
	primary_inverter_l_rcv_source_id218_48h_I_Limit_Inuse = 72,
	primary_inverter_l_rcv_source_id218_57h_I_Limit_Inuse_ramp_ = 87,
	primary_inverter_l_rcv_source_id218_FBh_Ain_1_Calc = 251,
	primary_inverter_l_rcv_source_id218_FCh_Ain_2_Calc = 252,
	primary_inverter_l_rcv_source_id218_29h_Vq_Output = 41,
	primary_inverter_l_rcv_source_id218_2Ah_Vd_Output = 42,
	primary_inverter_l_rcv_source_id218_8Ah_V_Output = 138,
	primary_inverter_l_rcv_source_id218_8Bh_V_Red_Ref_ = 139,
	primary_inverter_l_rcv_source_id218_8Ch_V_Control_Kp = 140,
	primary_inverter_l_rcv_source_id218_8Dh_V_Control_Ti = 141,
	primary_inverter_l_rcv_source_id218_ACh_PWM_1_5_6_ = 172,
	primary_inverter_l_rcv_source_id218_ADh_PWM_2_3_4_ = 173,
	primary_inverter_l_rcv_source_id218_AEh_PWM_3_1_2_ = 174,
	primary_inverter_l_rcv_source_id218_49h_T_Motor = 73,
	primary_inverter_l_rcv_source_id218_4Ah_T_Igbt = 74,
	primary_inverter_l_rcv_source_id218_4Bh_T_Air_Inside = 75,
	primary_inverter_l_rcv_source_id218_45h_It_Rg_Monitor = 69,
	primary_inverter_l_rcv_source_id218_9Ah_Temp_DEBUG = 154,
	primary_inverter_l_rcv_source_id218_ABh_Logic_Freq = 171,
	primary_inverter_l_rcv_source_id218_B8h_Ptr_1_DEBUG = 184,
	primary_inverter_l_rcv_source_id218_BAh_Ptr_2_DEBUG = 186,
	primary_inverter_l_rcv_source_id218_8Fh_ErrorWarning_Map = 143,
	primary_inverter_l_rcv_source_id218_40h_Status_Map = 64,
	primary_inverter_l_rcv_source_id218_41h_Incr_Delta = 65,
	primary_inverter_l_rcv_source_id218_34h_N_Lim = 52,
	primary_inverter_l_rcv_source_id218_63h_FPGA_Status = 99,
	primary_inverter_l_rcv_source_id218_31h_N_set_dig_ = 49,
	primary_inverter_l_rcv_source_id218_90h_M_set_dig_ = 144,
	primary_inverter_l_rcv_source_id218_A0h_M_out_dig_ = 160,
	primary_inverter_l_rcv_source_id218_6Fh_Pos_Actual_2 = 111,
	primary_inverter_l_rcv_source_id218_98h_Logic_O_Block = 152,
	primary_inverter_l_rcv_source_id218_9Bh_Logic_I_Block = 155,
	primary_inverter_l_rcv_source_id218_02h_SC_Info = 2,
	primary_inverter_l_rcv_source_id218_EBh_Vdc_Bus = 235,
	primary_inverter_l_rcv_source_id218_66h_Vdc_Bus_Filt = 102,
	primary_inverter_l_rcv_source_id218_99h_Info_Timer_Diff = 153,
	primary_inverter_l_rcv_source_id218_A1h_Ballast_cntr = 161,
	primary_inverter_l_rcv_source_id218_51_Kern_Mode_State = 81,
	primary_inverter_l_rcv_source_id218_11h_Control_Status = 17,
} primary_inverter_l_rcv_source_id218;

typedef enum {
	primary_inverter_l_rcv_source_id219_5Dh_N_cmd_int_ = 93,
	primary_inverter_l_rcv_source_id219_32h_N_cmd_ramp_ = 50,
	primary_inverter_l_rcv_source_id219_30h_N_Actual = 48,
	primary_inverter_l_rcv_source_id219_A8h_N_Actual_Filt = 168,
	primary_inverter_l_rcv_source_id219_33h_N_Error = 51,
	primary_inverter_l_rcv_source_id219_26h_I_cmd = 38,
	primary_inverter_l_rcv_source_id219_22h_I_cmd_ramp_ = 34,
	primary_inverter_l_rcv_source_id219_20h_I_Actual = 32,
	primary_inverter_l_rcv_source_id219_5Fh_I_Actual_Filt = 95,
	primary_inverter_l_rcv_source_id219_6Eh_Pos_Destination = 110,
	primary_inverter_l_rcv_source_id219_91h_Pos_cmd = 145,
	primary_inverter_l_rcv_source_id219_6Dh_Pos_Actual = 109,
	primary_inverter_l_rcv_source_id219_70h_Pos_Error = 112,
	primary_inverter_l_rcv_source_id219_74h_Pos_ZeroCapture = 116,
	primary_inverter_l_rcv_source_id219_E4h_DigInput_END_1 = 228,
	primary_inverter_l_rcv_source_id219_E5h_DigInput_END_2 = 229,
	primary_inverter_l_rcv_source_id219_E6h_DigInput_DIN_1 = 230,
	primary_inverter_l_rcv_source_id219_E7h_DigInput_DIN_2 = 231,
	primary_inverter_l_rcv_source_id219_E8h_DigInput_RUN = 232,
	primary_inverter_l_rcv_source_id219_E0h_DigOutput_DOUT_1 = 224,
	primary_inverter_l_rcv_source_id219_E1h_DigOutput_DOUT_2 = 225,
	primary_inverter_l_rcv_source_id219_DEh_DigOutput_DOUT_3 = 222,
	primary_inverter_l_rcv_source_id219_DFh_DigOutput_DOUT_4 = 223,
	primary_inverter_l_rcv_source_id219_E2h_DigOutput_Rdy_BTB = 226,
	primary_inverter_l_rcv_source_id219_E9h_Error_I_Fault = 233,
	primary_inverter_l_rcv_source_id219_EAh_I_Ballast_Act = 234,
	primary_inverter_l_rcv_source_id219_24h_I_Max_Inuse = 36,
	primary_inverter_l_rcv_source_id219_ECh_FB_LossOfSignal = 236,
	primary_inverter_l_rcv_source_id219__Off_ = 0,
	primary_inverter_l_rcv_source_id219_E3h_DigSignal_GO = 227,
	primary_inverter_l_rcv_source_id219_F2h_DigSignal_Brake = 242,
	primary_inverter_l_rcv_source_id219_F3h_DigSignal_Icns = 243,
	primary_inverter_l_rcv_source_id219_F5h_DigSignal_LessN0 = 245,
	primary_inverter_l_rcv_source_id219_F4h_DigSignal_PosToler_Set = 244,
	primary_inverter_l_rcv_source_id219_5Ch_Rotor_Signals = 92,
	primary_inverter_l_rcv_source_id219_D1h_Var_1 = 209,
	primary_inverter_l_rcv_source_id219_D2h_Var_2 = 210,
	primary_inverter_l_rcv_source_id219_D3h_Var_3 = 211,
	primary_inverter_l_rcv_source_id219_D4h_Var_4 = 212,
	primary_inverter_l_rcv_source_id219_D5h_Ain_In_1 = 213,
	primary_inverter_l_rcv_source_id219_D6h_Ain_In_2 = 214,
	primary_inverter_l_rcv_source_id219_42h_MotorPos_Mech = 66,
	primary_inverter_l_rcv_source_id219_43h_MotorPos_Elec = 67,
	primary_inverter_l_rcv_source_id219_A9h_I3_Adc_Value = 169,
	primary_inverter_l_rcv_source_id219_AAh_I2_Adc_Value = 170,
	primary_inverter_l_rcv_source_id219_54h_I1_Actual = 84,
	primary_inverter_l_rcv_source_id219_55h_I2_Actual = 85,
	primary_inverter_l_rcv_source_id219_56h_I3_Actual = 86,
	primary_inverter_l_rcv_source_id219_27h_Iq_Actual = 39,
	primary_inverter_l_rcv_source_id219_28h_Id_Actual = 40,
	primary_inverter_l_rcv_source_id219_38h_Iq_Error = 56,
	primary_inverter_l_rcv_source_id219_39h_Id_Error = 57,
	primary_inverter_l_rcv_source_id219_23h_Id_Ref = 35,
	primary_inverter_l_rcv_source_id219_B5h_Id_Min = 181,
	primary_inverter_l_rcv_source_id219_61h_Ixt_Monitor = 97,
	primary_inverter_l_rcv_source_id219_48h_I_Limit_Inuse = 72,
	primary_inverter_l_rcv_source_id219_57h_I_Limit_Inuse_ramp_ = 87,
	primary_inverter_l_rcv_source_id219_FBh_Ain_1_Calc = 251,
	primary_inverter_l_rcv_source_id219_FCh_Ain_2_Calc = 252,
	primary_inverter_l_rcv_source_id219_29h_Vq_Output = 41,
	primary_inverter_l_rcv_source_id219_2Ah_Vd_Output = 42,
	primary_inverter_l_rcv_source_id219_8Ah_V_Output = 138,
	primary_inverter_l_rcv_source_id219_8Bh_V_Red_Ref_ = 139,
	primary_inverter_l_rcv_source_id219_8Ch_V_Control_Kp = 140,
	primary_inverter_l_rcv_source_id219_8Dh_V_Control_Ti = 141,
	primary_inverter_l_rcv_source_id219_ACh_PWM_1_5_6_ = 172,
	primary_inverter_l_rcv_source_id219_ADh_PWM_2_3_4_ = 173,
	primary_inverter_l_rcv_source_id219_AEh_PWM_3_1_2_ = 174,
	primary_inverter_l_rcv_source_id219_49h_T_Motor = 73,
	primary_inverter_l_rcv_source_id219_4Ah_T_Igbt = 74,
	primary_inverter_l_rcv_source_id219_4Bh_T_Air_Inside = 75,
	primary_inverter_l_rcv_source_id219_45h_It_Rg_Monitor = 69,
	primary_inverter_l_rcv_source_id219_9Ah_Temp_DEBUG = 154,
	primary_inverter_l_rcv_source_id219_ABh_Logic_Freq = 171,
	primary_inverter_l_rcv_source_id219_B8h_Ptr_1_DEBUG = 184,
	primary_inverter_l_rcv_source_id219_BAh_Ptr_2_DEBUG = 186,
	primary_inverter_l_rcv_source_id219_8Fh_ErrorWarning_Map = 143,
	primary_inverter_l_rcv_source_id219_40h_Status_Map = 64,
	primary_inverter_l_rcv_source_id219_41h_Incr_Delta = 65,
	primary_inverter_l_rcv_source_id219_34h_N_Lim = 52,
	primary_inverter_l_rcv_source_id219_63h_FPGA_Status = 99,
	primary_inverter_l_rcv_source_id219_31h_N_set_dig_ = 49,
	primary_inverter_l_rcv_source_id219_90h_M_set_dig_ = 144,
	primary_inverter_l_rcv_source_id219_A0h_M_out_dig_ = 160,
	primary_inverter_l_rcv_source_id219_6Fh_Pos_Actual_2 = 111,
	primary_inverter_l_rcv_source_id219_98h_Logic_O_Block = 152,
	primary_inverter_l_rcv_source_id219_9Bh_Logic_I_Block = 155,
	primary_inverter_l_rcv_source_id219_02h_SC_Info = 2,
	primary_inverter_l_rcv_source_id219_EBh_Vdc_Bus = 235,
	primary_inverter_l_rcv_source_id219_66h_Vdc_Bus_Filt = 102,
	primary_inverter_l_rcv_source_id219_99h_Info_Timer_Diff = 153,
	primary_inverter_l_rcv_source_id219_A1h_Ballast_cntr = 161,
	primary_inverter_l_rcv_source_id219_51_Kern_Mode_State = 81,
	primary_inverter_l_rcv_source_id219_11h_Control_Status = 17,
} primary_inverter_l_rcv_source_id219;

typedef enum {
	primary_inverter_l_rcv_motortype_EC_Servo = 0,
	primary_inverter_l_rcv_motortype_ACI_V_f = 1,
	primary_inverter_l_rcv_motortype_ACI_Servo = 2,
	primary_inverter_l_rcv_motortype_DC = 3,
} primary_inverter_l_rcv_motortype;

typedef enum {
	primary_inverter_l_rcv_cs_cmd_type_Digital_Commands = 0,
	primary_inverter_l_rcv_cs_cmd_type_Dig_Ana_Speed = 1,
	primary_inverter_l_rcv_cs_cmd_type_Analog_Speed = 2,
	primary_inverter_l_rcv_cs_cmd_type_Analog_Torque = 3,
} primary_inverter_l_rcv_cs_cmd_type;

typedef enum {
	primary_inverter_l_rcv_currentmode_PWM_FIX = 0,
	primary_inverter_l_rcv_currentmode_BOTTOM_W = 1,
	primary_inverter_l_rcv_currentmode_BOTTOM_V = 2,
	primary_inverter_l_rcv_currentmode_BOTTOM_U = 3,
	primary_inverter_l_rcv_currentmode_DEFINE_CMD = 4,
	primary_inverter_l_rcv_currentmode_CURRENT_RAMP = 5,
} primary_inverter_l_rcv_currentmode;

typedef enum {
	primary_inverter_l_rcv_mo_sc2_reso_14_bit = 1,
	primary_inverter_l_rcv_mo_sc2_reso_12_bit = 2,
	primary_inverter_l_rcv_mo_sc2_reso_10_bit = 3,
} primary_inverter_l_rcv_mo_sc2_reso;

typedef enum {
	primary_inverter_l_rcv_active190_Low = 0,
	primary_inverter_l_rcv_active190_High = 1,
} primary_inverter_l_rcv_active190;

typedef enum {
	primary_inverter_l_rcv_active191_Low = 0,
	primary_inverter_l_rcv_active191_High = 1,
} primary_inverter_l_rcv_active191;

typedef enum {
	primary_inverter_l_rcv_active192_Low = 0,
	primary_inverter_l_rcv_active192_High = 1,
} primary_inverter_l_rcv_active192;

typedef enum {
	primary_inverter_l_rcv_active193_Low = 0,
	primary_inverter_l_rcv_active193_High = 1,
} primary_inverter_l_rcv_active193;

typedef enum {
	primary_inverter_l_rcv_pwm_freq_8_kHz = 0,
	primary_inverter_l_rcv_pwm_freq_24_kHz = 1,
	primary_inverter_l_rcv_pwm_freq_20_kHz = 2,
	primary_inverter_l_rcv_pwm_freq_16_kHz = 3,
	primary_inverter_l_rcv_pwm_freq_12_kHz = 4,
	primary_inverter_l_rcv_pwm_freq_8_kHz_i16 = 5,
	primary_inverter_l_rcv_pwm_freq_6_kHz_i12 = 6,
	primary_inverter_l_rcv_pwm_freq_4_kHz_i12 = 7,
} primary_inverter_l_rcv_pwm_freq;

typedef enum {
	primary_set_tlm_status_tlm_status_OFF = 0,
	primary_set_tlm_status_tlm_status_ON = 1,
} primary_set_tlm_status_tlm_status;

typedef enum {
	primary_tlm_status_tlm_status_OFF = 0,
	primary_tlm_status_tlm_status_ON = 1,
} primary_tlm_status_tlm_status;

typedef enum {
	primary_hv_can_forward_can_forward_set_OFF = 0,
	primary_hv_can_forward_can_forward_set_ON = 1,
} primary_hv_can_forward_can_forward_set;

typedef enum {
	primary_hv_fans_override_fans_override_OFF = 0,
	primary_hv_fans_override_fans_override_ON = 1,
} primary_hv_fans_override_fans_override;

typedef enum {
	primary_hv_can_forward_status_can_forward_status_OFF = 0,
	primary_hv_can_forward_status_can_forward_status_ON = 1,
} primary_hv_can_forward_status_can_forward_status;

typedef enum {
	primary_hv_fans_override_status_fans_override_OFF = 0,
	primary_hv_fans_override_status_fans_override_ON = 1,
} primary_hv_fans_override_status_fans_override;

typedef enum {
	primary_hv_imd_status_imd_status_IMD_SC = 0,
	primary_hv_imd_status_imd_status_IMD_NORMAL = 1,
	primary_hv_imd_status_imd_status_IMD_UNDER_VOLTAGE = 2,
	primary_hv_imd_status_imd_status_IMD_START_MEASURE = 3,
	primary_hv_imd_status_imd_status_IMD_DEVICE_ERROR = 4,
	primary_hv_imd_status_imd_status_IMD_EARTH_FAULT = 5,
} primary_hv_imd_status_imd_status;

typedef enum {
	primary_ts_status_das_ts_status_OFF = 0,
	primary_ts_status_das_ts_status_PRECHARGE = 1,
	primary_ts_status_das_ts_status_ON = 2,
	primary_ts_status_das_ts_status_FATAL = 3,
} primary_ts_status_das_ts_status;

typedef enum {
	primary_ts_status_steer_ts_status_OFF = 0,
	primary_ts_status_steer_ts_status_PRECHARGE = 1,
	primary_ts_status_steer_ts_status_ON = 2,
	primary_ts_status_steer_ts_status_FATAL = 3,
} primary_ts_status_steer_ts_status;

typedef enum {
	primary_ts_status_handcart_ts_status_OFF = 0,
	primary_ts_status_handcart_ts_status_PRECHARGE = 1,
	primary_ts_status_handcart_ts_status_ON = 2,
	primary_ts_status_handcart_ts_status_FATAL = 3,
} primary_ts_status_handcart_ts_status;

typedef enum {
	primary_set_ts_status_das_ts_status_set_OFF = 0,
	primary_set_ts_status_das_ts_status_set_ON = 1,
} primary_set_ts_status_das_ts_status_set;

typedef enum {
	primary_set_ts_status_handcart_ts_status_set_OFF = 0,
	primary_set_ts_status_handcart_ts_status_set_ON = 1,
} primary_set_ts_status_handcart_ts_status_set;

typedef enum {
	primary_set_car_status_car_status_set_IDLE = 0,
	primary_set_car_status_car_status_set_READY = 1,
	primary_set_car_status_car_status_set_DRIVE = 2,
} primary_set_car_status_car_status_set;

typedef enum {
	primary_set_pedals_range_bound_SET_MAX = 0,
	primary_set_pedals_range_bound_SET_MIN = 1,
} primary_set_pedals_range_bound;

typedef enum {
	primary_set_pedals_range_pedal_ACCELERATOR = 0,
	primary_set_pedals_range_pedal_BRAKE = 1,
} primary_set_pedals_range_pedal;

typedef enum {
	primary_set_steering_angle_range_bound_SET_MAX = 0,
	primary_set_steering_angle_range_bound_SET_MIN = 1,
} primary_set_steering_angle_range_bound;

typedef enum {
	primary_car_status_inverter_l_OFF = 0,
	primary_car_status_inverter_l_IDLE = 1,
	primary_car_status_inverter_l_ON = 2,
} primary_car_status_inverter_l;

typedef enum {
	primary_car_status_inverter_r_OFF = 0,
	primary_car_status_inverter_r_IDLE = 1,
	primary_car_status_inverter_r_ON = 2,
} primary_car_status_inverter_r;

typedef enum {
	primary_car_status_car_status_IDLE = 0,
	primary_car_status_car_status_PRE_SETUP = 1,
	primary_car_status_car_status_TS_ON = 2,
	primary_car_status_car_status_POST_SETUP = 3,
	primary_car_status_car_status_DRIVE = 4,
	primary_car_status_car_status_TEARDOWN = 5,
} primary_car_status_car_status;

typedef enum {
	primary_set_inverter_connection_status_status_OFF = 0,
	primary_set_inverter_connection_status_status_ON = 1,
} primary_set_inverter_connection_status_status;

typedef enum {
	primary_inverter_connection_status_status_OFF = 0,
	primary_inverter_connection_status_status_ON = 1,
} primary_inverter_connection_status_status;

typedef enum {
	primary_hv_cell_balancing_status_balancing_status_OFF = 0,
	primary_hv_cell_balancing_status_balancing_status_ON = 1,
} primary_hv_cell_balancing_status_balancing_status;

typedef enum {
	primary_set_cell_balancing_status_set_balancing_status_OFF = 0,
	primary_set_cell_balancing_status_set_balancing_status_ON = 1,
} primary_set_cell_balancing_status_set_balancing_status;

/**
 * Signals in message Inverter_L_Send.
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_send_send_mux send_mux;

    /**
     * Nominal Motor Frequency
     *
     * Range: 0..65535 (0..6553.5 Hz)
     * Scale: 0.1
     * Offset: 0
     */
    uint16_t motor_f_n;

    /**
     * Time For DC Pre-Charge-Magnitising - Start
     *
     * Range: 0..65535 (0..65535 ms)
     * Scale: 1
     * Offset: 0
     */
    uint16_t t_dc__start;

    /**
     * DC Voltage for Pre-Magnitization - Start
     *
     * Range: -32768..32767 (-3276.8..3276.7 %)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t v_dc__start;

    /**
     * FU Special - Start
     *
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t special__start;

    /**
     * Minimum Voltage (FU operation) at Start
     *
     * Range: -32768..32767 (-3276.8..3276.7 %)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t v_min__start;

    /**
     * Minimum Frequency (FU operation) at Start
     *
     * Range: -32768..32767 (-3276.8..3276.7 Hz)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t f_min__start;

    /**
     * Voltage (percentage of DC-Bus) at max. Frequency
     *
     * Range: -32768..32767 (-3276.8..3276.7 %)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t v_corner__start;

    /**
     * Frequency at max output voltage - Start
     *
     * Range: -32768..32767 (-3276.8..3276.7 Hz)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t f_corner__start;

    /**
     * Motor Power Factor
     *
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t cos_phi;

    /**
     * FU Extra - Start
     *
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t extra__start;

    /**
     * NDrive Oszillloscop - Capture Channel
     *
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t capture_channel;

    /**
     * NDrive Oszillloscop - Capture Trigger Edge
     *
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t trig_level;

    /**
     * NDrive Oszillloscop - Capture Trigger Level
     *
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t trig_edge;

    /**
     * NDrive Oszillloscop - Capture Trigger Source
     *
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t trig_source;

    /**
     * NDrive Oszillloscop - Capture Source
     *
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t oszi_source;

    /**
     * NDrive Oszillloscop - Capture Skip
     *
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t oszi_skip;

    /**
     * NDrive Oszillloscop - Read Command
     *
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t oszi_read_cmd;

    /**
     * NDrive Oszillloscop - Run Command
     *
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t oszi_run_cmd;

    /**
     * Entry for the Reference Value used for various Calibrations
     *
     * Range: 0..65535 (0..6553.5 -)
     * Scale: 0.1
     * Offset: 0
     */
    uint16_t calib_ref_value;

    /**
     * Proportional Gain Iq-Current Controller - A entry 33 equals 1.0 normalized
     *
     * Range: 0..200 (0..200 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pid_i__kp__iq;

    /**
     * Integral Action Time (Integral Part) Iq-Current Controller
     *
     * Range: 300..20000 (300..20000 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pid_i__ti__iq;

    /**
     * Digital Cutoff area of incomming digital commands
     *
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t cutoffdig;

    /**
     * Digital numerical Id-Current Command - input
     *
     * Range: -32768..32767 (-12249.91571968..12249.54188192 Arms)
     * Scale: 0.37383776
     * Offset: 0
     */
    int16_t id_setdig__id;

    /**
     * Final Current Ramp Step setting
     *
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t i_delta_ramp;

    /**
     * Iq-Current Control Integral Maximum Output Range
     *
     * Range: 0..500 (0..500 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pid_i__tim__iq;

    /**
     * Proportional Gain Speed Controller
     *
     * Range: 0..200 (0..200 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pid_n__kp;

    /**
     * Integral Action Time (Integral Part) Speed Controller
     *
     * Range: 0..10000 (0..10000 ms)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pid_n__ti;

    /**
     * Derative Action Time (Derative Part) Speed Controller
     *
     * Range: 0..10000 (0..10000 ms)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pid_n__td;

    /**
     * Analog Input Signal 1 - Offset Value Setting
     *
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t ain_in_1_offsetval;

    /**
     * Digital numerical Speed Command - input
     *
     * Range: -32766.99999691205638057269621..32766.99999691205638057269621 (-7100..7100 Num)
     * Scale: 0.2166814173
     * Offset: 0
     */
    int16_t n_setdig;

    /**
     * Speed n Limit - Percentage as 15 Bit entry format (32767 equal 100perc)
     *
     * Range: -32766.99943739061966000306044..32766.99943739061966000306044 (-100..100 %)
     * Scale: 0.003051851
     * Offset: 0
     */
    int16_t n_lim;

    /**
     * Speed Ramp Acc Time [0..30000 ms]
     *
     * Range: 0..30000 (0..30000 ms)
     * Scale: 1
     * Offset: 0
     */
    uint16_t n_r_acc;

    /**
     * Command Source Mask - Analog 1 Format Bits
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_send_cs_ain_1_format cs_ain_1_format;

    /**
     * Speed Control Integral Maximum Output Range
     *
     * Range: 0..100 (0..100 %)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pid_n__tim;

    /**
     * Current reduction by rotation speed - Percentage as 15 Bit entry format (32767 equal 100perc)
     *
     * Range: 0..32766.99943739061966000306044 (0..100 %)
     * Scale: 0.003051851
     * Offset: 0
     */
    uint16_t i_red_n;

    /**
     * Speed n Limit minus - Percentage as 15 Bit entry format (-32767 equal -100perc)
     *
     * Range: -32766.99943739061966000306044..0 (-100..0 %)
     * Scale: 0.003051851
     * Offset: 0
     */
    int16_t n_lim_minus;

    /**
     * Speed n Limit plus - Percentage as 15 Bit entry format (32767 equal 100perc)
     *
     * Range: 0..32766.99943739061966000306044 (0..100 %)
     * Scale: 0.003051851
     * Offset: 0
     */
    int16_t n_lim_plus;

    /**
     * FeedBack Offset Angle Value
     *
     * Range: -3600..3600 (-360..360 -)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t fb_offset;

    /**
     * Global ID for Read Command 0x3D in Get_Value
     *
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_send_read_id read_id;

    /**
     * Derating Reduction to percentage Value - Trigger is Dig Input - Percentage as 15 Bit entry format (32767 equal 100perc)
     *
     * Range: 0..32766.99943739061966000306044 (0..100 %)
     * Scale: 0.003051851
     * Offset: 0
     */
    int16_t i_lim_dig;

    /**
     * Stop of current reduction by power stage temperature
     *
     * Range: 0..32767 (0..32767 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t i_red_te;

    /**
     * Motor Maximum Effective Peak Current
     *
     * Range: 0..32767 (0..3276.7 Arms)
     * Scale: 0.1
     * Offset: 0
     */
    uint16_t i_max_eff;

    /**
     * Motor Nominal Effective Current
     *
     * Range: 0..65535 (0..6553.5 0,1)
     * Scale: 0.1
     * Offset: 0
     */
    uint16_t i_nom_eff;

    /**
     * Motor Pole Number
     *
     * Range: 2..96 (2..96 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t motor_pole;

    /**
     * Analog Input Signal 1 - Cutoff Value Setting
     *
     * Range: 0..32767 (0..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t ain_in_1_cutoff;

    /**
     * Kern Mode State Bit - rsvd_0
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t km_rsvd_0;

    /**
     * Analog Input Signal 2 - Cutoff Value Setting
     *
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t ain_in_2_cutoff;

    /**
     * Start of current reduction by power stage temperature
     *
     * Range: 0..32767 (0..32767 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t i_red_td;

    /**
     * Motor Nominal Rotation Speed
     *
     * Range: 60..65000 (60..65000 rpm)
     * Scale: 1
     * Offset: 0
     */
    uint16_t n_nom;

    /**
     * Analoge Zwischenkreismessung geht in Uout ein
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dc_bus_comp;

    /**
     * Speed Control Acceleration Feed Foreward Gain
     *
     * Range: 0..100 (0..100 %)
     * Scale: 1
     * Offset: 0
     */
    int16_t pid_n__kacc;

    /**
     * Additional Filter Adjustment of the Rotation Speed Measurement
     *
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t speed_filter;

    /**
     * Analog Input Signal 1 - Filter Value Setting
     *
     * Range: 0..255 (0..127.5 ms)
     * Scale: 0.5
     * Offset: 0
     */
    uint8_t ain_in_1_filter;

    /**
     * Device Serial Number
     *
     * Range: 0..4294967295 (0..4294967295 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t snr;

    /**
     * Device Mains Supply Voltage Value
     *
     * Range: 0..1000 (0..1000 V)
     * Scale: 1
     * Offset: 0
     */
    uint16_t device_mains;

    /**
     * Regenerative Resistor Power Value
     *
     * Range: 25..10000 (25..10000 W)
     * Scale: 1
     * Offset: 0
     */
    uint16_t regen_p;

    /**
     * Coding Signal defining various device types
     *
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_send_devicetype devicetype;

    /**
     * CAN Identiciation ID for Receive - Rx
     *
     * Range: 0..65530 (0..65530 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t can_id_rx;

    /**
     * CAN Identiciation ID for Transmit - Tx
     *
     * Range: 0..65530 (0..65530 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t can_id_tx;

    /**
     * Proportional Gain Position Controller
     *
     * Range: 0..500 (0..500 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pos_kp;

    /**
     * Integral Action Time (Integral Part) Position Controller
     *
     * Range: 0..10000 (0..10000 ms)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pos_ti;

    /**
     * Derative Action Time (Derative Part) Position Controller
     *
     * Range: 0..65535 (0..65535 ms)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pos_td;

    /**
     * Numeric Destination Position Value
     *
     * Range: -2147483648..2147483647 (-2147483648..2147483647 -)
     * Scale: 1
     * Offset: 0
     */
    int32_t pos_dest;

    /**
     * Position Control Integral Maximum Output Range
     *
     * Range: 0..100 (0..100 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pos_tim;

    /**
     * Numeric Position Zero Offset Value
     *
     * Range: -2147483648..2147483647 (-2147483648..2147483647 -)
     * Scale: 1
     * Offset: 0
     */
    int32_t pos_offsref;

    /**
     * CAN BaudRate Configuration Setting
     *
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_send_can_nbt can_nbt;

    /**
     * Resolver Position at Reference Switch (Rsw)
     *
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t ref_reso_edge;

    /**
     * Position Reference Speed 1 (Fast)
     *
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t speed_1;

    /**
     * Position Reference Speed 1 (Slow) + Phasing electrical Rotation Speed
     *
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t speed_2;

    /**
     * Tolerance Window for Destination Position
     *
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t pos_tol_win;

    /**
     * Numeric Preset Position Value (Set actual Position to Preset Position)
     *
     * Range: -2147483648..2147483647 (-2147483648..2147483647 -)
     * Scale: 1
     * Offset: 0
     */
    int32_t pos_preset_val;

    /**
     * NDrive Position Display Scale Factor
     *
     * Range: -2147483648..2147483647 (-2147483648..2147483647 -)
     * Scale: 1
     * Offset: 0
     */
    int32_t pos_nd_scale;

    /**
     * NDrive Position Display Offset Factor
     *
     * Range: -2147483648..2147483647 (-2147483648..2147483647 -)
     * Scale: 1
     * Offset: 0
     */
    int32_t pos_nd_offset;

    /**
     * Feedback 2 - External Scale Factor
     *
     * Range: -2147483648..2147483647 (-2147483648..2147483647 -)
     * Scale: 1
     * Offset: 0
     */
    int32_t fb2_scale_ext;

    /**
     * Position Offset Slack Value
     *
     * Range: -2147483648..2147483647 (-2147483648..2147483647 -)
     * Scale: 1
     * Offset: 0
     */
    int32_t pos_offset_slack;

    /**
     * Position Difference Slack Value
     *
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t pos_diff_slack;

    /**
     * Range: 0..2 (0..2 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_send_eprom131 eprom131;

    /**
     * Range: 0..2 (0..2 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_send_eprom132 eprom132;

    /**
     * Special Functions for automatic logics or calculations
     *
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t fun_special;

    /**
     * CAN Identiciation ID - 2 - for Receive - Rx
     *
     * Range: 0..4294967295 (0..4294967295 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t can_id_2_rx;

    /**
     * CAN Identiciation ID - 2 - for Transmit - Tx
     *
     * Range: 0..4294967295 (0..4294967295 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t can_id_2_tx;

    /**
     * Voltage Controller Reference value in perc of Vout (V_Red - Start of Field Reduction)
     *
     * Range: -32768..32767 (-32768..32767 %)
     * Scale: 1
     * Offset: 0
     */
    int16_t v_ref;

    /**
     * Proportional Gain Voltage Controller (0.0001 * Ti equals 1.0)
     *
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t v_kp;

    /**
     * Integral Action Time (Integral Part) Voltage Controller (0.0001 x Ti equals 1.0)
     *
     * Range: 0..65535 (0..65535 ms)
     * Scale: 1
     * Offset: 0
     */
    uint16_t v_ti;

    /**
     * Clear Errors. Just send a value of 0 to this ID Address
     *
     * Range: 1..1 (1..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t clear_errors;

    /**
     * Digital numerical Iq-Current Command - input
     *
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t m_setdig__iq;

    /**
     * Current reduction by motor temperature
     *
     * Range: 0..32767 (0..32767 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t i_red_tm;

    /**
     * Motor Temperature Limit for Inverter Error shutdown
     *
     * Range: 0..32767 (0..32767 Num)
     * Scale: 1
     * Offset: 0
     */
    uint16_t m_temp;

    /**
     * Motor Options - Feedback 1 Type
     *
     * Range: 0..31 (0..31 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_send_mo_feedback_1 mo_feedback_1;

    /**
     * DC Bus Min Value Superpision Limit
     *
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t dc_bus_min_lim;

    /**
     * Feedback System Increments per rotation
     *
     * Range: 0..65535 (0..65535 Inc/Rev)
     * Scale: 1
     * Offset: 0
     */
    uint16_t fb_incr_mot;

    /**
     * Feedback Pole number
     *
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t fb_pole;

    /**
     * Motor - Stator Leakage Inductance - Lsq
     *
     * Range: 0..65535 (0..65.535 mH)
     * Scale: 0.001
     * Offset: 0
     */
    uint16_t motor_lsq;

    /**
     * Nominal Magnetising d-Current value as perc of nominal current
     *
     * Range: -32768..32767 (-32768..32767 %)
     * Scale: 1
     * Offset: 0
     */
    int16_t id_nom;

    /**
     * Motor - Magnetizing Inductance - L
     *
     * Range: 0..65535 (0..655.35 mH)
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t motor_lm;

    /**
     * Motor - Rotor Resistance Value
     *
     * Range: 0..65535 (0..65535 mOhm)
     * Scale: 1
     * Offset: 0
     */
    uint16_t motor_rr;

    /**
     * Minimum Magnetising d-Current value as perc of nominal current
     *
     * Range: 0..100 (0..100 %)
     * Scale: 1
     * Offset: 0
     */
    int16_t id_min;

    /**
     * Rotor Time Contant of the Motor
     *
     * Range: -32768..32767 (-32768..32767 ms)
     * Scale: 1
     * Offset: 0
     */
    int16_t motor_tr;

    /**
     * Motor Leakage Inductance ph-ph - Lsd
     *
     * Range: 0..65535 (0..65.535 mH)
     * Scale: 0.001
     * Offset: 0
     */
    uint16_t motor_lsd;

    /**
     * Motor - Stator Resistance Value
     *
     * Range: 0..65535 (0..65535 mOhm)
     * Scale: 1
     * Offset: 0
     */
    uint16_t motor_rs;

    /**
     * Stator Time Contant of the Motor
     *
     * Range: -32768..32767 (-32.768..32.767 ms)
     * Scale: 0.001
     * Offset: 0
     */
    int16_t motor_ts;

    /**
     * Definition - Function attribution of the Digital Input - END 1 (Limit 1)
     *
     * Range: 0..32767 (0..32767 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_send_def_end_1 def_end_1;

    /**
     * Definition - Function attribution of the Digital Input - END 2 (Limit 2)
     *
     * Range: 0..32767 (0..32767 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_send_def_end_2 def_end_2;

    /**
     * Definition - Function attribution of the Digital Input - DIN 1
     *
     * Range: 0..32767 (0..32767 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_send_def_din_1 def_din_1;

    /**
     * Definition - Function attribution of the Digital Input - DIN 2
     *
     * Range: 0..32767 (0..32767 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_send_def_din_2 def_din_2;

    /**
     * Selection List Operant for digital Output OUT 1
     *
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_send_operand194 operand194;

    /**
     * Selection List Operant for digital Output OUT 2
     *
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_send_operand195 operand195;

    /**
     * Selection List Operant for digital Output OUT 3
     *
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_send_operand218 operand218;

    /**
     * Selection List Operant for digital Output OUT 4
     *
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_send_operand219 operand219;

    /**
     * Max. Device Current (A) settings via percentage entry - Percentage as 13 Bit entry format (16383 equal 100perc)
     *
     * Range: 0..16382.99999132683980459157101 (0..100 %)
     * Scale: 0.00610388818
     * Offset: 0
     */
    uint16_t i_max_pk;

    /**
     * Continuous Device Current (Arms) settings via percentage entry - Percentage as 13 Bit entry format (16383 is equal 100perc)
     *
     * Range: 0..16382.99999132683980459157101 (0..100 %)
     * Scale: 0.00610388818
     * Offset: 0
     */
    uint16_t i_con_eff;

    /**
     * Set device define for continuous current
     *
     * Range: 0..65535 (0..6553.5 A)
     * Scale: 0.1
     * Offset: 0
     */
    uint16_t i_device;

    /**
     * Emergency Stopping Ramp Time [0..1000 ms]
     *
     * Range: 0..1000 (0..1000 ms)
     * Scale: 1
     * Offset: 0
     */
    uint16_t n_r_lim;

    /**
     * Maximum Speed Value for Resolution of 16Bit
     *
     * Range: -32768..32767 (-32768..32767 rpm)
     * Scale: 1
     * Offset: 0
     */
    int16_t nmax100perc;

    /**
     * Proportional Gain Iq-Current Controller if actual current is above I Limit Inuse Current - perc is depending on Kp value
     *
     * Range: 0..200 (0..200 %)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pid_i__xkp__iq;

    /**
     * Idc or Pdc Limit during Motor operation
     *
     * Range: 0..65535 (0..6553.5 A or W)
     * Scale: 0.1
     * Offset: 0
     */
    uint16_t bat_opr_limit__mot;

    /**
     * Feedforward - Proportional Gain Iq-Current Controller
     *
     * Range: 0..200 (0..200 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pid_i__kf__iq;

    /**
     * Enable the use of the DC current Sensor (if present)
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cmc__bit0__dc_current_sens_ena;

    /**
     * CAN Timeout time settings
     *
     * Range: 0..32767 (0..32767 ms)
     * Scale: 1
     * Offset: 0
     */
    int16_t can_rxtimeout;

    /**
     * Comparison Variable 1
     *
     * Range: -2147483648..2147483647 (-2147483648..2147483647 -)
     * Scale: 1
     * Offset: 0
     */
    int32_t var_1;

    /**
     * Comparison Variable 2
     *
     * Range: -2147483648..2147483647 (-2147483648..2147483647 -)
     * Scale: 1
     * Offset: 0
     */
    int32_t var_2;

    /**
     * Comparison Variable 3
     *
     * Range: -2147483648..2147483647 (-2147483648..2147483647 -)
     * Scale: 1
     * Offset: 0
     */
    int32_t var_3;

    /**
     * Comparison Variable 4
     *
     * Range: -2147483648..2147483647 (-2147483648..2147483647 -)
     * Scale: 1
     * Offset: 0
     */
    int32_t var_4;

    /**
     * Analog Input Signal 2 - Offset Value Setting
     *
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t ain_in_2_offsetval;

    /**
     * DAC Configuration of the RegID Source Channel as Output
     *
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dup__bit7_0__dac_source_channel;

    /**
     * Speed Ramp Dec Time [0..30000 ms]
     *
     * Range: 0..30000 (0..30000 ms)
     * Scale: 1
     * Offset: 0
     */
    uint16_t n_r_dec;

    /**
     * Current Sensor rated voltage
     *
     * Range: 0..65535 (0..65535 mV)
     * Scale: 1
     * Offset: 0
     */
    uint16_t v_shunt;

    /**
     * Allowed Timing for Peak Current
     *
     * Range: 0..65535 (0..65535 s)
     * Scale: 1
     * Offset: 0
     */
    uint16_t t_peak;

    /**
     * Mechanical Brake Delay Time (e.g. Relay)
     *
     * Range: 0..65535 (0..65535 ms)
     * Scale: 1
     * Offset: 0
     */
    uint16_t brake_delay;

    /**
     * Inverter 4 Letter Name define
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t axis;

    /**
     * Kern Mode State Bit -
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t km_speed_0;

    /**
     * Ballast-R extern
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ballast_ext;

    /**
     * Enable the Limitiation Calculation depending on the DC Current limits
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cmc__bit1__idc_limit_ena;

    /**
     * Command Source Mask - Analog 2 Format Bits
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_send_cs_ain_2_format cs_ain_2_format;

    /**
     * Kern Mode State Bit -
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t km_frg_off;

    /**
     * Feedback Speciality
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t fb_special;

    /**
     * Use the DC current Limitiation Calculation depending on the DC Power limits
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cmc__bit2__pdc_limit_usage;

    /**
     * Kern Mode State Bit -
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t km_cal_off;

    /**
     * Coast Stop Activation
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t coaststop;

    /**
     * Enable Init as Torque Mode after Enable (Run)
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cmc__bit3__torqueval_init_ena;

    /**
     * Command Source Mask - Analog 1 Mode Bits
     *
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_send_cs_ain_1_mode cs_ain_1_mode;

    /**
     * Kern Mode State Bit -
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t km_tx_tog_stat;

    /**
     * Current Measurement Inverse
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t i_ist_inverse;

    /**
     * Arrangement Variable Selection List for digital Output 1
     *
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_send_compare_var194 compare_var194;

    /**
     * Arrangement Variable Selection List for digital Output 2
     *
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_send_compare_var195 compare_var195;

    /**
     * Arrangement Variable Selection List for digital Output 3
     *
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_send_compare_var218 compare_var218;

    /**
     * Arrangement Variable Selection List for digital Output 4
     *
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_send_compare_var219 compare_var219;

    /**
     * Enable the use of Recuperation Ramps during Torque Mode
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cmc__bit4__dig_m_rcpramp_ena;

    /**
     * Kern Mode State Bit -
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t km_i_limit;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t refsoft;

    /**
     * Motor Options - Feedback 2 Type
     *
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_send_mo_feedback_2 mo_feedback_2;

    /**
     * Speed Ramp Reset to 0 if actual speed crosses 0 rpm
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cmc__bit5__reset_nramp_atnzero;

    /**
     * Kern Mode State Bit -
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t km_n_clip;

    /**
     * BTB nicht mit Powervoltage Ãœberwachung verknÃ¼pft
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t no_uesp_btb;

    /**
     * Set Torque command to 0 if no new external torque command input within 100 ms is registered
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cmc__bit6__torquetimeout_100ms_e;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cs_oora1;

    /**
     * Kern Mode State Bit -
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t km_mix_ana_on;

    /**
     * Analogue DC-Bus measurement
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t vdc_ana;

    /**
     * Free (NOT INUSE)
     *
     * Range: 0..127 (0..127 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cmc__bit13_7__free;

    /**
     * Command Source Mask - Analog 2 Mode Bits
     *
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_send_cs_ain_2_mode cs_ain_2_mode;

    /**
     * Range: 0..255 (0..255 ms)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_send_ret_interval ret_interval;

    /**
     * Kern Mode State Bit - Allow Sync
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t km_allow_sync;

    /**
     * Current Measurement I1 Enable
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t i1_adc_ena;

    /**
     * Analog Input Signal 2 - Filter Value Setting
     *
     * Range: 0..255 (0..127.5 ms)
     * Scale: 0.5
     * Offset: 0
     */
    uint8_t ain_in_2_filter;

    /**
     * Motor Options -
     *
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_send_mo_sc1_reso mo_sc1_reso;

    /**
     * Signal Source ID for the compare operation according to RegID Address
     *
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_send_source_id194 source_id194;

    /**
     * Signal Source ID for the compare operation according to RegID Address
     *
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_send_source_id195 source_id195;

    /**
     * Signal Source ID for the compare operation according to RegID Address
     *
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_send_source_id218 source_id218;

    /**
     * Signal Source ID for the compare operation according to RegID Address
     *
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_send_source_id219 source_id219;

    /**
     * CAN PDOs extension
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dup__bit8__can_extended_0;

    /**
     * Kern Mode State Bit -
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t km_handwheel;

    /**
     * Inverted order of Hall sensors
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t hxinv;

    /**
     * Special DC Bus generator operation
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dup__bit9__generator;

    /**
     * Kern Mode State Bit -
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t km_phasing_extend;

    /**
     * Inverted Hall 2
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t h2inv;

    /**
     * Set factor 1divsqrt(2) in park currents
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dup__bit10__park_rms;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cs_oora2;

    /**
     * Kern Mode State Bit - rsvd_11
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t km_rsvd_11;

    /**
     * Over Loop current limit or slip compensation Enable
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ol_comp;

    /**
     * Motor Options -
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t mo_sc1_comp;

    /**
     * DCBus Value as V for output Communication
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dup__bit11__dcbus_volts;

    /**
     * Command Source Mask - Bitmask Coding of Command Type
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_send_cs_cmd_type cs_cmd_type;

    /**
     * Kern Mode State Bit - rsvd_12
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t km_rsvd_12;

    /**
     * Motor Type define
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_send_motortype motortype;

    /**
     * Motor Options -
     *
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_send_mo_sc2_reso mo_sc2_reso;

    /**
     * Command (Acc Pedal) must be at 0 to enable inverter
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dup__bit12__boat_pedal;

    /**
     * Kern Mode State Bit - rsvd_13
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t km_rsvd_13;

    /**
     * Special Generator Mode with automatic Iac limit reduction
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dup__bit13__gen_autoiaclimit;

    /**
     * Command Source Mask - Analog 2 I Limit Status Bit
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cs_ain_2__i_limit;

    /**
     * Kern Mode State Bit -
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t km_pseudo_enable;

    /**
     * Messbereich DC-Bus,1 (0..5 V), 0 (2,5..5 V)
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ana_0up;

    /**
     * Enable the Limitiation Calculation depending on the DC Current limits V2
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cmc__bit14__idc_limit_ena_v2;

    /**
     * Enable MTPA calculation and automatic command of Id_ref
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dup__bit14__mtpa_reluct_enab;

    /**
     * Command Source Mask - Analog 1 N Limit Bit
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cs_ain_1__n_limit;

    /**
     * Kern Mode State Bit -
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t km_debug_test;

    /**
     * Low Baud rate of 9600 (serial)
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t lowbd;

    /**
     * Motor Options -
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t mo_sc2_inv;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_send_active190 active190;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_send_active191 active191;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_send_active192 active192;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_send_active193 active193;

    /**
     * Activate automated digital Recuperation Command
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cmc__bit15__dig_e_brake_act;

    /**
     * (Write Protected) Use CANopen instead of normal CAN protocol for the CAN communication
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dup__bit15__canopen_acv;

    /**
     * DC Current Time
     *
     * Range: 0..65535 (0..65535 ms)
     * Scale: 1
     * Offset: 0
     */
    uint16_t t_dc__stop;

    /**
     * DC-Voltage Value for DC-Braking
     *
     * Range: -32768..32767 (-3276.8..3276.7 %)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t v_dc__stop;

    /**
     * FU Special - Start
     *
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t special__stop;

    /**
     * Minimum Voltage (FU operation) at Stop
     *
     * Range: -32768..32767 (-3276.8..3276.7 %)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t v_min__stop;

    /**
     * Minimum Frequency (FU operation) at Stop
     *
     * Range: -32768..32767 (-3276.8..3276.7 Hz)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t f_min__stop;

    /**
     * Voltage (percentage of DC-Bus) at max. Frequency
     *
     * Range: -32768..32767 (-3276.8..3276.7 %)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t v_corner__stop;

    /**
     * Frequency at max output voltage - Stop
     *
     * Range: -32768..32767 (-3276.8..3276.7 Hz)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t f_corner__stop;

    /**
     * Proportional Gain Id-Current Controller - A entry 33 equals 1.0 normalized
     *
     * Range: 0..200 (0..200 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pid_i__kp__id;

    /**
     * Integral Action Time (Integral Part) Id-Current Controller
     *
     * Range: 300..20000 (300..20000 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pid_i__ti__id;

    /**
     * Id-Current Control Integral Maximum Output Range
     *
     * Range: 0..500 (0..500 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pid_i__tim__id;

    /**
     * Analog Input Signal 1 - Scale Value Setting
     *
     * Range: -32763.904..32763.904 (-7.999..7.999 -)
     * Scale: 0.000244140625
     * Offset: 0
     */
    int16_t ain_in_1_scaleval;

    /**
     * Torque Ramp Acc Time [0..4000 ms]
     *
     * Range: 0..4000 (0..4000 ms)
     * Scale: 1
     * Offset: 0
     */
    uint16_t m_r_acc;

    /**
     * S-Ramp N Command (Inactive)
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t sramp;

    /**
     * Regenerative Resistor Value
     *
     * Range: 0..65535 (0..65535 Ohm)
     * Scale: 1
     * Offset: 0
     */
    uint16_t regen_r;

    /**
     * DC Bus Max Value Superpision Limit
     *
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t dc_bus_max_lim;

    /**
     * Torque Ramp Rcp Time [0..4000 ms]
     *
     * Range: 0..4000 (0..4000 ms)
     * Scale: 1
     * Offset: 0
     */
    uint16_t m_r_rcp;

    /**
     * Proportional Gain Id-Current Controller if actual current is above I Limit Inuse Current - perc is depending on Kp value
     *
     * Range: 0..200 (0..200 %)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pid_i__xkp__id;

    /**
     * Idc or Pdc Limit during Generator operation
     *
     * Range: 0..65535 (0..6553.5 A or W)
     * Scale: 0.1
     * Offset: 0
     */
    uint16_t bat_opr_limit__gen;

    /**
     * Feedforward - Proportional Gain Id-Current Controller
     *
     * Range: 0..200 (0..200 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pid_i__kf__id;

    /**
     * Configuration of the I Peak supervision Limits
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cmc__bit17_16__checkipeak_config;

    /**
     * Analog Input Signal 2 - Scale Value Setting
     *
     * Range: -32768..32767 (-8..7.999755859375 -)
     * Scale: 0.000244140625
     * Offset: 0
     */
    int16_t ain_in_2_scaleval;

    /**
     * (Write Protected) Activation for the Offset Correction for older Bamobil 3.2 hardware setup
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dup__bit16__bamobil3_2_offcrct;

    /**
     * Torque Ramp Dec Time [0..4000 ms]
     *
     * Range: 0..4000 (0..4000 ms)
     * Scale: 1
     * Offset: 0
     */
    uint16_t m_r_dec;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ramp4;

    /**
     * (Write Protected) External ECODE processing matrix reconfiguration
     *
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dup__bit19_17__ecode_redefine;

    /**
     * Motor Brake
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t motbrake;

    /**
     * Enable the special Traction Control Logic
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cmc__bit18__tractioncontrol_ena;

    /**
     * AC or DC power supply
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ac_dc;

    /**
     * Definition of the Delta Time rpm Speed Change supervision (20ms, 50ms, 100ms, 250ms)
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cmc__bit20_19__tc_deltatime_conf;

    /**
     * PWM Frequency define
     *
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_send_pwm_freq pwm_freq;

    /**
     * HAL Sensor Estimator Logic Activation
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dup__bit20__hal_extmr_acv;

    /**
     * Definition of the minumim rpm Speed percentage to activate the TC (0perc, 10perc, 20perc, 30perc)
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cmc__bit22_21__tc_minspeed_conf;

    /**
     * Initialize inverter with a set Software Lock
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dup__bit21__initwith_frg_off;

    /**
     * Bit 31_22 - free (NOT INUSE)
     *
     * Range: 0..1023 (0..1023 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t dup__bit31_22__free;

    /**
     * IGBT NTC Temperature Sensor
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ntc;

    /**
     * Defines how the speed command ramp should be reset when TC triggers
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cmc__bit23__tc_ncmdrestoption;

    /**
     * Motorphasen Dreieck
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t delta;

    /**
     * Free (NOT INUSE)
     *
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cmc__bit31_24__free;

    /**
     * DC-1Quadrant, direkt pwm (Volt)
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dc_1qdirvolt;

    /**
     * DC-Feldregler
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dc_field;

    /**
     * deadband*2
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dead_2;

    /**
     * Blockstrom bei ROT
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t block;

    /**
     * DC-1Quadrant, minimale Schaltverluste
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dc_1qmv;

    /**
     * DC-1Quadrant, no high-side, bottom parallel
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dc_1q3p;

    /**
     * Automatic change to 4 kHz in case n < 10 Hz (No Derating)
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t reducelosses;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_inverter_l_send_t;

/**
 * Signals in message Inverter_L_Send.
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_send_send_mux send_mux;

    /**
     * Nominal Motor Frequency
     *
     * Range: 0..65535 (0..6553.5 Hz)
     * Scale: 0.1
     * Offset: 0
     */
    float motor_f_n;

    /**
     * Time For DC Pre-Charge-Magnitising - Start
     *
     * Range: 0..65535 (0..65535 ms)
     * Scale: 1
     * Offset: 0
     */
    uint16_t t_dc__start;

    /**
     * DC Voltage for Pre-Magnitization - Start
     *
     * Range: -32768..32767 (-3276.8..3276.7 %)
     * Scale: 0.1
     * Offset: 0
     */
    float v_dc__start;

    /**
     * FU Special - Start
     *
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t special__start;

    /**
     * Minimum Voltage (FU operation) at Start
     *
     * Range: -32768..32767 (-3276.8..3276.7 %)
     * Scale: 0.1
     * Offset: 0
     */
    float v_min__start;

    /**
     * Minimum Frequency (FU operation) at Start
     *
     * Range: -32768..32767 (-3276.8..3276.7 Hz)
     * Scale: 0.1
     * Offset: 0
     */
    float f_min__start;

    /**
     * Voltage (percentage of DC-Bus) at max. Frequency
     *
     * Range: -32768..32767 (-3276.8..3276.7 %)
     * Scale: 0.1
     * Offset: 0
     */
    float v_corner__start;

    /**
     * Frequency at max output voltage - Start
     *
     * Range: -32768..32767 (-3276.8..3276.7 Hz)
     * Scale: 0.1
     * Offset: 0
     */
    float f_corner__start;

    /**
     * Motor Power Factor
     *
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t cos_phi;

    /**
     * FU Extra - Start
     *
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t extra__start;

    /**
     * NDrive Oszillloscop - Capture Channel
     *
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t capture_channel;

    /**
     * NDrive Oszillloscop - Capture Trigger Edge
     *
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t trig_level;

    /**
     * NDrive Oszillloscop - Capture Trigger Level
     *
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t trig_edge;

    /**
     * NDrive Oszillloscop - Capture Trigger Source
     *
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t trig_source;

    /**
     * NDrive Oszillloscop - Capture Source
     *
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t oszi_source;

    /**
     * NDrive Oszillloscop - Capture Skip
     *
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t oszi_skip;

    /**
     * NDrive Oszillloscop - Read Command
     *
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t oszi_read_cmd;

    /**
     * NDrive Oszillloscop - Run Command
     *
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t oszi_run_cmd;

    /**
     * Entry for the Reference Value used for various Calibrations
     *
     * Range: 0..65535 (0..6553.5 -)
     * Scale: 0.1
     * Offset: 0
     */
    float calib_ref_value;

    /**
     * Proportional Gain Iq-Current Controller - A entry 33 equals 1.0 normalized
     *
     * Range: 0..200 (0..200 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pid_i__kp__iq;

    /**
     * Integral Action Time (Integral Part) Iq-Current Controller
     *
     * Range: 300..20000 (300..20000 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pid_i__ti__iq;

    /**
     * Digital Cutoff area of incomming digital commands
     *
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t cutoffdig;

    /**
     * Digital numerical Id-Current Command - input
     *
     * Range: -32768..32767 (-12249.91571968..12249.54188192 Arms)
     * Scale: 0.37383776
     * Offset: 0
     */
    float id_setdig__id;

    /**
     * Final Current Ramp Step setting
     *
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t i_delta_ramp;

    /**
     * Iq-Current Control Integral Maximum Output Range
     *
     * Range: 0..500 (0..500 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pid_i__tim__iq;

    /**
     * Proportional Gain Speed Controller
     *
     * Range: 0..200 (0..200 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pid_n__kp;

    /**
     * Integral Action Time (Integral Part) Speed Controller
     *
     * Range: 0..10000 (0..10000 ms)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pid_n__ti;

    /**
     * Derative Action Time (Derative Part) Speed Controller
     *
     * Range: 0..10000 (0..10000 ms)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pid_n__td;

    /**
     * Analog Input Signal 1 - Offset Value Setting
     *
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t ain_in_1_offsetval;

    /**
     * Digital numerical Speed Command - input
     *
     * Range: -32766.99999691205638057269621..32766.99999691205638057269621 (-7100..7100 Num)
     * Scale: 0.2166814173
     * Offset: 0
     */
    float n_setdig;

    /**
     * Speed n Limit - Percentage as 15 Bit entry format (32767 equal 100perc)
     *
     * Range: -32766.99943739061966000306044..32766.99943739061966000306044 (-100..100 %)
     * Scale: 0.003051851
     * Offset: 0
     */
    float n_lim;

    /**
     * Speed Ramp Acc Time [0..30000 ms]
     *
     * Range: 0..30000 (0..30000 ms)
     * Scale: 1
     * Offset: 0
     */
    uint16_t n_r_acc;

    /**
     * Command Source Mask - Analog 1 Format Bits
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_send_cs_ain_1_format cs_ain_1_format;

    /**
     * Speed Control Integral Maximum Output Range
     *
     * Range: 0..100 (0..100 %)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pid_n__tim;

    /**
     * Current reduction by rotation speed - Percentage as 15 Bit entry format (32767 equal 100perc)
     *
     * Range: 0..32766.99943739061966000306044 (0..100 %)
     * Scale: 0.003051851
     * Offset: 0
     */
    float i_red_n;

    /**
     * Speed n Limit minus - Percentage as 15 Bit entry format (-32767 equal -100perc)
     *
     * Range: -32766.99943739061966000306044..0 (-100..0 %)
     * Scale: 0.003051851
     * Offset: 0
     */
    float n_lim_minus;

    /**
     * Speed n Limit plus - Percentage as 15 Bit entry format (32767 equal 100perc)
     *
     * Range: 0..32766.99943739061966000306044 (0..100 %)
     * Scale: 0.003051851
     * Offset: 0
     */
    float n_lim_plus;

    /**
     * FeedBack Offset Angle Value
     *
     * Range: -3600..3600 (-360..360 -)
     * Scale: 0.1
     * Offset: 0
     */
    float fb_offset;

    /**
     * Global ID for Read Command 0x3D in Get_Value
     *
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_send_read_id read_id;

    /**
     * Derating Reduction to percentage Value - Trigger is Dig Input - Percentage as 15 Bit entry format (32767 equal 100perc)
     *
     * Range: 0..32766.99943739061966000306044 (0..100 %)
     * Scale: 0.003051851
     * Offset: 0
     */
    float i_lim_dig;

    /**
     * Stop of current reduction by power stage temperature
     *
     * Range: 0..32767 (0..32767 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t i_red_te;

    /**
     * Motor Maximum Effective Peak Current
     *
     * Range: 0..32767 (0..3276.7 Arms)
     * Scale: 0.1
     * Offset: 0
     */
    float i_max_eff;

    /**
     * Motor Nominal Effective Current
     *
     * Range: 0..65535 (0..6553.5 0,1)
     * Scale: 0.1
     * Offset: 0
     */
    float i_nom_eff;

    /**
     * Motor Pole Number
     *
     * Range: 2..96 (2..96 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t motor_pole;

    /**
     * Analog Input Signal 1 - Cutoff Value Setting
     *
     * Range: 0..32767 (0..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t ain_in_1_cutoff;

    /**
     * Kern Mode State Bit - rsvd_0
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int km_rsvd_0 : 1;

    /**
     * Analog Input Signal 2 - Cutoff Value Setting
     *
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t ain_in_2_cutoff;

    /**
     * Start of current reduction by power stage temperature
     *
     * Range: 0..32767 (0..32767 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t i_red_td;

    /**
     * Motor Nominal Rotation Speed
     *
     * Range: 60..65000 (60..65000 rpm)
     * Scale: 1
     * Offset: 0
     */
    uint16_t n_nom;

    /**
     * Analoge Zwischenkreismessung geht in Uout ein
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int dc_bus_comp : 1;

    /**
     * Speed Control Acceleration Feed Foreward Gain
     *
     * Range: 0..100 (0..100 %)
     * Scale: 1
     * Offset: 0
     */
    int16_t pid_n__kacc;

    /**
     * Additional Filter Adjustment of the Rotation Speed Measurement
     *
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t speed_filter;

    /**
     * Analog Input Signal 1 - Filter Value Setting
     *
     * Range: 0..255 (0..127.5 ms)
     * Scale: 0.5
     * Offset: 0
     */
    float ain_in_1_filter;

    /**
     * Device Serial Number
     *
     * Range: 0..4294967295 (0..4294967295 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t snr;

    /**
     * Device Mains Supply Voltage Value
     *
     * Range: 0..1000 (0..1000 V)
     * Scale: 1
     * Offset: 0
     */
    uint16_t device_mains;

    /**
     * Regenerative Resistor Power Value
     *
     * Range: 25..10000 (25..10000 W)
     * Scale: 1
     * Offset: 0
     */
    uint16_t regen_p;

    /**
     * Coding Signal defining various device types
     *
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_send_devicetype devicetype;

    /**
     * CAN Identiciation ID for Receive - Rx
     *
     * Range: 0..65530 (0..65530 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t can_id_rx;

    /**
     * CAN Identiciation ID for Transmit - Tx
     *
     * Range: 0..65530 (0..65530 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t can_id_tx;

    /**
     * Proportional Gain Position Controller
     *
     * Range: 0..500 (0..500 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pos_kp;

    /**
     * Integral Action Time (Integral Part) Position Controller
     *
     * Range: 0..10000 (0..10000 ms)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pos_ti;

    /**
     * Derative Action Time (Derative Part) Position Controller
     *
     * Range: 0..65535 (0..65535 ms)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pos_td;

    /**
     * Numeric Destination Position Value
     *
     * Range: -2147483648..2147483647 (-2147483648..2147483647 -)
     * Scale: 1
     * Offset: 0
     */
    int32_t pos_dest;

    /**
     * Position Control Integral Maximum Output Range
     *
     * Range: 0..100 (0..100 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pos_tim;

    /**
     * Numeric Position Zero Offset Value
     *
     * Range: -2147483648..2147483647 (-2147483648..2147483647 -)
     * Scale: 1
     * Offset: 0
     */
    int32_t pos_offsref;

    /**
     * CAN BaudRate Configuration Setting
     *
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_send_can_nbt can_nbt;

    /**
     * Resolver Position at Reference Switch (Rsw)
     *
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t ref_reso_edge;

    /**
     * Position Reference Speed 1 (Fast)
     *
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t speed_1;

    /**
     * Position Reference Speed 1 (Slow) + Phasing electrical Rotation Speed
     *
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t speed_2;

    /**
     * Tolerance Window for Destination Position
     *
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t pos_tol_win;

    /**
     * Numeric Preset Position Value (Set actual Position to Preset Position)
     *
     * Range: -2147483648..2147483647 (-2147483648..2147483647 -)
     * Scale: 1
     * Offset: 0
     */
    int32_t pos_preset_val;

    /**
     * NDrive Position Display Scale Factor
     *
     * Range: -2147483648..2147483647 (-2147483648..2147483647 -)
     * Scale: 1
     * Offset: 0
     */
    int32_t pos_nd_scale;

    /**
     * NDrive Position Display Offset Factor
     *
     * Range: -2147483648..2147483647 (-2147483648..2147483647 -)
     * Scale: 1
     * Offset: 0
     */
    int32_t pos_nd_offset;

    /**
     * Feedback 2 - External Scale Factor
     *
     * Range: -2147483648..2147483647 (-2147483648..2147483647 -)
     * Scale: 1
     * Offset: 0
     */
    int32_t fb2_scale_ext;

    /**
     * Position Offset Slack Value
     *
     * Range: -2147483648..2147483647 (-2147483648..2147483647 -)
     * Scale: 1
     * Offset: 0
     */
    int32_t pos_offset_slack;

    /**
     * Position Difference Slack Value
     *
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t pos_diff_slack;

    /**
     * Range: 0..2 (0..2 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_send_eprom131 eprom131;

    /**
     * Range: 0..2 (0..2 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_send_eprom132 eprom132;

    /**
     * Special Functions for automatic logics or calculations
     *
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t fun_special;

    /**
     * CAN Identiciation ID - 2 - for Receive - Rx
     *
     * Range: 0..4294967295 (0..4294967295 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t can_id_2_rx;

    /**
     * CAN Identiciation ID - 2 - for Transmit - Tx
     *
     * Range: 0..4294967295 (0..4294967295 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t can_id_2_tx;

    /**
     * Voltage Controller Reference value in perc of Vout (V_Red - Start of Field Reduction)
     *
     * Range: -32768..32767 (-32768..32767 %)
     * Scale: 1
     * Offset: 0
     */
    int16_t v_ref;

    /**
     * Proportional Gain Voltage Controller (0.0001 * Ti equals 1.0)
     *
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t v_kp;

    /**
     * Integral Action Time (Integral Part) Voltage Controller (0.0001 x Ti equals 1.0)
     *
     * Range: 0..65535 (0..65535 ms)
     * Scale: 1
     * Offset: 0
     */
    uint16_t v_ti;

    /**
     * Clear Errors. Just send a value of 0 to this ID Address
     *
     * Range: 1..1 (1..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t clear_errors;

    /**
     * Digital numerical Iq-Current Command - input
     *
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t m_setdig__iq;

    /**
     * Current reduction by motor temperature
     *
     * Range: 0..32767 (0..32767 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t i_red_tm;

    /**
     * Motor Temperature Limit for Inverter Error shutdown
     *
     * Range: 0..32767 (0..32767 Num)
     * Scale: 1
     * Offset: 0
     */
    uint16_t m_temp;

    /**
     * Motor Options - Feedback 1 Type
     *
     * Range: 0..31 (0..31 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_send_mo_feedback_1 mo_feedback_1;

    /**
     * DC Bus Min Value Superpision Limit
     *
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t dc_bus_min_lim;

    /**
     * Feedback System Increments per rotation
     *
     * Range: 0..65535 (0..65535 Inc/Rev)
     * Scale: 1
     * Offset: 0
     */
    uint16_t fb_incr_mot;

    /**
     * Feedback Pole number
     *
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t fb_pole;

    /**
     * Motor - Stator Leakage Inductance - Lsq
     *
     * Range: 0..65535 (0..65.535 mH)
     * Scale: 0.001
     * Offset: 0
     */
    float motor_lsq;

    /**
     * Nominal Magnetising d-Current value as perc of nominal current
     *
     * Range: -32768..32767 (-32768..32767 %)
     * Scale: 1
     * Offset: 0
     */
    int16_t id_nom;

    /**
     * Motor - Magnetizing Inductance - L
     *
     * Range: 0..65535 (0..655.35 mH)
     * Scale: 0.01
     * Offset: 0
     */
    float motor_lm;

    /**
     * Motor - Rotor Resistance Value
     *
     * Range: 0..65535 (0..65535 mOhm)
     * Scale: 1
     * Offset: 0
     */
    uint16_t motor_rr;

    /**
     * Minimum Magnetising d-Current value as perc of nominal current
     *
     * Range: 0..100 (0..100 %)
     * Scale: 1
     * Offset: 0
     */
    int16_t id_min;

    /**
     * Rotor Time Contant of the Motor
     *
     * Range: -32768..32767 (-32768..32767 ms)
     * Scale: 1
     * Offset: 0
     */
    int16_t motor_tr;

    /**
     * Motor Leakage Inductance ph-ph - Lsd
     *
     * Range: 0..65535 (0..65.535 mH)
     * Scale: 0.001
     * Offset: 0
     */
    float motor_lsd;

    /**
     * Motor - Stator Resistance Value
     *
     * Range: 0..65535 (0..65535 mOhm)
     * Scale: 1
     * Offset: 0
     */
    uint16_t motor_rs;

    /**
     * Stator Time Contant of the Motor
     *
     * Range: -32768..32767 (-32.768..32.767 ms)
     * Scale: 0.001
     * Offset: 0
     */
    float motor_ts;

    /**
     * Definition - Function attribution of the Digital Input - END 1 (Limit 1)
     *
     * Range: 0..32767 (0..32767 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_send_def_end_1 def_end_1;

    /**
     * Definition - Function attribution of the Digital Input - END 2 (Limit 2)
     *
     * Range: 0..32767 (0..32767 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_send_def_end_2 def_end_2;

    /**
     * Definition - Function attribution of the Digital Input - DIN 1
     *
     * Range: 0..32767 (0..32767 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_send_def_din_1 def_din_1;

    /**
     * Definition - Function attribution of the Digital Input - DIN 2
     *
     * Range: 0..32767 (0..32767 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_send_def_din_2 def_din_2;

    /**
     * Selection List Operant for digital Output OUT 1
     *
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_send_operand194 operand194;

    /**
     * Selection List Operant for digital Output OUT 2
     *
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_send_operand195 operand195;

    /**
     * Selection List Operant for digital Output OUT 3
     *
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_send_operand218 operand218;

    /**
     * Selection List Operant for digital Output OUT 4
     *
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_send_operand219 operand219;

    /**
     * Max. Device Current (A) settings via percentage entry - Percentage as 13 Bit entry format (16383 equal 100perc)
     *
     * Range: 0..16382.99999132683980459157101 (0..100 %)
     * Scale: 0.00610388818
     * Offset: 0
     */
    float i_max_pk;

    /**
     * Continuous Device Current (Arms) settings via percentage entry - Percentage as 13 Bit entry format (16383 is equal 100perc)
     *
     * Range: 0..16382.99999132683980459157101 (0..100 %)
     * Scale: 0.00610388818
     * Offset: 0
     */
    float i_con_eff;

    /**
     * Set device define for continuous current
     *
     * Range: 0..65535 (0..6553.5 A)
     * Scale: 0.1
     * Offset: 0
     */
    float i_device;

    /**
     * Emergency Stopping Ramp Time [0..1000 ms]
     *
     * Range: 0..1000 (0..1000 ms)
     * Scale: 1
     * Offset: 0
     */
    uint16_t n_r_lim;

    /**
     * Maximum Speed Value for Resolution of 16Bit
     *
     * Range: -32768..32767 (-32768..32767 rpm)
     * Scale: 1
     * Offset: 0
     */
    int16_t nmax100perc;

    /**
     * Proportional Gain Iq-Current Controller if actual current is above I Limit Inuse Current - perc is depending on Kp value
     *
     * Range: 0..200 (0..200 %)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pid_i__xkp__iq;

    /**
     * Idc or Pdc Limit during Motor operation
     *
     * Range: 0..65535 (0..6553.5 A or W)
     * Scale: 0.1
     * Offset: 0
     */
    float bat_opr_limit__mot;

    /**
     * Feedforward - Proportional Gain Iq-Current Controller
     *
     * Range: 0..200 (0..200 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pid_i__kf__iq;

    /**
     * Enable the use of the DC current Sensor (if present)
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int cmc__bit0__dc_current_sens_ena : 1;

    /**
     * CAN Timeout time settings
     *
     * Range: 0..32767 (0..32767 ms)
     * Scale: 1
     * Offset: 0
     */
    int16_t can_rxtimeout;

    /**
     * Comparison Variable 1
     *
     * Range: -2147483648..2147483647 (-2147483648..2147483647 -)
     * Scale: 1
     * Offset: 0
     */
    int32_t var_1;

    /**
     * Comparison Variable 2
     *
     * Range: -2147483648..2147483647 (-2147483648..2147483647 -)
     * Scale: 1
     * Offset: 0
     */
    int32_t var_2;

    /**
     * Comparison Variable 3
     *
     * Range: -2147483648..2147483647 (-2147483648..2147483647 -)
     * Scale: 1
     * Offset: 0
     */
    int32_t var_3;

    /**
     * Comparison Variable 4
     *
     * Range: -2147483648..2147483647 (-2147483648..2147483647 -)
     * Scale: 1
     * Offset: 0
     */
    int32_t var_4;

    /**
     * Analog Input Signal 2 - Offset Value Setting
     *
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t ain_in_2_offsetval;

    /**
     * DAC Configuration of the RegID Source Channel as Output
     *
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dup__bit7_0__dac_source_channel;

    /**
     * Speed Ramp Dec Time [0..30000 ms]
     *
     * Range: 0..30000 (0..30000 ms)
     * Scale: 1
     * Offset: 0
     */
    uint16_t n_r_dec;

    /**
     * Current Sensor rated voltage
     *
     * Range: 0..65535 (0..65535 mV)
     * Scale: 1
     * Offset: 0
     */
    uint16_t v_shunt;

    /**
     * Allowed Timing for Peak Current
     *
     * Range: 0..65535 (0..65535 s)
     * Scale: 1
     * Offset: 0
     */
    uint16_t t_peak;

    /**
     * Mechanical Brake Delay Time (e.g. Relay)
     *
     * Range: 0..65535 (0..65535 ms)
     * Scale: 1
     * Offset: 0
     */
    uint16_t brake_delay;

    /**
     * Inverter 4 Letter Name define
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t axis;

    /**
     * Kern Mode State Bit -
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int km_speed_0 : 1;

    /**
     * Ballast-R extern
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int ballast_ext : 1;

    /**
     * Enable the Limitiation Calculation depending on the DC Current limits
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int cmc__bit1__idc_limit_ena : 1;

    /**
     * Command Source Mask - Analog 2 Format Bits
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_send_cs_ain_2_format cs_ain_2_format;

    /**
     * Kern Mode State Bit -
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int km_frg_off : 1;

    /**
     * Feedback Speciality
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int fb_special : 1;

    /**
     * Use the DC current Limitiation Calculation depending on the DC Power limits
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int cmc__bit2__pdc_limit_usage : 1;

    /**
     * Kern Mode State Bit -
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int km_cal_off : 1;

    /**
     * Coast Stop Activation
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int coaststop : 1;

    /**
     * Enable Init as Torque Mode after Enable (Run)
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int cmc__bit3__torqueval_init_ena : 1;

    /**
     * Command Source Mask - Analog 1 Mode Bits
     *
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_send_cs_ain_1_mode cs_ain_1_mode;

    /**
     * Kern Mode State Bit -
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int km_tx_tog_stat : 1;

    /**
     * Current Measurement Inverse
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int i_ist_inverse : 1;

    /**
     * Arrangement Variable Selection List for digital Output 1
     *
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_send_compare_var194 compare_var194;

    /**
     * Arrangement Variable Selection List for digital Output 2
     *
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_send_compare_var195 compare_var195;

    /**
     * Arrangement Variable Selection List for digital Output 3
     *
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_send_compare_var218 compare_var218;

    /**
     * Arrangement Variable Selection List for digital Output 4
     *
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_send_compare_var219 compare_var219;

    /**
     * Enable the use of Recuperation Ramps during Torque Mode
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int cmc__bit4__dig_m_rcpramp_ena : 1;

    /**
     * Kern Mode State Bit -
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int km_i_limit : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int refsoft : 1;

    /**
     * Motor Options - Feedback 2 Type
     *
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_send_mo_feedback_2 mo_feedback_2;

    /**
     * Speed Ramp Reset to 0 if actual speed crosses 0 rpm
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int cmc__bit5__reset_nramp_atnzero : 1;

    /**
     * Kern Mode State Bit -
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int km_n_clip : 1;

    /**
     * BTB nicht mit Powervoltage Ãœberwachung verknÃ¼pft
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int no_uesp_btb : 1;

    /**
     * Set Torque command to 0 if no new external torque command input within 100 ms is registered
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int cmc__bit6__torquetimeout_100ms_e : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int cs_oora1 : 1;

    /**
     * Kern Mode State Bit -
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int km_mix_ana_on : 1;

    /**
     * Analogue DC-Bus measurement
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int vdc_ana : 1;

    /**
     * Free (NOT INUSE)
     *
     * Range: 0..127 (0..127 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cmc__bit13_7__free;

    /**
     * Command Source Mask - Analog 2 Mode Bits
     *
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_send_cs_ain_2_mode cs_ain_2_mode;

    /**
     * Range: 0..255 (0..255 ms)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_send_ret_interval ret_interval;

    /**
     * Kern Mode State Bit - Allow Sync
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int km_allow_sync : 1;

    /**
     * Current Measurement I1 Enable
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int i1_adc_ena : 1;

    /**
     * Analog Input Signal 2 - Filter Value Setting
     *
     * Range: 0..255 (0..127.5 ms)
     * Scale: 0.5
     * Offset: 0
     */
    float ain_in_2_filter;

    /**
     * Motor Options -
     *
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_send_mo_sc1_reso mo_sc1_reso;

    /**
     * Signal Source ID for the compare operation according to RegID Address
     *
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_send_source_id194 source_id194;

    /**
     * Signal Source ID for the compare operation according to RegID Address
     *
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_send_source_id195 source_id195;

    /**
     * Signal Source ID for the compare operation according to RegID Address
     *
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_send_source_id218 source_id218;

    /**
     * Signal Source ID for the compare operation according to RegID Address
     *
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_send_source_id219 source_id219;

    /**
     * CAN PDOs extension
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int dup__bit8__can_extended_0 : 1;

    /**
     * Kern Mode State Bit -
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int km_handwheel : 1;

    /**
     * Inverted order of Hall sensors
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int hxinv : 1;

    /**
     * Special DC Bus generator operation
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int dup__bit9__generator : 1;

    /**
     * Kern Mode State Bit -
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int km_phasing_extend : 1;

    /**
     * Inverted Hall 2
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int h2inv : 1;

    /**
     * Set factor 1divsqrt(2) in park currents
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int dup__bit10__park_rms : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int cs_oora2 : 1;

    /**
     * Kern Mode State Bit - rsvd_11
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int km_rsvd_11 : 1;

    /**
     * Over Loop current limit or slip compensation Enable
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int ol_comp : 1;

    /**
     * Motor Options -
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int mo_sc1_comp : 1;

    /**
     * DCBus Value as V for output Communication
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int dup__bit11__dcbus_volts : 1;

    /**
     * Command Source Mask - Bitmask Coding of Command Type
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_send_cs_cmd_type cs_cmd_type;

    /**
     * Kern Mode State Bit - rsvd_12
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int km_rsvd_12 : 1;

    /**
     * Motor Type define
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_send_motortype motortype;

    /**
     * Motor Options -
     *
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_send_mo_sc2_reso mo_sc2_reso;

    /**
     * Command (Acc Pedal) must be at 0 to enable inverter
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int dup__bit12__boat_pedal : 1;

    /**
     * Kern Mode State Bit - rsvd_13
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int km_rsvd_13 : 1;

    /**
     * Special Generator Mode with automatic Iac limit reduction
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int dup__bit13__gen_autoiaclimit : 1;

    /**
     * Command Source Mask - Analog 2 I Limit Status Bit
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int cs_ain_2__i_limit : 1;

    /**
     * Kern Mode State Bit -
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int km_pseudo_enable : 1;

    /**
     * Messbereich DC-Bus,1 (0..5 V), 0 (2,5..5 V)
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int ana_0up : 1;

    /**
     * Enable the Limitiation Calculation depending on the DC Current limits V2
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int cmc__bit14__idc_limit_ena_v2 : 1;

    /**
     * Enable MTPA calculation and automatic command of Id_ref
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int dup__bit14__mtpa_reluct_enab : 1;

    /**
     * Command Source Mask - Analog 1 N Limit Bit
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int cs_ain_1__n_limit : 1;

    /**
     * Kern Mode State Bit -
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int km_debug_test : 1;

    /**
     * Low Baud rate of 9600 (serial)
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int lowbd : 1;

    /**
     * Motor Options -
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int mo_sc2_inv : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_send_active190 active190;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_send_active191 active191;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_send_active192 active192;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_send_active193 active193;

    /**
     * Activate automated digital Recuperation Command
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int cmc__bit15__dig_e_brake_act : 1;

    /**
     * (Write Protected) Use CANopen instead of normal CAN protocol for the CAN communication
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int dup__bit15__canopen_acv : 1;

    /**
     * DC Current Time
     *
     * Range: 0..65535 (0..65535 ms)
     * Scale: 1
     * Offset: 0
     */
    uint16_t t_dc__stop;

    /**
     * DC-Voltage Value for DC-Braking
     *
     * Range: -32768..32767 (-3276.8..3276.7 %)
     * Scale: 0.1
     * Offset: 0
     */
    float v_dc__stop;

    /**
     * FU Special - Start
     *
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t special__stop;

    /**
     * Minimum Voltage (FU operation) at Stop
     *
     * Range: -32768..32767 (-3276.8..3276.7 %)
     * Scale: 0.1
     * Offset: 0
     */
    float v_min__stop;

    /**
     * Minimum Frequency (FU operation) at Stop
     *
     * Range: -32768..32767 (-3276.8..3276.7 Hz)
     * Scale: 0.1
     * Offset: 0
     */
    float f_min__stop;

    /**
     * Voltage (percentage of DC-Bus) at max. Frequency
     *
     * Range: -32768..32767 (-3276.8..3276.7 %)
     * Scale: 0.1
     * Offset: 0
     */
    float v_corner__stop;

    /**
     * Frequency at max output voltage - Stop
     *
     * Range: -32768..32767 (-3276.8..3276.7 Hz)
     * Scale: 0.1
     * Offset: 0
     */
    float f_corner__stop;

    /**
     * Proportional Gain Id-Current Controller - A entry 33 equals 1.0 normalized
     *
     * Range: 0..200 (0..200 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pid_i__kp__id;

    /**
     * Integral Action Time (Integral Part) Id-Current Controller
     *
     * Range: 300..20000 (300..20000 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pid_i__ti__id;

    /**
     * Id-Current Control Integral Maximum Output Range
     *
     * Range: 0..500 (0..500 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pid_i__tim__id;

    /**
     * Analog Input Signal 1 - Scale Value Setting
     *
     * Range: -32763.904..32763.904 (-7.999..7.999 -)
     * Scale: 0.000244140625
     * Offset: 0
     */
    float ain_in_1_scaleval;

    /**
     * Torque Ramp Acc Time [0..4000 ms]
     *
     * Range: 0..4000 (0..4000 ms)
     * Scale: 1
     * Offset: 0
     */
    uint16_t m_r_acc;

    /**
     * S-Ramp N Command (Inactive)
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int sramp : 1;

    /**
     * Regenerative Resistor Value
     *
     * Range: 0..65535 (0..65535 Ohm)
     * Scale: 1
     * Offset: 0
     */
    uint16_t regen_r;

    /**
     * DC Bus Max Value Superpision Limit
     *
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t dc_bus_max_lim;

    /**
     * Torque Ramp Rcp Time [0..4000 ms]
     *
     * Range: 0..4000 (0..4000 ms)
     * Scale: 1
     * Offset: 0
     */
    uint16_t m_r_rcp;

    /**
     * Proportional Gain Id-Current Controller if actual current is above I Limit Inuse Current - perc is depending on Kp value
     *
     * Range: 0..200 (0..200 %)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pid_i__xkp__id;

    /**
     * Idc or Pdc Limit during Generator operation
     *
     * Range: 0..65535 (0..6553.5 A or W)
     * Scale: 0.1
     * Offset: 0
     */
    float bat_opr_limit__gen;

    /**
     * Feedforward - Proportional Gain Id-Current Controller
     *
     * Range: 0..200 (0..200 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pid_i__kf__id;

    /**
     * Configuration of the I Peak supervision Limits
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cmc__bit17_16__checkipeak_config;

    /**
     * Analog Input Signal 2 - Scale Value Setting
     *
     * Range: -32768..32767 (-8..7.999755859375 -)
     * Scale: 0.000244140625
     * Offset: 0
     */
    float ain_in_2_scaleval;

    /**
     * (Write Protected) Activation for the Offset Correction for older Bamobil 3.2 hardware setup
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int dup__bit16__bamobil3_2_offcrct : 1;

    /**
     * Torque Ramp Dec Time [0..4000 ms]
     *
     * Range: 0..4000 (0..4000 ms)
     * Scale: 1
     * Offset: 0
     */
    uint16_t m_r_dec;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int ramp4 : 1;

    /**
     * (Write Protected) External ECODE processing matrix reconfiguration
     *
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dup__bit19_17__ecode_redefine;

    /**
     * Motor Brake
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int motbrake : 1;

    /**
     * Enable the special Traction Control Logic
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int cmc__bit18__tractioncontrol_ena : 1;

    /**
     * AC or DC power supply
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int ac_dc : 1;

    /**
     * Definition of the Delta Time rpm Speed Change supervision (20ms, 50ms, 100ms, 250ms)
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cmc__bit20_19__tc_deltatime_conf;

    /**
     * PWM Frequency define
     *
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_send_pwm_freq pwm_freq;

    /**
     * HAL Sensor Estimator Logic Activation
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int dup__bit20__hal_extmr_acv : 1;

    /**
     * Definition of the minumim rpm Speed percentage to activate the TC (0perc, 10perc, 20perc, 30perc)
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cmc__bit22_21__tc_minspeed_conf;

    /**
     * Initialize inverter with a set Software Lock
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int dup__bit21__initwith_frg_off : 1;

    /**
     * Bit 31_22 - free (NOT INUSE)
     *
     * Range: 0..1023 (0..1023 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t dup__bit31_22__free;

    /**
     * IGBT NTC Temperature Sensor
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int ntc : 1;

    /**
     * Defines how the speed command ramp should be reset when TC triggers
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int cmc__bit23__tc_ncmdrestoption : 1;

    /**
     * Motorphasen Dreieck
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int delta : 1;

    /**
     * Free (NOT INUSE)
     *
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cmc__bit31_24__free;

    /**
     * DC-1Quadrant, direkt pwm (Volt)
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int dc_1qdirvolt : 1;

    /**
     * DC-Feldregler
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int dc_field : 1;

    /**
     * deadband*2
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int dead_2 : 1;

    /**
     * Blockstrom bei ROT
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int block : 1;

    /**
     * DC-1Quadrant, minimale Schaltverluste
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int dc_1qmv : 1;

    /**
     * DC-1Quadrant, no high-side, bottom parallel
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int dc_1q3p : 1;

    /**
     * Automatic change to 4 kHz in case n < 10 Hz (No Derating)
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int reducelosses : 1;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_inverter_l_send_converted_t;

/**
 * Signals in message Inverter_L_Rcv.
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Actual Motor Roations Speed
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_rcv_rcv_mux rcv_mux;

    /**
     * Actual Motor Roations Speed
     *
     * Range: -32767.00000405309586161245655..32767 (-3600..3599.9999995547 Num)
     * Scale: 0.1098666341
     * Offset: 0
     */
    int16_t n_actual;

    /**
     * Speed Ramp Dec Time [0..30000 ms]
     *
     * Range: 0..30000 (0..30000 ms)
     * Scale: 1
     * Offset: 0
     */
    uint16_t n_r_dec;

    /**
     * Emergency Stopping Ramp Time [0..1000 ms]
     *
     * Range: 0..1000 (0..1000 ms)
     * Scale: 1
     * Offset: 0
     */
    uint16_t n_r_lim;

    /**
     * Actual Motor Roations Speed Filtered
     *
     * Range: -32768..32767 (-3600.1098661888..3599.9999995547 rpm)
     * Scale: 0.1098666341
     * Offset: 0
     */
    int16_t n_actual_filt;

    /**
     * Firmware Number
     *
     * Range: 0..4095 (0..4095 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t firmware;

    /**
     * Coding Signal defining various device types
     *
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_rcv_devicetype devicetype;

    /**
     * Device Serial Number
     *
     * Range: 0..4294967295 (0..4294967295 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t snr;

    /**
     * Inverter 4 Letter Name define
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t axis;

    /**
     * Set device define for continuous current
     *
     * Range: 0..65535 (0..6553.5 A)
     * Scale: 0.1
     * Offset: 0
     */
    uint16_t i_device;

    /**
     * Current Sensor rated voltage
     *
     * Range: 0..65535 (0..65535 mV)
     * Scale: 1
     * Offset: 0
     */
    uint16_t v_shunt;

    /**
     * Internal Current value at 200% nominal device current
     *
     * Range: 0..65535 (0..65535 adc)
     * Scale: 1
     * Offset: 0
     */
    uint16_t i_200perc;

    /**
     * Analoge Zwischenkreismessung geht in Uout ein
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dc_bus_comp;

    /**
     * Enable drive
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ena64;

    /**
     * Damaged parameter
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t err_badparas;

    /**
     * Digital input limit 1 active
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t lmt1;

    /**
     * Analog Input Signal 1 - Raw
     *
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t ain_in_1_raw;

    /**
     * Analog Input Signal 2 - Raw
     *
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t ain_in_2_raw;

    /**
     * Maximum Speed Value for Resolution of 16Bit
     *
     * Range: -32768..32767 (-32768..32767 rpm)
     * Scale: 1
     * Offset: 0
     */
    int16_t nmax100perc;

    /**
     * Digital numerical Speed Command - input
     *
     * Range: -32766.99999691205638057269621..32766.99999691205638057269621 (-7100..7100 Num)
     * Scale: 0.2166814173
     * Offset: 0
     */
    int16_t n_setdig;

    /**
     * Digital numerical Speed Command - internal
     *
     * Range: -32768..32767 (-32768..32767 Num)
     * Scale: 1
     * Offset: 0
     */
    int16_t n_cmd;

    /**
     * Digital numerical Speed Command - internal ramped
     *
     * Range: -32766.99999691205638057269621..32766.99999691205638057269621 (-7100..7100 Num)
     * Scale: 0.2166814173
     * Offset: 0
     */
    int16_t n_cmd_ramp;

    /**
     * Speed n Limit - Percentage as 15 Bit entry format (32767 equal 100perc)
     *
     * Range: -32766.99943739061966000306044..32766.99943739061966000306044 (-100..100 %)
     * Scale: 0.003051851
     * Offset: 0
     */
    int16_t n_lim;

    /**
     * Speed n Error difference
     *
     * Range: -32766.99999691205638057269621..32766.99999691205638057269621 (-7100..7100 Num)
     * Scale: 0.2166814173
     * Offset: 0
     */
    int16_t n_error;

    /**
     * Digital numerical Iq-Current Command - input
     *
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t m_setdig__iq;

    /**
     * Digital numerical Id-Current Command - input
     *
     * Range: -32768..32767 (-12249.91571968..12249.54188192 Arms)
     * Scale: 0.37383776
     * Offset: 0
     */
    int16_t id_setdig__id;

    /**
     * Max. Device Current (A) settings via percentage entry - Percentage as 13 Bit entry format (16383 equal 100perc)
     *
     * Range: 0..16382.99999132683980459157101 (0..100 %)
     * Scale: 0.00610388818
     * Offset: 0
     */
    uint16_t i_max_pk;

    /**
     * Continuous Device Current (Arms) settings via percentage entry - Percentage as 13 Bit entry format (16383 is equal 100perc)
     *
     * Range: 0..16382.99999132683980459157101 (0..100 %)
     * Scale: 0.00610388818
     * Offset: 0
     */
    uint16_t i_con_eff;

    /**
     * Motor Maximum Effective Peak Current
     *
     * Range: 0..32767 (0..3276.7 Arms)
     * Scale: 0.1
     * Offset: 0
     */
    uint16_t i_max_eff;

    /**
     * Motor Nominal Effective Current
     *
     * Range: 0..65535 (0..6553.5 0,1)
     * Scale: 0.1
     * Offset: 0
     */
    uint16_t i_nom_eff;

    /**
     * Actual Reduced Current Limit
     *
     * Range: -32768..32767 (-4547.16391424..4547.02514581 Arms)
     * Scale: 0.13876843
     * Offset: 0
     */
    int16_t i_limit_inuse;

    /**
     * Digital numerical Current Command - internal
     *
     * Range: -32768..32767 (-4547.16391424..4547.02514581 Arms)
     * Scale: 0.13876843
     * Offset: 0
     */
    int16_t i_cmd;

    /**
     * Digital numerical Current Command - internal ramped
     *
     * Range: -32768..32767 (-4547.16391424..4547.02514581 Arms)
     * Scale: 0.13876843
     * Offset: 0
     */
    int16_t i_cmd_ramp;

    /**
     * Measured numerical Current - internal
     *
     * Range: -32768..32767 (-4547.16391424..4547.02514581 Arms)
     * Scale: 0.13876843
     * Offset: 0
     */
    int16_t i_actual;

    /**
     * Measured numerical Current Filtered - internal
     *
     * Range: -32768..32767 (-4547.16391424..4547.02514581 Arms)
     * Scale: 0.13876843
     * Offset: 0
     */
    int16_t i_actual_filt;

    /**
     * Measured numerical Iq-Current - internal
     *
     * Range: -32768..32767 (-4547.16391424..4547.02514581 Arms)
     * Scale: 0.13876843
     * Offset: 0
     */
    int16_t iq_actual;

    /**
     * Measured numerical Id-Current - internal
     *
     * Range: -32768..32767 (-4547.16391424..4547.02514581 Arms)
     * Scale: 0.13876843
     * Offset: 0
     */
    int16_t id_actual;

    /**
     * Error of the numerical Iq-Current - internal
     *
     * Range: -32768..32767 (-4547.16391424..4547.02514581 Arms)
     * Scale: 0.13876843
     * Offset: 0
     */
    int16_t iq_error;

    /**
     * Error of the numerical Id-Current - internal
     *
     * Range: -32768..32767 (-4547.16391424..4547.02514581 Arms)
     * Scale: 0.13876843
     * Offset: 0
     */
    int16_t id_error;

    /**
     * Measured numerical I1-Current - internal
     *
     * Range: -32768..32767 (-6430.660886528..6430.464638332 A)
     * Scale: 0.196248196
     * Offset: 0
     */
    int16_t i1_actual;

    /**
     * Measured numerical I2-Current - internal
     *
     * Range: -32768..32767 (-6430.660886528..6430.464638332 A)
     * Scale: 0.196248196
     * Offset: 0
     */
    int16_t i2_actual;

    /**
     * Measured numerical I3-Current - internal
     *
     * Range: -32768..32767 (-6430.660886528..6430.464638332 A)
     * Scale: 0.196248196
     * Offset: 0
     */
    int16_t i3_actual;

    /**
     * Measured ADC Value of the I3-current Shunt
     *
     * Range: 0..65535 (0..65535 Num)
     * Scale: 1
     * Offset: 0
     */
    uint16_t i3_adc;

    /**
     * Measured ADC Value of the I2-current Shunt
     *
     * Range: 0..65535 (0..65535 Num)
     * Scale: 1
     * Offset: 0
     */
    uint16_t i2_adc;

    /**
     * Q - Value Voltage Output
     *
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t vq;

    /**
     * D - Value Voltage Output
     *
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t vd;

    /**
     * Voltage Output Vq and Vd total
     *
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t vout;

    /**
     * Temperature Motor as ADC value
     *
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t t_motor;

    /**
     * Temperature Igbt as ADC value
     *
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t t_igbt;

    /**
     * Temperature Air (inside) as ADC value
     *
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t t_air;

    /**
     * DC-Bus Voltage
     *
     * Range: 0..65532.05229287863361432703605 (0..2075 V)
     * Scale: 0.03166389465
     * Offset: 0
     */
    uint16_t vdc_bus_filt;

    /**
     * Digital Input - END 1
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t end_1;

    /**
     * Digital Input - DIN 1
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t din_1;

    /**
     * Digital Input - END 2
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t end_2;

    /**
     * Digital Input - DIN 2
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t din_2;

    /**
     * Digital Input - RUN
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t run232;

    /**
     * Digital Output - DOUT 1
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dout_1;

    /**
     * Digital Output - DOUT 2
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dout_2;

    /**
     * Digital Output - DOUT 3
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dout_3;

    /**
     * Digital Output - Rdy_BTB
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t rdy_btb;

    /**
     * Hardware Error Signal I_Fault
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t i_fault;

    /**
     * Digital Output - DOUT 4
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dout_4;

    /**
     * Derating Reduction to percentage Value - Trigger is Dig Input - Percentage as 15 Bit entry format (32767 equal 100perc)
     *
     * Range: 0..32766.99943739061966000306044 (0..100 %)
     * Scale: 0.003051851
     * Offset: 0
     */
    int16_t i_lim_dig;

    /**
     * Current reduction by rotation speed - Percentage as 15 Bit entry format (32767 equal 100perc)
     *
     * Range: 0..32766.99943739061966000306044 (0..100 %)
     * Scale: 0.003051851
     * Offset: 0
     */
    uint16_t i_red_n;

    /**
     * Start of current reduction by power stage temperature
     *
     * Range: 0..32767 (0..32767 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t i_red_td;

    /**
     * Stop of current reduction by power stage temperature
     *
     * Range: 0..32767 (0..32767 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t i_red_te;

    /**
     * Current reduction by motor temperature
     *
     * Range: 0..32767 (0..32767 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t i_red_tm;

    /**
     * Command Source Mask - Analog 1 Format Bits
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_rcv_cs_ain_1_format cs_ain_1_format;

    /**
     * Set (Reference) numerical Id-Current - internal
     *
     * Range: -32768..32767 (-4547.16391424..4547.02514581 Arms)
     * Scale: 0.13876843
     * Offset: 0
     */
    int16_t id_ref;

    /**
     * Digital numerical Iq-Current Output - input
     *
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t m_outdig__iq;

    /**
     * Debugger Pointer 1
     *
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t ptr_1_debug;

    /**
     * Debugger Pointer 2
     *
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t ptr_2_debug;

    /**
     * Debugger Pointer Temp
     *
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t temp_debug;

    /**
     * Nominal Motor Frequency
     *
     * Range: 0..65535 (0..6553.5 Hz)
     * Scale: 0.1
     * Offset: 0
     */
    uint16_t motor_f_n;

    /**
     * Nominal Motor Voltage
     *
     * Range: 0..65535 (0..65535 V)
     * Scale: 1
     * Offset: 0
     */
    uint16_t motor_v_n;

    /**
     * Time For DC Pre-Charge-Magnitising - Start
     *
     * Range: 0..65535 (0..65535 ms)
     * Scale: 1
     * Offset: 0
     */
    uint16_t t_dc__start;

    /**
     * DC Voltage for Pre-Magnitization - Start
     *
     * Range: -32768..32767 (-3276.8..3276.7 %)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t v_dc__start;

    /**
     * Minimum Voltage (FU operation) at Start
     *
     * Range: -32768..32767 (-3276.8..3276.7 %)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t v_min__start;

    /**
     * Minimum Frequency (FU operation) at Start
     *
     * Range: -32768..32767 (-3276.8..3276.7 Hz)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t f_min__start;

    /**
     * Voltage (percentage of DC-Bus) at max. Frequency
     *
     * Range: -32768..32767 (-3276.8..3276.7 %)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t v_corner__start;

    /**
     * Frequency at max output voltage - Start
     *
     * Range: -32768..32767 (-3276.8..3276.7 Hz)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t f_corner__start;

    /**
     * Motor Power Factor
     *
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t cos_phi;

    /**
     * Value for PWM Frequency configuration (Internal)
     *
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pwm_enum;

    /**
     * Entry for the Reference Value used for various Calibrations
     *
     * Range: 0..65535 (0..6553.5 -)
     * Scale: 0.1
     * Offset: 0
     */
    uint16_t calib_ref_value;

    /**
     * Proportional Gain Iq-Current Controller - A entry 33 equals 1.0 normalized
     *
     * Range: 0..200 (0..200 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pid_i__kp__iq;

    /**
     * Integral Action Time (Integral Part) Iq-Current Controller
     *
     * Range: 300..20000 (300..20000 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pid_i__ti__iq;

    /**
     * Digital Cutoff area of incomming digital commands
     *
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t cutoffdig;

    /**
     * I3 Offset value measured at Enable
     *
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t i3_offset;

    /**
     * Final Current Ramp Step setting
     *
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t i_delta_ramp;

    /**
     * Iq-Current Control Integral Maximum Output Range
     *
     * Range: 0..500 (0..500 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pid_i__tim__iq;

    /**
     * Proportional Gain Speed Controller
     *
     * Range: 0..200 (0..200 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pid_n__kp;

    /**
     * Integral Action Time (Integral Part) Voltage Controller (0.0001 x Ti equals 1.0)
     *
     * Range: 0..65535 (0..65535 ms)
     * Scale: 1
     * Offset: 0
     */
    uint16_t v_ti;

    /**
     * Derative Action Time (Derative Part) Speed Controller
     *
     * Range: 0..10000 (0..10000 ms)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pid_n__td;

    /**
     * Analog Input Signal 1 - Offset Value Setting
     *
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t ain_in_1_offsetval;

    /**
     * Analog Input Signal 2 - Offset Value Setting
     *
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t ain_in_2_offsetval;

    /**
     * SpeedControl Loop (DZR) Sequencer Configuration (PWM Freq dependent)
     *
     * Range: 0..32767 (0..32767 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t dzr_seq;

    /**
     * Speed Control Integral Maximum Output Range
     *
     * Range: 0..100 (0..100 %)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pid_n__tim;

    /**
     * Speed n Limit plus - Percentage as 15 Bit entry format (32767 equal 100perc)
     *
     * Range: 0..32766.99943739061966000306044 (0..100 %)
     * Scale: 0.003051851
     * Offset: 0
     */
    int16_t n_lim_plus;

    /**
     * Speed n Limit minus - Percentage as 15 Bit entry format (-32767 equal -100perc)
     *
     * Range: -32766.99943739061966000306044..0 (-100..0 %)
     * Scale: 0.003051851
     * Offset: 0
     */
    int16_t n_lim_minus;

    /**
     * Delta diff of the feedback Signal per measuring point
     *
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t incr_delta;

    /**
     * Actual Mechanical Angle Position of the Motor
     *
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t motorpos_mech;

    /**
     * Actual Electrical Angle Position of the Motor
     *
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t motorpos_elec;

    /**
     * FeedBack Offset Angle Value
     *
     * Range: -3600..3600 (-360..360 -)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t fb_offset;

    /**
     * Bleeder Resistor Ixt  Monitor
     *
     * Range: -2147483648..2147483647 (-2147483648..2147483647 -)
     * Scale: 1
     * Offset: 0
     */
    int32_t it_rg_monitor;

    /**
     * Motor Pole Number
     *
     * Range: 2..96 (2..96 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t motor_pole;

    /**
     * Analog Input Signal 1 - Cutoff Value Setting
     *
     * Range: 0..32767 (0..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t ain_in_1_cutoff;

    /**
     * Active Control Mode Mask
     *
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_rcv_activecontrolmode activecontrolmode;

    /**
     * Kern Mode State Bit - rsvd_0
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t km_rsvd_0;

    /**
     * Enable drive
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ena82;

    /**
     * Analog Input Signal 2 - Cutoff Value Setting
     *
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t ain_in_2_cutoff;

    /**
     * Actual Reduced Current Limit ramped
     *
     * Range: -32768..32767 (-12249.91571968..12249.54188192 Arms)
     * Scale: 0.37383776
     * Offset: 0
     */
    int16_t i_limit_inuse_ramp;

    /**
     * Motor Nominal Rotation Speed
     *
     * Range: 60..65000 (60..65000 rpm)
     * Scale: 1
     * Offset: 0
     */
    uint16_t n_nom;

    /**
     * Speed Control Acceleration Feed Foreward Gain
     *
     * Range: 0..100 (0..100 %)
     * Scale: 1
     * Offset: 0
     */
    int16_t pid_n__kacc;

    /**
     * Digital Hall Sensor Position Rotor Signals Value
     *
     * Range: 0..65535 (0..65535 %)
     * Scale: 1
     * Offset: 0
     */
    uint16_t rotor_signals;

    /**
     * Additional Filter Adjustment of the Rotation Speed Measurement
     *
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t speed_filter;

    /**
     * Analog Input Signal 1 - Filter Value Setting
     *
     * Range: 0..255 (0..127.5 ms)
     * Scale: 0.5
     * Offset: 0
     */
    uint8_t ain_in_1_filter;

    /**
     * Monitor Value for Regen I x t calculation
     *
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t ixt_monitor;

    /**
     * Ecode - Bit 0 - First Error Detected
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ecode_bit0_firsterrordtcd99;

    /**
     * Device Mains Supply Voltage Value
     *
     * Range: 0..1000 (0..1000 V)
     * Scale: 1
     * Offset: 0
     */
    uint16_t device_mains;

    /**
     * Regenerative Resistor Power Value
     *
     * Range: 25..10000 (25..10000 W)
     * Scale: 1
     * Offset: 0
     */
    uint16_t regen_p;

    /**
     * CAN Identiciation ID for Receive - Rx
     *
     * Range: 0..65530 (0..65530 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t can_id_rx;

    /**
     * CAN Identiciation ID for Transmit - Tx
     *
     * Range: 0..65530 (0..65530 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t can_id_tx;

    /**
     * Proportional Gain Position Controller
     *
     * Range: 0..500 (0..500 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pos_kp;

    /**
     * Integral Action Time (Integral Part) Position Controller
     *
     * Range: 0..10000 (0..10000 ms)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pos_ti;

    /**
     * Derative Action Time (Derative Part) Position Controller
     *
     * Range: 0..65535 (0..65535 ms)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pos_td;

    /**
     * Numeric Actual Position Value
     *
     * Range: -2147483648..2147483647 (-2147483648..2147483647 -)
     * Scale: 1
     * Offset: 0
     */
    int32_t pos_actual;

    /**
     * Numeric Destination Position Value
     *
     * Range: -2147483648..2147483647 (-2147483648..2147483647 -)
     * Scale: 1
     * Offset: 0
     */
    int32_t pos_dest;

    /**
     * Numeric Actual Position 2 (Alternative) Value
     *
     * Range: -2147483648..2147483647 (-2147483648..2147483647 -)
     * Scale: 1
     * Offset: 0
     */
    int32_t pos_actual_2;

    /**
     * Numeric Error Position Value
     *
     * Range: -2147483648..2147483647 (-2147483648..2147483647 -)
     * Scale: 1
     * Offset: 0
     */
    int32_t pos_error;

    /**
     * Position Control Integral Maximum Output Range
     *
     * Range: 0..100 (0..100 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pos_tim;

    /**
     * Numeric Position Zero Offset Value
     *
     * Range: -2147483648..2147483647 (-2147483648..2147483647 -)
     * Scale: 1
     * Offset: 0
     */
    int32_t pos_offsref;

    /**
     * CAN BaudRate Configuration Setting
     *
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_rcv_can_nbt can_nbt;

    /**
     * Position Zero Capture
     *
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pos_zero_capture;

    /**
     * Resolver Position at Reference Switch (Rsw)
     *
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t ref_reso_edge;

    /**
     * Position Reference Speed 1 (Fast)
     *
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t speed_1;

    /**
     * Position Reference Speed 1 (Slow) + Phasing electrical Rotation Speed
     *
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t speed_2;

    /**
     * Tolerance Window for Destination Position
     *
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t pos_tol_win;

    /**
     * Numeric Preset Position Value (Set actual Position to Preset Position)
     *
     * Range: -2147483648..2147483647 (-2147483648..2147483647 -)
     * Scale: 1
     * Offset: 0
     */
    int32_t pos_preset_val;

    /**
     * User Zero Offset Position Value
     *
     * Range: -2147483648..2147483647 (-2147483648..2147483647 -)
     * Scale: 1
     * Offset: 0
     */
    int32_t pos_zero_offset;

    /**
     * NDrive Position Display Scale Factor
     *
     * Range: -2147483648..2147483647 (-2147483648..2147483647 -)
     * Scale: 1
     * Offset: 0
     */
    int32_t pos_nd_scale;

    /**
     * NDrive Position Display Offset Factor
     *
     * Range: -2147483648..2147483647 (-2147483648..2147483647 -)
     * Scale: 1
     * Offset: 0
     */
    int32_t pos_nd_offset;

    /**
     * Feedback 2 - External Scale Factor
     *
     * Range: -2147483648..2147483647 (-2147483648..2147483647 -)
     * Scale: 1
     * Offset: 0
     */
    int32_t fb2_scale_ext;

    /**
     * Position Offset Slack Value
     *
     * Range: -2147483648..2147483647 (-2147483648..2147483647 -)
     * Scale: 1
     * Offset: 0
     */
    int32_t pos_offset_slack;

    /**
     * Position Difference Slack Value
     *
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t pos_diff_slack;

    /**
     * Special Function For Parameter Read command from Eeprom sector
     *
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t fun_para_read;

    /**
     * Special Function For Parameter Write command to Eeprom sector
     *
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t fun_para_write;

    /**
     * Special Functions for automatic logics or calculations
     *
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t fun_special;

    /**
     * CAN Identiciation ID - 2 - for Receive - Rx
     *
     * Range: 0..4294967295 (0..4294967295 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t can_id_2_rx;

    /**
     * CAN Identiciation ID - 2 - for Transmit - Tx
     *
     * Range: 0..4294967295 (0..4294967295 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t can_id_2_tx;

    /**
     * Voltage Controller Reference value in perc of Vout (V_Red - Start of Field Reduction)
     *
     * Range: -32768..32767 (-32768..32767 %)
     * Scale: 1
     * Offset: 0
     */
    int16_t v_ref;

    /**
     * Proportional Gain Voltage Controller (0.0001 * Ti equals 1.0)
     *
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t v_kp;

    /**
     * Integral Action Time (Integral Part) Speed Controller
     *
     * Range: 0..10000 (0..10000 ms)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pid_n__ti;

    /**
     * Clear Error and Warning List
     *
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t clear_errors;

    /**
     * Numeric Position Command Value
     *
     * Range: -2147483648..2147483647 (-2147483648..2147483647 -)
     * Scale: 1
     * Offset: 0
     */
    int32_t pos_cmd;

    /**
     * CAN Bus Error counter - Bus Off
     *
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t can_error_busoff;

    /**
     * CAN Bus Error counter - Write Time
     *
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t can_error_writetime;

    /**
     * Ecode - Bit 0 - First Error Detected
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ecode_bit0_firsterrordtcd148;

    /**
     * CAN Bus Error counter - No Ack
     *
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t can_error_no_ack;

    /**
     * CAN Bus Error counter - CRC_Check
     *
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t can_error_crc_check150;

    /**
     * CAN Bus Error counter - Error Status Bit from CAN Module
     *
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t can_error_crc_check151;

    /**
     * Info Interrupt time
     *
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t info_timer_diff;

    /**
     * Internal Ballast Count Value
     *
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t ballastcount;

    /**
     * Motor Temperature Limit for Inverter Error shutdown
     *
     * Range: 0..32767 (0..32767 Num)
     * Scale: 1
     * Offset: 0
     */
    uint16_t m_temp;

    /**
     * Motor Options - Feedback 1 Type
     *
     * Range: 0..31 (0..31 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_rcv_mo_feedback_1 mo_feedback_1;

    /**
     * DC Bus Min Value Superpision Limit
     *
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t dc_bus_min_lim;

    /**
     * Feedback System Increments per rotation
     *
     * Range: 0..65535 (0..65535 Inc/Rev)
     * Scale: 1
     * Offset: 0
     */
    uint16_t fb_incr_mot;

    /**
     * Feedback Pole number
     *
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t fb_pole;

    /**
     * Foreground Cycle Frequency
     *
     * Range: 0..65535 (0..65535 Hz)
     * Scale: 1
     * Offset: 0
     */
    uint16_t logic_freq;

    /**
     * PWM 1 (5/6) clock open time
     *
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t pwm_1;

    /**
     * PWM 2 (3/4) clock open time
     *
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t pwm_2;

    /**
     * PWM 3 (1/2) clock open time
     *
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t pwm_3;

    /**
     * PWM Configuration value of timer delta
     *
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t timer_delta;

    /**
     * Motor - Stator Leakage Inductance - Lsq
     *
     * Range: 0..65535 (0..65.535 mH)
     * Scale: 0.001
     * Offset: 0
     */
    uint16_t motor_lsq;

    /**
     * Motor Leakage Inductance ph-ph - Lsd
     *
     * Range: 0..65535 (0..65.535 mH)
     * Scale: 0.001
     * Offset: 0
     */
    uint16_t motor_lsd;

    /**
     * Nominal Magnetising d-Current value as perc of nominal current
     *
     * Range: -32768..32767 (-32768..32767 %)
     * Scale: 1
     * Offset: 0
     */
    int16_t id_nom;

    /**
     * Motor - Magnetizing Inductance - L
     *
     * Range: 0..65535 (0..655.35 mH)
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t motor_lm;

    /**
     * Motor - Rotor Resistance Value
     *
     * Range: 0..65535 (0..65535 mOhm)
     * Scale: 1
     * Offset: 0
     */
    uint16_t motor_rr;

    /**
     * Minimum Magnetising d-Current value as perc of nominal current
     *
     * Range: 0..100 (0..100 %)
     * Scale: 1
     * Offset: 0
     */
    int16_t id_min;

    /**
     * Rotor Time Contant of the Motor
     *
     * Range: -32768..32767 (-32768..32767 ms)
     * Scale: 1
     * Offset: 0
     */
    int16_t motor_tr;

    /**
     * Motor - Stator Resistance Value
     *
     * Range: 0..65535 (0..65535 mOhm)
     * Scale: 1
     * Offset: 0
     */
    uint16_t motor_rs;

    /**
     * Stator Time Contant of the Motor
     *
     * Range: -32768..32767 (-32.768..32.767 ms)
     * Scale: 0.001
     * Offset: 0
     */
    int16_t motor_ts;

    /**
     * Definition - Function attribution of the Digital Input - END 1 (Limit 1)
     *
     * Range: 0..32767 (0..32767 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_rcv_def_end_1 def_end_1;

    /**
     * Definition - Function attribution of the Digital Input - END 2 (Limit 2)
     *
     * Range: 0..32767 (0..32767 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_rcv_def_end_2 def_end_2;

    /**
     * Definition - Function attribution of the Digital Input - DIN 1
     *
     * Range: 0..32767 (0..32767 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_rcv_def_din_1 def_din_1;

    /**
     * Definition - Function attribution of the Digital Input - DIN 2
     *
     * Range: 0..32767 (0..32767 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_rcv_def_din_2 def_din_2;

    /**
     * Selection List Operant for digital Output OUT 1
     *
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_rcv_operand194 operand194;

    /**
     * Maximum possible allowed current
     *
     * Range: -32768..32767 (-4547.16391424..4547.02514581 Arms)
     * Scale: 0.13876843
     * Offset: 0
     */
    int16_t i_max_inuse;

    /**
     * Digital Output Signal - internal GO is set (no errors)
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t signal_go;

    /**
     * Digital Output Signal - mechanical Brake Activated
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t signal_brake;

    /**
     * Digital Output Signal - The current limit is reduced to continuous current
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t signal_icns;

    /**
     * Digital Output Signal - Actual speed less than 0.1 %
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t signal_lessn0;

    /**
     * Digital Output Signal - Actual Position is within tolerance window
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t signal_postolerance;

    /**
     * Analog Input Signal 1 - Scaled
     *
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t ain_in_1_scaled251;

    /**
     * Analog Input Signal 2 - Scaled
     *
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t ain_in_2_scaled252;

    /**
     * Selection List Operant for digital Output OUT 2
     *
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_rcv_operand195 operand195;

    /**
     * Selection List Operant for digital Output OUT 3
     *
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_rcv_operand218 operand218;

    /**
     * Selection List Operant for digital Output OUT 4
     *
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_rcv_operand219 operand219;

    /**
     * Proportional Gain Iq-Current Controller if actual current is above I Limit Inuse Current - perc is depending on Kp value
     *
     * Range: 0..200 (0..200 %)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pid_i__xkp__iq;

    /**
     * Idc or Pdc Limit during Motor operation
     *
     * Range: 0..65535 (0..6553.5 A or W)
     * Scale: 0.1
     * Offset: 0
     */
    uint16_t bat_opr_limit__mot;

    /**
     * Feedforward - Proportional Gain Iq-Current Controller
     *
     * Range: 0..200 (0..200 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pid_i__kf__iq;

    /**
     * DC Current Sesnor is set to enabled
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dc_current_sens_ena_set;

    /**
     * Enable the use of the DC current Sensor (if present)
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cmc__bit0__dc_current_sens_ena;

    /**
     * Max possible Rotation Speed internal
     *
     * Range: -32768..32767 (-32768..32767 rpm)
     * Scale: 1
     * Offset: 0
     */
    int16_t n_rpm_maxint;

    /**
     * Comparison Variable 1
     *
     * Range: -2147483648..2147483647 (-2147483648..2147483647 -)
     * Scale: 1
     * Offset: 0
     */
    int32_t var_1;

    /**
     * CAN Timeout time settings
     *
     * Range: 0..32767 (0..32767 ms)
     * Scale: 1
     * Offset: 0
     */
    int16_t can_rxtimeout;

    /**
     * Comparison Variable 2
     *
     * Range: -2147483648..2147483647 (-2147483648..2147483647 -)
     * Scale: 1
     * Offset: 0
     */
    int32_t var_2;

    /**
     * Comparison Variable 3
     *
     * Range: -2147483648..2147483647 (-2147483648..2147483647 -)
     * Scale: 1
     * Offset: 0
     */
    int32_t var_3;

    /**
     * Comparison Variable 4
     *
     * Range: -2147483648..2147483647 (-2147483648..2147483647 -)
     * Scale: 1
     * Offset: 0
     */
    int32_t var_4;

    /**
     * DAC Configuration of the RegID Source Channel as Output
     *
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dup__bit7_0__dac_source_channel;

    /**
     * Feedback Loss of Signal
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t fb_lossofsignal;

    /**
     * No HW_Fault detected
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t no_hw_fault;

    /**
     * Allowed Timing for Peak Current
     *
     * Range: 0..65535 (0..65535 s)
     * Scale: 1
     * Offset: 0
     */
    uint16_t t_peak;

    /**
     * Mechanical Brake Delay Time (e.g. Relay)
     *
     * Range: 0..65535 (0..65535 ms)
     * Scale: 1
     * Offset: 0
     */
    uint16_t brake_delay;

    /**
     * Inverter Output AC Power (DO NOT USE!!)
     *
     * Range: -32768..32767 (-32768..32767 W)
     * Scale: 1
     * Offset: 0
     */
    int16_t power;

    /**
     * Inverter Output AC Work (DO NOT USE!!)
     *
     * Range: -32768..32767 (-32768..32767 Joul)
     * Scale: 1
     * Offset: 0
     */
    int16_t work;

    /**
     * FU Extra - Start
     *
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t extra__start;

    /**
     * NDrive Oszillloscop - Capture Channel
     *
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t capture_channel;

    /**
     * NDrive Oszillloscop - Capture Trigger Edge
     *
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t trig_level;

    /**
     * NDrive Oszillloscop - Capture Trigger Level
     *
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t trig_edge;

    /**
     * NDrive Oszillloscop - Capture Trigger Source
     *
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t trig_source;

    /**
     * NDrive Oszillloscop - Capture Source
     *
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t oszi_source;

    /**
     * NDrive Oszillloscop - Capture Skip
     *
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t oszi_skip;

    /**
     * NDrive Oszillloscop - Run Command
     *
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t oszi_run_cmd;

    /**
     * NDrive Oszillloscop - Read Command
     *
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t oszi_read_cmd;

    /**
     * Start Park Cycle
     *
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t pos_ref_start;

    /**
     * DC-Bus Voltage
     *
     * Range: 0..65532.05229287863361432703605 (0..2075 V)
     * Scale: 0.03166389465
     * Offset: 0
     */
    uint16_t vdc_bus;

    /**
     * Digital numerical Iq-Current Command - internal ramped
     *
     * Range: -32767..32767 (-32767..32767 Num)
     * Scale: 1
     * Offset: 0
     */
    int16_t m_cmd_ramp;

    /**
     * Input Signal - Limit 1
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t lmt_1;

    /**
     * Output Signal - Out 1
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t out_1;

    /**
     * Firmware Subversion Number
     *
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t subversion_nr;

    /**
     * Ballast-R extern
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ballast_ext;

    /**
     * Speed command value = 0 (drive stopped)
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ncr064;

    /**
     * Hardware error
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t err_powerfault;

    /**
     * Digital input limit 2 active
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t lmt2;

    /**
     * Kern Mode State Bit -
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t km_speed_0;

    /**
     * Speed command value = 0 (drive stopped)
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ncr082;

    /**
     * Ecode - Bit 1 - HW 1 Coding State
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ecode_bit1__hw1_state99;

    /**
     * Ecode - Bit 1 - HW 1 Coding State
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ecode_bit1__hw1_state148;

    /**
     * DC current Sensor (if present) Activated
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dc_i_sensena_set;

    /**
     * Enable the Limitiation Calculation depending on the DC Current limits
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cmc__bit1__idc_limit_ena;

    /**
     * Input Signal - Limit 2
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t lmt_2;

    /**
     * Output Signal - Out 2
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t out_2;

    /**
     * Feedback Speciality
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t fb_special;

    /**
     * Limit switch plus assigned
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t lim_plus64;

    /**
     * Safety circuit faulty (only active with RUN)
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t err_rfe_fault;

    /**
     * Digital input Din 2 active
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t in2;

    /**
     * Command Source Mask - Analog 2 Format Bits
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_rcv_cs_ain_2_format cs_ain_2_format;

    /**
     * Kern Mode State Bit -
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t km_frg_off;

    /**
     * Limit switch plus assigned
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t lim_plus82;

    /**
     * Ecode - Bit 2 - HW 0 Coding State
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ecode_bit2__hw0_state99;

    /**
     * Ecode - Bit 2 - HW 0 Coding State
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ecode_bit2__hw0_state148;

    /**
     * Present Operation Quadrant Mode
     *
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t op_mode_quadrant;

    /**
     * Use the DC current Limitiation Calculation depending on the DC Power limits
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cmc__bit2__pdc_limit_usage;

    /**
     * Input Signal - Input 2
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t in_2;

    /**
     * Output Signal - Rdy
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t rdy155;

    /**
     * Coast Stop Activation
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t coaststop;

    /**
     * Limit switch minus assigned
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t lim_minus64;

    /**
     * CAN TimeOut time exceeded
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t err_bustimeout;

    /**
     * Digital input Din 1 active
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t in1;

    /**
     * Kern Mode State Bit -
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t km_cal_off;

    /**
     * Limit switch minus assigned
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t lim_minus82;

    /**
     * Ecode - Bit 3 - Free (NOT INUSE)
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ecode_bit3__free99;

    /**
     * Ecode - Bit 3 - Free (NOT INUSE)
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ecode_bit3__free148;

    /**
     * Enable Init as Torque Mode after Enable (Run)
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cmc__bit3__torqueval_init_ena;

    /**
     * Input Signal - Input 1
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t in_1;

    /**
     * Output Signal - Go
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t go155;

    /**
     * Current Measurement Inverse
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t i_ist_inverse;

    /**
     * Drive ok (no uncontrolled control-voltage reset seen)
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ok64;

    /**
     * Encoder signal faulty or missing
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t err_feedbacksignal;

    /**
     * Hardware enable active
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t frgrun;

    /**
     * Command Source Mask - Analog 1 Mode Bits
     *
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_rcv_cs_ain_1_mode cs_ain_1_mode;

    /**
     * Kern Mode State Bit -
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t km_tx_tog_stat;

    /**
     * Drive ok (no uncontrolled control-voltage reset seen)
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ok82;

    /**
     * Ecode - Bit 4 - RDY3
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ecode_bit4__rdy399;

    /**
     * Ecode - Bit 4 - RDY3
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ecode_bit4__rdy3148;

    /**
     * Arrangement Variable Selection List for digital Output 1
     *
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_rcv_compare_var194 compare_var194;

    /**
     * Arrangement Variable Selection List for digital Output 2
     *
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_rcv_compare_var195 compare_var195;

    /**
     * Arrangement Variable Selection List for digital Output 3
     *
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_rcv_compare_var218 compare_var218;

    /**
     * Arrangement Variable Selection List for digital Output 4
     *
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_rcv_compare_var219 compare_var219;

    /**
     * Enable the use of Recuperation Ramps during Torque Mode
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cmc__bit4__dig_m_rcpramp_ena;

    /**
     * Input Signal - Run (FRG)
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t run152;

    /**
     * Output Signal - Out 3
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t out_3;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t refsoft;

    /**
     * Current is limited to the continuous current level
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t icns64;

    /**
     * Power voltage missing
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t err_powervoltage_low;

    /**
     * Rotating Field Enable
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t rfe216;

    /**
     * Kern Mode State Bit -
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t km_i_limit;

    /**
     * Current is limited to the continuous current level
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t icns82;

    /**
     * Ecode - Bit 5 - N FAIL
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ecode_bit5__n_fail99;

    /**
     * Ecode - Bit 5 - N FAIL
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ecode_bit5__n_fail148;

    /**
     * Motor Options - Feedback 2 Type
     *
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_rcv_mo_feedback_2 mo_feedback_2;

    /**
     * Recuperation is active
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t recup_is_acv;

    /**
     * Speed Ramp Reset to 0 if actual speed crosses 0 rpm
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cmc__bit5__reset_nramp_atnzero;

    /**
     * Input Signal - RFE
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t rfe152;

    /**
     * Output Signal - Out 4
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t out_4;

    /**
     * BTB nicht mit Powervoltage Ãœberwachung verknÃ¼pft
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t no_uesp_btb;

    /**
     * Speed-limited torque mode active
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t tnlim64;

    /**
     * Motor temperature too high
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t err_motortemp;

    /**
     * Kern Mode State Bit -
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t km_n_clip;

    /**
     * Speed-limited torque mode active
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t tnlim82;

    /**
     * Ecode - Bit 6 - FLTHS
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ecode_bit6__flths99;

    /**
     * Ecode - Bit 6 - FLTHS
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ecode_bit6__flths148;

    /**
     * Motor Current Limiting Activated because of DC Current lmiting
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t i_dc_limit_is_acv;

    /**
     * Set Torque command to 0 if no new external torque command input within 100 ms is registered
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cmc__bit6__torquetimeout_100ms_e;

    /**
     * reserved
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t rsvd;

    /**
     * reserved 1
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t rsvd1;

    /**
     * Analogue DC-Bus measurement
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t vdc_ana;

    /**
     * Position control possible
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t pn64;

    /**
     * Device temperature too high
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t err_devicetemp;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cs_oora1;

    /**
     * Kern Mode State Bit -
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t km_mix_ana_on;

    /**
     * Position control possible
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t pn82;

    /**
     * Ecode - Bit 7 - FLTLS
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ecode_bit7__fltls99;

    /**
     * Ecode - Bit 7 - FLTLS
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ecode_bit7__fltls148;

    /**
     * Free (NOT INUSE)
     *
     * Range: 0..127 (0..127 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cmc__bit13_7__free;

    /**
     * Output Signal - break 1
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t brk1155;

    /**
     * Current Measurement I1 Enable
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t i1_adc_ena;

    /**
     * Speed control possible
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ni64;

    /**
     * Overvoltage > 1.8 x UN reached
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t err_overvoltage;

    /**
     * Digital output Dout 1 on
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t out1;

    /**
     * Command Source Mask - Analog 2 Mode Bits
     *
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_rcv_cs_ain_2_mode cs_ain_2_mode;

    /**
     * Active SubControl Mode Mask
     *
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_rcv_ctrlsubmode ctrlsubmode;

    /**
     * Kern Mode State Bit - Allow Sync
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t km_allow_sync;

    /**
     * Speed control possible
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ni82;

    /**
     * Analog Input Signal 2 - Filter Value Setting
     *
     * Range: 0..255 (0..127.5 ms)
     * Scale: 0.5
     * Offset: 0
     */
    uint8_t ain_in_2_filter;

    /**
     * Ecode - Bit 1 - Idc Error detected
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ecode_bit8__fail_idc99;

    /**
     * Ecode - Bit 1 - Idc Error detected
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ecode_bit8__fail_idc148;

    /**
     * Motor Options -
     *
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_rcv_mo_sc1_reso mo_sc1_reso;

    /**
     * Signal Source ID for the compare operation according to RegID Address
     *
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_rcv_source_id194 source_id194;

    /**
     * Signal Source ID for the compare operation according to RegID Address
     *
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_rcv_source_id195 source_id195;

    /**
     * Signal Source ID for the compare operation according to RegID Address
     *
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_rcv_source_id218 source_id218;

    /**
     * Signal Source ID for the compare operation according to RegID Address
     *
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_rcv_source_id219 source_id219;

    /**
     * CAN PDOs extension
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dup__bit8__can_extended_0;

    /**
     * Inverted order of Hall sensors
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t hxinv;

    /**
     * Acutal speed less than 0.1% (standstill)
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t _n064;

    /**
     * Overcurrent or strongly oscillating current detected
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t err_ipeak;

    /**
     * Digital output Dout 2 on
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t out2;

    /**
     * Kern Mode State Bit -
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t km_handwheel;

    /**
     * Acutal speed less than 0.1% (standstill)
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t _n082;

    /**
     * Ecode - Bit 9 - I Error detected
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ecode_bit9__fail_i99;

    /**
     * Ecode - Bit 9 - I Error detected
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ecode_bit9__fail_i148;

    /**
     * Special DC Bus generator operation
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dup__bit9__generator;

    /**
     * Inverted Hall 2
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t h2inv;

    /**
     * Reference switch tripped
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t rsw64;

    /**
     * Drive races (without command value, wrong direction)
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t err_raceaway;

    /**
     * Hardware relay, output BTB (Rdy) on
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t btbrdy;

    /**
     * Kern Mode State Bit -
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t km_phasing_extend;

    /**
     * Reference switch tripped
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t rsw82;

    /**
     * Ecode - Bit 10 - VCC Voltage error
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ecode_bit10__vccm99;

    /**
     * Ecode - Bit 10 - VCC Voltage error
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ecode_bit10__vccm148;

    /**
     * Set factor 1divsqrt(2) in park currents
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dup__bit10__park_rms;

    /**
     * Over Loop current limit or slip compensation Enable
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ol_comp;

    /**
     * Calibration move active
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cal064;

    /**
     * User - choice of Error
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t err_user;

    /**
     * Internal enable GO active
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t go216;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cs_oora2;

    /**
     * Kern Mode State Bit - rsvd_11
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t km_rsvd_11;

    /**
     * Calibration move active
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cal082;

    /**
     * Ecode - Bit 11 - 15V minus Voltage error
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ecode_bit11__15m_minus99;

    /**
     * Ecode - Bit 11 - 15V minus Voltage error
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ecode_bit11__15m_minus148;

    /**
     * Motor Options -
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t mo_sc1_comp;

    /**
     * DCBus Value as V for output Communication
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dup__bit11__dcbus_volts;

    /**
     * Firmware Test Number
     *
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t test;

    /**
     * Motor Type define
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_rcv_motortype motortype;

    /**
     * Calibration move completed (position calibrated)
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cal64;

    /**
     * Digital output Dout 3 on
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t out3;

    /**
     * Command Source Mask - Bitmask Coding of Command Type
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_rcv_cs_cmd_type cs_cmd_type;

    /**
     * Active Control Current Mode Mask
     *
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_rcv_currentmode currentmode;

    /**
     * Kern Mode State Bit - rsvd_12
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t km_rsvd_12;

    /**
     * Calibration move completed (position calibrated)
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cal82;

    /**
     * Ecode - Bit 12 - 15V plus Voltage error
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ecode_bit12__15m_plus99;

    /**
     * Ecode - Bit 12 - 15V plus Voltage error
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ecode_bit12__15m_plus148;

    /**
     * Motor Options -
     *
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_rcv_mo_sc2_reso mo_sc2_reso;

    /**
     * Command (Acc Pedal) must be at 0 to enable inverter
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dup__bit12__boat_pedal;

    /**
     * Position within tolerance window
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t tol64;

    /**
     * Digital output Dout 4 on
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t out4;

    /**
     * Kern Mode State Bit - rsvd_13
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t km_rsvd_13;

    /**
     * Position within tolerance window
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t tol82;

    /**
     * Ecode - Bit 13 - 18V plus Voltage error
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ecode_bit13__18m_plus99;

    /**
     * Ecode - Bit 13 - 18V plus Voltage error
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ecode_bit13__18m_plus148;

    /**
     * Special Generator Mode with automatic Iac limit reduction
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dup__bit13__gen_autoiaclimit;

    /**
     * Messbereich DC-Bus,1 (0..5 V), 0 (2,5..5 V)
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ana_0up;

    /**
     * Drive is ready (BTB/TDY contact is closed)
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t rdy64;

    /**
     * Current - measurement error
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t err_hwerr;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t goff;

    /**
     * Command Source Mask - Analog 2 I Limit Status Bit
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cs_ain_2__i_limit;

    /**
     * Kern Mode State Bit -
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t km_pseudo_enable;

    /**
     * Drive is ready (BTB/TDY contact is closed)
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t rdy82;

    /**
     * Ecode - Bit 14 - UBMA overvoltage error (digital)
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ecode_bit14__ubmam99;

    /**
     * Ecode - Bit 14 - UBMA overvoltage error (digital)
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ecode_bit14__ubmam148;

    /**
     * Enable the Limitiation Calculation depending on the DC Current limits V2
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cmc__bit14__idc_limit_ena_v2;

    /**
     * Enable MTPA calculation and automatic command of Id_ref
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dup__bit14__mtpa_reluct_enab;

    /**
     * Low Baud rate of 9600 (serial)
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t lowbd;

    /**
     * De-energized brake with motor active
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t brk064;

    /**
     * Ballast circuit overloaded
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t err_ballast;

    /**
     * Excited Brake
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t brk1216;

    /**
     * Command Source Mask - Analog 1 N Limit Bit
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cs_ain_1__n_limit;

    /**
     * Kern Mode State Bit -
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t km_debug_test;

    /**
     * De-energized brake with motor active
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t brk082;

    /**
     * Ecode - Bit 15 - T Igbt error (digital)
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ecode_bit15__t_igbt99;

    /**
     * Ecode - Bit 15 - T Igbt error (digital)
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ecode_bit15__t_igbt148;

    /**
     * Motor Options -
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t mo_sc2_inv;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_rcv_active190 active190;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_rcv_active191 active191;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_rcv_active192 active192;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_rcv_active193 active193;

    /**
     * Automatic Iac Lmiting in generator mode is active
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t gen_autoiaclimit_is_acv;

    /**
     * Activate automated digital Recuperation Command
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cmc__bit15__dig_e_brake_act;

    /**
     * (Write Protected) Use CANopen instead of normal CAN protocol for the CAN communication
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dup__bit15__canopen_acv;

    /**
     * Torque Ramp Dec Time [0..4000 ms]
     *
     * Range: 0..4000 (0..4000 ms)
     * Scale: 1
     * Offset: 0
     */
    uint16_t m_r_dec;

    /**
     * Torque Ramp Rcp Time [0..4000 ms]
     *
     * Range: 0..4000 (0..4000 ms)
     * Scale: 1
     * Offset: 0
     */
    uint16_t m_r_rcp;

    /**
     * S-Ramp N Command (Inactive)
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t sramp;

    /**
     * Speed internally inverted
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t signmag64;

    /**
     * No device identification
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t warn_warning_0;

    /**
     * Analog Input Signal 1 - Scaled
     *
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t ain_in_1_scaled213;

    /**
     * Analog Input Signal 2 - Scaled
     *
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t ain_in_2_scaled214;

    /**
     * DC Current Time
     *
     * Range: 0..65535 (0..65535 ms)
     * Scale: 1
     * Offset: 0
     */
    uint16_t t_dc__stop;

    /**
     * DC-Voltage Value for DC-Braking
     *
     * Range: -32768..32767 (-3276.8..3276.7 %)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t v_dc__stop;

    /**
     * Minimum Voltage (FU operation) at Stop
     *
     * Range: -32768..32767 (-3276.8..3276.7 %)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t v_min__stop;

    /**
     * Minimum Frequency (FU operation) at Stop
     *
     * Range: -32768..32767 (-3276.8..3276.7 Hz)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t f_min__stop;

    /**
     * Voltage (percentage of DC-Bus) at max. Frequency
     *
     * Range: -32768..32767 (-3276.8..3276.7 %)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t v_corner__stop;

    /**
     * Frequency at max output voltage - Stop
     *
     * Range: -32768..32767 (-3276.8..3276.7 Hz)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t f_corner__stop;

    /**
     * Proportional Gain Id-Current Controller - A entry 33 equals 1.0 normalized
     *
     * Range: 0..200 (0..200 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pid_i__kp__id;

    /**
     * Integral Action Time (Integral Part) Id-Current Controller
     *
     * Range: 300..20000 (300..20000 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pid_i__ti__id;

    /**
     * Id-Current Control Integral Maximum Output Range
     *
     * Range: 0..500 (0..500 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pid_i__tim__id;

    /**
     * Analog Input Signal 1 - Scale Value Setting
     *
     * Range: -32763.904..32763.904 (-7.999..7.999 -)
     * Scale: 0.000244140625
     * Offset: 0
     */
    int16_t ain_in_1_scaleval;

    /**
     * Analog Input Signal 2 - Scale Value Setting
     *
     * Range: -32768..32767 (-8..7.999755859375 -)
     * Scale: 0.000244140625
     * Offset: 0
     */
    int16_t ain_in_2_scaleval;

    /**
     * Speed internally inverted
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t signmag82;

    /**
     * Regenerative Resistor Value
     *
     * Range: 0..65535 (0..65535 Ohm)
     * Scale: 1
     * Offset: 0
     */
    uint16_t regen_r;

    /**
     * DC Bus Max Value Superpision Limit
     *
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t dc_bus_max_lim;

    /**
     * Proportional Gain Id-Current Controller if actual current is above I Limit Inuse Current - perc is depending on Kp value
     *
     * Range: 0..200 (0..200 %)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pid_i__xkp__id;

    /**
     * Idc or Pdc Limit during Generator operation
     *
     * Range: 0..65535 (0..6553.5 A or W)
     * Scale: 0.1
     * Offset: 0
     */
    uint16_t bat_opr_limit__gen;

    /**
     * Feedforward - Proportional Gain Id-Current Controller
     *
     * Range: 0..200 (0..200 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pid_i__kf__id;

    /**
     * Configuration of the I Peak supervision Limits
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cmc__bit17_16__checkipeak_config;

    /**
     * (Write Protected) Activation for the Offset Correction for older Bamobil 3.2 hardware setup
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dup__bit16__bamobil3_2_offcrct;

    /**
     * FU Special - Start
     *
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t special__stop;

    /**
     * free
     *
     * Range: -32768..32767 (-32768..32767 Num)
     * Scale: 1
     * Offset: 0
     */
    int16_t free;

    /**
     * Firmware SVN Revision Number
     *
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t svnrevision_nr;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ramp4;

    /**
     * General speed limiting (if = 90 %) possible
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nclip64;

    /**
     * RUN signal disturbed, EMI
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t warn_illegal_status;

    /**
     * General speed limiting (if = 90 %) possible
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nclip82;

    /**
     * (Write Protected) External ECODE processing matrix reconfiguration
     *
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dup__bit19_17__ecode_redefine;

    /**
     * Motor Brake
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t motbrake;

    /**
     * Additional switchable negative speed limiting possible
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nclip_minus64;

    /**
     * RFE input inactive (active without RUN input)
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t warn_safe_in;

    /**
     * Additional switchable negative speed limiting possible
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nclip_minus82;

    /**
     * Enable the special Traction Control Logic
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cmc__bit18__tractioncontrol_ena;

    /**
     * AC or DC power supply
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ac_dc;

    /**
     * Additional switchable positive speed limiting possible
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nclip_plus64;

    /**
     * Additional switchable positive speed limiting possible
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nclip_plus82;

    /**
     * Definition of the Delta Time rpm Speed Change supervision (20ms, 50ms, 100ms, 250ms)
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cmc__bit20_19__tc_deltatime_conf;

    /**
     * PWM Frequency define
     *
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_rcv_pwm_freq pwm_freq;

    /**
     * Current limiting (switchable) reached
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t irddig64;

    /**
     * Current limiting (switchable) reached
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t irddig82;

    /**
     * HAL Sensor Estimator Logic Activation
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dup__bit20__hal_extmr_acv;

    /**
     * Actual current limit reached
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t iuserchd64;

    /**
     * Actual current limit reached
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t iuserchd82;

    /**
     * Definition of the minumim rpm Speed percentage to activate the TC (0perc, 10perc, 20perc, 30perc)
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cmc__bit22_21__tc_minspeed_conf;

    /**
     * Initialize inverter with a set Software Lock
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dup__bit21__initwith_frg_off;

    /**
     * Derating Triggered - Current limited by speed Limit
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t irdn64;

    /**
     * Motor temperature > (I-red-TM or 93 % from M-Temp)
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t warn_motortemp;

    /**
     * Derating Triggered - Current limited by speed Limit
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t irdn82;

    /**
     * Bit 31_22 - free (NOT INUSE)
     *
     * Range: 0..1023 (0..1023 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t dup__bit31_22__free;

    /**
     * IGBT NTC Temperature Sensor
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ntc;

    /**
     * Derating Configured - Current limited by igbt temperature Limit
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t irdti64;

    /**
     * Device temperature > 87 % of limit
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t warn_devicetemp;

    /**
     * Derating Configured - Current limited by igbt temperature Limit
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t irdti82;

    /**
     * Defines how the speed command ramp should be reset when TC triggers
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cmc__bit23__tc_ncmdrestoption;

    /**
     * Torque Ramp Acc Time [0..4000 ms]
     *
     * Range: 0..4000 (0..4000 ms)
     * Scale: 1
     * Offset: 0
     */
    uint16_t m_r_acc;

    /**
     * Motorphasen Dreieck
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t delta;

    /**
     * Derating Triggered - Current limited by igbt temperature Limit
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t irdtir64;

    /**
     * Limit of the existing voltage output is reached
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t warn_vout_sat;

    /**
     * Derating Triggered - Current limited by igbt temperature Limit
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t irdtir82;

    /**
     * Free (NOT INUSE)
     *
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cmc__bit31_24__free;

    /**
     * DC-1Quadrant, direkt pwm (Volt)
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dc_1qdirvolt;

    /**
     * Additional current limit if frequency less than 10 Hz
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t _10hz64;

    /**
     * Overcurrent 200 %
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t warn_ipeak;

    /**
     * Additional current limit if frequency less than 10 Hz
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t _10hz82;

    /**
     * DC-Feldregler
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dc_field;

    /**
     * Derating Triggered - Current limited by motor temperature Limit
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t irdtm64;

    /**
     * Resolution range of the speed measurement exceeded
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t warn_raceaway;

    /**
     * Derating Triggered - Current limited by motor temperature Limit
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t irdtm82;

    /**
     * deadband*2
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dead_2;

    /**
     * Current derating due to analog input (if = 90 %) possible
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t irdana64;

    /**
     * Current derating due to analog input (if = 90 %) possible
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t irdana82;

    /**
     * Blockstrom bei ROT
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t block;

    /**
     * Current peak value warning
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t iwcns64;

    /**
     * Current peak value warning
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t iwcns82;

    /**
     * DC-1Quadrant, minimale Schaltverluste
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dc_1qmv;

    /**
     * Pulsed RFE-input monitoring active
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t rfepulse64;

    /**
     * Pulsed RFE-input monitoring active
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t rfepulse82;

    /**
     * DC-1Quadrant, no high-side, bottom parallel
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dc_1q3p;

    /**
     * free
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t md64;

    /**
     * free
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t md82;

    /**
     * Automatic change to 4 kHz in case n < 10 Hz (No Derating)
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t reducelosses;

    /**
     * Hand-wheel function selected
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t hndwhl64;

    /**
     * Ballast circuit > 87 % overloaded
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t warn_ballast;

    /**
     * Hand-wheel function selected
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t hndwhl82;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_inverter_l_rcv_t;

/**
 * Signals in message Inverter_L_Rcv.
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Actual Motor Roations Speed
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_rcv_rcv_mux rcv_mux;

    /**
     * Actual Motor Roations Speed
     *
     * Range: -32767.00000405309586161245655..32767 (-3600..3599.9999995547 Num)
     * Scale: 0.1098666341
     * Offset: 0
     */
    float n_actual;

    /**
     * Speed Ramp Dec Time [0..30000 ms]
     *
     * Range: 0..30000 (0..30000 ms)
     * Scale: 1
     * Offset: 0
     */
    uint16_t n_r_dec;

    /**
     * Emergency Stopping Ramp Time [0..1000 ms]
     *
     * Range: 0..1000 (0..1000 ms)
     * Scale: 1
     * Offset: 0
     */
    uint16_t n_r_lim;

    /**
     * Actual Motor Roations Speed Filtered
     *
     * Range: -32768..32767 (-3600.1098661888..3599.9999995547 rpm)
     * Scale: 0.1098666341
     * Offset: 0
     */
    float n_actual_filt;

    /**
     * Firmware Number
     *
     * Range: 0..4095 (0..4095 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t firmware;

    /**
     * Coding Signal defining various device types
     *
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_rcv_devicetype devicetype;

    /**
     * Device Serial Number
     *
     * Range: 0..4294967295 (0..4294967295 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t snr;

    /**
     * Inverter 4 Letter Name define
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t axis;

    /**
     * Set device define for continuous current
     *
     * Range: 0..65535 (0..6553.5 A)
     * Scale: 0.1
     * Offset: 0
     */
    float i_device;

    /**
     * Current Sensor rated voltage
     *
     * Range: 0..65535 (0..65535 mV)
     * Scale: 1
     * Offset: 0
     */
    uint16_t v_shunt;

    /**
     * Internal Current value at 200% nominal device current
     *
     * Range: 0..65535 (0..65535 adc)
     * Scale: 1
     * Offset: 0
     */
    uint16_t i_200perc;

    /**
     * Analoge Zwischenkreismessung geht in Uout ein
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int dc_bus_comp : 1;

    /**
     * Enable drive
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int ena64 : 1;

    /**
     * Damaged parameter
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int err_badparas : 1;

    /**
     * Digital input limit 1 active
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int lmt1 : 1;

    /**
     * Analog Input Signal 1 - Raw
     *
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t ain_in_1_raw;

    /**
     * Analog Input Signal 2 - Raw
     *
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t ain_in_2_raw;

    /**
     * Maximum Speed Value for Resolution of 16Bit
     *
     * Range: -32768..32767 (-32768..32767 rpm)
     * Scale: 1
     * Offset: 0
     */
    int16_t nmax100perc;

    /**
     * Digital numerical Speed Command - input
     *
     * Range: -32766.99999691205638057269621..32766.99999691205638057269621 (-7100..7100 Num)
     * Scale: 0.2166814173
     * Offset: 0
     */
    float n_setdig;

    /**
     * Digital numerical Speed Command - internal
     *
     * Range: -32768..32767 (-32768..32767 Num)
     * Scale: 1
     * Offset: 0
     */
    int16_t n_cmd;

    /**
     * Digital numerical Speed Command - internal ramped
     *
     * Range: -32766.99999691205638057269621..32766.99999691205638057269621 (-7100..7100 Num)
     * Scale: 0.2166814173
     * Offset: 0
     */
    float n_cmd_ramp;

    /**
     * Speed n Limit - Percentage as 15 Bit entry format (32767 equal 100perc)
     *
     * Range: -32766.99943739061966000306044..32766.99943739061966000306044 (-100..100 %)
     * Scale: 0.003051851
     * Offset: 0
     */
    float n_lim;

    /**
     * Speed n Error difference
     *
     * Range: -32766.99999691205638057269621..32766.99999691205638057269621 (-7100..7100 Num)
     * Scale: 0.2166814173
     * Offset: 0
     */
    float n_error;

    /**
     * Digital numerical Iq-Current Command - input
     *
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t m_setdig__iq;

    /**
     * Digital numerical Id-Current Command - input
     *
     * Range: -32768..32767 (-12249.91571968..12249.54188192 Arms)
     * Scale: 0.37383776
     * Offset: 0
     */
    float id_setdig__id;

    /**
     * Max. Device Current (A) settings via percentage entry - Percentage as 13 Bit entry format (16383 equal 100perc)
     *
     * Range: 0..16382.99999132683980459157101 (0..100 %)
     * Scale: 0.00610388818
     * Offset: 0
     */
    float i_max_pk;

    /**
     * Continuous Device Current (Arms) settings via percentage entry - Percentage as 13 Bit entry format (16383 is equal 100perc)
     *
     * Range: 0..16382.99999132683980459157101 (0..100 %)
     * Scale: 0.00610388818
     * Offset: 0
     */
    float i_con_eff;

    /**
     * Motor Maximum Effective Peak Current
     *
     * Range: 0..32767 (0..3276.7 Arms)
     * Scale: 0.1
     * Offset: 0
     */
    float i_max_eff;

    /**
     * Motor Nominal Effective Current
     *
     * Range: 0..65535 (0..6553.5 0,1)
     * Scale: 0.1
     * Offset: 0
     */
    float i_nom_eff;

    /**
     * Actual Reduced Current Limit
     *
     * Range: -32768..32767 (-4547.16391424..4547.02514581 Arms)
     * Scale: 0.13876843
     * Offset: 0
     */
    float i_limit_inuse;

    /**
     * Digital numerical Current Command - internal
     *
     * Range: -32768..32767 (-4547.16391424..4547.02514581 Arms)
     * Scale: 0.13876843
     * Offset: 0
     */
    float i_cmd;

    /**
     * Digital numerical Current Command - internal ramped
     *
     * Range: -32768..32767 (-4547.16391424..4547.02514581 Arms)
     * Scale: 0.13876843
     * Offset: 0
     */
    float i_cmd_ramp;

    /**
     * Measured numerical Current - internal
     *
     * Range: -32768..32767 (-4547.16391424..4547.02514581 Arms)
     * Scale: 0.13876843
     * Offset: 0
     */
    float i_actual;

    /**
     * Measured numerical Current Filtered - internal
     *
     * Range: -32768..32767 (-4547.16391424..4547.02514581 Arms)
     * Scale: 0.13876843
     * Offset: 0
     */
    float i_actual_filt;

    /**
     * Measured numerical Iq-Current - internal
     *
     * Range: -32768..32767 (-4547.16391424..4547.02514581 Arms)
     * Scale: 0.13876843
     * Offset: 0
     */
    float iq_actual;

    /**
     * Measured numerical Id-Current - internal
     *
     * Range: -32768..32767 (-4547.16391424..4547.02514581 Arms)
     * Scale: 0.13876843
     * Offset: 0
     */
    float id_actual;

    /**
     * Error of the numerical Iq-Current - internal
     *
     * Range: -32768..32767 (-4547.16391424..4547.02514581 Arms)
     * Scale: 0.13876843
     * Offset: 0
     */
    float iq_error;

    /**
     * Error of the numerical Id-Current - internal
     *
     * Range: -32768..32767 (-4547.16391424..4547.02514581 Arms)
     * Scale: 0.13876843
     * Offset: 0
     */
    float id_error;

    /**
     * Measured numerical I1-Current - internal
     *
     * Range: -32768..32767 (-6430.660886528..6430.464638332 A)
     * Scale: 0.196248196
     * Offset: 0
     */
    float i1_actual;

    /**
     * Measured numerical I2-Current - internal
     *
     * Range: -32768..32767 (-6430.660886528..6430.464638332 A)
     * Scale: 0.196248196
     * Offset: 0
     */
    float i2_actual;

    /**
     * Measured numerical I3-Current - internal
     *
     * Range: -32768..32767 (-6430.660886528..6430.464638332 A)
     * Scale: 0.196248196
     * Offset: 0
     */
    float i3_actual;

    /**
     * Measured ADC Value of the I3-current Shunt
     *
     * Range: 0..65535 (0..65535 Num)
     * Scale: 1
     * Offset: 0
     */
    uint16_t i3_adc;

    /**
     * Measured ADC Value of the I2-current Shunt
     *
     * Range: 0..65535 (0..65535 Num)
     * Scale: 1
     * Offset: 0
     */
    uint16_t i2_adc;

    /**
     * Q - Value Voltage Output
     *
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t vq;

    /**
     * D - Value Voltage Output
     *
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t vd;

    /**
     * Voltage Output Vq and Vd total
     *
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t vout;

    /**
     * Temperature Motor as ADC value
     *
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t t_motor;

    /**
     * Temperature Igbt as ADC value
     *
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t t_igbt;

    /**
     * Temperature Air (inside) as ADC value
     *
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t t_air;

    /**
     * DC-Bus Voltage
     *
     * Range: 0..65532.05229287863361432703605 (0..2075 V)
     * Scale: 0.03166389465
     * Offset: 0
     */
    float vdc_bus_filt;

    /**
     * Digital Input - END 1
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int end_1 : 1;

    /**
     * Digital Input - DIN 1
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int din_1 : 1;

    /**
     * Digital Input - END 2
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int end_2 : 1;

    /**
     * Digital Input - DIN 2
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int din_2 : 1;

    /**
     * Digital Input - RUN
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int run232 : 1;

    /**
     * Digital Output - DOUT 1
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int dout_1 : 1;

    /**
     * Digital Output - DOUT 2
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int dout_2 : 1;

    /**
     * Digital Output - DOUT 3
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int dout_3 : 1;

    /**
     * Digital Output - Rdy_BTB
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int rdy_btb : 1;

    /**
     * Hardware Error Signal I_Fault
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int i_fault : 1;

    /**
     * Digital Output - DOUT 4
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int dout_4 : 1;

    /**
     * Derating Reduction to percentage Value - Trigger is Dig Input - Percentage as 15 Bit entry format (32767 equal 100perc)
     *
     * Range: 0..32766.99943739061966000306044 (0..100 %)
     * Scale: 0.003051851
     * Offset: 0
     */
    float i_lim_dig;

    /**
     * Current reduction by rotation speed - Percentage as 15 Bit entry format (32767 equal 100perc)
     *
     * Range: 0..32766.99943739061966000306044 (0..100 %)
     * Scale: 0.003051851
     * Offset: 0
     */
    float i_red_n;

    /**
     * Start of current reduction by power stage temperature
     *
     * Range: 0..32767 (0..32767 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t i_red_td;

    /**
     * Stop of current reduction by power stage temperature
     *
     * Range: 0..32767 (0..32767 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t i_red_te;

    /**
     * Current reduction by motor temperature
     *
     * Range: 0..32767 (0..32767 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t i_red_tm;

    /**
     * Command Source Mask - Analog 1 Format Bits
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_rcv_cs_ain_1_format cs_ain_1_format;

    /**
     * Set (Reference) numerical Id-Current - internal
     *
     * Range: -32768..32767 (-4547.16391424..4547.02514581 Arms)
     * Scale: 0.13876843
     * Offset: 0
     */
    float id_ref;

    /**
     * Digital numerical Iq-Current Output - input
     *
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t m_outdig__iq;

    /**
     * Debugger Pointer 1
     *
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t ptr_1_debug;

    /**
     * Debugger Pointer 2
     *
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t ptr_2_debug;

    /**
     * Debugger Pointer Temp
     *
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t temp_debug;

    /**
     * Nominal Motor Frequency
     *
     * Range: 0..65535 (0..6553.5 Hz)
     * Scale: 0.1
     * Offset: 0
     */
    float motor_f_n;

    /**
     * Nominal Motor Voltage
     *
     * Range: 0..65535 (0..65535 V)
     * Scale: 1
     * Offset: 0
     */
    uint16_t motor_v_n;

    /**
     * Time For DC Pre-Charge-Magnitising - Start
     *
     * Range: 0..65535 (0..65535 ms)
     * Scale: 1
     * Offset: 0
     */
    uint16_t t_dc__start;

    /**
     * DC Voltage for Pre-Magnitization - Start
     *
     * Range: -32768..32767 (-3276.8..3276.7 %)
     * Scale: 0.1
     * Offset: 0
     */
    float v_dc__start;

    /**
     * Minimum Voltage (FU operation) at Start
     *
     * Range: -32768..32767 (-3276.8..3276.7 %)
     * Scale: 0.1
     * Offset: 0
     */
    float v_min__start;

    /**
     * Minimum Frequency (FU operation) at Start
     *
     * Range: -32768..32767 (-3276.8..3276.7 Hz)
     * Scale: 0.1
     * Offset: 0
     */
    float f_min__start;

    /**
     * Voltage (percentage of DC-Bus) at max. Frequency
     *
     * Range: -32768..32767 (-3276.8..3276.7 %)
     * Scale: 0.1
     * Offset: 0
     */
    float v_corner__start;

    /**
     * Frequency at max output voltage - Start
     *
     * Range: -32768..32767 (-3276.8..3276.7 Hz)
     * Scale: 0.1
     * Offset: 0
     */
    float f_corner__start;

    /**
     * Motor Power Factor
     *
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t cos_phi;

    /**
     * Value for PWM Frequency configuration (Internal)
     *
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pwm_enum;

    /**
     * Entry for the Reference Value used for various Calibrations
     *
     * Range: 0..65535 (0..6553.5 -)
     * Scale: 0.1
     * Offset: 0
     */
    float calib_ref_value;

    /**
     * Proportional Gain Iq-Current Controller - A entry 33 equals 1.0 normalized
     *
     * Range: 0..200 (0..200 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pid_i__kp__iq;

    /**
     * Integral Action Time (Integral Part) Iq-Current Controller
     *
     * Range: 300..20000 (300..20000 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pid_i__ti__iq;

    /**
     * Digital Cutoff area of incomming digital commands
     *
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t cutoffdig;

    /**
     * I3 Offset value measured at Enable
     *
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t i3_offset;

    /**
     * Final Current Ramp Step setting
     *
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t i_delta_ramp;

    /**
     * Iq-Current Control Integral Maximum Output Range
     *
     * Range: 0..500 (0..500 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pid_i__tim__iq;

    /**
     * Proportional Gain Speed Controller
     *
     * Range: 0..200 (0..200 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pid_n__kp;

    /**
     * Integral Action Time (Integral Part) Voltage Controller (0.0001 x Ti equals 1.0)
     *
     * Range: 0..65535 (0..65535 ms)
     * Scale: 1
     * Offset: 0
     */
    uint16_t v_ti;

    /**
     * Derative Action Time (Derative Part) Speed Controller
     *
     * Range: 0..10000 (0..10000 ms)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pid_n__td;

    /**
     * Analog Input Signal 1 - Offset Value Setting
     *
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t ain_in_1_offsetval;

    /**
     * Analog Input Signal 2 - Offset Value Setting
     *
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t ain_in_2_offsetval;

    /**
     * SpeedControl Loop (DZR) Sequencer Configuration (PWM Freq dependent)
     *
     * Range: 0..32767 (0..32767 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t dzr_seq;

    /**
     * Speed Control Integral Maximum Output Range
     *
     * Range: 0..100 (0..100 %)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pid_n__tim;

    /**
     * Speed n Limit plus - Percentage as 15 Bit entry format (32767 equal 100perc)
     *
     * Range: 0..32766.99943739061966000306044 (0..100 %)
     * Scale: 0.003051851
     * Offset: 0
     */
    float n_lim_plus;

    /**
     * Speed n Limit minus - Percentage as 15 Bit entry format (-32767 equal -100perc)
     *
     * Range: -32766.99943739061966000306044..0 (-100..0 %)
     * Scale: 0.003051851
     * Offset: 0
     */
    float n_lim_minus;

    /**
     * Delta diff of the feedback Signal per measuring point
     *
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t incr_delta;

    /**
     * Actual Mechanical Angle Position of the Motor
     *
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t motorpos_mech;

    /**
     * Actual Electrical Angle Position of the Motor
     *
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t motorpos_elec;

    /**
     * FeedBack Offset Angle Value
     *
     * Range: -3600..3600 (-360..360 -)
     * Scale: 0.1
     * Offset: 0
     */
    float fb_offset;

    /**
     * Bleeder Resistor Ixt  Monitor
     *
     * Range: -2147483648..2147483647 (-2147483648..2147483647 -)
     * Scale: 1
     * Offset: 0
     */
    int32_t it_rg_monitor;

    /**
     * Motor Pole Number
     *
     * Range: 2..96 (2..96 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t motor_pole;

    /**
     * Analog Input Signal 1 - Cutoff Value Setting
     *
     * Range: 0..32767 (0..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t ain_in_1_cutoff;

    /**
     * Active Control Mode Mask
     *
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_rcv_activecontrolmode activecontrolmode;

    /**
     * Kern Mode State Bit - rsvd_0
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int km_rsvd_0 : 1;

    /**
     * Enable drive
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int ena82 : 1;

    /**
     * Analog Input Signal 2 - Cutoff Value Setting
     *
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t ain_in_2_cutoff;

    /**
     * Actual Reduced Current Limit ramped
     *
     * Range: -32768..32767 (-12249.91571968..12249.54188192 Arms)
     * Scale: 0.37383776
     * Offset: 0
     */
    float i_limit_inuse_ramp;

    /**
     * Motor Nominal Rotation Speed
     *
     * Range: 60..65000 (60..65000 rpm)
     * Scale: 1
     * Offset: 0
     */
    uint16_t n_nom;

    /**
     * Speed Control Acceleration Feed Foreward Gain
     *
     * Range: 0..100 (0..100 %)
     * Scale: 1
     * Offset: 0
     */
    int16_t pid_n__kacc;

    /**
     * Digital Hall Sensor Position Rotor Signals Value
     *
     * Range: 0..65535 (0..65535 %)
     * Scale: 1
     * Offset: 0
     */
    uint16_t rotor_signals;

    /**
     * Additional Filter Adjustment of the Rotation Speed Measurement
     *
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t speed_filter;

    /**
     * Analog Input Signal 1 - Filter Value Setting
     *
     * Range: 0..255 (0..127.5 ms)
     * Scale: 0.5
     * Offset: 0
     */
    float ain_in_1_filter;

    /**
     * Monitor Value for Regen I x t calculation
     *
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t ixt_monitor;

    /**
     * Ecode - Bit 0 - First Error Detected
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int ecode_bit0_firsterrordtcd99 : 1;

    /**
     * Device Mains Supply Voltage Value
     *
     * Range: 0..1000 (0..1000 V)
     * Scale: 1
     * Offset: 0
     */
    uint16_t device_mains;

    /**
     * Regenerative Resistor Power Value
     *
     * Range: 25..10000 (25..10000 W)
     * Scale: 1
     * Offset: 0
     */
    uint16_t regen_p;

    /**
     * CAN Identiciation ID for Receive - Rx
     *
     * Range: 0..65530 (0..65530 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t can_id_rx;

    /**
     * CAN Identiciation ID for Transmit - Tx
     *
     * Range: 0..65530 (0..65530 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t can_id_tx;

    /**
     * Proportional Gain Position Controller
     *
     * Range: 0..500 (0..500 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pos_kp;

    /**
     * Integral Action Time (Integral Part) Position Controller
     *
     * Range: 0..10000 (0..10000 ms)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pos_ti;

    /**
     * Derative Action Time (Derative Part) Position Controller
     *
     * Range: 0..65535 (0..65535 ms)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pos_td;

    /**
     * Numeric Actual Position Value
     *
     * Range: -2147483648..2147483647 (-2147483648..2147483647 -)
     * Scale: 1
     * Offset: 0
     */
    int32_t pos_actual;

    /**
     * Numeric Destination Position Value
     *
     * Range: -2147483648..2147483647 (-2147483648..2147483647 -)
     * Scale: 1
     * Offset: 0
     */
    int32_t pos_dest;

    /**
     * Numeric Actual Position 2 (Alternative) Value
     *
     * Range: -2147483648..2147483647 (-2147483648..2147483647 -)
     * Scale: 1
     * Offset: 0
     */
    int32_t pos_actual_2;

    /**
     * Numeric Error Position Value
     *
     * Range: -2147483648..2147483647 (-2147483648..2147483647 -)
     * Scale: 1
     * Offset: 0
     */
    int32_t pos_error;

    /**
     * Position Control Integral Maximum Output Range
     *
     * Range: 0..100 (0..100 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pos_tim;

    /**
     * Numeric Position Zero Offset Value
     *
     * Range: -2147483648..2147483647 (-2147483648..2147483647 -)
     * Scale: 1
     * Offset: 0
     */
    int32_t pos_offsref;

    /**
     * CAN BaudRate Configuration Setting
     *
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_rcv_can_nbt can_nbt;

    /**
     * Position Zero Capture
     *
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pos_zero_capture;

    /**
     * Resolver Position at Reference Switch (Rsw)
     *
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t ref_reso_edge;

    /**
     * Position Reference Speed 1 (Fast)
     *
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t speed_1;

    /**
     * Position Reference Speed 1 (Slow) + Phasing electrical Rotation Speed
     *
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t speed_2;

    /**
     * Tolerance Window for Destination Position
     *
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t pos_tol_win;

    /**
     * Numeric Preset Position Value (Set actual Position to Preset Position)
     *
     * Range: -2147483648..2147483647 (-2147483648..2147483647 -)
     * Scale: 1
     * Offset: 0
     */
    int32_t pos_preset_val;

    /**
     * User Zero Offset Position Value
     *
     * Range: -2147483648..2147483647 (-2147483648..2147483647 -)
     * Scale: 1
     * Offset: 0
     */
    int32_t pos_zero_offset;

    /**
     * NDrive Position Display Scale Factor
     *
     * Range: -2147483648..2147483647 (-2147483648..2147483647 -)
     * Scale: 1
     * Offset: 0
     */
    int32_t pos_nd_scale;

    /**
     * NDrive Position Display Offset Factor
     *
     * Range: -2147483648..2147483647 (-2147483648..2147483647 -)
     * Scale: 1
     * Offset: 0
     */
    int32_t pos_nd_offset;

    /**
     * Feedback 2 - External Scale Factor
     *
     * Range: -2147483648..2147483647 (-2147483648..2147483647 -)
     * Scale: 1
     * Offset: 0
     */
    int32_t fb2_scale_ext;

    /**
     * Position Offset Slack Value
     *
     * Range: -2147483648..2147483647 (-2147483648..2147483647 -)
     * Scale: 1
     * Offset: 0
     */
    int32_t pos_offset_slack;

    /**
     * Position Difference Slack Value
     *
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t pos_diff_slack;

    /**
     * Special Function For Parameter Read command from Eeprom sector
     *
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t fun_para_read;

    /**
     * Special Function For Parameter Write command to Eeprom sector
     *
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t fun_para_write;

    /**
     * Special Functions for automatic logics or calculations
     *
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t fun_special;

    /**
     * CAN Identiciation ID - 2 - for Receive - Rx
     *
     * Range: 0..4294967295 (0..4294967295 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t can_id_2_rx;

    /**
     * CAN Identiciation ID - 2 - for Transmit - Tx
     *
     * Range: 0..4294967295 (0..4294967295 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t can_id_2_tx;

    /**
     * Voltage Controller Reference value in perc of Vout (V_Red - Start of Field Reduction)
     *
     * Range: -32768..32767 (-32768..32767 %)
     * Scale: 1
     * Offset: 0
     */
    int16_t v_ref;

    /**
     * Proportional Gain Voltage Controller (0.0001 * Ti equals 1.0)
     *
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t v_kp;

    /**
     * Integral Action Time (Integral Part) Speed Controller
     *
     * Range: 0..10000 (0..10000 ms)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pid_n__ti;

    /**
     * Clear Error and Warning List
     *
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t clear_errors;

    /**
     * Numeric Position Command Value
     *
     * Range: -2147483648..2147483647 (-2147483648..2147483647 -)
     * Scale: 1
     * Offset: 0
     */
    int32_t pos_cmd;

    /**
     * CAN Bus Error counter - Bus Off
     *
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t can_error_busoff;

    /**
     * CAN Bus Error counter - Write Time
     *
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t can_error_writetime;

    /**
     * Ecode - Bit 0 - First Error Detected
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int ecode_bit0_firsterrordtcd148 : 1;

    /**
     * CAN Bus Error counter - No Ack
     *
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t can_error_no_ack;

    /**
     * CAN Bus Error counter - CRC_Check
     *
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t can_error_crc_check150;

    /**
     * CAN Bus Error counter - Error Status Bit from CAN Module
     *
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t can_error_crc_check151;

    /**
     * Info Interrupt time
     *
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t info_timer_diff;

    /**
     * Internal Ballast Count Value
     *
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t ballastcount;

    /**
     * Motor Temperature Limit for Inverter Error shutdown
     *
     * Range: 0..32767 (0..32767 Num)
     * Scale: 1
     * Offset: 0
     */
    uint16_t m_temp;

    /**
     * Motor Options - Feedback 1 Type
     *
     * Range: 0..31 (0..31 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_rcv_mo_feedback_1 mo_feedback_1;

    /**
     * DC Bus Min Value Superpision Limit
     *
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t dc_bus_min_lim;

    /**
     * Feedback System Increments per rotation
     *
     * Range: 0..65535 (0..65535 Inc/Rev)
     * Scale: 1
     * Offset: 0
     */
    uint16_t fb_incr_mot;

    /**
     * Feedback Pole number
     *
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t fb_pole;

    /**
     * Foreground Cycle Frequency
     *
     * Range: 0..65535 (0..65535 Hz)
     * Scale: 1
     * Offset: 0
     */
    uint16_t logic_freq;

    /**
     * PWM 1 (5/6) clock open time
     *
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t pwm_1;

    /**
     * PWM 2 (3/4) clock open time
     *
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t pwm_2;

    /**
     * PWM 3 (1/2) clock open time
     *
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t pwm_3;

    /**
     * PWM Configuration value of timer delta
     *
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t timer_delta;

    /**
     * Motor - Stator Leakage Inductance - Lsq
     *
     * Range: 0..65535 (0..65.535 mH)
     * Scale: 0.001
     * Offset: 0
     */
    float motor_lsq;

    /**
     * Motor Leakage Inductance ph-ph - Lsd
     *
     * Range: 0..65535 (0..65.535 mH)
     * Scale: 0.001
     * Offset: 0
     */
    float motor_lsd;

    /**
     * Nominal Magnetising d-Current value as perc of nominal current
     *
     * Range: -32768..32767 (-32768..32767 %)
     * Scale: 1
     * Offset: 0
     */
    int16_t id_nom;

    /**
     * Motor - Magnetizing Inductance - L
     *
     * Range: 0..65535 (0..655.35 mH)
     * Scale: 0.01
     * Offset: 0
     */
    float motor_lm;

    /**
     * Motor - Rotor Resistance Value
     *
     * Range: 0..65535 (0..65535 mOhm)
     * Scale: 1
     * Offset: 0
     */
    uint16_t motor_rr;

    /**
     * Minimum Magnetising d-Current value as perc of nominal current
     *
     * Range: 0..100 (0..100 %)
     * Scale: 1
     * Offset: 0
     */
    int16_t id_min;

    /**
     * Rotor Time Contant of the Motor
     *
     * Range: -32768..32767 (-32768..32767 ms)
     * Scale: 1
     * Offset: 0
     */
    int16_t motor_tr;

    /**
     * Motor - Stator Resistance Value
     *
     * Range: 0..65535 (0..65535 mOhm)
     * Scale: 1
     * Offset: 0
     */
    uint16_t motor_rs;

    /**
     * Stator Time Contant of the Motor
     *
     * Range: -32768..32767 (-32.768..32.767 ms)
     * Scale: 0.001
     * Offset: 0
     */
    float motor_ts;

    /**
     * Definition - Function attribution of the Digital Input - END 1 (Limit 1)
     *
     * Range: 0..32767 (0..32767 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_rcv_def_end_1 def_end_1;

    /**
     * Definition - Function attribution of the Digital Input - END 2 (Limit 2)
     *
     * Range: 0..32767 (0..32767 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_rcv_def_end_2 def_end_2;

    /**
     * Definition - Function attribution of the Digital Input - DIN 1
     *
     * Range: 0..32767 (0..32767 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_rcv_def_din_1 def_din_1;

    /**
     * Definition - Function attribution of the Digital Input - DIN 2
     *
     * Range: 0..32767 (0..32767 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_rcv_def_din_2 def_din_2;

    /**
     * Selection List Operant for digital Output OUT 1
     *
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_rcv_operand194 operand194;

    /**
     * Maximum possible allowed current
     *
     * Range: -32768..32767 (-4547.16391424..4547.02514581 Arms)
     * Scale: 0.13876843
     * Offset: 0
     */
    float i_max_inuse;

    /**
     * Digital Output Signal - internal GO is set (no errors)
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int signal_go : 1;

    /**
     * Digital Output Signal - mechanical Brake Activated
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int signal_brake : 1;

    /**
     * Digital Output Signal - The current limit is reduced to continuous current
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int signal_icns : 1;

    /**
     * Digital Output Signal - Actual speed less than 0.1 %
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int signal_lessn0 : 1;

    /**
     * Digital Output Signal - Actual Position is within tolerance window
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int signal_postolerance : 1;

    /**
     * Analog Input Signal 1 - Scaled
     *
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t ain_in_1_scaled251;

    /**
     * Analog Input Signal 2 - Scaled
     *
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t ain_in_2_scaled252;

    /**
     * Selection List Operant for digital Output OUT 2
     *
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_rcv_operand195 operand195;

    /**
     * Selection List Operant for digital Output OUT 3
     *
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_rcv_operand218 operand218;

    /**
     * Selection List Operant for digital Output OUT 4
     *
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_rcv_operand219 operand219;

    /**
     * Proportional Gain Iq-Current Controller if actual current is above I Limit Inuse Current - perc is depending on Kp value
     *
     * Range: 0..200 (0..200 %)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pid_i__xkp__iq;

    /**
     * Idc or Pdc Limit during Motor operation
     *
     * Range: 0..65535 (0..6553.5 A or W)
     * Scale: 0.1
     * Offset: 0
     */
    float bat_opr_limit__mot;

    /**
     * Feedforward - Proportional Gain Iq-Current Controller
     *
     * Range: 0..200 (0..200 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pid_i__kf__iq;

    /**
     * DC Current Sesnor is set to enabled
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int dc_current_sens_ena_set : 1;

    /**
     * Enable the use of the DC current Sensor (if present)
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int cmc__bit0__dc_current_sens_ena : 1;

    /**
     * Max possible Rotation Speed internal
     *
     * Range: -32768..32767 (-32768..32767 rpm)
     * Scale: 1
     * Offset: 0
     */
    int16_t n_rpm_maxint;

    /**
     * Comparison Variable 1
     *
     * Range: -2147483648..2147483647 (-2147483648..2147483647 -)
     * Scale: 1
     * Offset: 0
     */
    int32_t var_1;

    /**
     * CAN Timeout time settings
     *
     * Range: 0..32767 (0..32767 ms)
     * Scale: 1
     * Offset: 0
     */
    int16_t can_rxtimeout;

    /**
     * Comparison Variable 2
     *
     * Range: -2147483648..2147483647 (-2147483648..2147483647 -)
     * Scale: 1
     * Offset: 0
     */
    int32_t var_2;

    /**
     * Comparison Variable 3
     *
     * Range: -2147483648..2147483647 (-2147483648..2147483647 -)
     * Scale: 1
     * Offset: 0
     */
    int32_t var_3;

    /**
     * Comparison Variable 4
     *
     * Range: -2147483648..2147483647 (-2147483648..2147483647 -)
     * Scale: 1
     * Offset: 0
     */
    int32_t var_4;

    /**
     * DAC Configuration of the RegID Source Channel as Output
     *
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dup__bit7_0__dac_source_channel;

    /**
     * Feedback Loss of Signal
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int fb_lossofsignal : 1;

    /**
     * No HW_Fault detected
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int no_hw_fault : 1;

    /**
     * Allowed Timing for Peak Current
     *
     * Range: 0..65535 (0..65535 s)
     * Scale: 1
     * Offset: 0
     */
    uint16_t t_peak;

    /**
     * Mechanical Brake Delay Time (e.g. Relay)
     *
     * Range: 0..65535 (0..65535 ms)
     * Scale: 1
     * Offset: 0
     */
    uint16_t brake_delay;

    /**
     * Inverter Output AC Power (DO NOT USE!!)
     *
     * Range: -32768..32767 (-32768..32767 W)
     * Scale: 1
     * Offset: 0
     */
    int16_t power;

    /**
     * Inverter Output AC Work (DO NOT USE!!)
     *
     * Range: -32768..32767 (-32768..32767 Joul)
     * Scale: 1
     * Offset: 0
     */
    int16_t work;

    /**
     * FU Extra - Start
     *
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t extra__start;

    /**
     * NDrive Oszillloscop - Capture Channel
     *
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t capture_channel;

    /**
     * NDrive Oszillloscop - Capture Trigger Edge
     *
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t trig_level;

    /**
     * NDrive Oszillloscop - Capture Trigger Level
     *
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t trig_edge;

    /**
     * NDrive Oszillloscop - Capture Trigger Source
     *
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t trig_source;

    /**
     * NDrive Oszillloscop - Capture Source
     *
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t oszi_source;

    /**
     * NDrive Oszillloscop - Capture Skip
     *
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t oszi_skip;

    /**
     * NDrive Oszillloscop - Run Command
     *
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t oszi_run_cmd;

    /**
     * NDrive Oszillloscop - Read Command
     *
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t oszi_read_cmd;

    /**
     * Start Park Cycle
     *
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t pos_ref_start;

    /**
     * DC-Bus Voltage
     *
     * Range: 0..65532.05229287863361432703605 (0..2075 V)
     * Scale: 0.03166389465
     * Offset: 0
     */
    float vdc_bus;

    /**
     * Digital numerical Iq-Current Command - internal ramped
     *
     * Range: -32767..32767 (-32767..32767 Num)
     * Scale: 1
     * Offset: 0
     */
    int16_t m_cmd_ramp;

    /**
     * Input Signal - Limit 1
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int lmt_1 : 1;

    /**
     * Output Signal - Out 1
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int out_1 : 1;

    /**
     * Firmware Subversion Number
     *
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t subversion_nr;

    /**
     * Ballast-R extern
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int ballast_ext : 1;

    /**
     * Speed command value = 0 (drive stopped)
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int ncr064 : 1;

    /**
     * Hardware error
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int err_powerfault : 1;

    /**
     * Digital input limit 2 active
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int lmt2 : 1;

    /**
     * Kern Mode State Bit -
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int km_speed_0 : 1;

    /**
     * Speed command value = 0 (drive stopped)
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int ncr082 : 1;

    /**
     * Ecode - Bit 1 - HW 1 Coding State
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int ecode_bit1__hw1_state99 : 1;

    /**
     * Ecode - Bit 1 - HW 1 Coding State
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int ecode_bit1__hw1_state148 : 1;

    /**
     * DC current Sensor (if present) Activated
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int dc_i_sensena_set : 1;

    /**
     * Enable the Limitiation Calculation depending on the DC Current limits
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int cmc__bit1__idc_limit_ena : 1;

    /**
     * Input Signal - Limit 2
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int lmt_2 : 1;

    /**
     * Output Signal - Out 2
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int out_2 : 1;

    /**
     * Feedback Speciality
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int fb_special : 1;

    /**
     * Limit switch plus assigned
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int lim_plus64 : 1;

    /**
     * Safety circuit faulty (only active with RUN)
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int err_rfe_fault : 1;

    /**
     * Digital input Din 2 active
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int in2 : 1;

    /**
     * Command Source Mask - Analog 2 Format Bits
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_rcv_cs_ain_2_format cs_ain_2_format;

    /**
     * Kern Mode State Bit -
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int km_frg_off : 1;

    /**
     * Limit switch plus assigned
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int lim_plus82 : 1;

    /**
     * Ecode - Bit 2 - HW 0 Coding State
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int ecode_bit2__hw0_state99 : 1;

    /**
     * Ecode - Bit 2 - HW 0 Coding State
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int ecode_bit2__hw0_state148 : 1;

    /**
     * Present Operation Quadrant Mode
     *
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t op_mode_quadrant;

    /**
     * Use the DC current Limitiation Calculation depending on the DC Power limits
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int cmc__bit2__pdc_limit_usage : 1;

    /**
     * Input Signal - Input 2
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int in_2 : 1;

    /**
     * Output Signal - Rdy
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int rdy155 : 1;

    /**
     * Coast Stop Activation
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int coaststop : 1;

    /**
     * Limit switch minus assigned
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int lim_minus64 : 1;

    /**
     * CAN TimeOut time exceeded
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int err_bustimeout : 1;

    /**
     * Digital input Din 1 active
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int in1 : 1;

    /**
     * Kern Mode State Bit -
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int km_cal_off : 1;

    /**
     * Limit switch minus assigned
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int lim_minus82 : 1;

    /**
     * Ecode - Bit 3 - Free (NOT INUSE)
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int ecode_bit3__free99 : 1;

    /**
     * Ecode - Bit 3 - Free (NOT INUSE)
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int ecode_bit3__free148 : 1;

    /**
     * Enable Init as Torque Mode after Enable (Run)
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int cmc__bit3__torqueval_init_ena : 1;

    /**
     * Input Signal - Input 1
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int in_1 : 1;

    /**
     * Output Signal - Go
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int go155 : 1;

    /**
     * Current Measurement Inverse
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int i_ist_inverse : 1;

    /**
     * Drive ok (no uncontrolled control-voltage reset seen)
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int ok64 : 1;

    /**
     * Encoder signal faulty or missing
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int err_feedbacksignal : 1;

    /**
     * Hardware enable active
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int frgrun : 1;

    /**
     * Command Source Mask - Analog 1 Mode Bits
     *
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_rcv_cs_ain_1_mode cs_ain_1_mode;

    /**
     * Kern Mode State Bit -
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int km_tx_tog_stat : 1;

    /**
     * Drive ok (no uncontrolled control-voltage reset seen)
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int ok82 : 1;

    /**
     * Ecode - Bit 4 - RDY3
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int ecode_bit4__rdy399 : 1;

    /**
     * Ecode - Bit 4 - RDY3
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int ecode_bit4__rdy3148 : 1;

    /**
     * Arrangement Variable Selection List for digital Output 1
     *
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_rcv_compare_var194 compare_var194;

    /**
     * Arrangement Variable Selection List for digital Output 2
     *
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_rcv_compare_var195 compare_var195;

    /**
     * Arrangement Variable Selection List for digital Output 3
     *
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_rcv_compare_var218 compare_var218;

    /**
     * Arrangement Variable Selection List for digital Output 4
     *
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_rcv_compare_var219 compare_var219;

    /**
     * Enable the use of Recuperation Ramps during Torque Mode
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int cmc__bit4__dig_m_rcpramp_ena : 1;

    /**
     * Input Signal - Run (FRG)
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int run152 : 1;

    /**
     * Output Signal - Out 3
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int out_3 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int refsoft : 1;

    /**
     * Current is limited to the continuous current level
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int icns64 : 1;

    /**
     * Power voltage missing
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int err_powervoltage_low : 1;

    /**
     * Rotating Field Enable
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int rfe216 : 1;

    /**
     * Kern Mode State Bit -
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int km_i_limit : 1;

    /**
     * Current is limited to the continuous current level
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int icns82 : 1;

    /**
     * Ecode - Bit 5 - N FAIL
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int ecode_bit5__n_fail99 : 1;

    /**
     * Ecode - Bit 5 - N FAIL
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int ecode_bit5__n_fail148 : 1;

    /**
     * Motor Options - Feedback 2 Type
     *
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_rcv_mo_feedback_2 mo_feedback_2;

    /**
     * Recuperation is active
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int recup_is_acv : 1;

    /**
     * Speed Ramp Reset to 0 if actual speed crosses 0 rpm
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int cmc__bit5__reset_nramp_atnzero : 1;

    /**
     * Input Signal - RFE
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int rfe152 : 1;

    /**
     * Output Signal - Out 4
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int out_4 : 1;

    /**
     * BTB nicht mit Powervoltage Ãœberwachung verknÃ¼pft
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int no_uesp_btb : 1;

    /**
     * Speed-limited torque mode active
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int tnlim64 : 1;

    /**
     * Motor temperature too high
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int err_motortemp : 1;

    /**
     * Kern Mode State Bit -
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int km_n_clip : 1;

    /**
     * Speed-limited torque mode active
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int tnlim82 : 1;

    /**
     * Ecode - Bit 6 - FLTHS
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int ecode_bit6__flths99 : 1;

    /**
     * Ecode - Bit 6 - FLTHS
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int ecode_bit6__flths148 : 1;

    /**
     * Motor Current Limiting Activated because of DC Current lmiting
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int i_dc_limit_is_acv : 1;

    /**
     * Set Torque command to 0 if no new external torque command input within 100 ms is registered
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int cmc__bit6__torquetimeout_100ms_e : 1;

    /**
     * reserved
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t rsvd;

    /**
     * reserved 1
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int rsvd1 : 1;

    /**
     * Analogue DC-Bus measurement
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int vdc_ana : 1;

    /**
     * Position control possible
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int pn64 : 1;

    /**
     * Device temperature too high
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int err_devicetemp : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int cs_oora1 : 1;

    /**
     * Kern Mode State Bit -
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int km_mix_ana_on : 1;

    /**
     * Position control possible
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int pn82 : 1;

    /**
     * Ecode - Bit 7 - FLTLS
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int ecode_bit7__fltls99 : 1;

    /**
     * Ecode - Bit 7 - FLTLS
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int ecode_bit7__fltls148 : 1;

    /**
     * Free (NOT INUSE)
     *
     * Range: 0..127 (0..127 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cmc__bit13_7__free;

    /**
     * Output Signal - break 1
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int brk1155 : 1;

    /**
     * Current Measurement I1 Enable
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int i1_adc_ena : 1;

    /**
     * Speed control possible
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int ni64 : 1;

    /**
     * Overvoltage > 1.8 x UN reached
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int err_overvoltage : 1;

    /**
     * Digital output Dout 1 on
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int out1 : 1;

    /**
     * Command Source Mask - Analog 2 Mode Bits
     *
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_rcv_cs_ain_2_mode cs_ain_2_mode;

    /**
     * Active SubControl Mode Mask
     *
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_rcv_ctrlsubmode ctrlsubmode;

    /**
     * Kern Mode State Bit - Allow Sync
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int km_allow_sync : 1;

    /**
     * Speed control possible
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int ni82 : 1;

    /**
     * Analog Input Signal 2 - Filter Value Setting
     *
     * Range: 0..255 (0..127.5 ms)
     * Scale: 0.5
     * Offset: 0
     */
    float ain_in_2_filter;

    /**
     * Ecode - Bit 1 - Idc Error detected
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int ecode_bit8__fail_idc99 : 1;

    /**
     * Ecode - Bit 1 - Idc Error detected
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int ecode_bit8__fail_idc148 : 1;

    /**
     * Motor Options -
     *
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_rcv_mo_sc1_reso mo_sc1_reso;

    /**
     * Signal Source ID for the compare operation according to RegID Address
     *
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_rcv_source_id194 source_id194;

    /**
     * Signal Source ID for the compare operation according to RegID Address
     *
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_rcv_source_id195 source_id195;

    /**
     * Signal Source ID for the compare operation according to RegID Address
     *
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_rcv_source_id218 source_id218;

    /**
     * Signal Source ID for the compare operation according to RegID Address
     *
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_rcv_source_id219 source_id219;

    /**
     * CAN PDOs extension
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int dup__bit8__can_extended_0 : 1;

    /**
     * Inverted order of Hall sensors
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int hxinv : 1;

    /**
     * Acutal speed less than 0.1% (standstill)
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int _n064 : 1;

    /**
     * Overcurrent or strongly oscillating current detected
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int err_ipeak : 1;

    /**
     * Digital output Dout 2 on
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int out2 : 1;

    /**
     * Kern Mode State Bit -
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int km_handwheel : 1;

    /**
     * Acutal speed less than 0.1% (standstill)
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int _n082 : 1;

    /**
     * Ecode - Bit 9 - I Error detected
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int ecode_bit9__fail_i99 : 1;

    /**
     * Ecode - Bit 9 - I Error detected
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int ecode_bit9__fail_i148 : 1;

    /**
     * Special DC Bus generator operation
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int dup__bit9__generator : 1;

    /**
     * Inverted Hall 2
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int h2inv : 1;

    /**
     * Reference switch tripped
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int rsw64 : 1;

    /**
     * Drive races (without command value, wrong direction)
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int err_raceaway : 1;

    /**
     * Hardware relay, output BTB (Rdy) on
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int btbrdy : 1;

    /**
     * Kern Mode State Bit -
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int km_phasing_extend : 1;

    /**
     * Reference switch tripped
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int rsw82 : 1;

    /**
     * Ecode - Bit 10 - VCC Voltage error
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int ecode_bit10__vccm99 : 1;

    /**
     * Ecode - Bit 10 - VCC Voltage error
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int ecode_bit10__vccm148 : 1;

    /**
     * Set factor 1divsqrt(2) in park currents
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int dup__bit10__park_rms : 1;

    /**
     * Over Loop current limit or slip compensation Enable
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int ol_comp : 1;

    /**
     * Calibration move active
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int cal064 : 1;

    /**
     * User - choice of Error
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int err_user : 1;

    /**
     * Internal enable GO active
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int go216 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int cs_oora2 : 1;

    /**
     * Kern Mode State Bit - rsvd_11
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int km_rsvd_11 : 1;

    /**
     * Calibration move active
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int cal082 : 1;

    /**
     * Ecode - Bit 11 - 15V minus Voltage error
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int ecode_bit11__15m_minus99 : 1;

    /**
     * Ecode - Bit 11 - 15V minus Voltage error
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int ecode_bit11__15m_minus148 : 1;

    /**
     * Motor Options -
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int mo_sc1_comp : 1;

    /**
     * DCBus Value as V for output Communication
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int dup__bit11__dcbus_volts : 1;

    /**
     * Firmware Test Number
     *
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t test;

    /**
     * Motor Type define
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_rcv_motortype motortype;

    /**
     * Calibration move completed (position calibrated)
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int cal64 : 1;

    /**
     * Digital output Dout 3 on
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int out3 : 1;

    /**
     * Command Source Mask - Bitmask Coding of Command Type
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_rcv_cs_cmd_type cs_cmd_type;

    /**
     * Active Control Current Mode Mask
     *
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_rcv_currentmode currentmode;

    /**
     * Kern Mode State Bit - rsvd_12
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int km_rsvd_12 : 1;

    /**
     * Calibration move completed (position calibrated)
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int cal82 : 1;

    /**
     * Ecode - Bit 12 - 15V plus Voltage error
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int ecode_bit12__15m_plus99 : 1;

    /**
     * Ecode - Bit 12 - 15V plus Voltage error
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int ecode_bit12__15m_plus148 : 1;

    /**
     * Motor Options -
     *
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_rcv_mo_sc2_reso mo_sc2_reso;

    /**
     * Command (Acc Pedal) must be at 0 to enable inverter
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int dup__bit12__boat_pedal : 1;

    /**
     * Position within tolerance window
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int tol64 : 1;

    /**
     * Digital output Dout 4 on
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int out4 : 1;

    /**
     * Kern Mode State Bit - rsvd_13
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int km_rsvd_13 : 1;

    /**
     * Position within tolerance window
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int tol82 : 1;

    /**
     * Ecode - Bit 13 - 18V plus Voltage error
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int ecode_bit13__18m_plus99 : 1;

    /**
     * Ecode - Bit 13 - 18V plus Voltage error
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int ecode_bit13__18m_plus148 : 1;

    /**
     * Special Generator Mode with automatic Iac limit reduction
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int dup__bit13__gen_autoiaclimit : 1;

    /**
     * Messbereich DC-Bus,1 (0..5 V), 0 (2,5..5 V)
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int ana_0up : 1;

    /**
     * Drive is ready (BTB/TDY contact is closed)
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int rdy64 : 1;

    /**
     * Current - measurement error
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int err_hwerr : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int goff : 1;

    /**
     * Command Source Mask - Analog 2 I Limit Status Bit
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int cs_ain_2__i_limit : 1;

    /**
     * Kern Mode State Bit -
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int km_pseudo_enable : 1;

    /**
     * Drive is ready (BTB/TDY contact is closed)
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int rdy82 : 1;

    /**
     * Ecode - Bit 14 - UBMA overvoltage error (digital)
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int ecode_bit14__ubmam99 : 1;

    /**
     * Ecode - Bit 14 - UBMA overvoltage error (digital)
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int ecode_bit14__ubmam148 : 1;

    /**
     * Enable the Limitiation Calculation depending on the DC Current limits V2
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int cmc__bit14__idc_limit_ena_v2 : 1;

    /**
     * Enable MTPA calculation and automatic command of Id_ref
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int dup__bit14__mtpa_reluct_enab : 1;

    /**
     * Low Baud rate of 9600 (serial)
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int lowbd : 1;

    /**
     * De-energized brake with motor active
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int brk064 : 1;

    /**
     * Ballast circuit overloaded
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int err_ballast : 1;

    /**
     * Excited Brake
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int brk1216 : 1;

    /**
     * Command Source Mask - Analog 1 N Limit Bit
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int cs_ain_1__n_limit : 1;

    /**
     * Kern Mode State Bit -
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int km_debug_test : 1;

    /**
     * De-energized brake with motor active
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int brk082 : 1;

    /**
     * Ecode - Bit 15 - T Igbt error (digital)
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int ecode_bit15__t_igbt99 : 1;

    /**
     * Ecode - Bit 15 - T Igbt error (digital)
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int ecode_bit15__t_igbt148 : 1;

    /**
     * Motor Options -
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int mo_sc2_inv : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_rcv_active190 active190;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_rcv_active191 active191;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_rcv_active192 active192;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_rcv_active193 active193;

    /**
     * Automatic Iac Lmiting in generator mode is active
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int gen_autoiaclimit_is_acv : 1;

    /**
     * Activate automated digital Recuperation Command
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int cmc__bit15__dig_e_brake_act : 1;

    /**
     * (Write Protected) Use CANopen instead of normal CAN protocol for the CAN communication
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int dup__bit15__canopen_acv : 1;

    /**
     * Torque Ramp Dec Time [0..4000 ms]
     *
     * Range: 0..4000 (0..4000 ms)
     * Scale: 1
     * Offset: 0
     */
    uint16_t m_r_dec;

    /**
     * Torque Ramp Rcp Time [0..4000 ms]
     *
     * Range: 0..4000 (0..4000 ms)
     * Scale: 1
     * Offset: 0
     */
    uint16_t m_r_rcp;

    /**
     * S-Ramp N Command (Inactive)
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int sramp : 1;

    /**
     * Speed internally inverted
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int signmag64 : 1;

    /**
     * No device identification
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int warn_warning_0 : 1;

    /**
     * Analog Input Signal 1 - Scaled
     *
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t ain_in_1_scaled213;

    /**
     * Analog Input Signal 2 - Scaled
     *
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t ain_in_2_scaled214;

    /**
     * DC Current Time
     *
     * Range: 0..65535 (0..65535 ms)
     * Scale: 1
     * Offset: 0
     */
    uint16_t t_dc__stop;

    /**
     * DC-Voltage Value for DC-Braking
     *
     * Range: -32768..32767 (-3276.8..3276.7 %)
     * Scale: 0.1
     * Offset: 0
     */
    float v_dc__stop;

    /**
     * Minimum Voltage (FU operation) at Stop
     *
     * Range: -32768..32767 (-3276.8..3276.7 %)
     * Scale: 0.1
     * Offset: 0
     */
    float v_min__stop;

    /**
     * Minimum Frequency (FU operation) at Stop
     *
     * Range: -32768..32767 (-3276.8..3276.7 Hz)
     * Scale: 0.1
     * Offset: 0
     */
    float f_min__stop;

    /**
     * Voltage (percentage of DC-Bus) at max. Frequency
     *
     * Range: -32768..32767 (-3276.8..3276.7 %)
     * Scale: 0.1
     * Offset: 0
     */
    float v_corner__stop;

    /**
     * Frequency at max output voltage - Stop
     *
     * Range: -32768..32767 (-3276.8..3276.7 Hz)
     * Scale: 0.1
     * Offset: 0
     */
    float f_corner__stop;

    /**
     * Proportional Gain Id-Current Controller - A entry 33 equals 1.0 normalized
     *
     * Range: 0..200 (0..200 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pid_i__kp__id;

    /**
     * Integral Action Time (Integral Part) Id-Current Controller
     *
     * Range: 300..20000 (300..20000 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pid_i__ti__id;

    /**
     * Id-Current Control Integral Maximum Output Range
     *
     * Range: 0..500 (0..500 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pid_i__tim__id;

    /**
     * Analog Input Signal 1 - Scale Value Setting
     *
     * Range: -32763.904..32763.904 (-7.999..7.999 -)
     * Scale: 0.000244140625
     * Offset: 0
     */
    float ain_in_1_scaleval;

    /**
     * Analog Input Signal 2 - Scale Value Setting
     *
     * Range: -32768..32767 (-8..7.999755859375 -)
     * Scale: 0.000244140625
     * Offset: 0
     */
    float ain_in_2_scaleval;

    /**
     * Speed internally inverted
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int signmag82 : 1;

    /**
     * Regenerative Resistor Value
     *
     * Range: 0..65535 (0..65535 Ohm)
     * Scale: 1
     * Offset: 0
     */
    uint16_t regen_r;

    /**
     * DC Bus Max Value Superpision Limit
     *
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t dc_bus_max_lim;

    /**
     * Proportional Gain Id-Current Controller if actual current is above I Limit Inuse Current - perc is depending on Kp value
     *
     * Range: 0..200 (0..200 %)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pid_i__xkp__id;

    /**
     * Idc or Pdc Limit during Generator operation
     *
     * Range: 0..65535 (0..6553.5 A or W)
     * Scale: 0.1
     * Offset: 0
     */
    float bat_opr_limit__gen;

    /**
     * Feedforward - Proportional Gain Id-Current Controller
     *
     * Range: 0..200 (0..200 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pid_i__kf__id;

    /**
     * Configuration of the I Peak supervision Limits
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cmc__bit17_16__checkipeak_config;

    /**
     * (Write Protected) Activation for the Offset Correction for older Bamobil 3.2 hardware setup
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int dup__bit16__bamobil3_2_offcrct : 1;

    /**
     * FU Special - Start
     *
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t special__stop;

    /**
     * free
     *
     * Range: -32768..32767 (-32768..32767 Num)
     * Scale: 1
     * Offset: 0
     */
    int16_t free;

    /**
     * Firmware SVN Revision Number
     *
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t svnrevision_nr;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int ramp4 : 1;

    /**
     * General speed limiting (if = 90 %) possible
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int nclip64 : 1;

    /**
     * RUN signal disturbed, EMI
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int warn_illegal_status : 1;

    /**
     * General speed limiting (if = 90 %) possible
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int nclip82 : 1;

    /**
     * (Write Protected) External ECODE processing matrix reconfiguration
     *
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dup__bit19_17__ecode_redefine;

    /**
     * Motor Brake
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int motbrake : 1;

    /**
     * Additional switchable negative speed limiting possible
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int nclip_minus64 : 1;

    /**
     * RFE input inactive (active without RUN input)
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int warn_safe_in : 1;

    /**
     * Additional switchable negative speed limiting possible
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int nclip_minus82 : 1;

    /**
     * Enable the special Traction Control Logic
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int cmc__bit18__tractioncontrol_ena : 1;

    /**
     * AC or DC power supply
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int ac_dc : 1;

    /**
     * Additional switchable positive speed limiting possible
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int nclip_plus64 : 1;

    /**
     * Additional switchable positive speed limiting possible
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int nclip_plus82 : 1;

    /**
     * Definition of the Delta Time rpm Speed Change supervision (20ms, 50ms, 100ms, 250ms)
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cmc__bit20_19__tc_deltatime_conf;

    /**
     * PWM Frequency define
     *
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_l_rcv_pwm_freq pwm_freq;

    /**
     * Current limiting (switchable) reached
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int irddig64 : 1;

    /**
     * Current limiting (switchable) reached
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int irddig82 : 1;

    /**
     * HAL Sensor Estimator Logic Activation
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int dup__bit20__hal_extmr_acv : 1;

    /**
     * Actual current limit reached
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int iuserchd64 : 1;

    /**
     * Actual current limit reached
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int iuserchd82 : 1;

    /**
     * Definition of the minumim rpm Speed percentage to activate the TC (0perc, 10perc, 20perc, 30perc)
     *
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cmc__bit22_21__tc_minspeed_conf;

    /**
     * Initialize inverter with a set Software Lock
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int dup__bit21__initwith_frg_off : 1;

    /**
     * Derating Triggered - Current limited by speed Limit
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int irdn64 : 1;

    /**
     * Motor temperature > (I-red-TM or 93 % from M-Temp)
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int warn_motortemp : 1;

    /**
     * Derating Triggered - Current limited by speed Limit
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int irdn82 : 1;

    /**
     * Bit 31_22 - free (NOT INUSE)
     *
     * Range: 0..1023 (0..1023 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t dup__bit31_22__free;

    /**
     * IGBT NTC Temperature Sensor
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int ntc : 1;

    /**
     * Derating Configured - Current limited by igbt temperature Limit
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int irdti64 : 1;

    /**
     * Device temperature > 87 % of limit
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int warn_devicetemp : 1;

    /**
     * Derating Configured - Current limited by igbt temperature Limit
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int irdti82 : 1;

    /**
     * Defines how the speed command ramp should be reset when TC triggers
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int cmc__bit23__tc_ncmdrestoption : 1;

    /**
     * Torque Ramp Acc Time [0..4000 ms]
     *
     * Range: 0..4000 (0..4000 ms)
     * Scale: 1
     * Offset: 0
     */
    uint16_t m_r_acc;

    /**
     * Motorphasen Dreieck
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int delta : 1;

    /**
     * Derating Triggered - Current limited by igbt temperature Limit
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int irdtir64 : 1;

    /**
     * Limit of the existing voltage output is reached
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int warn_vout_sat : 1;

    /**
     * Derating Triggered - Current limited by igbt temperature Limit
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int irdtir82 : 1;

    /**
     * Free (NOT INUSE)
     *
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cmc__bit31_24__free;

    /**
     * DC-1Quadrant, direkt pwm (Volt)
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int dc_1qdirvolt : 1;

    /**
     * Additional current limit if frequency less than 10 Hz
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int _10hz64 : 1;

    /**
     * Overcurrent 200 %
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int warn_ipeak : 1;

    /**
     * Additional current limit if frequency less than 10 Hz
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int _10hz82 : 1;

    /**
     * DC-Feldregler
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int dc_field : 1;

    /**
     * Derating Triggered - Current limited by motor temperature Limit
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int irdtm64 : 1;

    /**
     * Resolution range of the speed measurement exceeded
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int warn_raceaway : 1;

    /**
     * Derating Triggered - Current limited by motor temperature Limit
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int irdtm82 : 1;

    /**
     * deadband*2
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int dead_2 : 1;

    /**
     * Current derating due to analog input (if = 90 %) possible
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int irdana64 : 1;

    /**
     * Current derating due to analog input (if = 90 %) possible
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int irdana82 : 1;

    /**
     * Blockstrom bei ROT
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int block : 1;

    /**
     * Current peak value warning
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int iwcns64 : 1;

    /**
     * Current peak value warning
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int iwcns82 : 1;

    /**
     * DC-1Quadrant, minimale Schaltverluste
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int dc_1qmv : 1;

    /**
     * Pulsed RFE-input monitoring active
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int rfepulse64 : 1;

    /**
     * Pulsed RFE-input monitoring active
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int rfepulse82 : 1;

    /**
     * DC-1Quadrant, no high-side, bottom parallel
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int dc_1q3p : 1;

    /**
     * free
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int md64 : 1;

    /**
     * free
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int md82 : 1;

    /**
     * Automatic change to 4 kHz in case n < 10 Hz (No Derating)
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int reducelosses : 1;

    /**
     * Hand-wheel function selected
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int hndwhl64 : 1;

    /**
     * Ballast circuit > 87 % overloaded
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int warn_ballast : 1;

    /**
     * Hand-wheel function selected
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int hndwhl82 : 1;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_inverter_l_rcv_converted_t;

/**
 * Signals in message Inverter_R_Send.
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t send_mux;

    /**
     * Range: 0..65535 (0..6553.5 Hz)
     * Scale: 0.1
     * Offset: 0
     */
    uint16_t motor_f_n;

    /**
     * Range: 0..65535 (0..65535 ms)
     * Scale: 1
     * Offset: 0
     */
    uint16_t t_dc__start;

    /**
     * Range: -32768..32767 (-3276.8..3276.7 %)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t v_dc__start;

    /**
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t special__start;

    /**
     * Range: -32768..32767 (-3276.8..3276.7 %)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t v_min__start;

    /**
     * Range: -32768..32767 (-3276.8..3276.7 Hz)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t f_min__start;

    /**
     * Range: -32768..32767 (-3276.8..3276.7 %)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t v_corner__start;

    /**
     * Range: -32768..32767 (-3276.8..3276.7 Hz)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t f_corner__start;

    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t cos_phi;

    /**
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t extra__start;

    /**
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t capture_channel;

    /**
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t trig_level;

    /**
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t trig_edge;

    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t trig_source;

    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t oszi_source;

    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t oszi_skip;

    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t oszi_read_cmd;

    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t oszi_run_cmd;

    /**
     * Range: 0..65535 (0..6553.5 -)
     * Scale: 0.1
     * Offset: 0
     */
    uint16_t calib_ref_value;

    /**
     * Range: 0..200 (0..200 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pid_i__kp__iq;

    /**
     * Range: 300..20000 (300..20000 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pid_i__ti__iq;

    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t cutoffdig;

    /**
     * Range: -32768..32767 (-12249.91571968..12249.54188192 Arms)
     * Scale: 0.37383776
     * Offset: 0
     */
    int16_t id_setdig__id;

    /**
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t i_delta_ramp;

    /**
     * Range: 0..500 (0..500 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pid_i__tim__iq;

    /**
     * Range: 0..200 (0..200 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pid_n__kp;

    /**
     * Range: 0..10000 (0..10000 ms)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pid_n__ti;

    /**
     * Range: 0..10000 (0..10000 ms)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pid_n__td;

    /**
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t ain_in_1_offsetval;

    /**
     * Range: -32766.99999691205638057269621..32766.99999691205638057269621 (-7100..7100 Num)
     * Scale: 0.2166814173
     * Offset: 0
     */
    int16_t n_setdig;

    /**
     * Range: -32766.99943739061966000306044..32766.99943739061966000306044 (-100..100 %)
     * Scale: 0.003051851
     * Offset: 0
     */
    int16_t n_lim;

    /**
     * Range: 0..30000 (0..30000 ms)
     * Scale: 1
     * Offset: 0
     */
    uint16_t n_r_acc;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cs_ain_1_format;

    /**
     * Range: 0..100 (0..100 %)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pid_n__tim;

    /**
     * Range: 0..32766.99943739061966000306044 (0..100 %)
     * Scale: 0.003051851
     * Offset: 0
     */
    uint16_t i_red_n;

    /**
     * Range: -32766.99943739061966000306044..0 (-100..0 %)
     * Scale: 0.003051851
     * Offset: 0
     */
    int16_t n_lim_minus;

    /**
     * Range: 0..32766.99943739061966000306044 (0..100 %)
     * Scale: 0.003051851
     * Offset: 0
     */
    int16_t n_lim_plus;

    /**
     * Range: -3600..3600 (-360..360 -)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t fb_offset;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t read_id;

    /**
     * Range: 0..32766.99943739061966000306044 (0..100 %)
     * Scale: 0.003051851
     * Offset: 0
     */
    int16_t i_lim_dig;

    /**
     * Range: 0..32767 (0..32767 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t i_red_te;

    /**
     * Range: 0..32767 (0..3276.7 Arms)
     * Scale: 0.1
     * Offset: 0
     */
    uint16_t i_max_eff;

    /**
     * Range: 0..65535 (0..6553.5 0,1)
     * Scale: 0.1
     * Offset: 0
     */
    uint16_t i_nom_eff;

    /**
     * Range: 2..96 (2..96 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t motor_pole;

    /**
     * Range: 0..32767 (0..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t ain_in_1_cutoff;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t km_rsvd_0;

    /**
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t ain_in_2_cutoff;

    /**
     * Range: 0..32767 (0..32767 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t i_red_td;

    /**
     * Range: 60..65000 (60..65000 rpm)
     * Scale: 1
     * Offset: 0
     */
    uint16_t n_nom;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dc_bus_comp;

    /**
     * Range: 0..100 (0..100 %)
     * Scale: 1
     * Offset: 0
     */
    int16_t pid_n__kacc;

    /**
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t speed_filter;

    /**
     * Range: 0..255 (0..127.5 ms)
     * Scale: 0.5
     * Offset: 0
     */
    uint8_t ain_in_1_filter;

    /**
     * Range: 0..4294967295 (0..4294967295 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t snr;

    /**
     * Range: 0..1000 (0..1000 V)
     * Scale: 1
     * Offset: 0
     */
    uint16_t device_mains;

    /**
     * Range: 25..10000 (25..10000 W)
     * Scale: 1
     * Offset: 0
     */
    uint16_t regen_p;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t devicetype;

    /**
     * Range: 0..65530 (0..65530 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t can_id_rx;

    /**
     * Range: 0..65530 (0..65530 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t can_id_tx;

    /**
     * Range: 0..500 (0..500 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pos_kp;

    /**
     * Range: 0..10000 (0..10000 ms)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pos_ti;

    /**
     * Range: 0..65535 (0..65535 ms)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pos_td;

    /**
     * Range: -2147483648..2147483647 (-2147483648..2147483647 -)
     * Scale: 1
     * Offset: 0
     */
    int32_t pos_dest;

    /**
     * Range: 0..100 (0..100 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pos_tim;

    /**
     * Range: -2147483648..2147483647 (-2147483648..2147483647 -)
     * Scale: 1
     * Offset: 0
     */
    int32_t pos_offsref;

    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t can_nbt;

    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t ref_reso_edge;

    /**
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t speed_1;

    /**
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t speed_2;

    /**
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t pos_tol_win;

    /**
     * Range: -2147483648..2147483647 (-2147483648..2147483647 -)
     * Scale: 1
     * Offset: 0
     */
    int32_t pos_preset_val;

    /**
     * Range: -2147483648..2147483647 (-2147483648..2147483647 -)
     * Scale: 1
     * Offset: 0
     */
    int32_t pos_nd_scale;

    /**
     * Range: -2147483648..2147483647 (-2147483648..2147483647 -)
     * Scale: 1
     * Offset: 0
     */
    int32_t pos_nd_offset;

    /**
     * Range: -2147483648..2147483647 (-2147483648..2147483647 -)
     * Scale: 1
     * Offset: 0
     */
    int32_t fb2_scale_ext;

    /**
     * Range: -2147483648..2147483647 (-2147483648..2147483647 -)
     * Scale: 1
     * Offset: 0
     */
    int32_t pos_offset_slack;

    /**
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t pos_diff_slack;

    /**
     * Range: 0..2 (0..2 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t eprom131;

    /**
     * Range: 0..2 (0..2 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t eprom132;

    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t fun_special;

    /**
     * Range: 0..4294967295 (0..4294967295 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t can_id_2_rx;

    /**
     * Range: 0..4294967295 (0..4294967295 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t can_id_2_tx;

    /**
     * Range: -32768..32767 (-32768..32767 %)
     * Scale: 1
     * Offset: 0
     */
    int16_t v_ref;

    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t v_kp;

    /**
     * Range: 0..65535 (0..65535 ms)
     * Scale: 1
     * Offset: 0
     */
    uint16_t v_ti;

    /**
     * Range: 1..1 (1..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t clear_errors;

    /**
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t m_setdig__iq;

    /**
     * Range: 0..32767 (0..32767 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t i_red_tm;

    /**
     * Range: 0..32767 (0..32767 Num)
     * Scale: 1
     * Offset: 0
     */
    uint16_t m_temp;

    /**
     * Range: 0..31 (0..31 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t mo_feedback_1;

    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t dc_bus_min_lim;

    /**
     * Range: 0..65535 (0..65535 Inc/Rev)
     * Scale: 1
     * Offset: 0
     */
    uint16_t fb_incr_mot;

    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t fb_pole;

    /**
     * Range: 0..65535 (0..65.535 mH)
     * Scale: 0.001
     * Offset: 0
     */
    uint16_t motor_lsq;

    /**
     * Range: -32768..32767 (-32768..32767 %)
     * Scale: 1
     * Offset: 0
     */
    int16_t id_nom;

    /**
     * Range: 0..65535 (0..655.35 mH)
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t motor_lm;

    /**
     * Range: 0..65535 (0..65535 mOhm)
     * Scale: 1
     * Offset: 0
     */
    uint16_t motor_rr;

    /**
     * Range: 0..100 (0..100 %)
     * Scale: 1
     * Offset: 0
     */
    int16_t id_min;

    /**
     * Range: -32768..32767 (-32768..32767 ms)
     * Scale: 1
     * Offset: 0
     */
    int16_t motor_tr;

    /**
     * Range: 0..65535 (0..65.535 mH)
     * Scale: 0.001
     * Offset: 0
     */
    uint16_t motor_lsd;

    /**
     * Range: 0..65535 (0..65535 mOhm)
     * Scale: 1
     * Offset: 0
     */
    uint16_t motor_rs;

    /**
     * Range: -32768..32767 (-32.768..32.767 ms)
     * Scale: 0.001
     * Offset: 0
     */
    int16_t motor_ts;

    /**
     * Range: 0..32767 (0..32767 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t def_end_1;

    /**
     * Range: 0..32767 (0..32767 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t def_end_2;

    /**
     * Range: 0..32767 (0..32767 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t def_din_1;

    /**
     * Range: 0..32767 (0..32767 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t def_din_2;

    /**
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t operand194;

    /**
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t operand195;

    /**
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t operand218;

    /**
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t operand219;

    /**
     * Range: 0..16382.99999132683980459157101 (0..100 %)
     * Scale: 0.00610388818
     * Offset: 0
     */
    uint16_t i_max_pk;

    /**
     * Range: 0..16382.99999132683980459157101 (0..100 %)
     * Scale: 0.00610388818
     * Offset: 0
     */
    uint16_t i_con_eff;

    /**
     * Range: 0..65535 (0..6553.5 A)
     * Scale: 0.1
     * Offset: 0
     */
    uint16_t i_device;

    /**
     * Range: 0..1000 (0..1000 ms)
     * Scale: 1
     * Offset: 0
     */
    uint16_t n_r_lim;

    /**
     * Range: -32768..32767 (-32768..32767 rpm)
     * Scale: 1
     * Offset: 0
     */
    int16_t nmax100perc;

    /**
     * Range: 0..200 (0..200 %)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pid_i__xkp__iq;

    /**
     * Range: 0..65535 (0..6553.5 A or W)
     * Scale: 0.1
     * Offset: 0
     */
    uint16_t bat_opr_limit__mot;

    /**
     * Range: 0..200 (0..200 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pid_i__kf__iq;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cmc__bit0__dc_current_sens_ena;

    /**
     * Range: 0..32767 (0..32767 ms)
     * Scale: 1
     * Offset: 0
     */
    int16_t can_rxtimeout;

    /**
     * Range: -2147483648..2147483647 (-2147483648..2147483647 -)
     * Scale: 1
     * Offset: 0
     */
    int32_t var_1;

    /**
     * Range: -2147483648..2147483647 (-2147483648..2147483647 -)
     * Scale: 1
     * Offset: 0
     */
    int32_t var_2;

    /**
     * Range: -2147483648..2147483647 (-2147483648..2147483647 -)
     * Scale: 1
     * Offset: 0
     */
    int32_t var_3;

    /**
     * Range: -2147483648..2147483647 (-2147483648..2147483647 -)
     * Scale: 1
     * Offset: 0
     */
    int32_t var_4;

    /**
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t ain_in_2_offsetval;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dup__bit7_0__dac_source_channel;

    /**
     * Range: 0..30000 (0..30000 ms)
     * Scale: 1
     * Offset: 0
     */
    uint16_t n_r_dec;

    /**
     * Range: 0..65535 (0..65535 mV)
     * Scale: 1
     * Offset: 0
     */
    uint16_t v_shunt;

    /**
     * Range: 0..65535 (0..65535 s)
     * Scale: 1
     * Offset: 0
     */
    uint16_t t_peak;

    /**
     * Range: 0..65535 (0..65535 ms)
     * Scale: 1
     * Offset: 0
     */
    uint16_t brake_delay;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t axis;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t km_speed_0;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ballast_ext;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cmc__bit1__idc_limit_ena;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cs_ain_2_format;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t km_frg_off;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t fb_special;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cmc__bit2__pdc_limit_usage;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t km_cal_off;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t coaststop;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cmc__bit3__torqueval_init_ena;

    /**
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cs_ain_1_mode;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t km_tx_tog_stat;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t i_ist_inverse;

    /**
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t compare_var194;

    /**
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t compare_var195;

    /**
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t compare_var218;

    /**
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t compare_var219;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cmc__bit4__dig_m_rcpramp_ena;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t km_i_limit;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t refsoft;

    /**
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t mo_feedback_2;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cmc__bit5__reset_nramp_atnzero;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t km_n_clip;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t no_uesp_btb;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cmc__bit6__torquetimeout_100ms_e;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cs_oora1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t km_mix_ana_on;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t vdc_ana;

    /**
     * Range: 0..127 (0..127 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cmc__bit13_7__free;

    /**
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cs_ain_2_mode;

    /**
     * Range: 0..255 (0..255 ms)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ret_interval;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t km_allow_sync;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t i1_adc_ena;

    /**
     * Range: 0..255 (0..127.5 ms)
     * Scale: 0.5
     * Offset: 0
     */
    uint8_t ain_in_2_filter;

    /**
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t mo_sc1_reso;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t source_id194;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t source_id195;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t source_id218;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t source_id219;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dup__bit8__can_extended_0;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t km_handwheel;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t hxinv;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dup__bit9__generator;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t km_phasing_extend;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t h2inv;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dup__bit10__park_rms;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cs_oora2;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t km_rsvd_11;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ol_comp;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t mo_sc1_comp;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dup__bit11__dcbus_volts;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cs_cmd_type;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t km_rsvd_12;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t motortype;

    /**
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t mo_sc2_reso;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dup__bit12__boat_pedal;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t km_rsvd_13;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dup__bit13__gen_autoiaclimit;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cs_ain_2__i_limit;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t km_pseudo_enable;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ana_0up;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cmc__bit14__idc_limit_ena_v2;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dup__bit14__mtpa_reluct_enab;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cs_ain_1__n_limit;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t km_debug_test;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t lowbd;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t mo_sc2_inv;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t active190;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t active191;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t active192;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t active193;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cmc__bit15__dig_e_brake_act;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dup__bit15__canopen_acv;

    /**
     * Range: 0..65535 (0..65535 ms)
     * Scale: 1
     * Offset: 0
     */
    uint16_t t_dc__stop;

    /**
     * Range: -32768..32767 (-3276.8..3276.7 %)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t v_dc__stop;

    /**
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t special__stop;

    /**
     * Range: -32768..32767 (-3276.8..3276.7 %)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t v_min__stop;

    /**
     * Range: -32768..32767 (-3276.8..3276.7 Hz)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t f_min__stop;

    /**
     * Range: -32768..32767 (-3276.8..3276.7 %)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t v_corner__stop;

    /**
     * Range: -32768..32767 (-3276.8..3276.7 Hz)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t f_corner__stop;

    /**
     * Range: 0..200 (0..200 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pid_i__kp__id;

    /**
     * Range: 300..20000 (300..20000 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pid_i__ti__id;

    /**
     * Range: 0..500 (0..500 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pid_i__tim__id;

    /**
     * Range: -32763.904..32763.904 (-7.999..7.999 -)
     * Scale: 0.000244140625
     * Offset: 0
     */
    int16_t ain_in_1_scaleval;

    /**
     * Range: 0..4000 (0..4000 ms)
     * Scale: 1
     * Offset: 0
     */
    uint16_t m_r_acc;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t sramp;

    /**
     * Range: 0..65535 (0..65535 Ohm)
     * Scale: 1
     * Offset: 0
     */
    uint16_t regen_r;

    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t dc_bus_max_lim;

    /**
     * Range: 0..4000 (0..4000 ms)
     * Scale: 1
     * Offset: 0
     */
    uint16_t m_r_rcp;

    /**
     * Range: 0..200 (0..200 %)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pid_i__xkp__id;

    /**
     * Range: 0..65535 (0..6553.5 A or W)
     * Scale: 0.1
     * Offset: 0
     */
    uint16_t bat_opr_limit__gen;

    /**
     * Range: 0..200 (0..200 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pid_i__kf__id;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cmc__bit17_16__checkipeak_config;

    /**
     * Range: -32768..32767 (-8..7.999755859375 -)
     * Scale: 0.000244140625
     * Offset: 0
     */
    int16_t ain_in_2_scaleval;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dup__bit16__bamobil3_2_offcrct;

    /**
     * Range: 0..4000 (0..4000 ms)
     * Scale: 1
     * Offset: 0
     */
    uint16_t m_r_dec;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ramp4;

    /**
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dup__bit19_17__ecode_redefine;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t motbrake;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cmc__bit18__tractioncontrol_ena;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ac_dc;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cmc__bit20_19__tc_deltatime_conf;

    /**
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t pwm_freq;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dup__bit20__hal_extmr_acv;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cmc__bit22_21__tc_minspeed_conf;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dup__bit21__initwith_frg_off;

    /**
     * Range: 0..1023 (0..1023 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t dup__bit31_22__free;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ntc;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cmc__bit23__tc_ncmdrestoption;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t delta;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cmc__bit31_24__free;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dc_1qdirvolt;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dc_field;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dead_2;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t block;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dc_1qmv;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dc_1q3p;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t reducelosses;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_inverter_r_send_t;

/**
 * Signals in message Inverter_R_Send.
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t send_mux;

    /**
     * Range: 0..65535 (0..6553.5 Hz)
     * Scale: 0.1
     * Offset: 0
     */
    float motor_f_n;

    /**
     * Range: 0..65535 (0..65535 ms)
     * Scale: 1
     * Offset: 0
     */
    uint16_t t_dc__start;

    /**
     * Range: -32768..32767 (-3276.8..3276.7 %)
     * Scale: 0.1
     * Offset: 0
     */
    float v_dc__start;

    /**
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t special__start;

    /**
     * Range: -32768..32767 (-3276.8..3276.7 %)
     * Scale: 0.1
     * Offset: 0
     */
    float v_min__start;

    /**
     * Range: -32768..32767 (-3276.8..3276.7 Hz)
     * Scale: 0.1
     * Offset: 0
     */
    float f_min__start;

    /**
     * Range: -32768..32767 (-3276.8..3276.7 %)
     * Scale: 0.1
     * Offset: 0
     */
    float v_corner__start;

    /**
     * Range: -32768..32767 (-3276.8..3276.7 Hz)
     * Scale: 0.1
     * Offset: 0
     */
    float f_corner__start;

    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t cos_phi;

    /**
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t extra__start;

    /**
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t capture_channel;

    /**
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t trig_level;

    /**
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t trig_edge;

    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t trig_source;

    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t oszi_source;

    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t oszi_skip;

    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t oszi_read_cmd;

    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t oszi_run_cmd;

    /**
     * Range: 0..65535 (0..6553.5 -)
     * Scale: 0.1
     * Offset: 0
     */
    float calib_ref_value;

    /**
     * Range: 0..200 (0..200 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pid_i__kp__iq;

    /**
     * Range: 300..20000 (300..20000 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pid_i__ti__iq;

    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t cutoffdig;

    /**
     * Range: -32768..32767 (-12249.91571968..12249.54188192 Arms)
     * Scale: 0.37383776
     * Offset: 0
     */
    float id_setdig__id;

    /**
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t i_delta_ramp;

    /**
     * Range: 0..500 (0..500 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pid_i__tim__iq;

    /**
     * Range: 0..200 (0..200 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pid_n__kp;

    /**
     * Range: 0..10000 (0..10000 ms)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pid_n__ti;

    /**
     * Range: 0..10000 (0..10000 ms)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pid_n__td;

    /**
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t ain_in_1_offsetval;

    /**
     * Range: -32766.99999691205638057269621..32766.99999691205638057269621 (-7100..7100 Num)
     * Scale: 0.2166814173
     * Offset: 0
     */
    float n_setdig;

    /**
     * Range: -32766.99943739061966000306044..32766.99943739061966000306044 (-100..100 %)
     * Scale: 0.003051851
     * Offset: 0
     */
    float n_lim;

    /**
     * Range: 0..30000 (0..30000 ms)
     * Scale: 1
     * Offset: 0
     */
    uint16_t n_r_acc;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cs_ain_1_format;

    /**
     * Range: 0..100 (0..100 %)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pid_n__tim;

    /**
     * Range: 0..32766.99943739061966000306044 (0..100 %)
     * Scale: 0.003051851
     * Offset: 0
     */
    float i_red_n;

    /**
     * Range: -32766.99943739061966000306044..0 (-100..0 %)
     * Scale: 0.003051851
     * Offset: 0
     */
    float n_lim_minus;

    /**
     * Range: 0..32766.99943739061966000306044 (0..100 %)
     * Scale: 0.003051851
     * Offset: 0
     */
    float n_lim_plus;

    /**
     * Range: -3600..3600 (-360..360 -)
     * Scale: 0.1
     * Offset: 0
     */
    float fb_offset;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t read_id;

    /**
     * Range: 0..32766.99943739061966000306044 (0..100 %)
     * Scale: 0.003051851
     * Offset: 0
     */
    float i_lim_dig;

    /**
     * Range: 0..32767 (0..32767 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t i_red_te;

    /**
     * Range: 0..32767 (0..3276.7 Arms)
     * Scale: 0.1
     * Offset: 0
     */
    float i_max_eff;

    /**
     * Range: 0..65535 (0..6553.5 0,1)
     * Scale: 0.1
     * Offset: 0
     */
    float i_nom_eff;

    /**
     * Range: 2..96 (2..96 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t motor_pole;

    /**
     * Range: 0..32767 (0..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t ain_in_1_cutoff;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int km_rsvd_0 : 1;

    /**
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t ain_in_2_cutoff;

    /**
     * Range: 0..32767 (0..32767 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t i_red_td;

    /**
     * Range: 60..65000 (60..65000 rpm)
     * Scale: 1
     * Offset: 0
     */
    uint16_t n_nom;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int dc_bus_comp : 1;

    /**
     * Range: 0..100 (0..100 %)
     * Scale: 1
     * Offset: 0
     */
    int16_t pid_n__kacc;

    /**
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t speed_filter;

    /**
     * Range: 0..255 (0..127.5 ms)
     * Scale: 0.5
     * Offset: 0
     */
    float ain_in_1_filter;

    /**
     * Range: 0..4294967295 (0..4294967295 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t snr;

    /**
     * Range: 0..1000 (0..1000 V)
     * Scale: 1
     * Offset: 0
     */
    uint16_t device_mains;

    /**
     * Range: 25..10000 (25..10000 W)
     * Scale: 1
     * Offset: 0
     */
    uint16_t regen_p;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t devicetype;

    /**
     * Range: 0..65530 (0..65530 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t can_id_rx;

    /**
     * Range: 0..65530 (0..65530 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t can_id_tx;

    /**
     * Range: 0..500 (0..500 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pos_kp;

    /**
     * Range: 0..10000 (0..10000 ms)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pos_ti;

    /**
     * Range: 0..65535 (0..65535 ms)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pos_td;

    /**
     * Range: -2147483648..2147483647 (-2147483648..2147483647 -)
     * Scale: 1
     * Offset: 0
     */
    int32_t pos_dest;

    /**
     * Range: 0..100 (0..100 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pos_tim;

    /**
     * Range: -2147483648..2147483647 (-2147483648..2147483647 -)
     * Scale: 1
     * Offset: 0
     */
    int32_t pos_offsref;

    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t can_nbt;

    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t ref_reso_edge;

    /**
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t speed_1;

    /**
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t speed_2;

    /**
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t pos_tol_win;

    /**
     * Range: -2147483648..2147483647 (-2147483648..2147483647 -)
     * Scale: 1
     * Offset: 0
     */
    int32_t pos_preset_val;

    /**
     * Range: -2147483648..2147483647 (-2147483648..2147483647 -)
     * Scale: 1
     * Offset: 0
     */
    int32_t pos_nd_scale;

    /**
     * Range: -2147483648..2147483647 (-2147483648..2147483647 -)
     * Scale: 1
     * Offset: 0
     */
    int32_t pos_nd_offset;

    /**
     * Range: -2147483648..2147483647 (-2147483648..2147483647 -)
     * Scale: 1
     * Offset: 0
     */
    int32_t fb2_scale_ext;

    /**
     * Range: -2147483648..2147483647 (-2147483648..2147483647 -)
     * Scale: 1
     * Offset: 0
     */
    int32_t pos_offset_slack;

    /**
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t pos_diff_slack;

    /**
     * Range: 0..2 (0..2 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t eprom131;

    /**
     * Range: 0..2 (0..2 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t eprom132;

    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t fun_special;

    /**
     * Range: 0..4294967295 (0..4294967295 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t can_id_2_rx;

    /**
     * Range: 0..4294967295 (0..4294967295 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t can_id_2_tx;

    /**
     * Range: -32768..32767 (-32768..32767 %)
     * Scale: 1
     * Offset: 0
     */
    int16_t v_ref;

    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t v_kp;

    /**
     * Range: 0..65535 (0..65535 ms)
     * Scale: 1
     * Offset: 0
     */
    uint16_t v_ti;

    /**
     * Range: 1..1 (1..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t clear_errors;

    /**
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t m_setdig__iq;

    /**
     * Range: 0..32767 (0..32767 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t i_red_tm;

    /**
     * Range: 0..32767 (0..32767 Num)
     * Scale: 1
     * Offset: 0
     */
    uint16_t m_temp;

    /**
     * Range: 0..31 (0..31 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t mo_feedback_1;

    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t dc_bus_min_lim;

    /**
     * Range: 0..65535 (0..65535 Inc/Rev)
     * Scale: 1
     * Offset: 0
     */
    uint16_t fb_incr_mot;

    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t fb_pole;

    /**
     * Range: 0..65535 (0..65.535 mH)
     * Scale: 0.001
     * Offset: 0
     */
    float motor_lsq;

    /**
     * Range: -32768..32767 (-32768..32767 %)
     * Scale: 1
     * Offset: 0
     */
    int16_t id_nom;

    /**
     * Range: 0..65535 (0..655.35 mH)
     * Scale: 0.01
     * Offset: 0
     */
    float motor_lm;

    /**
     * Range: 0..65535 (0..65535 mOhm)
     * Scale: 1
     * Offset: 0
     */
    uint16_t motor_rr;

    /**
     * Range: 0..100 (0..100 %)
     * Scale: 1
     * Offset: 0
     */
    int16_t id_min;

    /**
     * Range: -32768..32767 (-32768..32767 ms)
     * Scale: 1
     * Offset: 0
     */
    int16_t motor_tr;

    /**
     * Range: 0..65535 (0..65.535 mH)
     * Scale: 0.001
     * Offset: 0
     */
    float motor_lsd;

    /**
     * Range: 0..65535 (0..65535 mOhm)
     * Scale: 1
     * Offset: 0
     */
    uint16_t motor_rs;

    /**
     * Range: -32768..32767 (-32.768..32.767 ms)
     * Scale: 0.001
     * Offset: 0
     */
    float motor_ts;

    /**
     * Range: 0..32767 (0..32767 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t def_end_1;

    /**
     * Range: 0..32767 (0..32767 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t def_end_2;

    /**
     * Range: 0..32767 (0..32767 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t def_din_1;

    /**
     * Range: 0..32767 (0..32767 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t def_din_2;

    /**
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t operand194;

    /**
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t operand195;

    /**
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t operand218;

    /**
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t operand219;

    /**
     * Range: 0..16382.99999132683980459157101 (0..100 %)
     * Scale: 0.00610388818
     * Offset: 0
     */
    float i_max_pk;

    /**
     * Range: 0..16382.99999132683980459157101 (0..100 %)
     * Scale: 0.00610388818
     * Offset: 0
     */
    float i_con_eff;

    /**
     * Range: 0..65535 (0..6553.5 A)
     * Scale: 0.1
     * Offset: 0
     */
    float i_device;

    /**
     * Range: 0..1000 (0..1000 ms)
     * Scale: 1
     * Offset: 0
     */
    uint16_t n_r_lim;

    /**
     * Range: -32768..32767 (-32768..32767 rpm)
     * Scale: 1
     * Offset: 0
     */
    int16_t nmax100perc;

    /**
     * Range: 0..200 (0..200 %)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pid_i__xkp__iq;

    /**
     * Range: 0..65535 (0..6553.5 A or W)
     * Scale: 0.1
     * Offset: 0
     */
    float bat_opr_limit__mot;

    /**
     * Range: 0..200 (0..200 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pid_i__kf__iq;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int cmc__bit0__dc_current_sens_ena : 1;

    /**
     * Range: 0..32767 (0..32767 ms)
     * Scale: 1
     * Offset: 0
     */
    int16_t can_rxtimeout;

    /**
     * Range: -2147483648..2147483647 (-2147483648..2147483647 -)
     * Scale: 1
     * Offset: 0
     */
    int32_t var_1;

    /**
     * Range: -2147483648..2147483647 (-2147483648..2147483647 -)
     * Scale: 1
     * Offset: 0
     */
    int32_t var_2;

    /**
     * Range: -2147483648..2147483647 (-2147483648..2147483647 -)
     * Scale: 1
     * Offset: 0
     */
    int32_t var_3;

    /**
     * Range: -2147483648..2147483647 (-2147483648..2147483647 -)
     * Scale: 1
     * Offset: 0
     */
    int32_t var_4;

    /**
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t ain_in_2_offsetval;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dup__bit7_0__dac_source_channel;

    /**
     * Range: 0..30000 (0..30000 ms)
     * Scale: 1
     * Offset: 0
     */
    uint16_t n_r_dec;

    /**
     * Range: 0..65535 (0..65535 mV)
     * Scale: 1
     * Offset: 0
     */
    uint16_t v_shunt;

    /**
     * Range: 0..65535 (0..65535 s)
     * Scale: 1
     * Offset: 0
     */
    uint16_t t_peak;

    /**
     * Range: 0..65535 (0..65535 ms)
     * Scale: 1
     * Offset: 0
     */
    uint16_t brake_delay;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t axis;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int km_speed_0 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int ballast_ext : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int cmc__bit1__idc_limit_ena : 1;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cs_ain_2_format;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int km_frg_off : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int fb_special : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int cmc__bit2__pdc_limit_usage : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int km_cal_off : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int coaststop : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int cmc__bit3__torqueval_init_ena : 1;

    /**
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cs_ain_1_mode;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int km_tx_tog_stat : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int i_ist_inverse : 1;

    /**
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t compare_var194;

    /**
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t compare_var195;

    /**
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t compare_var218;

    /**
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t compare_var219;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int cmc__bit4__dig_m_rcpramp_ena : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int km_i_limit : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int refsoft : 1;

    /**
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t mo_feedback_2;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int cmc__bit5__reset_nramp_atnzero : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int km_n_clip : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int no_uesp_btb : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int cmc__bit6__torquetimeout_100ms_e : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int cs_oora1 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int km_mix_ana_on : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int vdc_ana : 1;

    /**
     * Range: 0..127 (0..127 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cmc__bit13_7__free;

    /**
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cs_ain_2_mode;

    /**
     * Range: 0..255 (0..255 ms)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ret_interval;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int km_allow_sync : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int i1_adc_ena : 1;

    /**
     * Range: 0..255 (0..127.5 ms)
     * Scale: 0.5
     * Offset: 0
     */
    float ain_in_2_filter;

    /**
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t mo_sc1_reso;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t source_id194;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t source_id195;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t source_id218;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t source_id219;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int dup__bit8__can_extended_0 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int km_handwheel : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int hxinv : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int dup__bit9__generator : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int km_phasing_extend : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int h2inv : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int dup__bit10__park_rms : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int cs_oora2 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int km_rsvd_11 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int ol_comp : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int mo_sc1_comp : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int dup__bit11__dcbus_volts : 1;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cs_cmd_type;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int km_rsvd_12 : 1;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t motortype;

    /**
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t mo_sc2_reso;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int dup__bit12__boat_pedal : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int km_rsvd_13 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int dup__bit13__gen_autoiaclimit : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int cs_ain_2__i_limit : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int km_pseudo_enable : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int ana_0up : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int cmc__bit14__idc_limit_ena_v2 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int dup__bit14__mtpa_reluct_enab : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int cs_ain_1__n_limit : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int km_debug_test : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int lowbd : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int mo_sc2_inv : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int active190 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int active191 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int active192 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int active193 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int cmc__bit15__dig_e_brake_act : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int dup__bit15__canopen_acv : 1;

    /**
     * Range: 0..65535 (0..65535 ms)
     * Scale: 1
     * Offset: 0
     */
    uint16_t t_dc__stop;

    /**
     * Range: -32768..32767 (-3276.8..3276.7 %)
     * Scale: 0.1
     * Offset: 0
     */
    float v_dc__stop;

    /**
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t special__stop;

    /**
     * Range: -32768..32767 (-3276.8..3276.7 %)
     * Scale: 0.1
     * Offset: 0
     */
    float v_min__stop;

    /**
     * Range: -32768..32767 (-3276.8..3276.7 Hz)
     * Scale: 0.1
     * Offset: 0
     */
    float f_min__stop;

    /**
     * Range: -32768..32767 (-3276.8..3276.7 %)
     * Scale: 0.1
     * Offset: 0
     */
    float v_corner__stop;

    /**
     * Range: -32768..32767 (-3276.8..3276.7 Hz)
     * Scale: 0.1
     * Offset: 0
     */
    float f_corner__stop;

    /**
     * Range: 0..200 (0..200 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pid_i__kp__id;

    /**
     * Range: 300..20000 (300..20000 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pid_i__ti__id;

    /**
     * Range: 0..500 (0..500 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pid_i__tim__id;

    /**
     * Range: -32763.904..32763.904 (-7.999..7.999 -)
     * Scale: 0.000244140625
     * Offset: 0
     */
    float ain_in_1_scaleval;

    /**
     * Range: 0..4000 (0..4000 ms)
     * Scale: 1
     * Offset: 0
     */
    uint16_t m_r_acc;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int sramp : 1;

    /**
     * Range: 0..65535 (0..65535 Ohm)
     * Scale: 1
     * Offset: 0
     */
    uint16_t regen_r;

    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t dc_bus_max_lim;

    /**
     * Range: 0..4000 (0..4000 ms)
     * Scale: 1
     * Offset: 0
     */
    uint16_t m_r_rcp;

    /**
     * Range: 0..200 (0..200 %)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pid_i__xkp__id;

    /**
     * Range: 0..65535 (0..6553.5 A or W)
     * Scale: 0.1
     * Offset: 0
     */
    float bat_opr_limit__gen;

    /**
     * Range: 0..200 (0..200 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pid_i__kf__id;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cmc__bit17_16__checkipeak_config;

    /**
     * Range: -32768..32767 (-8..7.999755859375 -)
     * Scale: 0.000244140625
     * Offset: 0
     */
    float ain_in_2_scaleval;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int dup__bit16__bamobil3_2_offcrct : 1;

    /**
     * Range: 0..4000 (0..4000 ms)
     * Scale: 1
     * Offset: 0
     */
    uint16_t m_r_dec;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int ramp4 : 1;

    /**
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dup__bit19_17__ecode_redefine;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int motbrake : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int cmc__bit18__tractioncontrol_ena : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int ac_dc : 1;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cmc__bit20_19__tc_deltatime_conf;

    /**
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t pwm_freq;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int dup__bit20__hal_extmr_acv : 1;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cmc__bit22_21__tc_minspeed_conf;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int dup__bit21__initwith_frg_off : 1;

    /**
     * Range: 0..1023 (0..1023 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t dup__bit31_22__free;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int ntc : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int cmc__bit23__tc_ncmdrestoption : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int delta : 1;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cmc__bit31_24__free;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int dc_1qdirvolt : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int dc_field : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int dead_2 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int block : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int dc_1qmv : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int dc_1q3p : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int reducelosses : 1;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_inverter_r_send_converted_t;

/**
 * Signals in message Inverter_R_Rcv.
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t rcv_mux;

    /**
     * Range: -32767.00000405309586161245655..32767 (-3600..3599.9999995547 Num)
     * Scale: 0.1098666341
     * Offset: 0
     */
    int16_t n_actual;

    /**
     * Range: 0..30000 (0..30000 ms)
     * Scale: 1
     * Offset: 0
     */
    uint16_t n_r_dec;

    /**
     * Range: 0..1000 (0..1000 ms)
     * Scale: 1
     * Offset: 0
     */
    uint16_t n_r_lim;

    /**
     * Range: -32768..32767 (-3600.1098661888..3599.9999995547 rpm)
     * Scale: 0.1098666341
     * Offset: 0
     */
    int16_t n_actual_filt;

    /**
     * Range: 0..4095 (0..4095 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t firmware;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t devicetype;

    /**
     * Range: 0..4294967295 (0..4294967295 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t snr;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t axis;

    /**
     * Range: 0..65535 (0..6553.5 A)
     * Scale: 0.1
     * Offset: 0
     */
    uint16_t i_device;

    /**
     * Range: 0..65535 (0..65535 mV)
     * Scale: 1
     * Offset: 0
     */
    uint16_t v_shunt;

    /**
     * Range: 0..65535 (0..65535 adc)
     * Scale: 1
     * Offset: 0
     */
    uint16_t i_200perc;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dc_bus_comp;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ena64;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t err_badparas;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t lmt1;

    /**
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t ain_in_1_raw;

    /**
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t ain_in_2_raw;

    /**
     * Range: -32768..32767 (-32768..32767 rpm)
     * Scale: 1
     * Offset: 0
     */
    int16_t nmax100perc;

    /**
     * Range: -32766.99999691205638057269621..32766.99999691205638057269621 (-7100..7100 Num)
     * Scale: 0.2166814173
     * Offset: 0
     */
    int16_t n_setdig;

    /**
     * Range: -32768..32767 (-32768..32767 Num)
     * Scale: 1
     * Offset: 0
     */
    int16_t n_cmd;

    /**
     * Range: -32766.99999691205638057269621..32766.99999691205638057269621 (-7100..7100 Num)
     * Scale: 0.2166814173
     * Offset: 0
     */
    int16_t n_cmd_ramp;

    /**
     * Range: -32766.99943739061966000306044..32766.99943739061966000306044 (-100..100 %)
     * Scale: 0.003051851
     * Offset: 0
     */
    int16_t n_lim;

    /**
     * Range: -32766.99999691205638057269621..32766.99999691205638057269621 (-7100..7100 Num)
     * Scale: 0.2166814173
     * Offset: 0
     */
    int16_t n_error;

    /**
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t m_setdig__iq;

    /**
     * Range: -32768..32767 (-12249.91571968..12249.54188192 Arms)
     * Scale: 0.37383776
     * Offset: 0
     */
    int16_t id_setdig__id;

    /**
     * Range: 0..16382.99999132683980459157101 (0..100 %)
     * Scale: 0.00610388818
     * Offset: 0
     */
    uint16_t i_max_pk;

    /**
     * Range: 0..16382.99999132683980459157101 (0..100 %)
     * Scale: 0.00610388818
     * Offset: 0
     */
    uint16_t i_con_eff;

    /**
     * Range: 0..32767 (0..3276.7 Arms)
     * Scale: 0.1
     * Offset: 0
     */
    uint16_t i_max_eff;

    /**
     * Range: 0..65535 (0..6553.5 0,1)
     * Scale: 0.1
     * Offset: 0
     */
    uint16_t i_nom_eff;

    /**
     * Range: -32768..32767 (-4547.16391424..4547.02514581 Arms)
     * Scale: 0.13876843
     * Offset: 0
     */
    int16_t i_limit_inuse;

    /**
     * Range: -32768..32767 (-4547.16391424..4547.02514581 Arms)
     * Scale: 0.13876843
     * Offset: 0
     */
    int16_t i_cmd;

    /**
     * Range: -32768..32767 (-4547.16391424..4547.02514581 Arms)
     * Scale: 0.13876843
     * Offset: 0
     */
    int16_t i_cmd_ramp;

    /**
     * Range: -32768..32767 (-4547.16391424..4547.02514581 Arms)
     * Scale: 0.13876843
     * Offset: 0
     */
    int16_t i_actual;

    /**
     * Range: -32768..32767 (-4547.16391424..4547.02514581 Arms)
     * Scale: 0.13876843
     * Offset: 0
     */
    int16_t i_actual_filt;

    /**
     * Range: -32768..32767 (-4547.16391424..4547.02514581 Arms)
     * Scale: 0.13876843
     * Offset: 0
     */
    int16_t iq_actual;

    /**
     * Range: -32768..32767 (-4547.16391424..4547.02514581 Arms)
     * Scale: 0.13876843
     * Offset: 0
     */
    int16_t id_actual;

    /**
     * Range: -32768..32767 (-4547.16391424..4547.02514581 Arms)
     * Scale: 0.13876843
     * Offset: 0
     */
    int16_t iq_error;

    /**
     * Range: -32768..32767 (-4547.16391424..4547.02514581 Arms)
     * Scale: 0.13876843
     * Offset: 0
     */
    int16_t id_error;

    /**
     * Range: -32768..32767 (-6430.660886528..6430.464638332 A)
     * Scale: 0.196248196
     * Offset: 0
     */
    int16_t i1_actual;

    /**
     * Range: -32768..32767 (-6430.660886528..6430.464638332 A)
     * Scale: 0.196248196
     * Offset: 0
     */
    int16_t i2_actual;

    /**
     * Range: -32768..32767 (-6430.660886528..6430.464638332 A)
     * Scale: 0.196248196
     * Offset: 0
     */
    int16_t i3_actual;

    /**
     * Range: 0..65535 (0..65535 Num)
     * Scale: 1
     * Offset: 0
     */
    uint16_t i3_adc;

    /**
     * Range: 0..65535 (0..65535 Num)
     * Scale: 1
     * Offset: 0
     */
    uint16_t i2_adc;

    /**
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t vq;

    /**
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t vd;

    /**
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t vout;

    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t t_motor;

    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t t_igbt;

    /**
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t t_air;

    /**
     * Range: 0..65532.05229287863361432703605 (0..2075 V)
     * Scale: 0.03166389465
     * Offset: 0
     */
    uint16_t vdc_bus_filt;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t end_1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t din_1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t end_2;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t din_2;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t run232;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dout_1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dout_2;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dout_3;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t rdy_btb;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t i_fault;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dout_4;

    /**
     * Range: 0..32766.99943739061966000306044 (0..100 %)
     * Scale: 0.003051851
     * Offset: 0
     */
    int16_t i_lim_dig;

    /**
     * Range: 0..32766.99943739061966000306044 (0..100 %)
     * Scale: 0.003051851
     * Offset: 0
     */
    uint16_t i_red_n;

    /**
     * Range: 0..32767 (0..32767 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t i_red_td;

    /**
     * Range: 0..32767 (0..32767 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t i_red_te;

    /**
     * Range: 0..32767 (0..32767 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t i_red_tm;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cs_ain_1_format;

    /**
     * Range: -32768..32767 (-4547.16391424..4547.02514581 Arms)
     * Scale: 0.13876843
     * Offset: 0
     */
    int16_t id_ref;

    /**
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t m_outdig__iq;

    /**
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t ptr_1_debug;

    /**
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t ptr_2_debug;

    /**
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t temp_debug;

    /**
     * Range: 0..65535 (0..6553.5 Hz)
     * Scale: 0.1
     * Offset: 0
     */
    uint16_t motor_f_n;

    /**
     * Range: 0..65535 (0..65535 V)
     * Scale: 1
     * Offset: 0
     */
    uint16_t motor_v_n;

    /**
     * Range: 0..65535 (0..65535 ms)
     * Scale: 1
     * Offset: 0
     */
    uint16_t t_dc__start;

    /**
     * Range: -32768..32767 (-3276.8..3276.7 %)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t v_dc__start;

    /**
     * Range: -32768..32767 (-3276.8..3276.7 %)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t v_min__start;

    /**
     * Range: -32768..32767 (-3276.8..3276.7 Hz)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t f_min__start;

    /**
     * Range: -32768..32767 (-3276.8..3276.7 %)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t v_corner__start;

    /**
     * Range: -32768..32767 (-3276.8..3276.7 Hz)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t f_corner__start;

    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t cos_phi;

    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pwm_enum;

    /**
     * Range: 0..65535 (0..6553.5 -)
     * Scale: 0.1
     * Offset: 0
     */
    uint16_t calib_ref_value;

    /**
     * Range: 0..200 (0..200 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pid_i__kp__iq;

    /**
     * Range: 300..20000 (300..20000 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pid_i__ti__iq;

    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t cutoffdig;

    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t i3_offset;

    /**
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t i_delta_ramp;

    /**
     * Range: 0..500 (0..500 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pid_i__tim__iq;

    /**
     * Range: 0..200 (0..200 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pid_n__kp;

    /**
     * Range: 0..65535 (0..65535 ms)
     * Scale: 1
     * Offset: 0
     */
    uint16_t v_ti;

    /**
     * Range: 0..10000 (0..10000 ms)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pid_n__td;

    /**
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t ain_in_1_offsetval;

    /**
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t ain_in_2_offsetval;

    /**
     * Range: 0..32767 (0..32767 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t dzr_seq;

    /**
     * Range: 0..100 (0..100 %)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pid_n__tim;

    /**
     * Range: 0..32766.99943739061966000306044 (0..100 %)
     * Scale: 0.003051851
     * Offset: 0
     */
    int16_t n_lim_plus;

    /**
     * Range: -32766.99943739061966000306044..0 (-100..0 %)
     * Scale: 0.003051851
     * Offset: 0
     */
    int16_t n_lim_minus;

    /**
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t incr_delta;

    /**
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t motorpos_mech;

    /**
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t motorpos_elec;

    /**
     * Range: -3600..3600 (-360..360 -)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t fb_offset;

    /**
     * Range: -2147483648..2147483647 (-2147483648..2147483647 -)
     * Scale: 1
     * Offset: 0
     */
    int32_t it_rg_monitor;

    /**
     * Range: 2..96 (2..96 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t motor_pole;

    /**
     * Range: 0..32767 (0..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t ain_in_1_cutoff;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t activecontrolmode;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t km_rsvd_0;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ena82;

    /**
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t ain_in_2_cutoff;

    /**
     * Range: -32768..32767 (-12249.91571968..12249.54188192 Arms)
     * Scale: 0.37383776
     * Offset: 0
     */
    int16_t i_limit_inuse_ramp;

    /**
     * Range: 60..65000 (60..65000 rpm)
     * Scale: 1
     * Offset: 0
     */
    uint16_t n_nom;

    /**
     * Range: 0..100 (0..100 %)
     * Scale: 1
     * Offset: 0
     */
    int16_t pid_n__kacc;

    /**
     * Range: 0..65535 (0..65535 %)
     * Scale: 1
     * Offset: 0
     */
    uint16_t rotor_signals;

    /**
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t speed_filter;

    /**
     * Range: 0..255 (0..127.5 ms)
     * Scale: 0.5
     * Offset: 0
     */
    uint8_t ain_in_1_filter;

    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t ixt_monitor;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ecode_bit0_firsterrordtcd99;

    /**
     * Range: 0..1000 (0..1000 V)
     * Scale: 1
     * Offset: 0
     */
    uint16_t device_mains;

    /**
     * Range: 25..10000 (25..10000 W)
     * Scale: 1
     * Offset: 0
     */
    uint16_t regen_p;

    /**
     * Range: 0..65530 (0..65530 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t can_id_rx;

    /**
     * Range: 0..65530 (0..65530 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t can_id_tx;

    /**
     * Range: 0..500 (0..500 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pos_kp;

    /**
     * Range: 0..10000 (0..10000 ms)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pos_ti;

    /**
     * Range: 0..65535 (0..65535 ms)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pos_td;

    /**
     * Range: -2147483648..2147483647 (-2147483648..2147483647 -)
     * Scale: 1
     * Offset: 0
     */
    int32_t pos_actual;

    /**
     * Range: -2147483648..2147483647 (-2147483648..2147483647 -)
     * Scale: 1
     * Offset: 0
     */
    int32_t pos_dest;

    /**
     * Range: -2147483648..2147483647 (-2147483648..2147483647 -)
     * Scale: 1
     * Offset: 0
     */
    int32_t pos_actual_2;

    /**
     * Range: -2147483648..2147483647 (-2147483648..2147483647 -)
     * Scale: 1
     * Offset: 0
     */
    int32_t pos_error;

    /**
     * Range: 0..100 (0..100 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pos_tim;

    /**
     * Range: -2147483648..2147483647 (-2147483648..2147483647 -)
     * Scale: 1
     * Offset: 0
     */
    int32_t pos_offsref;

    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t can_nbt;

    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pos_zero_capture;

    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t ref_reso_edge;

    /**
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t speed_1;

    /**
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t speed_2;

    /**
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t pos_tol_win;

    /**
     * Range: -2147483648..2147483647 (-2147483648..2147483647 -)
     * Scale: 1
     * Offset: 0
     */
    int32_t pos_preset_val;

    /**
     * Range: -2147483648..2147483647 (-2147483648..2147483647 -)
     * Scale: 1
     * Offset: 0
     */
    int32_t pos_zero_offset;

    /**
     * Range: -2147483648..2147483647 (-2147483648..2147483647 -)
     * Scale: 1
     * Offset: 0
     */
    int32_t pos_nd_scale;

    /**
     * Range: -2147483648..2147483647 (-2147483648..2147483647 -)
     * Scale: 1
     * Offset: 0
     */
    int32_t pos_nd_offset;

    /**
     * Range: -2147483648..2147483647 (-2147483648..2147483647 -)
     * Scale: 1
     * Offset: 0
     */
    int32_t fb2_scale_ext;

    /**
     * Range: -2147483648..2147483647 (-2147483648..2147483647 -)
     * Scale: 1
     * Offset: 0
     */
    int32_t pos_offset_slack;

    /**
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t pos_diff_slack;

    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t fun_para_read;

    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t fun_para_write;

    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t fun_special;

    /**
     * Range: 0..4294967295 (0..4294967295 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t can_id_2_rx;

    /**
     * Range: 0..4294967295 (0..4294967295 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t can_id_2_tx;

    /**
     * Range: -32768..32767 (-32768..32767 %)
     * Scale: 1
     * Offset: 0
     */
    int16_t v_ref;

    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t v_kp;

    /**
     * Range: 0..10000 (0..10000 ms)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pid_n__ti;

    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t clear_errors;

    /**
     * Range: -2147483648..2147483647 (-2147483648..2147483647 -)
     * Scale: 1
     * Offset: 0
     */
    int32_t pos_cmd;

    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t can_error_busoff;

    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t can_error_writetime;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ecode_bit0_firsterrordtcd148;

    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t can_error_no_ack;

    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t can_error_crc_check150;

    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t can_error_crc_check151;

    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t info_timer_diff;

    /**
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t ballastcount;

    /**
     * Range: 0..32767 (0..32767 Num)
     * Scale: 1
     * Offset: 0
     */
    uint16_t m_temp;

    /**
     * Range: 0..31 (0..31 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t mo_feedback_1;

    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t dc_bus_min_lim;

    /**
     * Range: 0..65535 (0..65535 Inc/Rev)
     * Scale: 1
     * Offset: 0
     */
    uint16_t fb_incr_mot;

    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t fb_pole;

    /**
     * Range: 0..65535 (0..65535 Hz)
     * Scale: 1
     * Offset: 0
     */
    uint16_t logic_freq;

    /**
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t pwm_1;

    /**
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t pwm_2;

    /**
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t pwm_3;

    /**
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t timer_delta;

    /**
     * Range: 0..65535 (0..65.535 mH)
     * Scale: 0.001
     * Offset: 0
     */
    uint16_t motor_lsq;

    /**
     * Range: 0..65535 (0..65.535 mH)
     * Scale: 0.001
     * Offset: 0
     */
    uint16_t motor_lsd;

    /**
     * Range: -32768..32767 (-32768..32767 %)
     * Scale: 1
     * Offset: 0
     */
    int16_t id_nom;

    /**
     * Range: 0..65535 (0..655.35 mH)
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t motor_lm;

    /**
     * Range: 0..65535 (0..65535 mOhm)
     * Scale: 1
     * Offset: 0
     */
    uint16_t motor_rr;

    /**
     * Range: 0..100 (0..100 %)
     * Scale: 1
     * Offset: 0
     */
    int16_t id_min;

    /**
     * Range: -32768..32767 (-32768..32767 ms)
     * Scale: 1
     * Offset: 0
     */
    int16_t motor_tr;

    /**
     * Range: 0..65535 (0..65535 mOhm)
     * Scale: 1
     * Offset: 0
     */
    uint16_t motor_rs;

    /**
     * Range: -32768..32767 (-32.768..32.767 ms)
     * Scale: 0.001
     * Offset: 0
     */
    int16_t motor_ts;

    /**
     * Range: 0..32767 (0..32767 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t def_end_1;

    /**
     * Range: 0..32767 (0..32767 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t def_end_2;

    /**
     * Range: 0..32767 (0..32767 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t def_din_1;

    /**
     * Range: 0..32767 (0..32767 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t def_din_2;

    /**
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t operand194;

    /**
     * Range: -32768..32767 (-4547.16391424..4547.02514581 Arms)
     * Scale: 0.13876843
     * Offset: 0
     */
    int16_t i_max_inuse;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t signal_go;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t signal_brake;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t signal_icns;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t signal_lessn0;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t signal_postolerance;

    /**
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t ain_in_1_scaled251;

    /**
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t ain_in_2_scaled252;

    /**
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t operand195;

    /**
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t operand218;

    /**
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t operand219;

    /**
     * Range: 0..200 (0..200 %)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pid_i__xkp__iq;

    /**
     * Range: 0..65535 (0..6553.5 A or W)
     * Scale: 0.1
     * Offset: 0
     */
    uint16_t bat_opr_limit__mot;

    /**
     * Range: 0..200 (0..200 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pid_i__kf__iq;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dc_current_sens_ena_set;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cmc__bit0__dc_current_sens_ena;

    /**
     * Range: -32768..32767 (-32768..32767 rpm)
     * Scale: 1
     * Offset: 0
     */
    int16_t n_rpm_maxint;

    /**
     * Range: -2147483648..2147483647 (-2147483648..2147483647 -)
     * Scale: 1
     * Offset: 0
     */
    int32_t var_1;

    /**
     * Range: 0..32767 (0..32767 ms)
     * Scale: 1
     * Offset: 0
     */
    int16_t can_rxtimeout;

    /**
     * Range: -2147483648..2147483647 (-2147483648..2147483647 -)
     * Scale: 1
     * Offset: 0
     */
    int32_t var_2;

    /**
     * Range: -2147483648..2147483647 (-2147483648..2147483647 -)
     * Scale: 1
     * Offset: 0
     */
    int32_t var_3;

    /**
     * Range: -2147483648..2147483647 (-2147483648..2147483647 -)
     * Scale: 1
     * Offset: 0
     */
    int32_t var_4;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dup__bit7_0__dac_source_channel;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t fb_lossofsignal;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t no_hw_fault;

    /**
     * Range: 0..65535 (0..65535 s)
     * Scale: 1
     * Offset: 0
     */
    uint16_t t_peak;

    /**
     * Range: 0..65535 (0..65535 ms)
     * Scale: 1
     * Offset: 0
     */
    uint16_t brake_delay;

    /**
     * Range: -32768..32767 (-32768..32767 W)
     * Scale: 1
     * Offset: 0
     */
    int16_t power;

    /**
     * Range: -32768..32767 (-32768..32767 Joul)
     * Scale: 1
     * Offset: 0
     */
    int16_t work;

    /**
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t extra__start;

    /**
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t capture_channel;

    /**
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t trig_level;

    /**
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t trig_edge;

    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t trig_source;

    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t oszi_source;

    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t oszi_skip;

    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t oszi_run_cmd;

    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t oszi_read_cmd;

    /**
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t pos_ref_start;

    /**
     * Range: 0..65532.05229287863361432703605 (0..2075 V)
     * Scale: 0.03166389465
     * Offset: 0
     */
    uint16_t vdc_bus;

    /**
     * Range: -32767..32767 (-32767..32767 Num)
     * Scale: 1
     * Offset: 0
     */
    int16_t m_cmd_ramp;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t lmt_1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t out_1;

    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t subversion_nr;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ballast_ext;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ncr064;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t err_powerfault;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t lmt2;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t km_speed_0;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ncr082;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ecode_bit1__hw1_state99;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ecode_bit1__hw1_state148;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dc_i_sensena_set;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cmc__bit1__idc_limit_ena;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t lmt_2;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t out_2;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t fb_special;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t lim_plus64;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t err_rfe_fault;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t in2;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cs_ain_2_format;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t km_frg_off;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t lim_plus82;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ecode_bit2__hw0_state99;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ecode_bit2__hw0_state148;

    /**
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t op_mode_quadrant;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cmc__bit2__pdc_limit_usage;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t in_2;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t rdy155;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t coaststop;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t lim_minus64;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t err_bustimeout;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t in1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t km_cal_off;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t lim_minus82;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ecode_bit3__free99;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ecode_bit3__free148;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cmc__bit3__torqueval_init_ena;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t in_1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t go155;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t i_ist_inverse;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ok64;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t err_feedbacksignal;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t frgrun;

    /**
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cs_ain_1_mode;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t km_tx_tog_stat;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ok82;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ecode_bit4__rdy399;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ecode_bit4__rdy3148;

    /**
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t compare_var194;

    /**
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t compare_var195;

    /**
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t compare_var218;

    /**
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t compare_var219;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cmc__bit4__dig_m_rcpramp_ena;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t run152;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t out_3;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t refsoft;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t icns64;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t err_powervoltage_low;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t rfe216;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t km_i_limit;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t icns82;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ecode_bit5__n_fail99;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ecode_bit5__n_fail148;

    /**
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t mo_feedback_2;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t recup_is_acv;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cmc__bit5__reset_nramp_atnzero;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t rfe152;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t out_4;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t no_uesp_btb;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t tnlim64;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t err_motortemp;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t km_n_clip;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t tnlim82;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ecode_bit6__flths99;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ecode_bit6__flths148;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t i_dc_limit_is_acv;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cmc__bit6__torquetimeout_100ms_e;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t rsvd;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t rsvd1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t vdc_ana;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t pn64;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t err_devicetemp;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cs_oora1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t km_mix_ana_on;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t pn82;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ecode_bit7__fltls99;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ecode_bit7__fltls148;

    /**
     * Range: 0..127 (0..127 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cmc__bit13_7__free;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t brk1155;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t i1_adc_ena;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ni64;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t err_overvoltage;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t out1;

    /**
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cs_ain_2_mode;

    /**
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ctrlsubmode;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t km_allow_sync;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ni82;

    /**
     * Range: 0..255 (0..127.5 ms)
     * Scale: 0.5
     * Offset: 0
     */
    uint8_t ain_in_2_filter;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ecode_bit8__fail_idc99;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ecode_bit8__fail_idc148;

    /**
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t mo_sc1_reso;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t source_id194;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t source_id195;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t source_id218;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t source_id219;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dup__bit8__can_extended_0;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t hxinv;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t _n064;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t err_ipeak;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t out2;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t km_handwheel;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t _n082;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ecode_bit9__fail_i99;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ecode_bit9__fail_i148;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dup__bit9__generator;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t h2inv;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t rsw64;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t err_raceaway;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t btbrdy;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t km_phasing_extend;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t rsw82;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ecode_bit10__vccm99;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ecode_bit10__vccm148;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dup__bit10__park_rms;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ol_comp;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cal064;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t err_user;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t go216;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cs_oora2;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t km_rsvd_11;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cal082;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ecode_bit11__15m_minus99;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ecode_bit11__15m_minus148;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t mo_sc1_comp;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dup__bit11__dcbus_volts;

    /**
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t test;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t motortype;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cal64;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t out3;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cs_cmd_type;

    /**
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t currentmode;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t km_rsvd_12;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cal82;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ecode_bit12__15m_plus99;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ecode_bit12__15m_plus148;

    /**
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t mo_sc2_reso;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dup__bit12__boat_pedal;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t tol64;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t out4;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t km_rsvd_13;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t tol82;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ecode_bit13__18m_plus99;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ecode_bit13__18m_plus148;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dup__bit13__gen_autoiaclimit;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ana_0up;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t rdy64;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t err_hwerr;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t goff;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cs_ain_2__i_limit;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t km_pseudo_enable;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t rdy82;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ecode_bit14__ubmam99;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ecode_bit14__ubmam148;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cmc__bit14__idc_limit_ena_v2;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dup__bit14__mtpa_reluct_enab;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t lowbd;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t brk064;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t err_ballast;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t brk1216;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cs_ain_1__n_limit;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t km_debug_test;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t brk082;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ecode_bit15__t_igbt99;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ecode_bit15__t_igbt148;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t mo_sc2_inv;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t active190;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t active191;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t active192;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t active193;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t gen_autoiaclimit_is_acv;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cmc__bit15__dig_e_brake_act;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dup__bit15__canopen_acv;

    /**
     * Range: 0..4000 (0..4000 ms)
     * Scale: 1
     * Offset: 0
     */
    uint16_t m_r_dec;

    /**
     * Range: 0..4000 (0..4000 ms)
     * Scale: 1
     * Offset: 0
     */
    uint16_t m_r_rcp;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t sramp;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t signmag64;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t warn_warning_0;

    /**
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t ain_in_1_scaled213;

    /**
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t ain_in_2_scaled214;

    /**
     * Range: 0..65535 (0..65535 ms)
     * Scale: 1
     * Offset: 0
     */
    uint16_t t_dc__stop;

    /**
     * Range: -32768..32767 (-3276.8..3276.7 %)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t v_dc__stop;

    /**
     * Range: -32768..32767 (-3276.8..3276.7 %)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t v_min__stop;

    /**
     * Range: -32768..32767 (-3276.8..3276.7 Hz)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t f_min__stop;

    /**
     * Range: -32768..32767 (-3276.8..3276.7 %)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t v_corner__stop;

    /**
     * Range: -32768..32767 (-3276.8..3276.7 Hz)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t f_corner__stop;

    /**
     * Range: 0..200 (0..200 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pid_i__kp__id;

    /**
     * Range: 300..20000 (300..20000 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pid_i__ti__id;

    /**
     * Range: 0..500 (0..500 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pid_i__tim__id;

    /**
     * Range: -32763.904..32763.904 (-7.999..7.999 -)
     * Scale: 0.000244140625
     * Offset: 0
     */
    int16_t ain_in_1_scaleval;

    /**
     * Range: -32768..32767 (-8..7.999755859375 -)
     * Scale: 0.000244140625
     * Offset: 0
     */
    int16_t ain_in_2_scaleval;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t signmag82;

    /**
     * Range: 0..65535 (0..65535 Ohm)
     * Scale: 1
     * Offset: 0
     */
    uint16_t regen_r;

    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t dc_bus_max_lim;

    /**
     * Range: 0..200 (0..200 %)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pid_i__xkp__id;

    /**
     * Range: 0..65535 (0..6553.5 A or W)
     * Scale: 0.1
     * Offset: 0
     */
    uint16_t bat_opr_limit__gen;

    /**
     * Range: 0..200 (0..200 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pid_i__kf__id;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cmc__bit17_16__checkipeak_config;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dup__bit16__bamobil3_2_offcrct;

    /**
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t special__stop;

    /**
     * Range: -32768..32767 (-32768..32767 Num)
     * Scale: 1
     * Offset: 0
     */
    int16_t free;

    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t svnrevision_nr;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ramp4;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nclip64;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t warn_illegal_status;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nclip82;

    /**
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dup__bit19_17__ecode_redefine;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t motbrake;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nclip_minus64;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t warn_safe_in;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nclip_minus82;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cmc__bit18__tractioncontrol_ena;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ac_dc;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nclip_plus64;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nclip_plus82;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cmc__bit20_19__tc_deltatime_conf;

    /**
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t pwm_freq;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t irddig64;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t irddig82;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dup__bit20__hal_extmr_acv;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t iuserchd64;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t iuserchd82;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cmc__bit22_21__tc_minspeed_conf;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dup__bit21__initwith_frg_off;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t irdn64;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t warn_motortemp;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t irdn82;

    /**
     * Range: 0..1023 (0..1023 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t dup__bit31_22__free;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ntc;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t irdti64;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t warn_devicetemp;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t irdti82;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cmc__bit23__tc_ncmdrestoption;

    /**
     * Range: 0..4000 (0..4000 ms)
     * Scale: 1
     * Offset: 0
     */
    uint16_t m_r_acc;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t delta;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t irdtir64;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t warn_vout_sat;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t irdtir82;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cmc__bit31_24__free;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dc_1qdirvolt;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t _10hz64;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t warn_ipeak;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t _10hz82;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dc_field;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t irdtm64;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t warn_raceaway;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t irdtm82;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dead_2;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t irdana64;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t irdana82;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t block;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t iwcns64;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t iwcns82;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dc_1qmv;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t rfepulse64;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t rfepulse82;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dc_1q3p;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t md64;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t md82;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t reducelosses;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t hndwhl64;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t warn_ballast;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t hndwhl82;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_inverter_r_rcv_t;

/**
 * Signals in message Inverter_R_Rcv.
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t rcv_mux;

    /**
     * Range: -32767.00000405309586161245655..32767 (-3600..3599.9999995547 Num)
     * Scale: 0.1098666341
     * Offset: 0
     */
    float n_actual;

    /**
     * Range: 0..30000 (0..30000 ms)
     * Scale: 1
     * Offset: 0
     */
    uint16_t n_r_dec;

    /**
     * Range: 0..1000 (0..1000 ms)
     * Scale: 1
     * Offset: 0
     */
    uint16_t n_r_lim;

    /**
     * Range: -32768..32767 (-3600.1098661888..3599.9999995547 rpm)
     * Scale: 0.1098666341
     * Offset: 0
     */
    float n_actual_filt;

    /**
     * Range: 0..4095 (0..4095 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t firmware;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t devicetype;

    /**
     * Range: 0..4294967295 (0..4294967295 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t snr;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t axis;

    /**
     * Range: 0..65535 (0..6553.5 A)
     * Scale: 0.1
     * Offset: 0
     */
    float i_device;

    /**
     * Range: 0..65535 (0..65535 mV)
     * Scale: 1
     * Offset: 0
     */
    uint16_t v_shunt;

    /**
     * Range: 0..65535 (0..65535 adc)
     * Scale: 1
     * Offset: 0
     */
    uint16_t i_200perc;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int dc_bus_comp : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int ena64 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int err_badparas : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int lmt1 : 1;

    /**
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t ain_in_1_raw;

    /**
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t ain_in_2_raw;

    /**
     * Range: -32768..32767 (-32768..32767 rpm)
     * Scale: 1
     * Offset: 0
     */
    int16_t nmax100perc;

    /**
     * Range: -32766.99999691205638057269621..32766.99999691205638057269621 (-7100..7100 Num)
     * Scale: 0.2166814173
     * Offset: 0
     */
    float n_setdig;

    /**
     * Range: -32768..32767 (-32768..32767 Num)
     * Scale: 1
     * Offset: 0
     */
    int16_t n_cmd;

    /**
     * Range: -32766.99999691205638057269621..32766.99999691205638057269621 (-7100..7100 Num)
     * Scale: 0.2166814173
     * Offset: 0
     */
    float n_cmd_ramp;

    /**
     * Range: -32766.99943739061966000306044..32766.99943739061966000306044 (-100..100 %)
     * Scale: 0.003051851
     * Offset: 0
     */
    float n_lim;

    /**
     * Range: -32766.99999691205638057269621..32766.99999691205638057269621 (-7100..7100 Num)
     * Scale: 0.2166814173
     * Offset: 0
     */
    float n_error;

    /**
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t m_setdig__iq;

    /**
     * Range: -32768..32767 (-12249.91571968..12249.54188192 Arms)
     * Scale: 0.37383776
     * Offset: 0
     */
    float id_setdig__id;

    /**
     * Range: 0..16382.99999132683980459157101 (0..100 %)
     * Scale: 0.00610388818
     * Offset: 0
     */
    float i_max_pk;

    /**
     * Range: 0..16382.99999132683980459157101 (0..100 %)
     * Scale: 0.00610388818
     * Offset: 0
     */
    float i_con_eff;

    /**
     * Range: 0..32767 (0..3276.7 Arms)
     * Scale: 0.1
     * Offset: 0
     */
    float i_max_eff;

    /**
     * Range: 0..65535 (0..6553.5 0,1)
     * Scale: 0.1
     * Offset: 0
     */
    float i_nom_eff;

    /**
     * Range: -32768..32767 (-4547.16391424..4547.02514581 Arms)
     * Scale: 0.13876843
     * Offset: 0
     */
    float i_limit_inuse;

    /**
     * Range: -32768..32767 (-4547.16391424..4547.02514581 Arms)
     * Scale: 0.13876843
     * Offset: 0
     */
    float i_cmd;

    /**
     * Range: -32768..32767 (-4547.16391424..4547.02514581 Arms)
     * Scale: 0.13876843
     * Offset: 0
     */
    float i_cmd_ramp;

    /**
     * Range: -32768..32767 (-4547.16391424..4547.02514581 Arms)
     * Scale: 0.13876843
     * Offset: 0
     */
    float i_actual;

    /**
     * Range: -32768..32767 (-4547.16391424..4547.02514581 Arms)
     * Scale: 0.13876843
     * Offset: 0
     */
    float i_actual_filt;

    /**
     * Range: -32768..32767 (-4547.16391424..4547.02514581 Arms)
     * Scale: 0.13876843
     * Offset: 0
     */
    float iq_actual;

    /**
     * Range: -32768..32767 (-4547.16391424..4547.02514581 Arms)
     * Scale: 0.13876843
     * Offset: 0
     */
    float id_actual;

    /**
     * Range: -32768..32767 (-4547.16391424..4547.02514581 Arms)
     * Scale: 0.13876843
     * Offset: 0
     */
    float iq_error;

    /**
     * Range: -32768..32767 (-4547.16391424..4547.02514581 Arms)
     * Scale: 0.13876843
     * Offset: 0
     */
    float id_error;

    /**
     * Range: -32768..32767 (-6430.660886528..6430.464638332 A)
     * Scale: 0.196248196
     * Offset: 0
     */
    float i1_actual;

    /**
     * Range: -32768..32767 (-6430.660886528..6430.464638332 A)
     * Scale: 0.196248196
     * Offset: 0
     */
    float i2_actual;

    /**
     * Range: -32768..32767 (-6430.660886528..6430.464638332 A)
     * Scale: 0.196248196
     * Offset: 0
     */
    float i3_actual;

    /**
     * Range: 0..65535 (0..65535 Num)
     * Scale: 1
     * Offset: 0
     */
    uint16_t i3_adc;

    /**
     * Range: 0..65535 (0..65535 Num)
     * Scale: 1
     * Offset: 0
     */
    uint16_t i2_adc;

    /**
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t vq;

    /**
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t vd;

    /**
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t vout;

    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t t_motor;

    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t t_igbt;

    /**
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t t_air;

    /**
     * Range: 0..65532.05229287863361432703605 (0..2075 V)
     * Scale: 0.03166389465
     * Offset: 0
     */
    float vdc_bus_filt;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int end_1 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int din_1 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int end_2 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int din_2 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int run232 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int dout_1 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int dout_2 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int dout_3 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int rdy_btb : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int i_fault : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int dout_4 : 1;

    /**
     * Range: 0..32766.99943739061966000306044 (0..100 %)
     * Scale: 0.003051851
     * Offset: 0
     */
    float i_lim_dig;

    /**
     * Range: 0..32766.99943739061966000306044 (0..100 %)
     * Scale: 0.003051851
     * Offset: 0
     */
    float i_red_n;

    /**
     * Range: 0..32767 (0..32767 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t i_red_td;

    /**
     * Range: 0..32767 (0..32767 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t i_red_te;

    /**
     * Range: 0..32767 (0..32767 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t i_red_tm;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cs_ain_1_format;

    /**
     * Range: -32768..32767 (-4547.16391424..4547.02514581 Arms)
     * Scale: 0.13876843
     * Offset: 0
     */
    float id_ref;

    /**
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t m_outdig__iq;

    /**
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t ptr_1_debug;

    /**
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t ptr_2_debug;

    /**
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t temp_debug;

    /**
     * Range: 0..65535 (0..6553.5 Hz)
     * Scale: 0.1
     * Offset: 0
     */
    float motor_f_n;

    /**
     * Range: 0..65535 (0..65535 V)
     * Scale: 1
     * Offset: 0
     */
    uint16_t motor_v_n;

    /**
     * Range: 0..65535 (0..65535 ms)
     * Scale: 1
     * Offset: 0
     */
    uint16_t t_dc__start;

    /**
     * Range: -32768..32767 (-3276.8..3276.7 %)
     * Scale: 0.1
     * Offset: 0
     */
    float v_dc__start;

    /**
     * Range: -32768..32767 (-3276.8..3276.7 %)
     * Scale: 0.1
     * Offset: 0
     */
    float v_min__start;

    /**
     * Range: -32768..32767 (-3276.8..3276.7 Hz)
     * Scale: 0.1
     * Offset: 0
     */
    float f_min__start;

    /**
     * Range: -32768..32767 (-3276.8..3276.7 %)
     * Scale: 0.1
     * Offset: 0
     */
    float v_corner__start;

    /**
     * Range: -32768..32767 (-3276.8..3276.7 Hz)
     * Scale: 0.1
     * Offset: 0
     */
    float f_corner__start;

    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t cos_phi;

    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pwm_enum;

    /**
     * Range: 0..65535 (0..6553.5 -)
     * Scale: 0.1
     * Offset: 0
     */
    float calib_ref_value;

    /**
     * Range: 0..200 (0..200 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pid_i__kp__iq;

    /**
     * Range: 300..20000 (300..20000 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pid_i__ti__iq;

    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t cutoffdig;

    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t i3_offset;

    /**
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t i_delta_ramp;

    /**
     * Range: 0..500 (0..500 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pid_i__tim__iq;

    /**
     * Range: 0..200 (0..200 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pid_n__kp;

    /**
     * Range: 0..65535 (0..65535 ms)
     * Scale: 1
     * Offset: 0
     */
    uint16_t v_ti;

    /**
     * Range: 0..10000 (0..10000 ms)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pid_n__td;

    /**
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t ain_in_1_offsetval;

    /**
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t ain_in_2_offsetval;

    /**
     * Range: 0..32767 (0..32767 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t dzr_seq;

    /**
     * Range: 0..100 (0..100 %)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pid_n__tim;

    /**
     * Range: 0..32766.99943739061966000306044 (0..100 %)
     * Scale: 0.003051851
     * Offset: 0
     */
    float n_lim_plus;

    /**
     * Range: -32766.99943739061966000306044..0 (-100..0 %)
     * Scale: 0.003051851
     * Offset: 0
     */
    float n_lim_minus;

    /**
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t incr_delta;

    /**
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t motorpos_mech;

    /**
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t motorpos_elec;

    /**
     * Range: -3600..3600 (-360..360 -)
     * Scale: 0.1
     * Offset: 0
     */
    float fb_offset;

    /**
     * Range: -2147483648..2147483647 (-2147483648..2147483647 -)
     * Scale: 1
     * Offset: 0
     */
    int32_t it_rg_monitor;

    /**
     * Range: 2..96 (2..96 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t motor_pole;

    /**
     * Range: 0..32767 (0..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t ain_in_1_cutoff;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t activecontrolmode;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int km_rsvd_0 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int ena82 : 1;

    /**
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t ain_in_2_cutoff;

    /**
     * Range: -32768..32767 (-12249.91571968..12249.54188192 Arms)
     * Scale: 0.37383776
     * Offset: 0
     */
    float i_limit_inuse_ramp;

    /**
     * Range: 60..65000 (60..65000 rpm)
     * Scale: 1
     * Offset: 0
     */
    uint16_t n_nom;

    /**
     * Range: 0..100 (0..100 %)
     * Scale: 1
     * Offset: 0
     */
    int16_t pid_n__kacc;

    /**
     * Range: 0..65535 (0..65535 %)
     * Scale: 1
     * Offset: 0
     */
    uint16_t rotor_signals;

    /**
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t speed_filter;

    /**
     * Range: 0..255 (0..127.5 ms)
     * Scale: 0.5
     * Offset: 0
     */
    float ain_in_1_filter;

    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t ixt_monitor;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int ecode_bit0_firsterrordtcd99 : 1;

    /**
     * Range: 0..1000 (0..1000 V)
     * Scale: 1
     * Offset: 0
     */
    uint16_t device_mains;

    /**
     * Range: 25..10000 (25..10000 W)
     * Scale: 1
     * Offset: 0
     */
    uint16_t regen_p;

    /**
     * Range: 0..65530 (0..65530 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t can_id_rx;

    /**
     * Range: 0..65530 (0..65530 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t can_id_tx;

    /**
     * Range: 0..500 (0..500 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pos_kp;

    /**
     * Range: 0..10000 (0..10000 ms)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pos_ti;

    /**
     * Range: 0..65535 (0..65535 ms)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pos_td;

    /**
     * Range: -2147483648..2147483647 (-2147483648..2147483647 -)
     * Scale: 1
     * Offset: 0
     */
    int32_t pos_actual;

    /**
     * Range: -2147483648..2147483647 (-2147483648..2147483647 -)
     * Scale: 1
     * Offset: 0
     */
    int32_t pos_dest;

    /**
     * Range: -2147483648..2147483647 (-2147483648..2147483647 -)
     * Scale: 1
     * Offset: 0
     */
    int32_t pos_actual_2;

    /**
     * Range: -2147483648..2147483647 (-2147483648..2147483647 -)
     * Scale: 1
     * Offset: 0
     */
    int32_t pos_error;

    /**
     * Range: 0..100 (0..100 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pos_tim;

    /**
     * Range: -2147483648..2147483647 (-2147483648..2147483647 -)
     * Scale: 1
     * Offset: 0
     */
    int32_t pos_offsref;

    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t can_nbt;

    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pos_zero_capture;

    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t ref_reso_edge;

    /**
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t speed_1;

    /**
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t speed_2;

    /**
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t pos_tol_win;

    /**
     * Range: -2147483648..2147483647 (-2147483648..2147483647 -)
     * Scale: 1
     * Offset: 0
     */
    int32_t pos_preset_val;

    /**
     * Range: -2147483648..2147483647 (-2147483648..2147483647 -)
     * Scale: 1
     * Offset: 0
     */
    int32_t pos_zero_offset;

    /**
     * Range: -2147483648..2147483647 (-2147483648..2147483647 -)
     * Scale: 1
     * Offset: 0
     */
    int32_t pos_nd_scale;

    /**
     * Range: -2147483648..2147483647 (-2147483648..2147483647 -)
     * Scale: 1
     * Offset: 0
     */
    int32_t pos_nd_offset;

    /**
     * Range: -2147483648..2147483647 (-2147483648..2147483647 -)
     * Scale: 1
     * Offset: 0
     */
    int32_t fb2_scale_ext;

    /**
     * Range: -2147483648..2147483647 (-2147483648..2147483647 -)
     * Scale: 1
     * Offset: 0
     */
    int32_t pos_offset_slack;

    /**
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t pos_diff_slack;

    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t fun_para_read;

    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t fun_para_write;

    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t fun_special;

    /**
     * Range: 0..4294967295 (0..4294967295 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t can_id_2_rx;

    /**
     * Range: 0..4294967295 (0..4294967295 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t can_id_2_tx;

    /**
     * Range: -32768..32767 (-32768..32767 %)
     * Scale: 1
     * Offset: 0
     */
    int16_t v_ref;

    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t v_kp;

    /**
     * Range: 0..10000 (0..10000 ms)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pid_n__ti;

    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t clear_errors;

    /**
     * Range: -2147483648..2147483647 (-2147483648..2147483647 -)
     * Scale: 1
     * Offset: 0
     */
    int32_t pos_cmd;

    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t can_error_busoff;

    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t can_error_writetime;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int ecode_bit0_firsterrordtcd148 : 1;

    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t can_error_no_ack;

    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t can_error_crc_check150;

    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t can_error_crc_check151;

    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t info_timer_diff;

    /**
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t ballastcount;

    /**
     * Range: 0..32767 (0..32767 Num)
     * Scale: 1
     * Offset: 0
     */
    uint16_t m_temp;

    /**
     * Range: 0..31 (0..31 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t mo_feedback_1;

    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t dc_bus_min_lim;

    /**
     * Range: 0..65535 (0..65535 Inc/Rev)
     * Scale: 1
     * Offset: 0
     */
    uint16_t fb_incr_mot;

    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t fb_pole;

    /**
     * Range: 0..65535 (0..65535 Hz)
     * Scale: 1
     * Offset: 0
     */
    uint16_t logic_freq;

    /**
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t pwm_1;

    /**
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t pwm_2;

    /**
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t pwm_3;

    /**
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t timer_delta;

    /**
     * Range: 0..65535 (0..65.535 mH)
     * Scale: 0.001
     * Offset: 0
     */
    float motor_lsq;

    /**
     * Range: 0..65535 (0..65.535 mH)
     * Scale: 0.001
     * Offset: 0
     */
    float motor_lsd;

    /**
     * Range: -32768..32767 (-32768..32767 %)
     * Scale: 1
     * Offset: 0
     */
    int16_t id_nom;

    /**
     * Range: 0..65535 (0..655.35 mH)
     * Scale: 0.01
     * Offset: 0
     */
    float motor_lm;

    /**
     * Range: 0..65535 (0..65535 mOhm)
     * Scale: 1
     * Offset: 0
     */
    uint16_t motor_rr;

    /**
     * Range: 0..100 (0..100 %)
     * Scale: 1
     * Offset: 0
     */
    int16_t id_min;

    /**
     * Range: -32768..32767 (-32768..32767 ms)
     * Scale: 1
     * Offset: 0
     */
    int16_t motor_tr;

    /**
     * Range: 0..65535 (0..65535 mOhm)
     * Scale: 1
     * Offset: 0
     */
    uint16_t motor_rs;

    /**
     * Range: -32768..32767 (-32.768..32.767 ms)
     * Scale: 0.001
     * Offset: 0
     */
    float motor_ts;

    /**
     * Range: 0..32767 (0..32767 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t def_end_1;

    /**
     * Range: 0..32767 (0..32767 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t def_end_2;

    /**
     * Range: 0..32767 (0..32767 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t def_din_1;

    /**
     * Range: 0..32767 (0..32767 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t def_din_2;

    /**
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t operand194;

    /**
     * Range: -32768..32767 (-4547.16391424..4547.02514581 Arms)
     * Scale: 0.13876843
     * Offset: 0
     */
    float i_max_inuse;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int signal_go : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int signal_brake : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int signal_icns : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int signal_lessn0 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int signal_postolerance : 1;

    /**
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t ain_in_1_scaled251;

    /**
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t ain_in_2_scaled252;

    /**
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t operand195;

    /**
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t operand218;

    /**
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t operand219;

    /**
     * Range: 0..200 (0..200 %)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pid_i__xkp__iq;

    /**
     * Range: 0..65535 (0..6553.5 A or W)
     * Scale: 0.1
     * Offset: 0
     */
    float bat_opr_limit__mot;

    /**
     * Range: 0..200 (0..200 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pid_i__kf__iq;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int dc_current_sens_ena_set : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int cmc__bit0__dc_current_sens_ena : 1;

    /**
     * Range: -32768..32767 (-32768..32767 rpm)
     * Scale: 1
     * Offset: 0
     */
    int16_t n_rpm_maxint;

    /**
     * Range: -2147483648..2147483647 (-2147483648..2147483647 -)
     * Scale: 1
     * Offset: 0
     */
    int32_t var_1;

    /**
     * Range: 0..32767 (0..32767 ms)
     * Scale: 1
     * Offset: 0
     */
    int16_t can_rxtimeout;

    /**
     * Range: -2147483648..2147483647 (-2147483648..2147483647 -)
     * Scale: 1
     * Offset: 0
     */
    int32_t var_2;

    /**
     * Range: -2147483648..2147483647 (-2147483648..2147483647 -)
     * Scale: 1
     * Offset: 0
     */
    int32_t var_3;

    /**
     * Range: -2147483648..2147483647 (-2147483648..2147483647 -)
     * Scale: 1
     * Offset: 0
     */
    int32_t var_4;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dup__bit7_0__dac_source_channel;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int fb_lossofsignal : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int no_hw_fault : 1;

    /**
     * Range: 0..65535 (0..65535 s)
     * Scale: 1
     * Offset: 0
     */
    uint16_t t_peak;

    /**
     * Range: 0..65535 (0..65535 ms)
     * Scale: 1
     * Offset: 0
     */
    uint16_t brake_delay;

    /**
     * Range: -32768..32767 (-32768..32767 W)
     * Scale: 1
     * Offset: 0
     */
    int16_t power;

    /**
     * Range: -32768..32767 (-32768..32767 Joul)
     * Scale: 1
     * Offset: 0
     */
    int16_t work;

    /**
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t extra__start;

    /**
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t capture_channel;

    /**
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t trig_level;

    /**
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t trig_edge;

    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t trig_source;

    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t oszi_source;

    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t oszi_skip;

    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t oszi_run_cmd;

    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t oszi_read_cmd;

    /**
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t pos_ref_start;

    /**
     * Range: 0..65532.05229287863361432703605 (0..2075 V)
     * Scale: 0.03166389465
     * Offset: 0
     */
    float vdc_bus;

    /**
     * Range: -32767..32767 (-32767..32767 Num)
     * Scale: 1
     * Offset: 0
     */
    int16_t m_cmd_ramp;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int lmt_1 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int out_1 : 1;

    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t subversion_nr;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int ballast_ext : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int ncr064 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int err_powerfault : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int lmt2 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int km_speed_0 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int ncr082 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int ecode_bit1__hw1_state99 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int ecode_bit1__hw1_state148 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int dc_i_sensena_set : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int cmc__bit1__idc_limit_ena : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int lmt_2 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int out_2 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int fb_special : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int lim_plus64 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int err_rfe_fault : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int in2 : 1;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cs_ain_2_format;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int km_frg_off : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int lim_plus82 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int ecode_bit2__hw0_state99 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int ecode_bit2__hw0_state148 : 1;

    /**
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t op_mode_quadrant;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int cmc__bit2__pdc_limit_usage : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int in_2 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int rdy155 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int coaststop : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int lim_minus64 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int err_bustimeout : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int in1 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int km_cal_off : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int lim_minus82 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int ecode_bit3__free99 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int ecode_bit3__free148 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int cmc__bit3__torqueval_init_ena : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int in_1 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int go155 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int i_ist_inverse : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int ok64 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int err_feedbacksignal : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int frgrun : 1;

    /**
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cs_ain_1_mode;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int km_tx_tog_stat : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int ok82 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int ecode_bit4__rdy399 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int ecode_bit4__rdy3148 : 1;

    /**
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t compare_var194;

    /**
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t compare_var195;

    /**
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t compare_var218;

    /**
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t compare_var219;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int cmc__bit4__dig_m_rcpramp_ena : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int run152 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int out_3 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int refsoft : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int icns64 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int err_powervoltage_low : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int rfe216 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int km_i_limit : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int icns82 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int ecode_bit5__n_fail99 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int ecode_bit5__n_fail148 : 1;

    /**
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t mo_feedback_2;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int recup_is_acv : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int cmc__bit5__reset_nramp_atnzero : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int rfe152 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int out_4 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int no_uesp_btb : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int tnlim64 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int err_motortemp : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int km_n_clip : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int tnlim82 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int ecode_bit6__flths99 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int ecode_bit6__flths148 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int i_dc_limit_is_acv : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int cmc__bit6__torquetimeout_100ms_e : 1;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t rsvd;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int rsvd1 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int vdc_ana : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int pn64 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int err_devicetemp : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int cs_oora1 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int km_mix_ana_on : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int pn82 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int ecode_bit7__fltls99 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int ecode_bit7__fltls148 : 1;

    /**
     * Range: 0..127 (0..127 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cmc__bit13_7__free;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int brk1155 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int i1_adc_ena : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int ni64 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int err_overvoltage : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int out1 : 1;

    /**
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cs_ain_2_mode;

    /**
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ctrlsubmode;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int km_allow_sync : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int ni82 : 1;

    /**
     * Range: 0..255 (0..127.5 ms)
     * Scale: 0.5
     * Offset: 0
     */
    float ain_in_2_filter;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int ecode_bit8__fail_idc99 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int ecode_bit8__fail_idc148 : 1;

    /**
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t mo_sc1_reso;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t source_id194;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t source_id195;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t source_id218;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t source_id219;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int dup__bit8__can_extended_0 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int hxinv : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int _n064 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int err_ipeak : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int out2 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int km_handwheel : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int _n082 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int ecode_bit9__fail_i99 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int ecode_bit9__fail_i148 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int dup__bit9__generator : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int h2inv : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int rsw64 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int err_raceaway : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int btbrdy : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int km_phasing_extend : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int rsw82 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int ecode_bit10__vccm99 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int ecode_bit10__vccm148 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int dup__bit10__park_rms : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int ol_comp : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int cal064 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int err_user : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int go216 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int cs_oora2 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int km_rsvd_11 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int cal082 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int ecode_bit11__15m_minus99 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int ecode_bit11__15m_minus148 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int mo_sc1_comp : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int dup__bit11__dcbus_volts : 1;

    /**
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t test;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t motortype;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int cal64 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int out3 : 1;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cs_cmd_type;

    /**
     * Range: 0..15 (0..15 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t currentmode;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int km_rsvd_12 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int cal82 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int ecode_bit12__15m_plus99 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int ecode_bit12__15m_plus148 : 1;

    /**
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t mo_sc2_reso;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int dup__bit12__boat_pedal : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int tol64 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int out4 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int km_rsvd_13 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int tol82 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int ecode_bit13__18m_plus99 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int ecode_bit13__18m_plus148 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int dup__bit13__gen_autoiaclimit : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int ana_0up : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int rdy64 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int err_hwerr : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int goff : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int cs_ain_2__i_limit : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int km_pseudo_enable : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int rdy82 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int ecode_bit14__ubmam99 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int ecode_bit14__ubmam148 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int cmc__bit14__idc_limit_ena_v2 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int dup__bit14__mtpa_reluct_enab : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int lowbd : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int brk064 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int err_ballast : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int brk1216 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int cs_ain_1__n_limit : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int km_debug_test : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int brk082 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int ecode_bit15__t_igbt99 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int ecode_bit15__t_igbt148 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int mo_sc2_inv : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int active190 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int active191 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int active192 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int active193 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int gen_autoiaclimit_is_acv : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int cmc__bit15__dig_e_brake_act : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int dup__bit15__canopen_acv : 1;

    /**
     * Range: 0..4000 (0..4000 ms)
     * Scale: 1
     * Offset: 0
     */
    uint16_t m_r_dec;

    /**
     * Range: 0..4000 (0..4000 ms)
     * Scale: 1
     * Offset: 0
     */
    uint16_t m_r_rcp;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int sramp : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int signmag64 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int warn_warning_0 : 1;

    /**
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t ain_in_1_scaled213;

    /**
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t ain_in_2_scaled214;

    /**
     * Range: 0..65535 (0..65535 ms)
     * Scale: 1
     * Offset: 0
     */
    uint16_t t_dc__stop;

    /**
     * Range: -32768..32767 (-3276.8..3276.7 %)
     * Scale: 0.1
     * Offset: 0
     */
    float v_dc__stop;

    /**
     * Range: -32768..32767 (-3276.8..3276.7 %)
     * Scale: 0.1
     * Offset: 0
     */
    float v_min__stop;

    /**
     * Range: -32768..32767 (-3276.8..3276.7 Hz)
     * Scale: 0.1
     * Offset: 0
     */
    float f_min__stop;

    /**
     * Range: -32768..32767 (-3276.8..3276.7 %)
     * Scale: 0.1
     * Offset: 0
     */
    float v_corner__stop;

    /**
     * Range: -32768..32767 (-3276.8..3276.7 Hz)
     * Scale: 0.1
     * Offset: 0
     */
    float f_corner__stop;

    /**
     * Range: 0..200 (0..200 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pid_i__kp__id;

    /**
     * Range: 300..20000 (300..20000 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pid_i__ti__id;

    /**
     * Range: 0..500 (0..500 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pid_i__tim__id;

    /**
     * Range: -32763.904..32763.904 (-7.999..7.999 -)
     * Scale: 0.000244140625
     * Offset: 0
     */
    float ain_in_1_scaleval;

    /**
     * Range: -32768..32767 (-8..7.999755859375 -)
     * Scale: 0.000244140625
     * Offset: 0
     */
    float ain_in_2_scaleval;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int signmag82 : 1;

    /**
     * Range: 0..65535 (0..65535 Ohm)
     * Scale: 1
     * Offset: 0
     */
    uint16_t regen_r;

    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t dc_bus_max_lim;

    /**
     * Range: 0..200 (0..200 %)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pid_i__xkp__id;

    /**
     * Range: 0..65535 (0..6553.5 A or W)
     * Scale: 0.1
     * Offset: 0
     */
    float bat_opr_limit__gen;

    /**
     * Range: 0..200 (0..200 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t pid_i__kf__id;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cmc__bit17_16__checkipeak_config;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int dup__bit16__bamobil3_2_offcrct : 1;

    /**
     * Range: -32768..32767 (-32768..32767 -)
     * Scale: 1
     * Offset: 0
     */
    int16_t special__stop;

    /**
     * Range: -32768..32767 (-32768..32767 Num)
     * Scale: 1
     * Offset: 0
     */
    int16_t free;

    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t svnrevision_nr;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int ramp4 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int nclip64 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int warn_illegal_status : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int nclip82 : 1;

    /**
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dup__bit19_17__ecode_redefine;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int motbrake : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int nclip_minus64 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int warn_safe_in : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int nclip_minus82 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int cmc__bit18__tractioncontrol_ena : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int ac_dc : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int nclip_plus64 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int nclip_plus82 : 1;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cmc__bit20_19__tc_deltatime_conf;

    /**
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t pwm_freq;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int irddig64 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int irddig82 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int dup__bit20__hal_extmr_acv : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int iuserchd64 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int iuserchd82 : 1;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cmc__bit22_21__tc_minspeed_conf;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int dup__bit21__initwith_frg_off : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int irdn64 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int warn_motortemp : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int irdn82 : 1;

    /**
     * Range: 0..1023 (0..1023 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t dup__bit31_22__free;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int ntc : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int irdti64 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int warn_devicetemp : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int irdti82 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int cmc__bit23__tc_ncmdrestoption : 1;

    /**
     * Range: 0..4000 (0..4000 ms)
     * Scale: 1
     * Offset: 0
     */
    uint16_t m_r_acc;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int delta : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int irdtir64 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int warn_vout_sat : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int irdtir82 : 1;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cmc__bit31_24__free;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int dc_1qdirvolt : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int _10hz64 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int warn_ipeak : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int _10hz82 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int dc_field : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int irdtm64 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int warn_raceaway : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int irdtm82 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int dead_2 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int irdana64 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int irdana82 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int block : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int iwcns64 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int iwcns82 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int dc_1qmv : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int rfepulse64 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int rfepulse82 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int dc_1q3p : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int md64 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int md82 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int reducelosses : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int hndwhl64 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int warn_ballast : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int hndwhl82 : 1;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_inverter_r_rcv_converted_t;

/**
 * Signals in message BMS_HV_JMP_TO_BLT.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_bms_hv_jmp_to_blt_t;

/**
 * Signals in message BMS_HV_JMP_TO_BLT.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_bms_hv_jmp_to_blt_converted_t;

/**
 * Signals in message BMS_LV_JMP_TO_BLT.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_bms_lv_jmp_to_blt_t;

/**
 * Signals in message BMS_LV_JMP_TO_BLT.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_bms_lv_jmp_to_blt_converted_t;

/**
 * Signals in message STEER_VERSION.
 *
 * periodic message containing current can definitions version
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t component_version;

    /**
     * Range: 0..4294967295 (0..4294967295 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t canlib_build_time;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_steer_version_t;

/**
 * Signals in message STEER_VERSION.
 *
 * periodic message containing current can definitions version
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t component_version;

    /**
     * Range: 0..4294967295 (0..4294967295 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t canlib_build_time;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_steer_version_converted_t;

/**
 * Signals in message DAS_VERSION.
 *
 * periodic message containing current can definitions version
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t component_version;

    /**
     * Range: 0..4294967295 (0..4294967295 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t canlib_build_time;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_das_version_t;

/**
 * Signals in message DAS_VERSION.
 *
 * periodic message containing current can definitions version
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t component_version;

    /**
     * Range: 0..4294967295 (0..4294967295 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t canlib_build_time;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_das_version_converted_t;

/**
 * Signals in message HV_VERSION.
 *
 * periodic message containing current can definitions version
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t component_version;

    /**
     * Range: 0..4294967295 (0..4294967295 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t canlib_build_time;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_version_t;

/**
 * Signals in message HV_VERSION.
 *
 * periodic message containing current can definitions version
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t component_version;

    /**
     * Range: 0..4294967295 (0..4294967295 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t canlib_build_time;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_version_converted_t;

/**
 * Signals in message LV_VERSION.
 *
 * periodic message containing current can definitions version
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t component_version;

    /**
     * Range: 0..4294967295 (0..4294967295 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t canlib_build_time;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_lv_version_t;

/**
 * Signals in message LV_VERSION.
 *
 * periodic message containing current can definitions version
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t component_version;

    /**
     * Range: 0..4294967295 (0..4294967295 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t canlib_build_time;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_lv_version_converted_t;

/**
 * Signals in message TLM_VERSION.
 *
 * periodic message containing current can definitions version
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t component_version;

    /**
     * Range: 0..4294967295 (0..4294967295 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t canlib_build_time;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_tlm_version_t;

/**
 * Signals in message TLM_VERSION.
 *
 * periodic message containing current can definitions version
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t component_version;

    /**
     * Range: 0..4294967295 (0..4294967295 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t canlib_build_time;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_tlm_version_converted_t;

/**
 * Signals in message TIMESTAMP.
 *
 * every second unix encoded time and date used by logging devices to sync
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..4294967295 (0..4294967295 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t timestamp;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_timestamp_t;

/**
 * Signals in message TIMESTAMP.
 *
 * every second unix encoded time and date used by logging devices to sync
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..4294967295 (0..4294967295 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t timestamp;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_timestamp_converted_t;

/**
 * Signals in message AMBIENT_TEMPERATURE.
 *
 * ambient temperature as send from IMU
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (-32768..32767 -)
     * Scale: 1
     * Offset: -32768
     */
    int16_t temp;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_ambient_temperature_t;

/**
 * Signals in message AMBIENT_TEMPERATURE.
 *
 * ambient temperature as send from IMU
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (-32768..32767 -)
     * Scale: 1
     * Offset: -32768
     */
    int16_t temp;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_ambient_temperature_converted_t;

/**
 * Signals in message DATA_LOGGER.
 *
 * data logger message
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..4294967295 (0..4294967295 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t placeholder1;

    /**
     * Range: 0..4294967295 (0..4294967295 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t placeholder2;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_data_logger_t;

/**
 * Signals in message DATA_LOGGER.
 *
 * data logger message
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..4294967295 (0..4294967295 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t placeholder1;

    /**
     * Range: 0..4294967295 (0..4294967295 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t placeholder2;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_data_logger_converted_t;

/**
 * Signals in message SET_TLM_STATUS.
 *
 * Ask telemetry to turn on/off and send a tuple containing the current{test, driver, map); only once
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_set_tlm_status_tlm_status tlm_status;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_set_tlm_status_t;

/**
 * Signals in message SET_TLM_STATUS.
 *
 * Ask telemetry to turn on/off and send a tuple containing the current{test, driver, map); only once
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_set_tlm_status_tlm_status tlm_status;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_set_tlm_status_converted_t;

/**
 * Signals in message TLM_STATUS.
 *
 * The answer to the steering wheel's message that changes the status of the telemetry
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_tlm_status_tlm_status tlm_status;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_tlm_status_t;

/**
 * Signals in message TLM_STATUS.
 *
 * The answer to the steering wheel's message that changes the status of the telemetry
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_tlm_status_tlm_status tlm_status;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_tlm_status_converted_t;

/**
 * Signals in message STEER_SYSTEM_STATUS.
 *
 * System stats of the raspberry pi inside the steering wheel
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t soc_temp;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_steer_system_status_t;

/**
 * Signals in message STEER_SYSTEM_STATUS.
 *
 * System stats of the raspberry pi inside the steering wheel
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t soc_temp;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_steer_system_status_converted_t;

/**
 * Signals in message HV_VOLTAGE.
 *
 * Pack stats
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (0..460 -)
     * Scale: 0.007019150072480354
     * Offset: 0
     */
    uint32_t pack_voltage;

    /**
     * Range: 0..65535 (0..460 -)
     * Scale: 0.007019150072480354
     * Offset: 0
     */
    uint32_t bus_voltage;

    /**
     * Range: 0..7 (0..5 -)
     * Scale: 0.7142857142857143
     * Offset: 0
     */
    uint8_t max_cell_voltage;

    /**
     * Range: 0..7 (0..5 -)
     * Scale: 0.7142857142857143
     * Offset: 0
     */
    uint8_t min_cell_voltage;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_voltage_t;

/**
 * Signals in message HV_VOLTAGE.
 *
 * Pack stats
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (0..460 -)
     * Scale: 0.007019150072480354
     * Offset: 0
     */
    float pack_voltage;

    /**
     * Range: 0..65535 (0..460 -)
     * Scale: 0.007019150072480354
     * Offset: 0
     */
    float bus_voltage;

    /**
     * Range: 0..7 (0..5 -)
     * Scale: 0.7142857142857143
     * Offset: 0
     */
    float max_cell_voltage;

    /**
     * Range: 0..7 (0..5 -)
     * Scale: 0.7142857142857143
     * Offset: 0
     */
    float min_cell_voltage;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_voltage_converted_t;

/**
 * Signals in message HV_CURRENT.
 *
 * Current and power supplied by the pack, energy and state of charge of the pack
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (-10..200 -)
     * Scale: 0.0032043945983062485
     * Offset: -10
     */
    uint32_t current;

    /**
     * Range: 0..65535 (0..100 -)
     * Scale: 0.0015259021896696422
     * Offset: 0
     */
    uint32_t power;

    /**
     * Range: 0..65535 (0..7000 -)
     * Scale: 0.10681315327687495
     * Offset: 0
     */
    uint32_t energy;

    /**
     * Range: 0..255 (0..100 -)
     * Scale: 0.39215686274509803
     * Offset: 0
     */
    uint16_t soc;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_current_t;

/**
 * Signals in message HV_CURRENT.
 *
 * Current and power supplied by the pack, energy and state of charge of the pack
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (-10..200 -)
     * Scale: 0.0032043945983062485
     * Offset: -10
     */
    float current;

    /**
     * Range: 0..65535 (0..100 -)
     * Scale: 0.0015259021896696422
     * Offset: 0
     */
    float power;

    /**
     * Range: 0..65535 (0..7000 -)
     * Scale: 0.10681315327687495
     * Offset: 0
     */
    float energy;

    /**
     * Range: 0..255 (0..100 -)
     * Scale: 0.39215686274509803
     * Offset: 0
     */
    float soc;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_current_converted_t;

/**
 * Signals in message HV_TEMP.
 *
 * Cell temperatures
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..255 (-20..80 -)
     * Scale: 0.39215686274509803
     * Offset: -20
     */
    uint16_t average_temp;

    /**
     * Range: 0..255 (-20..80 -)
     * Scale: 0.39215686274509803
     * Offset: -20
     */
    uint16_t max_temp;

    /**
     * Range: 0..255 (-20..80 -)
     * Scale: 0.39215686274509803
     * Offset: -20
     */
    uint16_t min_temp;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_temp_t;

/**
 * Signals in message HV_TEMP.
 *
 * Cell temperatures
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..255 (-20..80 -)
     * Scale: 0.39215686274509803
     * Offset: -20
     */
    float average_temp;

    /**
     * Range: 0..255 (-20..80 -)
     * Scale: 0.39215686274509803
     * Offset: -20
     */
    float max_temp;

    /**
     * Range: 0..255 (-20..80 -)
     * Scale: 0.39215686274509803
     * Offset: -20
     */
    float min_temp;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_temp_converted_t;

/**
 * Signals in message HV_ERRORS.
 *
 * Battery-related errors
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t warnings_cell_low_voltage;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t warnings_cell_under_voltage;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t warnings_cell_over_voltage;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t warnings_cell_high_temperature;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t warnings_cell_over_temperature;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t warnings_over_current;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t warnings_can;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t warnings_int_voltage_mismatch;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t warnings_cellboard_comm;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t warnings_cellboard_internal;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t warnings_feedback;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t warnings_feedback_circuitry;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t warnings_eeprom_comm;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t warnings_eeprom_write;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_cell_low_voltage;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_cell_under_voltage;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_cell_over_voltage;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_cell_high_temperature;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_cell_over_temperature;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_over_current;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_can;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_int_voltage_mismatch;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_cellboard_comm;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_cellboard_internal;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_feedback;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_feedback_circuitry;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_eeprom_comm;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_eeprom_write;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_errors_t;

/**
 * Signals in message HV_ERRORS.
 *
 * Battery-related errors
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int warnings_cell_low_voltage : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int warnings_cell_under_voltage : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int warnings_cell_over_voltage : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int warnings_cell_high_temperature : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int warnings_cell_over_temperature : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int warnings_over_current : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int warnings_can : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int warnings_int_voltage_mismatch : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int warnings_cellboard_comm : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int warnings_cellboard_internal : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int warnings_feedback : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int warnings_feedback_circuitry : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int warnings_eeprom_comm : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int warnings_eeprom_write : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_cell_low_voltage : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_cell_under_voltage : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_cell_over_voltage : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_cell_high_temperature : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_cell_over_temperature : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_over_current : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_can : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_int_voltage_mismatch : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_cellboard_comm : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_cellboard_internal : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_feedback : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_feedback_circuitry : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_eeprom_comm : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_eeprom_write : 1;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_errors_converted_t;

/**
 * Signals in message HV_CAN_FORWARD.
 *
 * Enable/disable can forwarding to internal bms network
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_hv_can_forward_can_forward_set can_forward_set;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_can_forward_t;

/**
 * Signals in message HV_CAN_FORWARD.
 *
 * Enable/disable can forwarding to internal bms network
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_hv_can_forward_can_forward_set can_forward_set;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_can_forward_converted_t;

/**
 * Signals in message HV_FANS_OVERRIDE.
 *
 * override fans speed
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_hv_fans_override_fans_override fans_override;

    /**
     * Range: 0..65535 (0..1 -)
     * Scale: 1.5259021896696422e-05
     * Offset: 0
     */
    uint32_t fans_speed;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_fans_override_t;

/**
 * Signals in message HV_FANS_OVERRIDE.
 *
 * override fans speed
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_hv_fans_override_fans_override fans_override;

    /**
     * Range: 0..65535 (0..1 -)
     * Scale: 1.5259021896696422e-05
     * Offset: 0
     */
    float fans_speed;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_fans_override_converted_t;

/**
 * Signals in message HV_CAN_FORWARD_STATUS.
 *
 * Status of can forwarding to internal bms network
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_hv_can_forward_status_can_forward_status can_forward_status;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_can_forward_status_t;

/**
 * Signals in message HV_CAN_FORWARD_STATUS.
 *
 * Status of can forwarding to internal bms network
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_hv_can_forward_status_can_forward_status can_forward_status;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_can_forward_status_converted_t;

/**
 * Signals in message HV_FANS_OVERRIDE_STATUS.
 *
 * Status of fans override
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_hv_fans_override_status_fans_override fans_override;

    /**
     * Range: 0..65535 (0..1 -)
     * Scale: 1.5259021896696422e-05
     * Offset: 0
     */
    uint32_t fans_speed;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_fans_override_status_t;

/**
 * Signals in message HV_FANS_OVERRIDE_STATUS.
 *
 * Status of fans override
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_hv_fans_override_status_fans_override fans_override;

    /**
     * Range: 0..65535 (0..1 -)
     * Scale: 1.5259021896696422e-05
     * Offset: 0
     */
    float fans_speed;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_fans_override_status_converted_t;

/**
 * Signals in message HV_FEEDBACKS_STATUS.
 *
 * Errors on the feedbacks checks
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t feedbacks_status_feedback_tsal_green_fault;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t feedbacks_status_feedback_imd_latched;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t feedbacks_status_feedback_tsal_green_fault_latched;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t feedbacks_status_feedback_bms_latched;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t feedbacks_status_feedback_ext_latched;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t feedbacks_status_feedback_tsal_green;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t feedbacks_status_feedback_ts_over_60v_status;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t feedbacks_status_feedback_airn_status;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t feedbacks_status_feedback_airp_status;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t feedbacks_status_feedback_airp_gate;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t feedbacks_status_feedback_airn_gate;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t feedbacks_status_feedback_precharge_status;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t feedbacks_status_feedback_tsp_over_60v_status;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t feedbacks_status_feedback_check_mux;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t feedbacks_status_feedback_sd_in;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t feedbacks_status_feedback_sd_out;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t feedbacks_status_feedback_relay_sd;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t feedbacks_status_feedback_imd_fault;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t feedbacks_status_feedback_sd_end;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t is_circuitry_error_feedback_tsal_green_fault;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t is_circuitry_error_feedback_imd_latched;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t is_circuitry_error_feedback_tsal_green_fault_latched;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t is_circuitry_error_feedback_bms_latched;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t is_circuitry_error_feedback_ext_latched;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t is_circuitry_error_feedback_tsal_green;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t is_circuitry_error_feedback_ts_over_60v_status;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t is_circuitry_error_feedback_airn_status;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t is_circuitry_error_feedback_airp_status;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t is_circuitry_error_feedback_airp_gate;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t is_circuitry_error_feedback_airn_gate;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t is_circuitry_error_feedback_precharge_status;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t is_circuitry_error_feedback_tsp_over_60v_status;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t is_circuitry_error_feedback_check_mux;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t is_circuitry_error_feedback_sd_in;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t is_circuitry_error_feedback_sd_out;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t is_circuitry_error_feedback_relay_sd;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t is_circuitry_error_feedback_imd_fault;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t is_circuitry_error_feedback_sd_end;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_feedbacks_status_t;

/**
 * Signals in message HV_FEEDBACKS_STATUS.
 *
 * Errors on the feedbacks checks
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int feedbacks_status_feedback_tsal_green_fault : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int feedbacks_status_feedback_imd_latched : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int feedbacks_status_feedback_tsal_green_fault_latched : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int feedbacks_status_feedback_bms_latched : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int feedbacks_status_feedback_ext_latched : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int feedbacks_status_feedback_tsal_green : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int feedbacks_status_feedback_ts_over_60v_status : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int feedbacks_status_feedback_airn_status : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int feedbacks_status_feedback_airp_status : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int feedbacks_status_feedback_airp_gate : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int feedbacks_status_feedback_airn_gate : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int feedbacks_status_feedback_precharge_status : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int feedbacks_status_feedback_tsp_over_60v_status : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int feedbacks_status_feedback_check_mux : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int feedbacks_status_feedback_sd_in : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int feedbacks_status_feedback_sd_out : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int feedbacks_status_feedback_relay_sd : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int feedbacks_status_feedback_imd_fault : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int feedbacks_status_feedback_sd_end : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int is_circuitry_error_feedback_tsal_green_fault : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int is_circuitry_error_feedback_imd_latched : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int is_circuitry_error_feedback_tsal_green_fault_latched : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int is_circuitry_error_feedback_bms_latched : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int is_circuitry_error_feedback_ext_latched : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int is_circuitry_error_feedback_tsal_green : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int is_circuitry_error_feedback_ts_over_60v_status : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int is_circuitry_error_feedback_airn_status : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int is_circuitry_error_feedback_airp_status : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int is_circuitry_error_feedback_airp_gate : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int is_circuitry_error_feedback_airn_gate : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int is_circuitry_error_feedback_precharge_status : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int is_circuitry_error_feedback_tsp_over_60v_status : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int is_circuitry_error_feedback_check_mux : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int is_circuitry_error_feedback_sd_in : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int is_circuitry_error_feedback_sd_out : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int is_circuitry_error_feedback_relay_sd : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int is_circuitry_error_feedback_imd_fault : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int is_circuitry_error_feedback_sd_end : 1;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_feedbacks_status_converted_t;

/**
 * Signals in message HV_IMD_STATUS.
 *
 * Status of fans override
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t imd_fault;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_hv_imd_status_imd_status imd_status;

    /**
     * Range: 0..4294967295 (-2147483648..2147483647 -)
     * Scale: 1
     * Offset: -2147483648
     */
    int32_t imd_info;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_imd_status_t;

/**
 * Signals in message HV_IMD_STATUS.
 *
 * Status of fans override
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int imd_fault : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_hv_imd_status_imd_status imd_status;

    /**
     * Range: 0..4294967295 (-2147483648..2147483647 -)
     * Scale: 1
     * Offset: -2147483648
     */
    int32_t imd_info;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_imd_status_converted_t;

/**
 * Signals in message TS_STATUS_DAS.
 *
 * BMS status
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_ts_status_das_ts_status ts_status;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_ts_status_das_t;

/**
 * Signals in message TS_STATUS_DAS.
 *
 * BMS status
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_ts_status_das_ts_status ts_status;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_ts_status_das_converted_t;

/**
 * Signals in message TS_STATUS_STEER.
 *
 * BMS status
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_ts_status_steer_ts_status ts_status;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_ts_status_steer_t;

/**
 * Signals in message TS_STATUS_STEER.
 *
 * BMS status
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_ts_status_steer_ts_status ts_status;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_ts_status_steer_converted_t;

/**
 * Signals in message TS_STATUS_HANDCART.
 *
 * BMS status
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_ts_status_handcart_ts_status ts_status;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_ts_status_handcart_t;

/**
 * Signals in message TS_STATUS_HANDCART.
 *
 * BMS status
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_ts_status_handcart_ts_status ts_status;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_ts_status_handcart_converted_t;

/**
 * Signals in message SET_TS_STATUS_DAS.
 *
 * Requests a TS status; only once
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_set_ts_status_das_ts_status_set ts_status_set;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_set_ts_status_das_t;

/**
 * Signals in message SET_TS_STATUS_DAS.
 *
 * Requests a TS status; only once
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_set_ts_status_das_ts_status_set ts_status_set;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_set_ts_status_das_converted_t;

/**
 * Signals in message SET_TS_STATUS_HANDCART.
 *
 * Requests a TS status; only once
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_set_ts_status_handcart_ts_status_set ts_status_set;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_set_ts_status_handcart_t;

/**
 * Signals in message SET_TS_STATUS_HANDCART.
 *
 * Requests a TS status; only once
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_set_ts_status_handcart_ts_status_set ts_status_set;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_set_ts_status_handcart_converted_t;

/**
 * Signals in message STEER_STATUS.
 *
 * Send update of the tuneable values from the steering wheel
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (-0.5..1 -)
     * Scale: 1.5
     * Offset: -0.5
     */
    uint8_t map_pw;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1.0
     * Offset: 0
     */
    uint8_t map_sc;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1.0
     * Offset: 0
     */
    uint8_t map_tv;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_steer_status_t;

/**
 * Signals in message STEER_STATUS.
 *
 * Send update of the tuneable values from the steering wheel
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (-0.5..1 -)
     * Scale: 1.5
     * Offset: -0.5
     */
    float map_pw;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1.0
     * Offset: 0
     */
    uint8_t map_sc;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1.0
     * Offset: 0
     */
    uint8_t map_tv;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_steer_status_converted_t;

/**
 * Signals in message SET_CAR_STATUS.
 *
 * Ask to DAS to change car status; only once
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_set_car_status_car_status_set car_status_set;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_set_car_status_t;

/**
 * Signals in message SET_CAR_STATUS.
 *
 * Ask to DAS to change car status; only once
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_set_car_status_car_status_set car_status_set;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_set_car_status_converted_t;

/**
 * Signals in message SET_PEDALS_RANGE.
 *
 * Ask to calibrate pedals by specifying which pedal to calibrate and if the value is max or min
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_set_pedals_range_bound bound;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_set_pedals_range_pedal pedal;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_set_pedals_range_t;

/**
 * Signals in message SET_PEDALS_RANGE.
 *
 * Ask to calibrate pedals by specifying which pedal to calibrate and if the value is max or min
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_set_pedals_range_bound bound;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_set_pedals_range_pedal pedal;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_set_pedals_range_converted_t;

/**
 * Signals in message SET_STEERING_ANGLE_RANGE.
 *
 * Ask to calibrate steering encoder by specifying if the value is max or min
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_set_steering_angle_range_bound bound;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_set_steering_angle_range_t;

/**
 * Signals in message SET_STEERING_ANGLE_RANGE.
 *
 * Ask to calibrate steering encoder by specifying if the value is max or min
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_set_steering_angle_range_bound bound;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_set_steering_angle_range_converted_t;

/**
 * Signals in message CAR_STATUS.
 *
 * Car status, all states managed by the DAS will be send (car status, inverters status)
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_car_status_inverter_l inverter_l;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_car_status_inverter_r inverter_r;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_car_status_car_status car_status;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_car_status_t;

/**
 * Signals in message CAR_STATUS.
 *
 * Car status, all states managed by the DAS will be send (car status, inverters status)
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_car_status_inverter_l inverter_l;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_car_status_inverter_r inverter_r;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_car_status_car_status car_status;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_car_status_converted_t;

/**
 * Signals in message DAS_ERRORS.
 *
 * DAS errors messages
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t das_error_pedal_adc;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t das_error_pedal_implausibility;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t das_error_imu_tout;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t das_error_irts_tout;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t das_error_ts_tout;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t das_error_invl_tout;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t das_error_invr_tout;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t das_error_steer_tout;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t das_error_fsm;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_das_errors_t;

/**
 * Signals in message DAS_ERRORS.
 *
 * DAS errors messages
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int das_error_pedal_adc : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int das_error_pedal_implausibility : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int das_error_imu_tout : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int das_error_irts_tout : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int das_error_ts_tout : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int das_error_invl_tout : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int das_error_invr_tout : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int das_error_steer_tout : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int das_error_fsm : 1;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_das_errors_converted_t;

/**
 * Signals in message LV_CURRENT.
 *
 * Current of LV battery pack: total current taken from the battery itself
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (-10..50 -)
     * Scale: 0.0009155413138017853
     * Offset: -10
     */
    uint32_t current;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_lv_current_t;

/**
 * Signals in message LV_CURRENT.
 *
 * Current of LV battery pack: total current taken from the battery itself
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (-10..50 -)
     * Scale: 0.0009155413138017853
     * Offset: -10
     */
    float current;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_lv_current_converted_t;

/**
 * Signals in message LV_VOLTAGE.
 *
 * Voltages of LV battery pack: 4x single cell voltage 8bit [3.3,4.2]V 0.005mV/bit (no additional info, 0x000 is 3V 0xFFFF is 4.2V)
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..7 (0..5 -)
     * Scale: 0.7142857142857143
     * Offset: 0
     */
    uint8_t voltage_1;

    /**
     * Range: 0..7 (0..5 -)
     * Scale: 0.7142857142857143
     * Offset: 0
     */
    uint8_t voltage_2;

    /**
     * Range: 0..7 (0..5 -)
     * Scale: 0.7142857142857143
     * Offset: 0
     */
    uint8_t voltage_3;

    /**
     * Range: 0..7 (0..5 -)
     * Scale: 0.7142857142857143
     * Offset: 0
     */
    uint8_t voltage_4;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_lv_voltage_t;

/**
 * Signals in message LV_VOLTAGE.
 *
 * Voltages of LV battery pack: 4x single cell voltage 8bit [3.3,4.2]V 0.005mV/bit (no additional info, 0x000 is 3V 0xFFFF is 4.2V)
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..7 (0..5 -)
     * Scale: 0.7142857142857143
     * Offset: 0
     */
    float voltage_1;

    /**
     * Range: 0..7 (0..5 -)
     * Scale: 0.7142857142857143
     * Offset: 0
     */
    float voltage_2;

    /**
     * Range: 0..7 (0..5 -)
     * Scale: 0.7142857142857143
     * Offset: 0
     */
    float voltage_3;

    /**
     * Range: 0..7 (0..5 -)
     * Scale: 0.7142857142857143
     * Offset: 0
     */
    float voltage_4;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_lv_voltage_converted_t;

/**
 * Signals in message LV_TOTAL_VOLTAGE.
 *
 * Voltage of LV battery pack: total voltage 16 bit [12,17.2]V (0x0000 under_voltage,0xFFFF over_voltage
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..7 (0..16 -)
     * Scale: 2.2857142857142856
     * Offset: 0
     */
    uint8_t total_voltage;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_lv_total_voltage_t;

/**
 * Signals in message LV_TOTAL_VOLTAGE.
 *
 * Voltage of LV battery pack: total voltage 16 bit [12,17.2]V (0x0000 under_voltage,0xFFFF over_voltage
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..7 (0..16 -)
     * Scale: 2.2857142857142856
     * Offset: 0
     */
    float total_voltage;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_lv_total_voltage_converted_t;

/**
 * Signals in message LV_TEMPERATURE.
 *
 * Temperature of LV battery pack (two sensors),[-20,80] Celsius. Temperature of dcdc12V and dcdc24V converter
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (-20..80 -)
     * Scale: 0.0015259021896696422
     * Offset: -20
     */
    uint32_t bp_temperature_1;

    /**
     * Range: 0..65535 (-20..80 -)
     * Scale: 0.0015259021896696422
     * Offset: -20
     */
    uint32_t bp_temperature_2;

    /**
     * Range: 0..65535 (-20..80 -)
     * Scale: 0.0015259021896696422
     * Offset: -20
     */
    uint32_t dcdc12_temperature;

    /**
     * Range: 0..65535 (-20..80 -)
     * Scale: 0.0015259021896696422
     * Offset: -20
     */
    uint32_t dcdc24_temperature;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_lv_temperature_t;

/**
 * Signals in message LV_TEMPERATURE.
 *
 * Temperature of LV battery pack (two sensors),[-20,80] Celsius. Temperature of dcdc12V and dcdc24V converter
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (-20..80 -)
     * Scale: 0.0015259021896696422
     * Offset: -20
     */
    float bp_temperature_1;

    /**
     * Range: 0..65535 (-20..80 -)
     * Scale: 0.0015259021896696422
     * Offset: -20
     */
    float bp_temperature_2;

    /**
     * Range: 0..65535 (-20..80 -)
     * Scale: 0.0015259021896696422
     * Offset: -20
     */
    float dcdc12_temperature;

    /**
     * Range: 0..65535 (-20..80 -)
     * Scale: 0.0015259021896696422
     * Offset: -20
     */
    float dcdc24_temperature;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_lv_temperature_converted_t;

/**
 * Signals in message COOLING_STATUS.
 *
 * Percentage value from 0% to 100% of radiator fans and pumps speed, 8bit
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (-1..1 -)
     * Scale: 3.0518043793392844e-05
     * Offset: -1
     */
    uint32_t radiators_speed;

    /**
     * Range: 0..65535 (-1..1 -)
     * Scale: 3.0518043793392844e-05
     * Offset: -1
     */
    uint32_t pumps_speed;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_cooling_status_t;

/**
 * Signals in message COOLING_STATUS.
 *
 * Percentage value from 0% to 100% of radiator fans and pumps speed, 8bit
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (-1..1 -)
     * Scale: 3.0518043793392844e-05
     * Offset: -1
     */
    float radiators_speed;

    /**
     * Range: 0..65535 (-1..1 -)
     * Scale: 3.0518043793392844e-05
     * Offset: -1
     */
    float pumps_speed;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_cooling_status_converted_t;

/**
 * Signals in message SET_RADIATOR_SPEED.
 *
 * Set both radiators speed
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (-1..1 -)
     * Scale: 3.0518043793392844e-05
     * Offset: -1
     */
    uint32_t radiators_speed;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_set_radiator_speed_t;

/**
 * Signals in message SET_RADIATOR_SPEED.
 *
 * Set both radiators speed
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (-1..1 -)
     * Scale: 3.0518043793392844e-05
     * Offset: -1
     */
    float radiators_speed;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_set_radiator_speed_converted_t;

/**
 * Signals in message SET_PUMPS_SPEED.
 *
 * Set both pumps speed
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (-1..1 -)
     * Scale: 3.0518043793392844e-05
     * Offset: -1
     */
    uint32_t pumps_speed;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_set_pumps_speed_t;

/**
 * Signals in message SET_PUMPS_SPEED.
 *
 * Set both pumps speed
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (-1..1 -)
     * Scale: 3.0518043793392844e-05
     * Offset: -1
     */
    float pumps_speed;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_set_pumps_speed_converted_t;

/**
 * Signals in message SET_INVERTER_CONNECTION_STATUS.
 *
 * Set the status of the inverter inputs RFE and RUN
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_set_inverter_connection_status_status status;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_set_inverter_connection_status_t;

/**
 * Signals in message SET_INVERTER_CONNECTION_STATUS.
 *
 * Set the status of the inverter inputs RFE and RUN
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_set_inverter_connection_status_status status;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_set_inverter_connection_status_converted_t;

/**
 * Signals in message INVERTER_CONNECTION_STATUS.
 *
 * Inverter status
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_connection_status_status status;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_inverter_connection_status_t;

/**
 * Signals in message INVERTER_CONNECTION_STATUS.
 *
 * Inverter status
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_connection_status_status status;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_inverter_connection_status_converted_t;

/**
 * Signals in message LV_ERRORS.
 *
 * LV Battery-related errors
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t warnings_cell_undervoltage;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t warnings_cell_overvoltage;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t warnings_open_wire;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t warnings_can;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t warnings_spi;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t warnings_over_current;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t warnings_dcdc12_under_temperature;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t warnings_dcdc12_over_temperature;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t warnings_dcdc24_under_temperature;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t warnings_dcdc24_over_temperature;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t warnings_cell_under_temperature;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t warnings_cell_over_temperature;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t warnings_relay;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t warnings_ltc6810;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t warnings_voltages_not_ready;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t warnings_mcp23017;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t warnings_radiator;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t warnings_fan;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t warnings_pump;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t warnings_adc_init;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t warnings_dcdc12;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t warnings_dcdc24;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_cell_undervoltage;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_cell_overvoltage;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_open_wire;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_can;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_spi;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_over_current;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_dcdc12_under_temperature;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_dcdc12_over_temperature;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_dcdc24_under_temperature;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_dcdc24_over_temperature;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_cell_under_temperature;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_cell_over_temperature;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_relay;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_ltc6810;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_voltages_not_ready;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_mcp23017;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_radiator;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_fan;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_pump;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_adc_init;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_dcdc12;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_dcdc24;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_lv_errors_t;

/**
 * Signals in message LV_ERRORS.
 *
 * LV Battery-related errors
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int warnings_cell_undervoltage : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int warnings_cell_overvoltage : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int warnings_open_wire : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int warnings_can : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int warnings_spi : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int warnings_over_current : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int warnings_dcdc12_under_temperature : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int warnings_dcdc12_over_temperature : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int warnings_dcdc24_under_temperature : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int warnings_dcdc24_over_temperature : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int warnings_cell_under_temperature : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int warnings_cell_over_temperature : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int warnings_relay : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int warnings_ltc6810 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int warnings_voltages_not_ready : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int warnings_mcp23017 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int warnings_radiator : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int warnings_fan : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int warnings_pump : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int warnings_adc_init : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int warnings_dcdc12 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int warnings_dcdc24 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_cell_undervoltage : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_cell_overvoltage : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_open_wire : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_can : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_spi : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_over_current : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_dcdc12_under_temperature : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_dcdc12_over_temperature : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_dcdc24_under_temperature : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_dcdc24_over_temperature : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_cell_under_temperature : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_cell_over_temperature : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_relay : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_ltc6810 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_voltages_not_ready : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_mcp23017 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_radiator : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_fan : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_pump : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_adc_init : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_dcdc12 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_dcdc24 : 1;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_lv_errors_converted_t;

/**
 * Signals in message SHUTDOWN_STATUS.
 *
 * Shutdown status
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t input;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t output;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_shutdown_status_t;

/**
 * Signals in message SHUTDOWN_STATUS.
 *
 * Shutdown status
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int input : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int output : 1;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_shutdown_status_converted_t;

/**
 * Signals in message MARKER.
 *
 * Send a marker to telemetry
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_marker_t;

/**
 * Signals in message MARKER.
 *
 * Send a marker to telemetry
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_marker_converted_t;

/**
 * Signals in message HV_CELLS_VOLTAGE.
 *
 * Voltages for each cell
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t start_index;

    /**
     * Range: 0..7 (0..5 -)
     * Scale: 0.7142857142857143
     * Offset: 0
     */
    uint8_t voltage_0;

    /**
     * Range: 0..7 (0..5 -)
     * Scale: 0.7142857142857143
     * Offset: 0
     */
    uint8_t voltage_1;

    /**
     * Range: 0..7 (0..5 -)
     * Scale: 0.7142857142857143
     * Offset: 0
     */
    uint8_t voltage_2;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_cells_voltage_t;

/**
 * Signals in message HV_CELLS_VOLTAGE.
 *
 * Voltages for each cell
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t start_index;

    /**
     * Range: 0..7 (0..5 -)
     * Scale: 0.7142857142857143
     * Offset: 0
     */
    float voltage_0;

    /**
     * Range: 0..7 (0..5 -)
     * Scale: 0.7142857142857143
     * Offset: 0
     */
    float voltage_1;

    /**
     * Range: 0..7 (0..5 -)
     * Scale: 0.7142857142857143
     * Offset: 0
     */
    float voltage_2;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_cells_voltage_converted_t;

/**
 * Signals in message HV_CELLS_TEMP.
 *
 * Cell temperatures
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t start_index;

    /**
     * Range: 0..255 (-20..80 -)
     * Scale: 0.39215686274509803
     * Offset: -20
     */
    uint16_t temp_0;

    /**
     * Range: 0..255 (-20..80 -)
     * Scale: 0.39215686274509803
     * Offset: -20
     */
    uint16_t temp_1;

    /**
     * Range: 0..255 (-20..80 -)
     * Scale: 0.39215686274509803
     * Offset: -20
     */
    uint16_t temp_2;

    /**
     * Range: 0..255 (-20..80 -)
     * Scale: 0.39215686274509803
     * Offset: -20
     */
    uint16_t temp_3;

    /**
     * Range: 0..255 (-20..80 -)
     * Scale: 0.39215686274509803
     * Offset: -20
     */
    uint16_t temp_4;

    /**
     * Range: 0..255 (-20..80 -)
     * Scale: 0.39215686274509803
     * Offset: -20
     */
    uint16_t temp_5;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_cells_temp_t;

/**
 * Signals in message HV_CELLS_TEMP.
 *
 * Cell temperatures
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t start_index;

    /**
     * Range: 0..255 (-20..80 -)
     * Scale: 0.39215686274509803
     * Offset: -20
     */
    float temp_0;

    /**
     * Range: 0..255 (-20..80 -)
     * Scale: 0.39215686274509803
     * Offset: -20
     */
    float temp_1;

    /**
     * Range: 0..255 (-20..80 -)
     * Scale: 0.39215686274509803
     * Offset: -20
     */
    float temp_2;

    /**
     * Range: 0..255 (-20..80 -)
     * Scale: 0.39215686274509803
     * Offset: -20
     */
    float temp_3;

    /**
     * Range: 0..255 (-20..80 -)
     * Scale: 0.39215686274509803
     * Offset: -20
     */
    float temp_4;

    /**
     * Range: 0..255 (-20..80 -)
     * Scale: 0.39215686274509803
     * Offset: -20
     */
    float temp_5;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_cells_temp_converted_t;

/**
 * Signals in message HV_CELL_BALANCING_STATUS.
 *
 * Cell balancing status
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_hv_cell_balancing_status_balancing_status balancing_status;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_cell_balancing_status_t;

/**
 * Signals in message HV_CELL_BALANCING_STATUS.
 *
 * Cell balancing status
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_hv_cell_balancing_status_balancing_status balancing_status;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_cell_balancing_status_converted_t;

/**
 * Signals in message SET_CELL_BALANCING_STATUS.
 *
 * Set cell balancing status; only once
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_set_cell_balancing_status_set_balancing_status set_balancing_status;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_set_cell_balancing_status_t;

/**
 * Signals in message SET_CELL_BALANCING_STATUS.
 *
 * Set cell balancing status; only once
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_set_cell_balancing_status_set_balancing_status set_balancing_status;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_set_cell_balancing_status_converted_t;

/**
 * Signals in message HANDCART_STATUS.
 *
 * Sends updates on the presence of the handcart
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t connected;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_handcart_status_t;

/**
 * Signals in message HANDCART_STATUS.
 *
 * Sends updates on the presence of the handcart
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int connected : 1;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_handcart_status_converted_t;

/**
 * Signals in message SPEED.
 *
 * Encoder and inverter speed in rad/sec
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (-200..200 -)
     * Scale: 0.006103608758678569
     * Offset: -200
     */
    uint32_t encoder_r;

    /**
     * Range: 0..65535 (-200..200 -)
     * Scale: 0.006103608758678569
     * Offset: -200
     */
    uint32_t encoder_l;

    /**
     * Range: 0..65535 (-200..200 -)
     * Scale: 0.006103608758678569
     * Offset: -200
     */
    uint32_t inverter_r;

    /**
     * Range: 0..65535 (-200..200 -)
     * Scale: 0.006103608758678569
     * Offset: -200
     */
    uint32_t inverter_l;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_speed_t;

/**
 * Signals in message SPEED.
 *
 * Encoder and inverter speed in rad/sec
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (-200..200 -)
     * Scale: 0.006103608758678569
     * Offset: -200
     */
    float encoder_r;

    /**
     * Range: 0..65535 (-200..200 -)
     * Scale: 0.006103608758678569
     * Offset: -200
     */
    float encoder_l;

    /**
     * Range: 0..65535 (-200..200 -)
     * Scale: 0.006103608758678569
     * Offset: -200
     */
    float inverter_r;

    /**
     * Range: 0..65535 (-200..200 -)
     * Scale: 0.006103608758678569
     * Offset: -200
     */
    float inverter_l;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_speed_converted_t;

/**
 * Signals in message INV_L_REQUEST.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_0;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_1;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_2;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_3;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_4;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_5;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_6;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_7;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_inv_l_request_t;

/**
 * Signals in message INV_L_REQUEST.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_0;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_1;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_2;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_3;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_4;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_5;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_6;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_7;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_inv_l_request_converted_t;

/**
 * Signals in message INV_R_REQUEST.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_0;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_1;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_2;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_3;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_4;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_5;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_6;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_7;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_inv_r_request_t;

/**
 * Signals in message INV_R_REQUEST.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_0;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_1;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_2;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_3;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_4;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_5;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_6;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_7;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_inv_r_request_converted_t;

/**
 * Signals in message INV_L_RESPONSE.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t reg_id;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_0;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_1;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_2;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_3;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_4;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_5;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_6;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_inv_l_response_t;

/**
 * Signals in message INV_L_RESPONSE.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t reg_id;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_0;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_1;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_2;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_3;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_4;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_5;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_6;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_inv_l_response_converted_t;

/**
 * Signals in message INV_R_RESPONSE.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t reg_id;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_0;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_1;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_2;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_3;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_4;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_5;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_6;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_inv_r_response_t;

/**
 * Signals in message INV_R_RESPONSE.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t reg_id;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_0;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_1;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_2;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_3;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_4;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_5;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_6;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_inv_r_response_converted_t;

/**
 * Signals in message FLASH_CELLBOARD_0_TX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_flash_cellboard_0_tx_t;

/**
 * Signals in message FLASH_CELLBOARD_0_TX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_flash_cellboard_0_tx_converted_t;

/**
 * Signals in message FLASH_CELLBOARD_0_RX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_flash_cellboard_0_rx_t;

/**
 * Signals in message FLASH_CELLBOARD_0_RX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_flash_cellboard_0_rx_converted_t;

/**
 * Signals in message FLASH_CELLBOARD_1_TX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_flash_cellboard_1_tx_t;

/**
 * Signals in message FLASH_CELLBOARD_1_TX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_flash_cellboard_1_tx_converted_t;

/**
 * Signals in message FLASH_CELLBOARD_1_RX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_flash_cellboard_1_rx_t;

/**
 * Signals in message FLASH_CELLBOARD_1_RX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_flash_cellboard_1_rx_converted_t;

/**
 * Signals in message FLASH_CELLBOARD_2_TX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_flash_cellboard_2_tx_t;

/**
 * Signals in message FLASH_CELLBOARD_2_TX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_flash_cellboard_2_tx_converted_t;

/**
 * Signals in message FLASH_CELLBOARD_2_RX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_flash_cellboard_2_rx_t;

/**
 * Signals in message FLASH_CELLBOARD_2_RX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_flash_cellboard_2_rx_converted_t;

/**
 * Signals in message FLASH_CELLBOARD_3_TX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_flash_cellboard_3_tx_t;

/**
 * Signals in message FLASH_CELLBOARD_3_TX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_flash_cellboard_3_tx_converted_t;

/**
 * Signals in message FLASH_CELLBOARD_3_RX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_flash_cellboard_3_rx_t;

/**
 * Signals in message FLASH_CELLBOARD_3_RX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_flash_cellboard_3_rx_converted_t;

/**
 * Signals in message FLASH_CELLBOARD_4_TX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_flash_cellboard_4_tx_t;

/**
 * Signals in message FLASH_CELLBOARD_4_TX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_flash_cellboard_4_tx_converted_t;

/**
 * Signals in message FLASH_CELLBOARD_4_RX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_flash_cellboard_4_rx_t;

/**
 * Signals in message FLASH_CELLBOARD_4_RX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_flash_cellboard_4_rx_converted_t;

/**
 * Signals in message FLASH_CELLBOARD_5_TX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_flash_cellboard_5_tx_t;

/**
 * Signals in message FLASH_CELLBOARD_5_TX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_flash_cellboard_5_tx_converted_t;

/**
 * Signals in message FLASH_CELLBOARD_5_RX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_flash_cellboard_5_rx_t;

/**
 * Signals in message FLASH_CELLBOARD_5_RX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_flash_cellboard_5_rx_converted_t;

/**
 * Signals in message FLASH_BMS_HV_TX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_flash_bms_hv_tx_t;

/**
 * Signals in message FLASH_BMS_HV_TX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_flash_bms_hv_tx_converted_t;

/**
 * Signals in message FLASH_BMS_HV_RX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_flash_bms_hv_rx_t;

/**
 * Signals in message FLASH_BMS_HV_RX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_flash_bms_hv_rx_converted_t;

/**
 * Signals in message FLASH_BMS_LV_TX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_flash_bms_lv_tx_t;

/**
 * Signals in message FLASH_BMS_LV_TX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_flash_bms_lv_tx_converted_t;

/**
 * Signals in message FLASH_BMS_LV_RX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_flash_bms_lv_rx_t;

/**
 * Signals in message FLASH_BMS_LV_RX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_flash_bms_lv_rx_converted_t;

/**
 * Signals in message BRUSA_NLG5_CTL.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_brusa_nlg5_ctl_t;

/**
 * Signals in message BRUSA_NLG5_CTL.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_brusa_nlg5_ctl_converted_t;

/**
 * Signals in message BRUSA_ST.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_brusa_st_t;

/**
 * Signals in message BRUSA_ST.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_brusa_st_converted_t;

/**
 * Signals in message BRUSA_ACT_I.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_brusa_act_i_t;

/**
 * Signals in message BRUSA_ACT_I.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_brusa_act_i_converted_t;

/**
 * Signals in message BRUSA_ACT_II.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_brusa_act_ii_t;

/**
 * Signals in message BRUSA_ACT_II.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_brusa_act_ii_converted_t;

/**
 * Signals in message BRUSA_TEMP.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_brusa_temp_t;

/**
 * Signals in message BRUSA_TEMP.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_brusa_temp_converted_t;

/**
 * Signals in message BRUSA_ERR.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_brusa_err_t;

/**
 * Signals in message BRUSA_ERR.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_brusa_err_converted_t;

/**
 * Signals in message CONTROL_OUTPUT.
 *
 * Control output, N*m
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (-10..50 -)
     * Scale: 0.0009155413138017853
     * Offset: -10
     */
    uint32_t estimated_velocity;

    /**
     * Range: 0..255 (0..80 -)
     * Scale: 0.3137254901960784
     * Offset: 0
     */
    uint16_t tmax_r;

    /**
     * Range: 0..255 (0..80 -)
     * Scale: 0.3137254901960784
     * Offset: 0
     */
    uint16_t tmax_l;

    /**
     * Range: 0..65535 (0..80 -)
     * Scale: 0.0012207217517357137
     * Offset: 0
     */
    uint32_t torque_l;

    /**
     * Range: 0..65535 (0..80 -)
     * Scale: 0.0012207217517357137
     * Offset: 0
     */
    uint32_t torque_r;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_control_output_t;

/**
 * Signals in message CONTROL_OUTPUT.
 *
 * Control output, N*m
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (-10..50 -)
     * Scale: 0.0009155413138017853
     * Offset: -10
     */
    float estimated_velocity;

    /**
     * Range: 0..255 (0..80 -)
     * Scale: 0.3137254901960784
     * Offset: 0
     */
    float tmax_r;

    /**
     * Range: 0..255 (0..80 -)
     * Scale: 0.3137254901960784
     * Offset: 0
     */
    float tmax_l;

    /**
     * Range: 0..65535 (0..80 -)
     * Scale: 0.0012207217517357137
     * Offset: 0
     */
    float torque_l;

    /**
     * Range: 0..65535 (0..80 -)
     * Scale: 0.0012207217517357137
     * Offset: 0
     */
    float torque_r;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_control_output_converted_t;

/**
 * Signals in message LC_RESET.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_lc_reset_t;

/**
 * Signals in message LC_RESET.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_lc_reset_converted_t;


void primary_inverter_l_send_raw_to_conversion(
    primary_inverter_l_send_converted_t *conversion,
    primary_inverter_l_send_send_mux send_mux,
    float motor_f_n,
    uint16_t t_dc__start,
    float v_dc__start,
    int16_t special__start,
    float v_min__start,
    float f_min__start,
    float v_corner__start,
    float f_corner__start,
    uint16_t cos_phi,
    int16_t extra__start,
    int16_t capture_channel,
    int16_t trig_level,
    int16_t trig_edge,
    uint16_t trig_source,
    uint16_t oszi_source,
    uint16_t oszi_skip,
    uint16_t oszi_read_cmd,
    uint16_t oszi_run_cmd,
    float calib_ref_value,
    uint16_t pid_i__kp__iq,
    uint16_t pid_i__ti__iq,
    uint16_t cutoffdig,
    float id_setdig__id,
    int16_t i_delta_ramp,
    uint16_t pid_i__tim__iq,
    uint16_t pid_n__kp,
    uint16_t pid_n__ti,
    uint16_t pid_n__td,
    int16_t ain_in_1_offsetval,
    float n_setdig,
    float n_lim,
    uint16_t n_r_acc,
    primary_inverter_l_send_cs_ain_1_format cs_ain_1_format,
    uint16_t pid_n__tim,
    float i_red_n,
    float n_lim_minus,
    float n_lim_plus,
    float fb_offset,
    primary_inverter_l_send_read_id read_id,
    float i_lim_dig,
    uint16_t i_red_te,
    float i_max_eff,
    float i_nom_eff,
    uint16_t motor_pole,
    int16_t ain_in_1_cutoff,
    uint8_t km_rsvd_0,
    int16_t ain_in_2_cutoff,
    uint16_t i_red_td,
    uint16_t n_nom,
    uint8_t dc_bus_comp,
    int16_t pid_n__kacc,
    uint16_t speed_filter,
    float ain_in_1_filter,
    uint32_t snr,
    uint16_t device_mains,
    uint16_t regen_p,
    primary_inverter_l_send_devicetype devicetype,
    uint16_t can_id_rx,
    uint16_t can_id_tx,
    uint16_t pos_kp,
    uint16_t pos_ti,
    uint16_t pos_td,
    int32_t pos_dest,
    uint16_t pos_tim,
    int32_t pos_offsref,
    primary_inverter_l_send_can_nbt can_nbt,
    uint16_t ref_reso_edge,
    int16_t speed_1,
    int16_t speed_2,
    int16_t pos_tol_win,
    int32_t pos_preset_val,
    int32_t pos_nd_scale,
    int32_t pos_nd_offset,
    int32_t fb2_scale_ext,
    int32_t pos_offset_slack,
    int16_t pos_diff_slack,
    primary_inverter_l_send_eprom131 eprom131,
    primary_inverter_l_send_eprom132 eprom132,
    uint16_t fun_special,
    uint32_t can_id_2_rx,
    uint32_t can_id_2_tx,
    int16_t v_ref,
    uint16_t v_kp,
    uint16_t v_ti,
    uint16_t clear_errors,
    int16_t m_setdig__iq,
    uint16_t i_red_tm,
    uint16_t m_temp,
    primary_inverter_l_send_mo_feedback_1 mo_feedback_1,
    uint16_t dc_bus_min_lim,
    uint16_t fb_incr_mot,
    uint16_t fb_pole,
    float motor_lsq,
    int16_t id_nom,
    float motor_lm,
    uint16_t motor_rr,
    int16_t id_min,
    int16_t motor_tr,
    float motor_lsd,
    uint16_t motor_rs,
    float motor_ts,
    primary_inverter_l_send_def_end_1 def_end_1,
    primary_inverter_l_send_def_end_2 def_end_2,
    primary_inverter_l_send_def_din_1 def_din_1,
    primary_inverter_l_send_def_din_2 def_din_2,
    primary_inverter_l_send_operand194 operand194,
    primary_inverter_l_send_operand195 operand195,
    primary_inverter_l_send_operand218 operand218,
    primary_inverter_l_send_operand219 operand219,
    float i_max_pk,
    float i_con_eff,
    float i_device,
    uint16_t n_r_lim,
    int16_t nmax100perc,
    uint16_t pid_i__xkp__iq,
    float bat_opr_limit__mot,
    uint16_t pid_i__kf__iq,
    uint8_t cmc__bit0__dc_current_sens_ena,
    int16_t can_rxtimeout,
    int32_t var_1,
    int32_t var_2,
    int32_t var_3,
    int32_t var_4,
    int16_t ain_in_2_offsetval,
    uint8_t dup__bit7_0__dac_source_channel,
    uint16_t n_r_dec,
    uint16_t v_shunt,
    uint16_t t_peak,
    uint16_t brake_delay,
    uint32_t axis,
    uint8_t km_speed_0,
    uint8_t ballast_ext,
    uint8_t cmc__bit1__idc_limit_ena,
    primary_inverter_l_send_cs_ain_2_format cs_ain_2_format,
    uint8_t km_frg_off,
    uint8_t fb_special,
    uint8_t cmc__bit2__pdc_limit_usage,
    uint8_t km_cal_off,
    uint8_t coaststop,
    uint8_t cmc__bit3__torqueval_init_ena,
    primary_inverter_l_send_cs_ain_1_mode cs_ain_1_mode,
    uint8_t km_tx_tog_stat,
    uint8_t i_ist_inverse,
    primary_inverter_l_send_compare_var194 compare_var194,
    primary_inverter_l_send_compare_var195 compare_var195,
    primary_inverter_l_send_compare_var218 compare_var218,
    primary_inverter_l_send_compare_var219 compare_var219,
    uint8_t cmc__bit4__dig_m_rcpramp_ena,
    uint8_t km_i_limit,
    uint8_t refsoft,
    primary_inverter_l_send_mo_feedback_2 mo_feedback_2,
    uint8_t cmc__bit5__reset_nramp_atnzero,
    uint8_t km_n_clip,
    uint8_t no_uesp_btb,
    uint8_t cmc__bit6__torquetimeout_100ms_e,
    uint8_t cs_oora1,
    uint8_t km_mix_ana_on,
    uint8_t vdc_ana,
    uint8_t cmc__bit13_7__free,
    primary_inverter_l_send_cs_ain_2_mode cs_ain_2_mode,
    primary_inverter_l_send_ret_interval ret_interval,
    uint8_t km_allow_sync,
    uint8_t i1_adc_ena,
    float ain_in_2_filter,
    primary_inverter_l_send_mo_sc1_reso mo_sc1_reso,
    primary_inverter_l_send_source_id194 source_id194,
    primary_inverter_l_send_source_id195 source_id195,
    primary_inverter_l_send_source_id218 source_id218,
    primary_inverter_l_send_source_id219 source_id219,
    uint8_t dup__bit8__can_extended_0,
    uint8_t km_handwheel,
    uint8_t hxinv,
    uint8_t dup__bit9__generator,
    uint8_t km_phasing_extend,
    uint8_t h2inv,
    uint8_t dup__bit10__park_rms,
    uint8_t cs_oora2,
    uint8_t km_rsvd_11,
    uint8_t ol_comp,
    uint8_t mo_sc1_comp,
    uint8_t dup__bit11__dcbus_volts,
    primary_inverter_l_send_cs_cmd_type cs_cmd_type,
    uint8_t km_rsvd_12,
    primary_inverter_l_send_motortype motortype,
    primary_inverter_l_send_mo_sc2_reso mo_sc2_reso,
    uint8_t dup__bit12__boat_pedal,
    uint8_t km_rsvd_13,
    uint8_t dup__bit13__gen_autoiaclimit,
    uint8_t cs_ain_2__i_limit,
    uint8_t km_pseudo_enable,
    uint8_t ana_0up,
    uint8_t cmc__bit14__idc_limit_ena_v2,
    uint8_t dup__bit14__mtpa_reluct_enab,
    uint8_t cs_ain_1__n_limit,
    uint8_t km_debug_test,
    uint8_t lowbd,
    uint8_t mo_sc2_inv,
    primary_inverter_l_send_active190 active190,
    primary_inverter_l_send_active191 active191,
    primary_inverter_l_send_active192 active192,
    primary_inverter_l_send_active193 active193,
    uint8_t cmc__bit15__dig_e_brake_act,
    uint8_t dup__bit15__canopen_acv,
    uint16_t t_dc__stop,
    float v_dc__stop,
    int16_t special__stop,
    float v_min__stop,
    float f_min__stop,
    float v_corner__stop,
    float f_corner__stop,
    uint16_t pid_i__kp__id,
    uint16_t pid_i__ti__id,
    uint16_t pid_i__tim__id,
    float ain_in_1_scaleval,
    uint16_t m_r_acc,
    uint8_t sramp,
    uint16_t regen_r,
    uint16_t dc_bus_max_lim,
    uint16_t m_r_rcp,
    uint16_t pid_i__xkp__id,
    float bat_opr_limit__gen,
    uint16_t pid_i__kf__id,
    uint8_t cmc__bit17_16__checkipeak_config,
    float ain_in_2_scaleval,
    uint8_t dup__bit16__bamobil3_2_offcrct,
    uint16_t m_r_dec,
    uint8_t ramp4,
    uint8_t dup__bit19_17__ecode_redefine,
    uint8_t motbrake,
    uint8_t cmc__bit18__tractioncontrol_ena,
    uint8_t ac_dc,
    uint8_t cmc__bit20_19__tc_deltatime_conf,
    primary_inverter_l_send_pwm_freq pwm_freq,
    uint8_t dup__bit20__hal_extmr_acv,
    uint8_t cmc__bit22_21__tc_minspeed_conf,
    uint8_t dup__bit21__initwith_frg_off,
    uint16_t dup__bit31_22__free,
    uint8_t ntc,
    uint8_t cmc__bit23__tc_ncmdrestoption,
    uint8_t delta,
    uint8_t cmc__bit31_24__free,
    uint8_t dc_1qdirvolt,
    uint8_t dc_field,
    uint8_t dead_2,
    uint8_t block,
    uint8_t dc_1qmv,
    uint8_t dc_1q3p,
    uint8_t reducelosses
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_inverter_l_send_conversion_to_raw(
    primary_inverter_l_send_t *raw,
    primary_inverter_l_send_send_mux send_mux,
    float motor_f_n,
    uint16_t t_dc__start,
    float v_dc__start,
    int16_t special__start,
    float v_min__start,
    float f_min__start,
    float v_corner__start,
    float f_corner__start,
    uint16_t cos_phi,
    int16_t extra__start,
    int16_t capture_channel,
    int16_t trig_level,
    int16_t trig_edge,
    uint16_t trig_source,
    uint16_t oszi_source,
    uint16_t oszi_skip,
    uint16_t oszi_read_cmd,
    uint16_t oszi_run_cmd,
    float calib_ref_value,
    uint16_t pid_i__kp__iq,
    uint16_t pid_i__ti__iq,
    uint16_t cutoffdig,
    float id_setdig__id,
    int16_t i_delta_ramp,
    uint16_t pid_i__tim__iq,
    uint16_t pid_n__kp,
    uint16_t pid_n__ti,
    uint16_t pid_n__td,
    int16_t ain_in_1_offsetval,
    float n_setdig,
    float n_lim,
    uint16_t n_r_acc,
    primary_inverter_l_send_cs_ain_1_format cs_ain_1_format,
    uint16_t pid_n__tim,
    float i_red_n,
    float n_lim_minus,
    float n_lim_plus,
    float fb_offset,
    primary_inverter_l_send_read_id read_id,
    float i_lim_dig,
    uint16_t i_red_te,
    float i_max_eff,
    float i_nom_eff,
    uint16_t motor_pole,
    int16_t ain_in_1_cutoff,
    uint8_t km_rsvd_0,
    int16_t ain_in_2_cutoff,
    uint16_t i_red_td,
    uint16_t n_nom,
    uint8_t dc_bus_comp,
    int16_t pid_n__kacc,
    uint16_t speed_filter,
    float ain_in_1_filter,
    uint32_t snr,
    uint16_t device_mains,
    uint16_t regen_p,
    primary_inverter_l_send_devicetype devicetype,
    uint16_t can_id_rx,
    uint16_t can_id_tx,
    uint16_t pos_kp,
    uint16_t pos_ti,
    uint16_t pos_td,
    int32_t pos_dest,
    uint16_t pos_tim,
    int32_t pos_offsref,
    primary_inverter_l_send_can_nbt can_nbt,
    uint16_t ref_reso_edge,
    int16_t speed_1,
    int16_t speed_2,
    int16_t pos_tol_win,
    int32_t pos_preset_val,
    int32_t pos_nd_scale,
    int32_t pos_nd_offset,
    int32_t fb2_scale_ext,
    int32_t pos_offset_slack,
    int16_t pos_diff_slack,
    primary_inverter_l_send_eprom131 eprom131,
    primary_inverter_l_send_eprom132 eprom132,
    uint16_t fun_special,
    uint32_t can_id_2_rx,
    uint32_t can_id_2_tx,
    int16_t v_ref,
    uint16_t v_kp,
    uint16_t v_ti,
    uint16_t clear_errors,
    int16_t m_setdig__iq,
    uint16_t i_red_tm,
    uint16_t m_temp,
    primary_inverter_l_send_mo_feedback_1 mo_feedback_1,
    uint16_t dc_bus_min_lim,
    uint16_t fb_incr_mot,
    uint16_t fb_pole,
    float motor_lsq,
    int16_t id_nom,
    float motor_lm,
    uint16_t motor_rr,
    int16_t id_min,
    int16_t motor_tr,
    float motor_lsd,
    uint16_t motor_rs,
    float motor_ts,
    primary_inverter_l_send_def_end_1 def_end_1,
    primary_inverter_l_send_def_end_2 def_end_2,
    primary_inverter_l_send_def_din_1 def_din_1,
    primary_inverter_l_send_def_din_2 def_din_2,
    primary_inverter_l_send_operand194 operand194,
    primary_inverter_l_send_operand195 operand195,
    primary_inverter_l_send_operand218 operand218,
    primary_inverter_l_send_operand219 operand219,
    float i_max_pk,
    float i_con_eff,
    float i_device,
    uint16_t n_r_lim,
    int16_t nmax100perc,
    uint16_t pid_i__xkp__iq,
    float bat_opr_limit__mot,
    uint16_t pid_i__kf__iq,
    uint8_t cmc__bit0__dc_current_sens_ena,
    int16_t can_rxtimeout,
    int32_t var_1,
    int32_t var_2,
    int32_t var_3,
    int32_t var_4,
    int16_t ain_in_2_offsetval,
    uint8_t dup__bit7_0__dac_source_channel,
    uint16_t n_r_dec,
    uint16_t v_shunt,
    uint16_t t_peak,
    uint16_t brake_delay,
    uint32_t axis,
    uint8_t km_speed_0,
    uint8_t ballast_ext,
    uint8_t cmc__bit1__idc_limit_ena,
    primary_inverter_l_send_cs_ain_2_format cs_ain_2_format,
    uint8_t km_frg_off,
    uint8_t fb_special,
    uint8_t cmc__bit2__pdc_limit_usage,
    uint8_t km_cal_off,
    uint8_t coaststop,
    uint8_t cmc__bit3__torqueval_init_ena,
    primary_inverter_l_send_cs_ain_1_mode cs_ain_1_mode,
    uint8_t km_tx_tog_stat,
    uint8_t i_ist_inverse,
    primary_inverter_l_send_compare_var194 compare_var194,
    primary_inverter_l_send_compare_var195 compare_var195,
    primary_inverter_l_send_compare_var218 compare_var218,
    primary_inverter_l_send_compare_var219 compare_var219,
    uint8_t cmc__bit4__dig_m_rcpramp_ena,
    uint8_t km_i_limit,
    uint8_t refsoft,
    primary_inverter_l_send_mo_feedback_2 mo_feedback_2,
    uint8_t cmc__bit5__reset_nramp_atnzero,
    uint8_t km_n_clip,
    uint8_t no_uesp_btb,
    uint8_t cmc__bit6__torquetimeout_100ms_e,
    uint8_t cs_oora1,
    uint8_t km_mix_ana_on,
    uint8_t vdc_ana,
    uint8_t cmc__bit13_7__free,
    primary_inverter_l_send_cs_ain_2_mode cs_ain_2_mode,
    primary_inverter_l_send_ret_interval ret_interval,
    uint8_t km_allow_sync,
    uint8_t i1_adc_ena,
    float ain_in_2_filter,
    primary_inverter_l_send_mo_sc1_reso mo_sc1_reso,
    primary_inverter_l_send_source_id194 source_id194,
    primary_inverter_l_send_source_id195 source_id195,
    primary_inverter_l_send_source_id218 source_id218,
    primary_inverter_l_send_source_id219 source_id219,
    uint8_t dup__bit8__can_extended_0,
    uint8_t km_handwheel,
    uint8_t hxinv,
    uint8_t dup__bit9__generator,
    uint8_t km_phasing_extend,
    uint8_t h2inv,
    uint8_t dup__bit10__park_rms,
    uint8_t cs_oora2,
    uint8_t km_rsvd_11,
    uint8_t ol_comp,
    uint8_t mo_sc1_comp,
    uint8_t dup__bit11__dcbus_volts,
    primary_inverter_l_send_cs_cmd_type cs_cmd_type,
    uint8_t km_rsvd_12,
    primary_inverter_l_send_motortype motortype,
    primary_inverter_l_send_mo_sc2_reso mo_sc2_reso,
    uint8_t dup__bit12__boat_pedal,
    uint8_t km_rsvd_13,
    uint8_t dup__bit13__gen_autoiaclimit,
    uint8_t cs_ain_2__i_limit,
    uint8_t km_pseudo_enable,
    uint8_t ana_0up,
    uint8_t cmc__bit14__idc_limit_ena_v2,
    uint8_t dup__bit14__mtpa_reluct_enab,
    uint8_t cs_ain_1__n_limit,
    uint8_t km_debug_test,
    uint8_t lowbd,
    uint8_t mo_sc2_inv,
    primary_inverter_l_send_active190 active190,
    primary_inverter_l_send_active191 active191,
    primary_inverter_l_send_active192 active192,
    primary_inverter_l_send_active193 active193,
    uint8_t cmc__bit15__dig_e_brake_act,
    uint8_t dup__bit15__canopen_acv,
    uint16_t t_dc__stop,
    float v_dc__stop,
    int16_t special__stop,
    float v_min__stop,
    float f_min__stop,
    float v_corner__stop,
    float f_corner__stop,
    uint16_t pid_i__kp__id,
    uint16_t pid_i__ti__id,
    uint16_t pid_i__tim__id,
    float ain_in_1_scaleval,
    uint16_t m_r_acc,
    uint8_t sramp,
    uint16_t regen_r,
    uint16_t dc_bus_max_lim,
    uint16_t m_r_rcp,
    uint16_t pid_i__xkp__id,
    float bat_opr_limit__gen,
    uint16_t pid_i__kf__id,
    uint8_t cmc__bit17_16__checkipeak_config,
    float ain_in_2_scaleval,
    uint8_t dup__bit16__bamobil3_2_offcrct,
    uint16_t m_r_dec,
    uint8_t ramp4,
    uint8_t dup__bit19_17__ecode_redefine,
    uint8_t motbrake,
    uint8_t cmc__bit18__tractioncontrol_ena,
    uint8_t ac_dc,
    uint8_t cmc__bit20_19__tc_deltatime_conf,
    primary_inverter_l_send_pwm_freq pwm_freq,
    uint8_t dup__bit20__hal_extmr_acv,
    uint8_t cmc__bit22_21__tc_minspeed_conf,
    uint8_t dup__bit21__initwith_frg_off,
    uint16_t dup__bit31_22__free,
    uint8_t ntc,
    uint8_t cmc__bit23__tc_ncmdrestoption,
    uint8_t delta,
    uint8_t cmc__bit31_24__free,
    uint8_t dc_1qdirvolt,
    uint8_t dc_field,
    uint8_t dead_2,
    uint8_t block,
    uint8_t dc_1qmv,
    uint8_t dc_1q3p,
    uint8_t reducelosses
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_inverter_l_send_raw_to_conversion_struct(
    primary_inverter_l_send_converted_t *conversion, 
    const primary_inverter_l_send_t *raw);


void primary_inverter_l_send_conversion_to_raw_struct(
    primary_inverter_l_send_t *raw,
    const primary_inverter_l_send_converted_t *conversion);

int primary_inverter_l_send_send_mux_enum_to_string(primary_inverter_l_send_send_mux value, char *buffer);
int primary_inverter_l_send_cs_ain_1_format_enum_to_string(primary_inverter_l_send_cs_ain_1_format value, char *buffer);
int primary_inverter_l_send_read_id_enum_to_string(primary_inverter_l_send_read_id value, char *buffer);
int primary_inverter_l_send_devicetype_enum_to_string(primary_inverter_l_send_devicetype value, char *buffer);
int primary_inverter_l_send_can_nbt_enum_to_string(primary_inverter_l_send_can_nbt value, char *buffer);
int primary_inverter_l_send_eprom131_enum_to_string(primary_inverter_l_send_eprom131 value, char *buffer);
int primary_inverter_l_send_eprom132_enum_to_string(primary_inverter_l_send_eprom132 value, char *buffer);
int primary_inverter_l_send_mo_feedback_1_enum_to_string(primary_inverter_l_send_mo_feedback_1 value, char *buffer);
int primary_inverter_l_send_def_end_1_enum_to_string(primary_inverter_l_send_def_end_1 value, char *buffer);
int primary_inverter_l_send_def_end_2_enum_to_string(primary_inverter_l_send_def_end_2 value, char *buffer);
int primary_inverter_l_send_def_din_1_enum_to_string(primary_inverter_l_send_def_din_1 value, char *buffer);
int primary_inverter_l_send_def_din_2_enum_to_string(primary_inverter_l_send_def_din_2 value, char *buffer);
int primary_inverter_l_send_operand194_enum_to_string(primary_inverter_l_send_operand194 value, char *buffer);
int primary_inverter_l_send_operand195_enum_to_string(primary_inverter_l_send_operand195 value, char *buffer);
int primary_inverter_l_send_operand218_enum_to_string(primary_inverter_l_send_operand218 value, char *buffer);
int primary_inverter_l_send_operand219_enum_to_string(primary_inverter_l_send_operand219 value, char *buffer);
int primary_inverter_l_send_cs_ain_2_format_enum_to_string(primary_inverter_l_send_cs_ain_2_format value, char *buffer);
int primary_inverter_l_send_cs_ain_1_mode_enum_to_string(primary_inverter_l_send_cs_ain_1_mode value, char *buffer);
int primary_inverter_l_send_compare_var194_enum_to_string(primary_inverter_l_send_compare_var194 value, char *buffer);
int primary_inverter_l_send_compare_var195_enum_to_string(primary_inverter_l_send_compare_var195 value, char *buffer);
int primary_inverter_l_send_compare_var218_enum_to_string(primary_inverter_l_send_compare_var218 value, char *buffer);
int primary_inverter_l_send_compare_var219_enum_to_string(primary_inverter_l_send_compare_var219 value, char *buffer);
int primary_inverter_l_send_mo_feedback_2_enum_to_string(primary_inverter_l_send_mo_feedback_2 value, char *buffer);
int primary_inverter_l_send_cs_ain_2_mode_enum_to_string(primary_inverter_l_send_cs_ain_2_mode value, char *buffer);
int primary_inverter_l_send_ret_interval_enum_to_string(primary_inverter_l_send_ret_interval value, char *buffer);
int primary_inverter_l_send_mo_sc1_reso_enum_to_string(primary_inverter_l_send_mo_sc1_reso value, char *buffer);
int primary_inverter_l_send_source_id194_enum_to_string(primary_inverter_l_send_source_id194 value, char *buffer);
int primary_inverter_l_send_source_id195_enum_to_string(primary_inverter_l_send_source_id195 value, char *buffer);
int primary_inverter_l_send_source_id218_enum_to_string(primary_inverter_l_send_source_id218 value, char *buffer);
int primary_inverter_l_send_source_id219_enum_to_string(primary_inverter_l_send_source_id219 value, char *buffer);
int primary_inverter_l_send_cs_cmd_type_enum_to_string(primary_inverter_l_send_cs_cmd_type value, char *buffer);
int primary_inverter_l_send_motortype_enum_to_string(primary_inverter_l_send_motortype value, char *buffer);
int primary_inverter_l_send_mo_sc2_reso_enum_to_string(primary_inverter_l_send_mo_sc2_reso value, char *buffer);
int primary_inverter_l_send_active190_enum_to_string(primary_inverter_l_send_active190 value, char *buffer);
int primary_inverter_l_send_active191_enum_to_string(primary_inverter_l_send_active191 value, char *buffer);
int primary_inverter_l_send_active192_enum_to_string(primary_inverter_l_send_active192 value, char *buffer);
int primary_inverter_l_send_active193_enum_to_string(primary_inverter_l_send_active193 value, char *buffer);
int primary_inverter_l_send_pwm_freq_enum_to_string(primary_inverter_l_send_pwm_freq value, char *buffer);

int primary_inverter_l_send_converted_to_string(primary_inverter_l_send_converted_t *message, char *buffer);

int primary_inverter_l_send_converted_to_string_file(primary_inverter_l_send_converted_t *message, FILE *buffer);

int primary_inverter_l_send_fields(char *buffer);

int primary_inverter_l_send_fields_file(FILE *buffer);

/**
 * Pack message Inverter_L_Send.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_inverter_l_send_pack(
    uint8_t *dst_p,
    const primary_inverter_l_send_t *src_p,
    size_t size);

/**
 * Unpack message Inverter_L_Send.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_inverter_l_send_unpack(
    primary_inverter_l_send_t *dst_p,
    const uint8_t *src_p,
    size_t size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_send_mux_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_inverter_l_send_motor_f_n_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_l_send_motor_f_n_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_motor_f_n_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_t_dc__start_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t primary_inverter_l_send_v_dc__start_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_l_send_v_dc__start_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_v_dc__start_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_special__start_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t primary_inverter_l_send_v_min__start_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_l_send_v_min__start_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_v_min__start_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t primary_inverter_l_send_f_min__start_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_l_send_f_min__start_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_f_min__start_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t primary_inverter_l_send_v_corner__start_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_l_send_v_corner__start_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_v_corner__start_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t primary_inverter_l_send_f_corner__start_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_l_send_f_corner__start_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_f_corner__start_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_cos_phi_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_extra__start_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_capture_channel_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_trig_level_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_trig_edge_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_trig_source_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_oszi_source_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_oszi_skip_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_oszi_read_cmd_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_oszi_run_cmd_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_inverter_l_send_calib_ref_value_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_l_send_calib_ref_value_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_calib_ref_value_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_pid_i__kp__iq_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_pid_i__ti__iq_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_cutoffdig_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t primary_inverter_l_send_id_setdig__id_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_l_send_id_setdig__id_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_id_setdig__id_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_i_delta_ramp_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_pid_i__tim__iq_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_pid_n__kp_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_pid_n__ti_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_pid_n__td_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_ain_in_1_offsetval_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t primary_inverter_l_send_n_setdig_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_l_send_n_setdig_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_n_setdig_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t primary_inverter_l_send_n_lim_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_l_send_n_lim_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_n_lim_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_n_r_acc_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_cs_ain_1_format_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_pid_n__tim_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_inverter_l_send_i_red_n_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_l_send_i_red_n_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_i_red_n_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t primary_inverter_l_send_n_lim_minus_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_l_send_n_lim_minus_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_n_lim_minus_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t primary_inverter_l_send_n_lim_plus_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_l_send_n_lim_plus_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_n_lim_plus_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t primary_inverter_l_send_fb_offset_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_l_send_fb_offset_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_fb_offset_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_read_id_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t primary_inverter_l_send_i_lim_dig_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_l_send_i_lim_dig_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_i_lim_dig_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_i_red_te_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_inverter_l_send_i_max_eff_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_l_send_i_max_eff_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_i_max_eff_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_inverter_l_send_i_nom_eff_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_l_send_i_nom_eff_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_i_nom_eff_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_motor_pole_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_ain_in_1_cutoff_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_km_rsvd_0_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_ain_in_2_cutoff_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_i_red_td_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_n_nom_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_dc_bus_comp_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_pid_n__kacc_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_speed_filter_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t primary_inverter_l_send_ain_in_1_filter_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_l_send_ain_in_1_filter_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_ain_in_1_filter_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_snr_is_in_range(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_device_mains_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_regen_p_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_devicetype_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_can_id_rx_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_can_id_tx_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_pos_kp_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_pos_ti_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_pos_td_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_pos_dest_is_in_range(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_pos_tim_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_pos_offsref_is_in_range(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_can_nbt_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_ref_reso_edge_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_speed_1_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_speed_2_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_pos_tol_win_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_pos_preset_val_is_in_range(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_pos_nd_scale_is_in_range(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_pos_nd_offset_is_in_range(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_fb2_scale_ext_is_in_range(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_pos_offset_slack_is_in_range(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_pos_diff_slack_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_eprom131_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_eprom132_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_fun_special_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_can_id_2_rx_is_in_range(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_can_id_2_tx_is_in_range(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_v_ref_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_v_kp_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_v_ti_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_clear_errors_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_m_setdig__iq_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_i_red_tm_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_m_temp_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_mo_feedback_1_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_dc_bus_min_lim_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_fb_incr_mot_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_fb_pole_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_inverter_l_send_motor_lsq_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_l_send_motor_lsq_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_motor_lsq_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_id_nom_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_inverter_l_send_motor_lm_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_l_send_motor_lm_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_motor_lm_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_motor_rr_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_id_min_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_motor_tr_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_inverter_l_send_motor_lsd_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_l_send_motor_lsd_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_motor_lsd_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_motor_rs_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t primary_inverter_l_send_motor_ts_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_l_send_motor_ts_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_motor_ts_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_def_end_1_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_def_end_2_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_def_din_1_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_def_din_2_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_operand194_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_operand195_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_operand218_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_operand219_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_inverter_l_send_i_max_pk_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_l_send_i_max_pk_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_i_max_pk_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_inverter_l_send_i_con_eff_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_l_send_i_con_eff_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_i_con_eff_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_inverter_l_send_i_device_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_l_send_i_device_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_i_device_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_n_r_lim_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_nmax100perc_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_pid_i__xkp__iq_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_inverter_l_send_bat_opr_limit__mot_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_l_send_bat_opr_limit__mot_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_bat_opr_limit__mot_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_pid_i__kf__iq_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_cmc__bit0__dc_current_sens_ena_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_can_rxtimeout_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_var_1_is_in_range(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_var_2_is_in_range(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_var_3_is_in_range(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_var_4_is_in_range(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_ain_in_2_offsetval_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_dup__bit7_0__dac_source_channel_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_n_r_dec_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_v_shunt_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_t_peak_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_brake_delay_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_axis_is_in_range(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_km_speed_0_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_ballast_ext_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_cmc__bit1__idc_limit_ena_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_cs_ain_2_format_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_km_frg_off_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_fb_special_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_cmc__bit2__pdc_limit_usage_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_km_cal_off_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_coaststop_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_cmc__bit3__torqueval_init_ena_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_cs_ain_1_mode_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_km_tx_tog_stat_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_i_ist_inverse_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_compare_var194_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_compare_var195_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_compare_var218_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_compare_var219_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_cmc__bit4__dig_m_rcpramp_ena_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_km_i_limit_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_refsoft_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_mo_feedback_2_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_cmc__bit5__reset_nramp_atnzero_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_km_n_clip_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_no_uesp_btb_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_cmc__bit6__torquetimeout_100ms_e_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_cs_oora1_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_km_mix_ana_on_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_vdc_ana_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_cmc__bit13_7__free_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_cs_ain_2_mode_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_ret_interval_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_km_allow_sync_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_i1_adc_ena_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t primary_inverter_l_send_ain_in_2_filter_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_l_send_ain_in_2_filter_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_ain_in_2_filter_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_mo_sc1_reso_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_source_id194_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_source_id195_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_source_id218_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_source_id219_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_dup__bit8__can_extended_0_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_km_handwheel_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_hxinv_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_dup__bit9__generator_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_km_phasing_extend_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_h2inv_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_dup__bit10__park_rms_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_cs_oora2_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_km_rsvd_11_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_ol_comp_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_mo_sc1_comp_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_dup__bit11__dcbus_volts_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_cs_cmd_type_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_km_rsvd_12_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_motortype_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_mo_sc2_reso_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_dup__bit12__boat_pedal_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_km_rsvd_13_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_dup__bit13__gen_autoiaclimit_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_cs_ain_2__i_limit_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_km_pseudo_enable_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_ana_0up_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_cmc__bit14__idc_limit_ena_v2_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_dup__bit14__mtpa_reluct_enab_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_cs_ain_1__n_limit_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_km_debug_test_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_lowbd_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_mo_sc2_inv_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_active190_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_active191_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_active192_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_active193_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_cmc__bit15__dig_e_brake_act_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_dup__bit15__canopen_acv_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_t_dc__stop_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t primary_inverter_l_send_v_dc__stop_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_l_send_v_dc__stop_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_v_dc__stop_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_special__stop_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t primary_inverter_l_send_v_min__stop_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_l_send_v_min__stop_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_v_min__stop_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t primary_inverter_l_send_f_min__stop_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_l_send_f_min__stop_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_f_min__stop_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t primary_inverter_l_send_v_corner__stop_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_l_send_v_corner__stop_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_v_corner__stop_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t primary_inverter_l_send_f_corner__stop_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_l_send_f_corner__stop_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_f_corner__stop_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_pid_i__kp__id_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_pid_i__ti__id_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_pid_i__tim__id_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t primary_inverter_l_send_ain_in_1_scaleval_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_l_send_ain_in_1_scaleval_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_ain_in_1_scaleval_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_m_r_acc_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_sramp_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_regen_r_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_dc_bus_max_lim_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_m_r_rcp_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_pid_i__xkp__id_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_inverter_l_send_bat_opr_limit__gen_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_l_send_bat_opr_limit__gen_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_bat_opr_limit__gen_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_pid_i__kf__id_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_cmc__bit17_16__checkipeak_config_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t primary_inverter_l_send_ain_in_2_scaleval_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_l_send_ain_in_2_scaleval_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_ain_in_2_scaleval_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_dup__bit16__bamobil3_2_offcrct_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_m_r_dec_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_ramp4_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_dup__bit19_17__ecode_redefine_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_motbrake_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_cmc__bit18__tractioncontrol_ena_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_ac_dc_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_cmc__bit20_19__tc_deltatime_conf_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_pwm_freq_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_dup__bit20__hal_extmr_acv_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_cmc__bit22_21__tc_minspeed_conf_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_dup__bit21__initwith_frg_off_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_dup__bit31_22__free_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_ntc_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_cmc__bit23__tc_ncmdrestoption_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_delta_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_cmc__bit31_24__free_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_dc_1qdirvolt_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_dc_field_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_dead_2_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_block_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_dc_1qmv_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_dc_1q3p_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_send_reducelosses_is_in_range(uint8_t value);


void primary_inverter_l_rcv_raw_to_conversion(
    primary_inverter_l_rcv_converted_t *conversion,
    primary_inverter_l_rcv_rcv_mux rcv_mux,
    float n_actual,
    uint16_t n_r_dec,
    uint16_t n_r_lim,
    float n_actual_filt,
    uint16_t firmware,
    primary_inverter_l_rcv_devicetype devicetype,
    uint32_t snr,
    uint32_t axis,
    float i_device,
    uint16_t v_shunt,
    uint16_t i_200perc,
    uint8_t dc_bus_comp,
    uint8_t ena64,
    uint8_t err_badparas,
    uint8_t lmt1,
    int16_t ain_in_1_raw,
    int16_t ain_in_2_raw,
    int16_t nmax100perc,
    float n_setdig,
    int16_t n_cmd,
    float n_cmd_ramp,
    float n_lim,
    float n_error,
    int16_t m_setdig__iq,
    float id_setdig__id,
    float i_max_pk,
    float i_con_eff,
    float i_max_eff,
    float i_nom_eff,
    float i_limit_inuse,
    float i_cmd,
    float i_cmd_ramp,
    float i_actual,
    float i_actual_filt,
    float iq_actual,
    float id_actual,
    float iq_error,
    float id_error,
    float i1_actual,
    float i2_actual,
    float i3_actual,
    uint16_t i3_adc,
    uint16_t i2_adc,
    int16_t vq,
    int16_t vd,
    int16_t vout,
    uint16_t t_motor,
    uint16_t t_igbt,
    int16_t t_air,
    float vdc_bus_filt,
    uint8_t end_1,
    uint8_t din_1,
    uint8_t end_2,
    uint8_t din_2,
    uint8_t run232,
    uint8_t dout_1,
    uint8_t dout_2,
    uint8_t dout_3,
    uint8_t rdy_btb,
    uint8_t i_fault,
    uint8_t dout_4,
    float i_lim_dig,
    float i_red_n,
    uint16_t i_red_td,
    uint16_t i_red_te,
    uint16_t i_red_tm,
    primary_inverter_l_rcv_cs_ain_1_format cs_ain_1_format,
    float id_ref,
    int16_t m_outdig__iq,
    int16_t ptr_1_debug,
    int16_t ptr_2_debug,
    int16_t temp_debug,
    float motor_f_n,
    uint16_t motor_v_n,
    uint16_t t_dc__start,
    float v_dc__start,
    float v_min__start,
    float f_min__start,
    float v_corner__start,
    float f_corner__start,
    uint16_t cos_phi,
    uint16_t pwm_enum,
    float calib_ref_value,
    uint16_t pid_i__kp__iq,
    uint16_t pid_i__ti__iq,
    uint16_t cutoffdig,
    uint16_t i3_offset,
    int16_t i_delta_ramp,
    uint16_t pid_i__tim__iq,
    uint16_t pid_n__kp,
    uint16_t v_ti,
    uint16_t pid_n__td,
    int16_t ain_in_1_offsetval,
    int16_t ain_in_2_offsetval,
    uint16_t dzr_seq,
    uint16_t pid_n__tim,
    float n_lim_plus,
    float n_lim_minus,
    int16_t incr_delta,
    int16_t motorpos_mech,
    int16_t motorpos_elec,
    float fb_offset,
    int32_t it_rg_monitor,
    uint16_t motor_pole,
    int16_t ain_in_1_cutoff,
    primary_inverter_l_rcv_activecontrolmode activecontrolmode,
    uint8_t km_rsvd_0,
    uint8_t ena82,
    int16_t ain_in_2_cutoff,
    float i_limit_inuse_ramp,
    uint16_t n_nom,
    int16_t pid_n__kacc,
    uint16_t rotor_signals,
    uint16_t speed_filter,
    float ain_in_1_filter,
    uint16_t ixt_monitor,
    uint8_t ecode_bit0_firsterrordtcd99,
    uint16_t device_mains,
    uint16_t regen_p,
    uint16_t can_id_rx,
    uint16_t can_id_tx,
    uint16_t pos_kp,
    uint16_t pos_ti,
    uint16_t pos_td,
    int32_t pos_actual,
    int32_t pos_dest,
    int32_t pos_actual_2,
    int32_t pos_error,
    uint16_t pos_tim,
    int32_t pos_offsref,
    primary_inverter_l_rcv_can_nbt can_nbt,
    uint16_t pos_zero_capture,
    uint16_t ref_reso_edge,
    int16_t speed_1,
    int16_t speed_2,
    int16_t pos_tol_win,
    int32_t pos_preset_val,
    int32_t pos_zero_offset,
    int32_t pos_nd_scale,
    int32_t pos_nd_offset,
    int32_t fb2_scale_ext,
    int32_t pos_offset_slack,
    int16_t pos_diff_slack,
    uint16_t fun_para_read,
    uint16_t fun_para_write,
    uint16_t fun_special,
    uint32_t can_id_2_rx,
    uint32_t can_id_2_tx,
    int16_t v_ref,
    uint16_t v_kp,
    uint16_t pid_n__ti,
    uint16_t clear_errors,
    int32_t pos_cmd,
    uint16_t can_error_busoff,
    uint16_t can_error_writetime,
    uint8_t ecode_bit0_firsterrordtcd148,
    uint16_t can_error_no_ack,
    uint16_t can_error_crc_check150,
    uint16_t can_error_crc_check151,
    uint16_t info_timer_diff,
    int16_t ballastcount,
    uint16_t m_temp,
    primary_inverter_l_rcv_mo_feedback_1 mo_feedback_1,
    uint16_t dc_bus_min_lim,
    uint16_t fb_incr_mot,
    uint16_t fb_pole,
    uint16_t logic_freq,
    int16_t pwm_1,
    int16_t pwm_2,
    int16_t pwm_3,
    int16_t timer_delta,
    float motor_lsq,
    float motor_lsd,
    int16_t id_nom,
    float motor_lm,
    uint16_t motor_rr,
    int16_t id_min,
    int16_t motor_tr,
    uint16_t motor_rs,
    float motor_ts,
    primary_inverter_l_rcv_def_end_1 def_end_1,
    primary_inverter_l_rcv_def_end_2 def_end_2,
    primary_inverter_l_rcv_def_din_1 def_din_1,
    primary_inverter_l_rcv_def_din_2 def_din_2,
    primary_inverter_l_rcv_operand194 operand194,
    float i_max_inuse,
    uint8_t signal_go,
    uint8_t signal_brake,
    uint8_t signal_icns,
    uint8_t signal_lessn0,
    uint8_t signal_postolerance,
    int16_t ain_in_1_scaled251,
    int16_t ain_in_2_scaled252,
    primary_inverter_l_rcv_operand195 operand195,
    primary_inverter_l_rcv_operand218 operand218,
    primary_inverter_l_rcv_operand219 operand219,
    uint16_t pid_i__xkp__iq,
    float bat_opr_limit__mot,
    uint16_t pid_i__kf__iq,
    uint8_t dc_current_sens_ena_set,
    uint8_t cmc__bit0__dc_current_sens_ena,
    int16_t n_rpm_maxint,
    int32_t var_1,
    int16_t can_rxtimeout,
    int32_t var_2,
    int32_t var_3,
    int32_t var_4,
    uint8_t dup__bit7_0__dac_source_channel,
    uint8_t fb_lossofsignal,
    uint8_t no_hw_fault,
    uint16_t t_peak,
    uint16_t brake_delay,
    int16_t power,
    int16_t work,
    int16_t extra__start,
    int16_t capture_channel,
    int16_t trig_level,
    int16_t trig_edge,
    uint16_t trig_source,
    uint16_t oszi_source,
    uint16_t oszi_skip,
    uint16_t oszi_run_cmd,
    uint16_t oszi_read_cmd,
    int16_t pos_ref_start,
    float vdc_bus,
    int16_t m_cmd_ramp,
    uint8_t lmt_1,
    uint8_t out_1,
    uint16_t subversion_nr,
    uint8_t ballast_ext,
    uint8_t ncr064,
    uint8_t err_powerfault,
    uint8_t lmt2,
    uint8_t km_speed_0,
    uint8_t ncr082,
    uint8_t ecode_bit1__hw1_state99,
    uint8_t ecode_bit1__hw1_state148,
    uint8_t dc_i_sensena_set,
    uint8_t cmc__bit1__idc_limit_ena,
    uint8_t lmt_2,
    uint8_t out_2,
    uint8_t fb_special,
    uint8_t lim_plus64,
    uint8_t err_rfe_fault,
    uint8_t in2,
    primary_inverter_l_rcv_cs_ain_2_format cs_ain_2_format,
    uint8_t km_frg_off,
    uint8_t lim_plus82,
    uint8_t ecode_bit2__hw0_state99,
    uint8_t ecode_bit2__hw0_state148,
    uint8_t op_mode_quadrant,
    uint8_t cmc__bit2__pdc_limit_usage,
    uint8_t in_2,
    uint8_t rdy155,
    uint8_t coaststop,
    uint8_t lim_minus64,
    uint8_t err_bustimeout,
    uint8_t in1,
    uint8_t km_cal_off,
    uint8_t lim_minus82,
    uint8_t ecode_bit3__free99,
    uint8_t ecode_bit3__free148,
    uint8_t cmc__bit3__torqueval_init_ena,
    uint8_t in_1,
    uint8_t go155,
    uint8_t i_ist_inverse,
    uint8_t ok64,
    uint8_t err_feedbacksignal,
    uint8_t frgrun,
    primary_inverter_l_rcv_cs_ain_1_mode cs_ain_1_mode,
    uint8_t km_tx_tog_stat,
    uint8_t ok82,
    uint8_t ecode_bit4__rdy399,
    uint8_t ecode_bit4__rdy3148,
    primary_inverter_l_rcv_compare_var194 compare_var194,
    primary_inverter_l_rcv_compare_var195 compare_var195,
    primary_inverter_l_rcv_compare_var218 compare_var218,
    primary_inverter_l_rcv_compare_var219 compare_var219,
    uint8_t cmc__bit4__dig_m_rcpramp_ena,
    uint8_t run152,
    uint8_t out_3,
    uint8_t refsoft,
    uint8_t icns64,
    uint8_t err_powervoltage_low,
    uint8_t rfe216,
    uint8_t km_i_limit,
    uint8_t icns82,
    uint8_t ecode_bit5__n_fail99,
    uint8_t ecode_bit5__n_fail148,
    primary_inverter_l_rcv_mo_feedback_2 mo_feedback_2,
    uint8_t recup_is_acv,
    uint8_t cmc__bit5__reset_nramp_atnzero,
    uint8_t rfe152,
    uint8_t out_4,
    uint8_t no_uesp_btb,
    uint8_t tnlim64,
    uint8_t err_motortemp,
    uint8_t km_n_clip,
    uint8_t tnlim82,
    uint8_t ecode_bit6__flths99,
    uint8_t ecode_bit6__flths148,
    uint8_t i_dc_limit_is_acv,
    uint8_t cmc__bit6__torquetimeout_100ms_e,
    uint8_t rsvd,
    uint8_t rsvd1,
    uint8_t vdc_ana,
    uint8_t pn64,
    uint8_t err_devicetemp,
    uint8_t cs_oora1,
    uint8_t km_mix_ana_on,
    uint8_t pn82,
    uint8_t ecode_bit7__fltls99,
    uint8_t ecode_bit7__fltls148,
    uint8_t cmc__bit13_7__free,
    uint8_t brk1155,
    uint8_t i1_adc_ena,
    uint8_t ni64,
    uint8_t err_overvoltage,
    uint8_t out1,
    primary_inverter_l_rcv_cs_ain_2_mode cs_ain_2_mode,
    primary_inverter_l_rcv_ctrlsubmode ctrlsubmode,
    uint8_t km_allow_sync,
    uint8_t ni82,
    float ain_in_2_filter,
    uint8_t ecode_bit8__fail_idc99,
    uint8_t ecode_bit8__fail_idc148,
    primary_inverter_l_rcv_mo_sc1_reso mo_sc1_reso,
    primary_inverter_l_rcv_source_id194 source_id194,
    primary_inverter_l_rcv_source_id195 source_id195,
    primary_inverter_l_rcv_source_id218 source_id218,
    primary_inverter_l_rcv_source_id219 source_id219,
    uint8_t dup__bit8__can_extended_0,
    uint8_t hxinv,
    uint8_t _n064,
    uint8_t err_ipeak,
    uint8_t out2,
    uint8_t km_handwheel,
    uint8_t _n082,
    uint8_t ecode_bit9__fail_i99,
    uint8_t ecode_bit9__fail_i148,
    uint8_t dup__bit9__generator,
    uint8_t h2inv,
    uint8_t rsw64,
    uint8_t err_raceaway,
    uint8_t btbrdy,
    uint8_t km_phasing_extend,
    uint8_t rsw82,
    uint8_t ecode_bit10__vccm99,
    uint8_t ecode_bit10__vccm148,
    uint8_t dup__bit10__park_rms,
    uint8_t ol_comp,
    uint8_t cal064,
    uint8_t err_user,
    uint8_t go216,
    uint8_t cs_oora2,
    uint8_t km_rsvd_11,
    uint8_t cal082,
    uint8_t ecode_bit11__15m_minus99,
    uint8_t ecode_bit11__15m_minus148,
    uint8_t mo_sc1_comp,
    uint8_t dup__bit11__dcbus_volts,
    uint8_t test,
    primary_inverter_l_rcv_motortype motortype,
    uint8_t cal64,
    uint8_t out3,
    primary_inverter_l_rcv_cs_cmd_type cs_cmd_type,
    primary_inverter_l_rcv_currentmode currentmode,
    uint8_t km_rsvd_12,
    uint8_t cal82,
    uint8_t ecode_bit12__15m_plus99,
    uint8_t ecode_bit12__15m_plus148,
    primary_inverter_l_rcv_mo_sc2_reso mo_sc2_reso,
    uint8_t dup__bit12__boat_pedal,
    uint8_t tol64,
    uint8_t out4,
    uint8_t km_rsvd_13,
    uint8_t tol82,
    uint8_t ecode_bit13__18m_plus99,
    uint8_t ecode_bit13__18m_plus148,
    uint8_t dup__bit13__gen_autoiaclimit,
    uint8_t ana_0up,
    uint8_t rdy64,
    uint8_t err_hwerr,
    uint8_t goff,
    uint8_t cs_ain_2__i_limit,
    uint8_t km_pseudo_enable,
    uint8_t rdy82,
    uint8_t ecode_bit14__ubmam99,
    uint8_t ecode_bit14__ubmam148,
    uint8_t cmc__bit14__idc_limit_ena_v2,
    uint8_t dup__bit14__mtpa_reluct_enab,
    uint8_t lowbd,
    uint8_t brk064,
    uint8_t err_ballast,
    uint8_t brk1216,
    uint8_t cs_ain_1__n_limit,
    uint8_t km_debug_test,
    uint8_t brk082,
    uint8_t ecode_bit15__t_igbt99,
    uint8_t ecode_bit15__t_igbt148,
    uint8_t mo_sc2_inv,
    primary_inverter_l_rcv_active190 active190,
    primary_inverter_l_rcv_active191 active191,
    primary_inverter_l_rcv_active192 active192,
    primary_inverter_l_rcv_active193 active193,
    uint8_t gen_autoiaclimit_is_acv,
    uint8_t cmc__bit15__dig_e_brake_act,
    uint8_t dup__bit15__canopen_acv,
    uint16_t m_r_dec,
    uint16_t m_r_rcp,
    uint8_t sramp,
    uint8_t signmag64,
    uint8_t warn_warning_0,
    int16_t ain_in_1_scaled213,
    int16_t ain_in_2_scaled214,
    uint16_t t_dc__stop,
    float v_dc__stop,
    float v_min__stop,
    float f_min__stop,
    float v_corner__stop,
    float f_corner__stop,
    uint16_t pid_i__kp__id,
    uint16_t pid_i__ti__id,
    uint16_t pid_i__tim__id,
    float ain_in_1_scaleval,
    float ain_in_2_scaleval,
    uint8_t signmag82,
    uint16_t regen_r,
    uint16_t dc_bus_max_lim,
    uint16_t pid_i__xkp__id,
    float bat_opr_limit__gen,
    uint16_t pid_i__kf__id,
    uint8_t cmc__bit17_16__checkipeak_config,
    uint8_t dup__bit16__bamobil3_2_offcrct,
    int16_t special__stop,
    int16_t free,
    uint16_t svnrevision_nr,
    uint8_t ramp4,
    uint8_t nclip64,
    uint8_t warn_illegal_status,
    uint8_t nclip82,
    uint8_t dup__bit19_17__ecode_redefine,
    uint8_t motbrake,
    uint8_t nclip_minus64,
    uint8_t warn_safe_in,
    uint8_t nclip_minus82,
    uint8_t cmc__bit18__tractioncontrol_ena,
    uint8_t ac_dc,
    uint8_t nclip_plus64,
    uint8_t nclip_plus82,
    uint8_t cmc__bit20_19__tc_deltatime_conf,
    primary_inverter_l_rcv_pwm_freq pwm_freq,
    uint8_t irddig64,
    uint8_t irddig82,
    uint8_t dup__bit20__hal_extmr_acv,
    uint8_t iuserchd64,
    uint8_t iuserchd82,
    uint8_t cmc__bit22_21__tc_minspeed_conf,
    uint8_t dup__bit21__initwith_frg_off,
    uint8_t irdn64,
    uint8_t warn_motortemp,
    uint8_t irdn82,
    uint16_t dup__bit31_22__free,
    uint8_t ntc,
    uint8_t irdti64,
    uint8_t warn_devicetemp,
    uint8_t irdti82,
    uint8_t cmc__bit23__tc_ncmdrestoption,
    uint16_t m_r_acc,
    uint8_t delta,
    uint8_t irdtir64,
    uint8_t warn_vout_sat,
    uint8_t irdtir82,
    uint8_t cmc__bit31_24__free,
    uint8_t dc_1qdirvolt,
    uint8_t _10hz64,
    uint8_t warn_ipeak,
    uint8_t _10hz82,
    uint8_t dc_field,
    uint8_t irdtm64,
    uint8_t warn_raceaway,
    uint8_t irdtm82,
    uint8_t dead_2,
    uint8_t irdana64,
    uint8_t irdana82,
    uint8_t block,
    uint8_t iwcns64,
    uint8_t iwcns82,
    uint8_t dc_1qmv,
    uint8_t rfepulse64,
    uint8_t rfepulse82,
    uint8_t dc_1q3p,
    uint8_t md64,
    uint8_t md82,
    uint8_t reducelosses,
    uint8_t hndwhl64,
    uint8_t warn_ballast,
    uint8_t hndwhl82
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_inverter_l_rcv_conversion_to_raw(
    primary_inverter_l_rcv_t *raw,
    primary_inverter_l_rcv_rcv_mux rcv_mux,
    float n_actual,
    uint16_t n_r_dec,
    uint16_t n_r_lim,
    float n_actual_filt,
    uint16_t firmware,
    primary_inverter_l_rcv_devicetype devicetype,
    uint32_t snr,
    uint32_t axis,
    float i_device,
    uint16_t v_shunt,
    uint16_t i_200perc,
    uint8_t dc_bus_comp,
    uint8_t ena64,
    uint8_t err_badparas,
    uint8_t lmt1,
    int16_t ain_in_1_raw,
    int16_t ain_in_2_raw,
    int16_t nmax100perc,
    float n_setdig,
    int16_t n_cmd,
    float n_cmd_ramp,
    float n_lim,
    float n_error,
    int16_t m_setdig__iq,
    float id_setdig__id,
    float i_max_pk,
    float i_con_eff,
    float i_max_eff,
    float i_nom_eff,
    float i_limit_inuse,
    float i_cmd,
    float i_cmd_ramp,
    float i_actual,
    float i_actual_filt,
    float iq_actual,
    float id_actual,
    float iq_error,
    float id_error,
    float i1_actual,
    float i2_actual,
    float i3_actual,
    uint16_t i3_adc,
    uint16_t i2_adc,
    int16_t vq,
    int16_t vd,
    int16_t vout,
    uint16_t t_motor,
    uint16_t t_igbt,
    int16_t t_air,
    float vdc_bus_filt,
    uint8_t end_1,
    uint8_t din_1,
    uint8_t end_2,
    uint8_t din_2,
    uint8_t run232,
    uint8_t dout_1,
    uint8_t dout_2,
    uint8_t dout_3,
    uint8_t rdy_btb,
    uint8_t i_fault,
    uint8_t dout_4,
    float i_lim_dig,
    float i_red_n,
    uint16_t i_red_td,
    uint16_t i_red_te,
    uint16_t i_red_tm,
    primary_inverter_l_rcv_cs_ain_1_format cs_ain_1_format,
    float id_ref,
    int16_t m_outdig__iq,
    int16_t ptr_1_debug,
    int16_t ptr_2_debug,
    int16_t temp_debug,
    float motor_f_n,
    uint16_t motor_v_n,
    uint16_t t_dc__start,
    float v_dc__start,
    float v_min__start,
    float f_min__start,
    float v_corner__start,
    float f_corner__start,
    uint16_t cos_phi,
    uint16_t pwm_enum,
    float calib_ref_value,
    uint16_t pid_i__kp__iq,
    uint16_t pid_i__ti__iq,
    uint16_t cutoffdig,
    uint16_t i3_offset,
    int16_t i_delta_ramp,
    uint16_t pid_i__tim__iq,
    uint16_t pid_n__kp,
    uint16_t v_ti,
    uint16_t pid_n__td,
    int16_t ain_in_1_offsetval,
    int16_t ain_in_2_offsetval,
    uint16_t dzr_seq,
    uint16_t pid_n__tim,
    float n_lim_plus,
    float n_lim_minus,
    int16_t incr_delta,
    int16_t motorpos_mech,
    int16_t motorpos_elec,
    float fb_offset,
    int32_t it_rg_monitor,
    uint16_t motor_pole,
    int16_t ain_in_1_cutoff,
    primary_inverter_l_rcv_activecontrolmode activecontrolmode,
    uint8_t km_rsvd_0,
    uint8_t ena82,
    int16_t ain_in_2_cutoff,
    float i_limit_inuse_ramp,
    uint16_t n_nom,
    int16_t pid_n__kacc,
    uint16_t rotor_signals,
    uint16_t speed_filter,
    float ain_in_1_filter,
    uint16_t ixt_monitor,
    uint8_t ecode_bit0_firsterrordtcd99,
    uint16_t device_mains,
    uint16_t regen_p,
    uint16_t can_id_rx,
    uint16_t can_id_tx,
    uint16_t pos_kp,
    uint16_t pos_ti,
    uint16_t pos_td,
    int32_t pos_actual,
    int32_t pos_dest,
    int32_t pos_actual_2,
    int32_t pos_error,
    uint16_t pos_tim,
    int32_t pos_offsref,
    primary_inverter_l_rcv_can_nbt can_nbt,
    uint16_t pos_zero_capture,
    uint16_t ref_reso_edge,
    int16_t speed_1,
    int16_t speed_2,
    int16_t pos_tol_win,
    int32_t pos_preset_val,
    int32_t pos_zero_offset,
    int32_t pos_nd_scale,
    int32_t pos_nd_offset,
    int32_t fb2_scale_ext,
    int32_t pos_offset_slack,
    int16_t pos_diff_slack,
    uint16_t fun_para_read,
    uint16_t fun_para_write,
    uint16_t fun_special,
    uint32_t can_id_2_rx,
    uint32_t can_id_2_tx,
    int16_t v_ref,
    uint16_t v_kp,
    uint16_t pid_n__ti,
    uint16_t clear_errors,
    int32_t pos_cmd,
    uint16_t can_error_busoff,
    uint16_t can_error_writetime,
    uint8_t ecode_bit0_firsterrordtcd148,
    uint16_t can_error_no_ack,
    uint16_t can_error_crc_check150,
    uint16_t can_error_crc_check151,
    uint16_t info_timer_diff,
    int16_t ballastcount,
    uint16_t m_temp,
    primary_inverter_l_rcv_mo_feedback_1 mo_feedback_1,
    uint16_t dc_bus_min_lim,
    uint16_t fb_incr_mot,
    uint16_t fb_pole,
    uint16_t logic_freq,
    int16_t pwm_1,
    int16_t pwm_2,
    int16_t pwm_3,
    int16_t timer_delta,
    float motor_lsq,
    float motor_lsd,
    int16_t id_nom,
    float motor_lm,
    uint16_t motor_rr,
    int16_t id_min,
    int16_t motor_tr,
    uint16_t motor_rs,
    float motor_ts,
    primary_inverter_l_rcv_def_end_1 def_end_1,
    primary_inverter_l_rcv_def_end_2 def_end_2,
    primary_inverter_l_rcv_def_din_1 def_din_1,
    primary_inverter_l_rcv_def_din_2 def_din_2,
    primary_inverter_l_rcv_operand194 operand194,
    float i_max_inuse,
    uint8_t signal_go,
    uint8_t signal_brake,
    uint8_t signal_icns,
    uint8_t signal_lessn0,
    uint8_t signal_postolerance,
    int16_t ain_in_1_scaled251,
    int16_t ain_in_2_scaled252,
    primary_inverter_l_rcv_operand195 operand195,
    primary_inverter_l_rcv_operand218 operand218,
    primary_inverter_l_rcv_operand219 operand219,
    uint16_t pid_i__xkp__iq,
    float bat_opr_limit__mot,
    uint16_t pid_i__kf__iq,
    uint8_t dc_current_sens_ena_set,
    uint8_t cmc__bit0__dc_current_sens_ena,
    int16_t n_rpm_maxint,
    int32_t var_1,
    int16_t can_rxtimeout,
    int32_t var_2,
    int32_t var_3,
    int32_t var_4,
    uint8_t dup__bit7_0__dac_source_channel,
    uint8_t fb_lossofsignal,
    uint8_t no_hw_fault,
    uint16_t t_peak,
    uint16_t brake_delay,
    int16_t power,
    int16_t work,
    int16_t extra__start,
    int16_t capture_channel,
    int16_t trig_level,
    int16_t trig_edge,
    uint16_t trig_source,
    uint16_t oszi_source,
    uint16_t oszi_skip,
    uint16_t oszi_run_cmd,
    uint16_t oszi_read_cmd,
    int16_t pos_ref_start,
    float vdc_bus,
    int16_t m_cmd_ramp,
    uint8_t lmt_1,
    uint8_t out_1,
    uint16_t subversion_nr,
    uint8_t ballast_ext,
    uint8_t ncr064,
    uint8_t err_powerfault,
    uint8_t lmt2,
    uint8_t km_speed_0,
    uint8_t ncr082,
    uint8_t ecode_bit1__hw1_state99,
    uint8_t ecode_bit1__hw1_state148,
    uint8_t dc_i_sensena_set,
    uint8_t cmc__bit1__idc_limit_ena,
    uint8_t lmt_2,
    uint8_t out_2,
    uint8_t fb_special,
    uint8_t lim_plus64,
    uint8_t err_rfe_fault,
    uint8_t in2,
    primary_inverter_l_rcv_cs_ain_2_format cs_ain_2_format,
    uint8_t km_frg_off,
    uint8_t lim_plus82,
    uint8_t ecode_bit2__hw0_state99,
    uint8_t ecode_bit2__hw0_state148,
    uint8_t op_mode_quadrant,
    uint8_t cmc__bit2__pdc_limit_usage,
    uint8_t in_2,
    uint8_t rdy155,
    uint8_t coaststop,
    uint8_t lim_minus64,
    uint8_t err_bustimeout,
    uint8_t in1,
    uint8_t km_cal_off,
    uint8_t lim_minus82,
    uint8_t ecode_bit3__free99,
    uint8_t ecode_bit3__free148,
    uint8_t cmc__bit3__torqueval_init_ena,
    uint8_t in_1,
    uint8_t go155,
    uint8_t i_ist_inverse,
    uint8_t ok64,
    uint8_t err_feedbacksignal,
    uint8_t frgrun,
    primary_inverter_l_rcv_cs_ain_1_mode cs_ain_1_mode,
    uint8_t km_tx_tog_stat,
    uint8_t ok82,
    uint8_t ecode_bit4__rdy399,
    uint8_t ecode_bit4__rdy3148,
    primary_inverter_l_rcv_compare_var194 compare_var194,
    primary_inverter_l_rcv_compare_var195 compare_var195,
    primary_inverter_l_rcv_compare_var218 compare_var218,
    primary_inverter_l_rcv_compare_var219 compare_var219,
    uint8_t cmc__bit4__dig_m_rcpramp_ena,
    uint8_t run152,
    uint8_t out_3,
    uint8_t refsoft,
    uint8_t icns64,
    uint8_t err_powervoltage_low,
    uint8_t rfe216,
    uint8_t km_i_limit,
    uint8_t icns82,
    uint8_t ecode_bit5__n_fail99,
    uint8_t ecode_bit5__n_fail148,
    primary_inverter_l_rcv_mo_feedback_2 mo_feedback_2,
    uint8_t recup_is_acv,
    uint8_t cmc__bit5__reset_nramp_atnzero,
    uint8_t rfe152,
    uint8_t out_4,
    uint8_t no_uesp_btb,
    uint8_t tnlim64,
    uint8_t err_motortemp,
    uint8_t km_n_clip,
    uint8_t tnlim82,
    uint8_t ecode_bit6__flths99,
    uint8_t ecode_bit6__flths148,
    uint8_t i_dc_limit_is_acv,
    uint8_t cmc__bit6__torquetimeout_100ms_e,
    uint8_t rsvd,
    uint8_t rsvd1,
    uint8_t vdc_ana,
    uint8_t pn64,
    uint8_t err_devicetemp,
    uint8_t cs_oora1,
    uint8_t km_mix_ana_on,
    uint8_t pn82,
    uint8_t ecode_bit7__fltls99,
    uint8_t ecode_bit7__fltls148,
    uint8_t cmc__bit13_7__free,
    uint8_t brk1155,
    uint8_t i1_adc_ena,
    uint8_t ni64,
    uint8_t err_overvoltage,
    uint8_t out1,
    primary_inverter_l_rcv_cs_ain_2_mode cs_ain_2_mode,
    primary_inverter_l_rcv_ctrlsubmode ctrlsubmode,
    uint8_t km_allow_sync,
    uint8_t ni82,
    float ain_in_2_filter,
    uint8_t ecode_bit8__fail_idc99,
    uint8_t ecode_bit8__fail_idc148,
    primary_inverter_l_rcv_mo_sc1_reso mo_sc1_reso,
    primary_inverter_l_rcv_source_id194 source_id194,
    primary_inverter_l_rcv_source_id195 source_id195,
    primary_inverter_l_rcv_source_id218 source_id218,
    primary_inverter_l_rcv_source_id219 source_id219,
    uint8_t dup__bit8__can_extended_0,
    uint8_t hxinv,
    uint8_t _n064,
    uint8_t err_ipeak,
    uint8_t out2,
    uint8_t km_handwheel,
    uint8_t _n082,
    uint8_t ecode_bit9__fail_i99,
    uint8_t ecode_bit9__fail_i148,
    uint8_t dup__bit9__generator,
    uint8_t h2inv,
    uint8_t rsw64,
    uint8_t err_raceaway,
    uint8_t btbrdy,
    uint8_t km_phasing_extend,
    uint8_t rsw82,
    uint8_t ecode_bit10__vccm99,
    uint8_t ecode_bit10__vccm148,
    uint8_t dup__bit10__park_rms,
    uint8_t ol_comp,
    uint8_t cal064,
    uint8_t err_user,
    uint8_t go216,
    uint8_t cs_oora2,
    uint8_t km_rsvd_11,
    uint8_t cal082,
    uint8_t ecode_bit11__15m_minus99,
    uint8_t ecode_bit11__15m_minus148,
    uint8_t mo_sc1_comp,
    uint8_t dup__bit11__dcbus_volts,
    uint8_t test,
    primary_inverter_l_rcv_motortype motortype,
    uint8_t cal64,
    uint8_t out3,
    primary_inverter_l_rcv_cs_cmd_type cs_cmd_type,
    primary_inverter_l_rcv_currentmode currentmode,
    uint8_t km_rsvd_12,
    uint8_t cal82,
    uint8_t ecode_bit12__15m_plus99,
    uint8_t ecode_bit12__15m_plus148,
    primary_inverter_l_rcv_mo_sc2_reso mo_sc2_reso,
    uint8_t dup__bit12__boat_pedal,
    uint8_t tol64,
    uint8_t out4,
    uint8_t km_rsvd_13,
    uint8_t tol82,
    uint8_t ecode_bit13__18m_plus99,
    uint8_t ecode_bit13__18m_plus148,
    uint8_t dup__bit13__gen_autoiaclimit,
    uint8_t ana_0up,
    uint8_t rdy64,
    uint8_t err_hwerr,
    uint8_t goff,
    uint8_t cs_ain_2__i_limit,
    uint8_t km_pseudo_enable,
    uint8_t rdy82,
    uint8_t ecode_bit14__ubmam99,
    uint8_t ecode_bit14__ubmam148,
    uint8_t cmc__bit14__idc_limit_ena_v2,
    uint8_t dup__bit14__mtpa_reluct_enab,
    uint8_t lowbd,
    uint8_t brk064,
    uint8_t err_ballast,
    uint8_t brk1216,
    uint8_t cs_ain_1__n_limit,
    uint8_t km_debug_test,
    uint8_t brk082,
    uint8_t ecode_bit15__t_igbt99,
    uint8_t ecode_bit15__t_igbt148,
    uint8_t mo_sc2_inv,
    primary_inverter_l_rcv_active190 active190,
    primary_inverter_l_rcv_active191 active191,
    primary_inverter_l_rcv_active192 active192,
    primary_inverter_l_rcv_active193 active193,
    uint8_t gen_autoiaclimit_is_acv,
    uint8_t cmc__bit15__dig_e_brake_act,
    uint8_t dup__bit15__canopen_acv,
    uint16_t m_r_dec,
    uint16_t m_r_rcp,
    uint8_t sramp,
    uint8_t signmag64,
    uint8_t warn_warning_0,
    int16_t ain_in_1_scaled213,
    int16_t ain_in_2_scaled214,
    uint16_t t_dc__stop,
    float v_dc__stop,
    float v_min__stop,
    float f_min__stop,
    float v_corner__stop,
    float f_corner__stop,
    uint16_t pid_i__kp__id,
    uint16_t pid_i__ti__id,
    uint16_t pid_i__tim__id,
    float ain_in_1_scaleval,
    float ain_in_2_scaleval,
    uint8_t signmag82,
    uint16_t regen_r,
    uint16_t dc_bus_max_lim,
    uint16_t pid_i__xkp__id,
    float bat_opr_limit__gen,
    uint16_t pid_i__kf__id,
    uint8_t cmc__bit17_16__checkipeak_config,
    uint8_t dup__bit16__bamobil3_2_offcrct,
    int16_t special__stop,
    int16_t free,
    uint16_t svnrevision_nr,
    uint8_t ramp4,
    uint8_t nclip64,
    uint8_t warn_illegal_status,
    uint8_t nclip82,
    uint8_t dup__bit19_17__ecode_redefine,
    uint8_t motbrake,
    uint8_t nclip_minus64,
    uint8_t warn_safe_in,
    uint8_t nclip_minus82,
    uint8_t cmc__bit18__tractioncontrol_ena,
    uint8_t ac_dc,
    uint8_t nclip_plus64,
    uint8_t nclip_plus82,
    uint8_t cmc__bit20_19__tc_deltatime_conf,
    primary_inverter_l_rcv_pwm_freq pwm_freq,
    uint8_t irddig64,
    uint8_t irddig82,
    uint8_t dup__bit20__hal_extmr_acv,
    uint8_t iuserchd64,
    uint8_t iuserchd82,
    uint8_t cmc__bit22_21__tc_minspeed_conf,
    uint8_t dup__bit21__initwith_frg_off,
    uint8_t irdn64,
    uint8_t warn_motortemp,
    uint8_t irdn82,
    uint16_t dup__bit31_22__free,
    uint8_t ntc,
    uint8_t irdti64,
    uint8_t warn_devicetemp,
    uint8_t irdti82,
    uint8_t cmc__bit23__tc_ncmdrestoption,
    uint16_t m_r_acc,
    uint8_t delta,
    uint8_t irdtir64,
    uint8_t warn_vout_sat,
    uint8_t irdtir82,
    uint8_t cmc__bit31_24__free,
    uint8_t dc_1qdirvolt,
    uint8_t _10hz64,
    uint8_t warn_ipeak,
    uint8_t _10hz82,
    uint8_t dc_field,
    uint8_t irdtm64,
    uint8_t warn_raceaway,
    uint8_t irdtm82,
    uint8_t dead_2,
    uint8_t irdana64,
    uint8_t irdana82,
    uint8_t block,
    uint8_t iwcns64,
    uint8_t iwcns82,
    uint8_t dc_1qmv,
    uint8_t rfepulse64,
    uint8_t rfepulse82,
    uint8_t dc_1q3p,
    uint8_t md64,
    uint8_t md82,
    uint8_t reducelosses,
    uint8_t hndwhl64,
    uint8_t warn_ballast,
    uint8_t hndwhl82
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_inverter_l_rcv_raw_to_conversion_struct(
    primary_inverter_l_rcv_converted_t *conversion, 
    const primary_inverter_l_rcv_t *raw);


void primary_inverter_l_rcv_conversion_to_raw_struct(
    primary_inverter_l_rcv_t *raw,
    const primary_inverter_l_rcv_converted_t *conversion);

int primary_inverter_l_rcv_rcv_mux_enum_to_string(primary_inverter_l_rcv_rcv_mux value, char *buffer);
int primary_inverter_l_rcv_devicetype_enum_to_string(primary_inverter_l_rcv_devicetype value, char *buffer);
int primary_inverter_l_rcv_cs_ain_1_format_enum_to_string(primary_inverter_l_rcv_cs_ain_1_format value, char *buffer);
int primary_inverter_l_rcv_activecontrolmode_enum_to_string(primary_inverter_l_rcv_activecontrolmode value, char *buffer);
int primary_inverter_l_rcv_can_nbt_enum_to_string(primary_inverter_l_rcv_can_nbt value, char *buffer);
int primary_inverter_l_rcv_mo_feedback_1_enum_to_string(primary_inverter_l_rcv_mo_feedback_1 value, char *buffer);
int primary_inverter_l_rcv_def_end_1_enum_to_string(primary_inverter_l_rcv_def_end_1 value, char *buffer);
int primary_inverter_l_rcv_def_end_2_enum_to_string(primary_inverter_l_rcv_def_end_2 value, char *buffer);
int primary_inverter_l_rcv_def_din_1_enum_to_string(primary_inverter_l_rcv_def_din_1 value, char *buffer);
int primary_inverter_l_rcv_def_din_2_enum_to_string(primary_inverter_l_rcv_def_din_2 value, char *buffer);
int primary_inverter_l_rcv_operand194_enum_to_string(primary_inverter_l_rcv_operand194 value, char *buffer);
int primary_inverter_l_rcv_operand195_enum_to_string(primary_inverter_l_rcv_operand195 value, char *buffer);
int primary_inverter_l_rcv_operand218_enum_to_string(primary_inverter_l_rcv_operand218 value, char *buffer);
int primary_inverter_l_rcv_operand219_enum_to_string(primary_inverter_l_rcv_operand219 value, char *buffer);
int primary_inverter_l_rcv_cs_ain_2_format_enum_to_string(primary_inverter_l_rcv_cs_ain_2_format value, char *buffer);
int primary_inverter_l_rcv_cs_ain_1_mode_enum_to_string(primary_inverter_l_rcv_cs_ain_1_mode value, char *buffer);
int primary_inverter_l_rcv_compare_var194_enum_to_string(primary_inverter_l_rcv_compare_var194 value, char *buffer);
int primary_inverter_l_rcv_compare_var195_enum_to_string(primary_inverter_l_rcv_compare_var195 value, char *buffer);
int primary_inverter_l_rcv_compare_var218_enum_to_string(primary_inverter_l_rcv_compare_var218 value, char *buffer);
int primary_inverter_l_rcv_compare_var219_enum_to_string(primary_inverter_l_rcv_compare_var219 value, char *buffer);
int primary_inverter_l_rcv_mo_feedback_2_enum_to_string(primary_inverter_l_rcv_mo_feedback_2 value, char *buffer);
int primary_inverter_l_rcv_cs_ain_2_mode_enum_to_string(primary_inverter_l_rcv_cs_ain_2_mode value, char *buffer);
int primary_inverter_l_rcv_ctrlsubmode_enum_to_string(primary_inverter_l_rcv_ctrlsubmode value, char *buffer);
int primary_inverter_l_rcv_mo_sc1_reso_enum_to_string(primary_inverter_l_rcv_mo_sc1_reso value, char *buffer);
int primary_inverter_l_rcv_source_id194_enum_to_string(primary_inverter_l_rcv_source_id194 value, char *buffer);
int primary_inverter_l_rcv_source_id195_enum_to_string(primary_inverter_l_rcv_source_id195 value, char *buffer);
int primary_inverter_l_rcv_source_id218_enum_to_string(primary_inverter_l_rcv_source_id218 value, char *buffer);
int primary_inverter_l_rcv_source_id219_enum_to_string(primary_inverter_l_rcv_source_id219 value, char *buffer);
int primary_inverter_l_rcv_motortype_enum_to_string(primary_inverter_l_rcv_motortype value, char *buffer);
int primary_inverter_l_rcv_cs_cmd_type_enum_to_string(primary_inverter_l_rcv_cs_cmd_type value, char *buffer);
int primary_inverter_l_rcv_currentmode_enum_to_string(primary_inverter_l_rcv_currentmode value, char *buffer);
int primary_inverter_l_rcv_mo_sc2_reso_enum_to_string(primary_inverter_l_rcv_mo_sc2_reso value, char *buffer);
int primary_inverter_l_rcv_active190_enum_to_string(primary_inverter_l_rcv_active190 value, char *buffer);
int primary_inverter_l_rcv_active191_enum_to_string(primary_inverter_l_rcv_active191 value, char *buffer);
int primary_inverter_l_rcv_active192_enum_to_string(primary_inverter_l_rcv_active192 value, char *buffer);
int primary_inverter_l_rcv_active193_enum_to_string(primary_inverter_l_rcv_active193 value, char *buffer);
int primary_inverter_l_rcv_pwm_freq_enum_to_string(primary_inverter_l_rcv_pwm_freq value, char *buffer);

int primary_inverter_l_rcv_converted_to_string(primary_inverter_l_rcv_converted_t *message, char *buffer);

int primary_inverter_l_rcv_converted_to_string_file(primary_inverter_l_rcv_converted_t *message, FILE *buffer);

int primary_inverter_l_rcv_fields(char *buffer);

int primary_inverter_l_rcv_fields_file(FILE *buffer);

/**
 * Pack message Inverter_L_Rcv.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_inverter_l_rcv_pack(
    uint8_t *dst_p,
    const primary_inverter_l_rcv_t *src_p,
    size_t size);

/**
 * Unpack message Inverter_L_Rcv.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_inverter_l_rcv_unpack(
    primary_inverter_l_rcv_t *dst_p,
    const uint8_t *src_p,
    size_t size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_rcv_mux_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t primary_inverter_l_rcv_n_actual_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_l_rcv_n_actual_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_n_actual_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_n_r_dec_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_n_r_lim_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t primary_inverter_l_rcv_n_actual_filt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_l_rcv_n_actual_filt_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_n_actual_filt_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_firmware_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_devicetype_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_snr_is_in_range(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_axis_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_inverter_l_rcv_i_device_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_l_rcv_i_device_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_i_device_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_v_shunt_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_i_200perc_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_dc_bus_comp_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_ena64_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_err_badparas_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_lmt1_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_ain_in_1_raw_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_ain_in_2_raw_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_nmax100perc_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t primary_inverter_l_rcv_n_setdig_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_l_rcv_n_setdig_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_n_setdig_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_n_cmd_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t primary_inverter_l_rcv_n_cmd_ramp_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_l_rcv_n_cmd_ramp_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_n_cmd_ramp_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t primary_inverter_l_rcv_n_lim_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_l_rcv_n_lim_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_n_lim_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t primary_inverter_l_rcv_n_error_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_l_rcv_n_error_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_n_error_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_m_setdig__iq_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t primary_inverter_l_rcv_id_setdig__id_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_l_rcv_id_setdig__id_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_id_setdig__id_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_inverter_l_rcv_i_max_pk_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_l_rcv_i_max_pk_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_i_max_pk_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_inverter_l_rcv_i_con_eff_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_l_rcv_i_con_eff_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_i_con_eff_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_inverter_l_rcv_i_max_eff_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_l_rcv_i_max_eff_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_i_max_eff_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_inverter_l_rcv_i_nom_eff_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_l_rcv_i_nom_eff_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_i_nom_eff_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t primary_inverter_l_rcv_i_limit_inuse_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_l_rcv_i_limit_inuse_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_i_limit_inuse_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t primary_inverter_l_rcv_i_cmd_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_l_rcv_i_cmd_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_i_cmd_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t primary_inverter_l_rcv_i_cmd_ramp_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_l_rcv_i_cmd_ramp_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_i_cmd_ramp_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t primary_inverter_l_rcv_i_actual_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_l_rcv_i_actual_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_i_actual_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t primary_inverter_l_rcv_i_actual_filt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_l_rcv_i_actual_filt_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_i_actual_filt_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t primary_inverter_l_rcv_iq_actual_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_l_rcv_iq_actual_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_iq_actual_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t primary_inverter_l_rcv_id_actual_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_l_rcv_id_actual_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_id_actual_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t primary_inverter_l_rcv_iq_error_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_l_rcv_iq_error_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_iq_error_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t primary_inverter_l_rcv_id_error_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_l_rcv_id_error_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_id_error_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t primary_inverter_l_rcv_i1_actual_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_l_rcv_i1_actual_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_i1_actual_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t primary_inverter_l_rcv_i2_actual_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_l_rcv_i2_actual_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_i2_actual_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t primary_inverter_l_rcv_i3_actual_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_l_rcv_i3_actual_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_i3_actual_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_i3_adc_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_i2_adc_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_vq_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_vd_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_vout_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_t_motor_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_t_igbt_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_t_air_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_inverter_l_rcv_vdc_bus_filt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_l_rcv_vdc_bus_filt_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_vdc_bus_filt_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_end_1_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_din_1_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_end_2_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_din_2_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_run232_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_dout_1_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_dout_2_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_dout_3_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_rdy_btb_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_i_fault_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_dout_4_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t primary_inverter_l_rcv_i_lim_dig_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_l_rcv_i_lim_dig_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_i_lim_dig_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_inverter_l_rcv_i_red_n_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_l_rcv_i_red_n_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_i_red_n_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_i_red_td_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_i_red_te_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_i_red_tm_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_cs_ain_1_format_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t primary_inverter_l_rcv_id_ref_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_l_rcv_id_ref_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_id_ref_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_m_outdig__iq_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_ptr_1_debug_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_ptr_2_debug_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_temp_debug_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_inverter_l_rcv_motor_f_n_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_l_rcv_motor_f_n_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_motor_f_n_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_motor_v_n_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_t_dc__start_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t primary_inverter_l_rcv_v_dc__start_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_l_rcv_v_dc__start_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_v_dc__start_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t primary_inverter_l_rcv_v_min__start_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_l_rcv_v_min__start_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_v_min__start_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t primary_inverter_l_rcv_f_min__start_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_l_rcv_f_min__start_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_f_min__start_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t primary_inverter_l_rcv_v_corner__start_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_l_rcv_v_corner__start_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_v_corner__start_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t primary_inverter_l_rcv_f_corner__start_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_l_rcv_f_corner__start_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_f_corner__start_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_cos_phi_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_pwm_enum_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_inverter_l_rcv_calib_ref_value_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_l_rcv_calib_ref_value_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_calib_ref_value_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_pid_i__kp__iq_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_pid_i__ti__iq_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_cutoffdig_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_i3_offset_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_i_delta_ramp_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_pid_i__tim__iq_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_pid_n__kp_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_v_ti_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_pid_n__td_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_ain_in_1_offsetval_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_ain_in_2_offsetval_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_dzr_seq_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_pid_n__tim_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t primary_inverter_l_rcv_n_lim_plus_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_l_rcv_n_lim_plus_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_n_lim_plus_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t primary_inverter_l_rcv_n_lim_minus_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_l_rcv_n_lim_minus_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_n_lim_minus_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_incr_delta_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_motorpos_mech_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_motorpos_elec_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t primary_inverter_l_rcv_fb_offset_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_l_rcv_fb_offset_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_fb_offset_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_it_rg_monitor_is_in_range(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_motor_pole_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_ain_in_1_cutoff_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_activecontrolmode_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_km_rsvd_0_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_ena82_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_ain_in_2_cutoff_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t primary_inverter_l_rcv_i_limit_inuse_ramp_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_l_rcv_i_limit_inuse_ramp_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_i_limit_inuse_ramp_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_n_nom_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_pid_n__kacc_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_rotor_signals_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_speed_filter_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t primary_inverter_l_rcv_ain_in_1_filter_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_l_rcv_ain_in_1_filter_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_ain_in_1_filter_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_ixt_monitor_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_ecode_bit0_firsterrordtcd99_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_device_mains_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_regen_p_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_can_id_rx_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_can_id_tx_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_pos_kp_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_pos_ti_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_pos_td_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_pos_actual_is_in_range(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_pos_dest_is_in_range(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_pos_actual_2_is_in_range(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_pos_error_is_in_range(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_pos_tim_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_pos_offsref_is_in_range(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_can_nbt_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_pos_zero_capture_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_ref_reso_edge_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_speed_1_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_speed_2_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_pos_tol_win_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_pos_preset_val_is_in_range(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_pos_zero_offset_is_in_range(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_pos_nd_scale_is_in_range(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_pos_nd_offset_is_in_range(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_fb2_scale_ext_is_in_range(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_pos_offset_slack_is_in_range(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_pos_diff_slack_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_fun_para_read_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_fun_para_write_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_fun_special_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_can_id_2_rx_is_in_range(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_can_id_2_tx_is_in_range(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_v_ref_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_v_kp_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_pid_n__ti_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_clear_errors_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_pos_cmd_is_in_range(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_can_error_busoff_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_can_error_writetime_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_ecode_bit0_firsterrordtcd148_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_can_error_no_ack_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_can_error_crc_check150_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_can_error_crc_check151_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_info_timer_diff_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_ballastcount_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_m_temp_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_mo_feedback_1_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_dc_bus_min_lim_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_fb_incr_mot_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_fb_pole_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_logic_freq_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_pwm_1_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_pwm_2_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_pwm_3_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_timer_delta_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_inverter_l_rcv_motor_lsq_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_l_rcv_motor_lsq_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_motor_lsq_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_inverter_l_rcv_motor_lsd_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_l_rcv_motor_lsd_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_motor_lsd_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_id_nom_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_inverter_l_rcv_motor_lm_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_l_rcv_motor_lm_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_motor_lm_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_motor_rr_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_id_min_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_motor_tr_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_motor_rs_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t primary_inverter_l_rcv_motor_ts_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_l_rcv_motor_ts_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_motor_ts_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_def_end_1_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_def_end_2_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_def_din_1_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_def_din_2_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_operand194_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t primary_inverter_l_rcv_i_max_inuse_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_l_rcv_i_max_inuse_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_i_max_inuse_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_signal_go_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_signal_brake_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_signal_icns_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_signal_lessn0_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_signal_postolerance_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_ain_in_1_scaled251_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_ain_in_2_scaled252_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_operand195_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_operand218_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_operand219_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_pid_i__xkp__iq_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_inverter_l_rcv_bat_opr_limit__mot_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_l_rcv_bat_opr_limit__mot_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_bat_opr_limit__mot_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_pid_i__kf__iq_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_dc_current_sens_ena_set_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_cmc__bit0__dc_current_sens_ena_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_n_rpm_maxint_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_var_1_is_in_range(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_can_rxtimeout_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_var_2_is_in_range(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_var_3_is_in_range(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_var_4_is_in_range(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_dup__bit7_0__dac_source_channel_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_fb_lossofsignal_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_no_hw_fault_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_t_peak_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_brake_delay_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_power_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_work_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_extra__start_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_capture_channel_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_trig_level_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_trig_edge_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_trig_source_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_oszi_source_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_oszi_skip_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_oszi_run_cmd_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_oszi_read_cmd_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_pos_ref_start_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_inverter_l_rcv_vdc_bus_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_l_rcv_vdc_bus_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_vdc_bus_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_m_cmd_ramp_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_lmt_1_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_out_1_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_subversion_nr_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_ballast_ext_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_ncr064_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_err_powerfault_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_lmt2_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_km_speed_0_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_ncr082_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_ecode_bit1__hw1_state99_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_ecode_bit1__hw1_state148_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_dc_i_sensena_set_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_cmc__bit1__idc_limit_ena_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_lmt_2_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_out_2_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_fb_special_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_lim_plus64_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_err_rfe_fault_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_in2_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_cs_ain_2_format_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_km_frg_off_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_lim_plus82_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_ecode_bit2__hw0_state99_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_ecode_bit2__hw0_state148_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_op_mode_quadrant_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_cmc__bit2__pdc_limit_usage_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_in_2_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_rdy155_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_coaststop_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_lim_minus64_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_err_bustimeout_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_in1_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_km_cal_off_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_lim_minus82_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_ecode_bit3__free99_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_ecode_bit3__free148_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_cmc__bit3__torqueval_init_ena_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_in_1_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_go155_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_i_ist_inverse_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_ok64_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_err_feedbacksignal_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_frgrun_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_cs_ain_1_mode_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_km_tx_tog_stat_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_ok82_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_ecode_bit4__rdy399_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_ecode_bit4__rdy3148_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_compare_var194_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_compare_var195_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_compare_var218_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_compare_var219_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_cmc__bit4__dig_m_rcpramp_ena_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_run152_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_out_3_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_refsoft_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_icns64_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_err_powervoltage_low_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_rfe216_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_km_i_limit_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_icns82_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_ecode_bit5__n_fail99_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_ecode_bit5__n_fail148_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_mo_feedback_2_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_recup_is_acv_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_cmc__bit5__reset_nramp_atnzero_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_rfe152_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_out_4_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_no_uesp_btb_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_tnlim64_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_err_motortemp_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_km_n_clip_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_tnlim82_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_ecode_bit6__flths99_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_ecode_bit6__flths148_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_i_dc_limit_is_acv_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_cmc__bit6__torquetimeout_100ms_e_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_rsvd_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_rsvd1_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_vdc_ana_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_pn64_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_err_devicetemp_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_cs_oora1_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_km_mix_ana_on_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_pn82_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_ecode_bit7__fltls99_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_ecode_bit7__fltls148_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_cmc__bit13_7__free_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_brk1155_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_i1_adc_ena_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_ni64_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_err_overvoltage_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_out1_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_cs_ain_2_mode_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_ctrlsubmode_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_km_allow_sync_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_ni82_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t primary_inverter_l_rcv_ain_in_2_filter_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_l_rcv_ain_in_2_filter_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_ain_in_2_filter_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_ecode_bit8__fail_idc99_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_ecode_bit8__fail_idc148_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_mo_sc1_reso_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_source_id194_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_source_id195_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_source_id218_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_source_id219_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_dup__bit8__can_extended_0_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_hxinv_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv__n064_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_err_ipeak_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_out2_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_km_handwheel_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv__n082_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_ecode_bit9__fail_i99_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_ecode_bit9__fail_i148_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_dup__bit9__generator_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_h2inv_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_rsw64_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_err_raceaway_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_btbrdy_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_km_phasing_extend_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_rsw82_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_ecode_bit10__vccm99_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_ecode_bit10__vccm148_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_dup__bit10__park_rms_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_ol_comp_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_cal064_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_err_user_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_go216_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_cs_oora2_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_km_rsvd_11_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_cal082_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_ecode_bit11__15m_minus99_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_ecode_bit11__15m_minus148_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_mo_sc1_comp_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_dup__bit11__dcbus_volts_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_test_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_motortype_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_cal64_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_out3_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_cs_cmd_type_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_currentmode_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_km_rsvd_12_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_cal82_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_ecode_bit12__15m_plus99_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_ecode_bit12__15m_plus148_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_mo_sc2_reso_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_dup__bit12__boat_pedal_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_tol64_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_out4_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_km_rsvd_13_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_tol82_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_ecode_bit13__18m_plus99_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_ecode_bit13__18m_plus148_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_dup__bit13__gen_autoiaclimit_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_ana_0up_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_rdy64_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_err_hwerr_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_goff_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_cs_ain_2__i_limit_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_km_pseudo_enable_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_rdy82_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_ecode_bit14__ubmam99_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_ecode_bit14__ubmam148_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_cmc__bit14__idc_limit_ena_v2_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_dup__bit14__mtpa_reluct_enab_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_lowbd_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_brk064_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_err_ballast_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_brk1216_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_cs_ain_1__n_limit_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_km_debug_test_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_brk082_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_ecode_bit15__t_igbt99_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_ecode_bit15__t_igbt148_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_mo_sc2_inv_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_active190_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_active191_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_active192_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_active193_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_gen_autoiaclimit_is_acv_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_cmc__bit15__dig_e_brake_act_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_dup__bit15__canopen_acv_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_m_r_dec_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_m_r_rcp_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_sramp_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_signmag64_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_warn_warning_0_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_ain_in_1_scaled213_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_ain_in_2_scaled214_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_t_dc__stop_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t primary_inverter_l_rcv_v_dc__stop_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_l_rcv_v_dc__stop_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_v_dc__stop_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t primary_inverter_l_rcv_v_min__stop_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_l_rcv_v_min__stop_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_v_min__stop_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t primary_inverter_l_rcv_f_min__stop_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_l_rcv_f_min__stop_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_f_min__stop_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t primary_inverter_l_rcv_v_corner__stop_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_l_rcv_v_corner__stop_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_v_corner__stop_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t primary_inverter_l_rcv_f_corner__stop_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_l_rcv_f_corner__stop_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_f_corner__stop_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_pid_i__kp__id_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_pid_i__ti__id_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_pid_i__tim__id_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t primary_inverter_l_rcv_ain_in_1_scaleval_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_l_rcv_ain_in_1_scaleval_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_ain_in_1_scaleval_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t primary_inverter_l_rcv_ain_in_2_scaleval_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_l_rcv_ain_in_2_scaleval_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_ain_in_2_scaleval_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_signmag82_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_regen_r_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_dc_bus_max_lim_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_pid_i__xkp__id_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_inverter_l_rcv_bat_opr_limit__gen_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_l_rcv_bat_opr_limit__gen_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_bat_opr_limit__gen_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_pid_i__kf__id_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_cmc__bit17_16__checkipeak_config_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_dup__bit16__bamobil3_2_offcrct_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_special__stop_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_free_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_svnrevision_nr_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_ramp4_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_nclip64_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_warn_illegal_status_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_nclip82_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_dup__bit19_17__ecode_redefine_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_motbrake_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_nclip_minus64_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_warn_safe_in_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_nclip_minus82_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_cmc__bit18__tractioncontrol_ena_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_ac_dc_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_nclip_plus64_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_nclip_plus82_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_cmc__bit20_19__tc_deltatime_conf_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_pwm_freq_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_irddig64_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_irddig82_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_dup__bit20__hal_extmr_acv_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_iuserchd64_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_iuserchd82_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_cmc__bit22_21__tc_minspeed_conf_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_dup__bit21__initwith_frg_off_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_irdn64_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_warn_motortemp_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_irdn82_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_dup__bit31_22__free_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_ntc_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_irdti64_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_warn_devicetemp_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_irdti82_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_cmc__bit23__tc_ncmdrestoption_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_m_r_acc_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_delta_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_irdtir64_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_warn_vout_sat_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_irdtir82_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_cmc__bit31_24__free_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_dc_1qdirvolt_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv__10hz64_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_warn_ipeak_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv__10hz82_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_dc_field_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_irdtm64_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_warn_raceaway_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_irdtm82_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_dead_2_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_irdana64_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_irdana82_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_block_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_iwcns64_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_iwcns82_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_dc_1qmv_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_rfepulse64_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_rfepulse82_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_dc_1q3p_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_md64_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_md82_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_reducelosses_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_hndwhl64_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_warn_ballast_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_l_rcv_hndwhl82_is_in_range(uint8_t value);


void primary_inverter_r_send_raw_to_conversion(
    primary_inverter_r_send_converted_t *conversion,
    uint8_t send_mux,
    float motor_f_n,
    uint16_t t_dc__start,
    float v_dc__start,
    int16_t special__start,
    float v_min__start,
    float f_min__start,
    float v_corner__start,
    float f_corner__start,
    uint16_t cos_phi,
    int16_t extra__start,
    int16_t capture_channel,
    int16_t trig_level,
    int16_t trig_edge,
    uint16_t trig_source,
    uint16_t oszi_source,
    uint16_t oszi_skip,
    uint16_t oszi_read_cmd,
    uint16_t oszi_run_cmd,
    float calib_ref_value,
    uint16_t pid_i__kp__iq,
    uint16_t pid_i__ti__iq,
    uint16_t cutoffdig,
    float id_setdig__id,
    int16_t i_delta_ramp,
    uint16_t pid_i__tim__iq,
    uint16_t pid_n__kp,
    uint16_t pid_n__ti,
    uint16_t pid_n__td,
    int16_t ain_in_1_offsetval,
    float n_setdig,
    float n_lim,
    uint16_t n_r_acc,
    uint8_t cs_ain_1_format,
    uint16_t pid_n__tim,
    float i_red_n,
    float n_lim_minus,
    float n_lim_plus,
    float fb_offset,
    uint8_t read_id,
    float i_lim_dig,
    uint16_t i_red_te,
    float i_max_eff,
    float i_nom_eff,
    uint16_t motor_pole,
    int16_t ain_in_1_cutoff,
    uint8_t km_rsvd_0,
    int16_t ain_in_2_cutoff,
    uint16_t i_red_td,
    uint16_t n_nom,
    uint8_t dc_bus_comp,
    int16_t pid_n__kacc,
    uint16_t speed_filter,
    float ain_in_1_filter,
    uint32_t snr,
    uint16_t device_mains,
    uint16_t regen_p,
    uint8_t devicetype,
    uint16_t can_id_rx,
    uint16_t can_id_tx,
    uint16_t pos_kp,
    uint16_t pos_ti,
    uint16_t pos_td,
    int32_t pos_dest,
    uint16_t pos_tim,
    int32_t pos_offsref,
    uint16_t can_nbt,
    uint16_t ref_reso_edge,
    int16_t speed_1,
    int16_t speed_2,
    int16_t pos_tol_win,
    int32_t pos_preset_val,
    int32_t pos_nd_scale,
    int32_t pos_nd_offset,
    int32_t fb2_scale_ext,
    int32_t pos_offset_slack,
    int16_t pos_diff_slack,
    uint8_t eprom131,
    uint8_t eprom132,
    uint16_t fun_special,
    uint32_t can_id_2_rx,
    uint32_t can_id_2_tx,
    int16_t v_ref,
    uint16_t v_kp,
    uint16_t v_ti,
    uint16_t clear_errors,
    int16_t m_setdig__iq,
    uint16_t i_red_tm,
    uint16_t m_temp,
    uint8_t mo_feedback_1,
    uint16_t dc_bus_min_lim,
    uint16_t fb_incr_mot,
    uint16_t fb_pole,
    float motor_lsq,
    int16_t id_nom,
    float motor_lm,
    uint16_t motor_rr,
    int16_t id_min,
    int16_t motor_tr,
    float motor_lsd,
    uint16_t motor_rs,
    float motor_ts,
    uint16_t def_end_1,
    uint16_t def_end_2,
    uint16_t def_din_1,
    uint16_t def_din_2,
    uint8_t operand194,
    uint8_t operand195,
    uint8_t operand218,
    uint8_t operand219,
    float i_max_pk,
    float i_con_eff,
    float i_device,
    uint16_t n_r_lim,
    int16_t nmax100perc,
    uint16_t pid_i__xkp__iq,
    float bat_opr_limit__mot,
    uint16_t pid_i__kf__iq,
    uint8_t cmc__bit0__dc_current_sens_ena,
    int16_t can_rxtimeout,
    int32_t var_1,
    int32_t var_2,
    int32_t var_3,
    int32_t var_4,
    int16_t ain_in_2_offsetval,
    uint8_t dup__bit7_0__dac_source_channel,
    uint16_t n_r_dec,
    uint16_t v_shunt,
    uint16_t t_peak,
    uint16_t brake_delay,
    uint32_t axis,
    uint8_t km_speed_0,
    uint8_t ballast_ext,
    uint8_t cmc__bit1__idc_limit_ena,
    uint8_t cs_ain_2_format,
    uint8_t km_frg_off,
    uint8_t fb_special,
    uint8_t cmc__bit2__pdc_limit_usage,
    uint8_t km_cal_off,
    uint8_t coaststop,
    uint8_t cmc__bit3__torqueval_init_ena,
    uint8_t cs_ain_1_mode,
    uint8_t km_tx_tog_stat,
    uint8_t i_ist_inverse,
    uint8_t compare_var194,
    uint8_t compare_var195,
    uint8_t compare_var218,
    uint8_t compare_var219,
    uint8_t cmc__bit4__dig_m_rcpramp_ena,
    uint8_t km_i_limit,
    uint8_t refsoft,
    uint8_t mo_feedback_2,
    uint8_t cmc__bit5__reset_nramp_atnzero,
    uint8_t km_n_clip,
    uint8_t no_uesp_btb,
    uint8_t cmc__bit6__torquetimeout_100ms_e,
    uint8_t cs_oora1,
    uint8_t km_mix_ana_on,
    uint8_t vdc_ana,
    uint8_t cmc__bit13_7__free,
    uint8_t cs_ain_2_mode,
    uint8_t ret_interval,
    uint8_t km_allow_sync,
    uint8_t i1_adc_ena,
    float ain_in_2_filter,
    uint8_t mo_sc1_reso,
    uint8_t source_id194,
    uint8_t source_id195,
    uint8_t source_id218,
    uint8_t source_id219,
    uint8_t dup__bit8__can_extended_0,
    uint8_t km_handwheel,
    uint8_t hxinv,
    uint8_t dup__bit9__generator,
    uint8_t km_phasing_extend,
    uint8_t h2inv,
    uint8_t dup__bit10__park_rms,
    uint8_t cs_oora2,
    uint8_t km_rsvd_11,
    uint8_t ol_comp,
    uint8_t mo_sc1_comp,
    uint8_t dup__bit11__dcbus_volts,
    uint8_t cs_cmd_type,
    uint8_t km_rsvd_12,
    uint8_t motortype,
    uint8_t mo_sc2_reso,
    uint8_t dup__bit12__boat_pedal,
    uint8_t km_rsvd_13,
    uint8_t dup__bit13__gen_autoiaclimit,
    uint8_t cs_ain_2__i_limit,
    uint8_t km_pseudo_enable,
    uint8_t ana_0up,
    uint8_t cmc__bit14__idc_limit_ena_v2,
    uint8_t dup__bit14__mtpa_reluct_enab,
    uint8_t cs_ain_1__n_limit,
    uint8_t km_debug_test,
    uint8_t lowbd,
    uint8_t mo_sc2_inv,
    uint8_t active190,
    uint8_t active191,
    uint8_t active192,
    uint8_t active193,
    uint8_t cmc__bit15__dig_e_brake_act,
    uint8_t dup__bit15__canopen_acv,
    uint16_t t_dc__stop,
    float v_dc__stop,
    int16_t special__stop,
    float v_min__stop,
    float f_min__stop,
    float v_corner__stop,
    float f_corner__stop,
    uint16_t pid_i__kp__id,
    uint16_t pid_i__ti__id,
    uint16_t pid_i__tim__id,
    float ain_in_1_scaleval,
    uint16_t m_r_acc,
    uint8_t sramp,
    uint16_t regen_r,
    uint16_t dc_bus_max_lim,
    uint16_t m_r_rcp,
    uint16_t pid_i__xkp__id,
    float bat_opr_limit__gen,
    uint16_t pid_i__kf__id,
    uint8_t cmc__bit17_16__checkipeak_config,
    float ain_in_2_scaleval,
    uint8_t dup__bit16__bamobil3_2_offcrct,
    uint16_t m_r_dec,
    uint8_t ramp4,
    uint8_t dup__bit19_17__ecode_redefine,
    uint8_t motbrake,
    uint8_t cmc__bit18__tractioncontrol_ena,
    uint8_t ac_dc,
    uint8_t cmc__bit20_19__tc_deltatime_conf,
    uint8_t pwm_freq,
    uint8_t dup__bit20__hal_extmr_acv,
    uint8_t cmc__bit22_21__tc_minspeed_conf,
    uint8_t dup__bit21__initwith_frg_off,
    uint16_t dup__bit31_22__free,
    uint8_t ntc,
    uint8_t cmc__bit23__tc_ncmdrestoption,
    uint8_t delta,
    uint8_t cmc__bit31_24__free,
    uint8_t dc_1qdirvolt,
    uint8_t dc_field,
    uint8_t dead_2,
    uint8_t block,
    uint8_t dc_1qmv,
    uint8_t dc_1q3p,
    uint8_t reducelosses
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_inverter_r_send_conversion_to_raw(
    primary_inverter_r_send_t *raw,
    uint8_t send_mux,
    float motor_f_n,
    uint16_t t_dc__start,
    float v_dc__start,
    int16_t special__start,
    float v_min__start,
    float f_min__start,
    float v_corner__start,
    float f_corner__start,
    uint16_t cos_phi,
    int16_t extra__start,
    int16_t capture_channel,
    int16_t trig_level,
    int16_t trig_edge,
    uint16_t trig_source,
    uint16_t oszi_source,
    uint16_t oszi_skip,
    uint16_t oszi_read_cmd,
    uint16_t oszi_run_cmd,
    float calib_ref_value,
    uint16_t pid_i__kp__iq,
    uint16_t pid_i__ti__iq,
    uint16_t cutoffdig,
    float id_setdig__id,
    int16_t i_delta_ramp,
    uint16_t pid_i__tim__iq,
    uint16_t pid_n__kp,
    uint16_t pid_n__ti,
    uint16_t pid_n__td,
    int16_t ain_in_1_offsetval,
    float n_setdig,
    float n_lim,
    uint16_t n_r_acc,
    uint8_t cs_ain_1_format,
    uint16_t pid_n__tim,
    float i_red_n,
    float n_lim_minus,
    float n_lim_plus,
    float fb_offset,
    uint8_t read_id,
    float i_lim_dig,
    uint16_t i_red_te,
    float i_max_eff,
    float i_nom_eff,
    uint16_t motor_pole,
    int16_t ain_in_1_cutoff,
    uint8_t km_rsvd_0,
    int16_t ain_in_2_cutoff,
    uint16_t i_red_td,
    uint16_t n_nom,
    uint8_t dc_bus_comp,
    int16_t pid_n__kacc,
    uint16_t speed_filter,
    float ain_in_1_filter,
    uint32_t snr,
    uint16_t device_mains,
    uint16_t regen_p,
    uint8_t devicetype,
    uint16_t can_id_rx,
    uint16_t can_id_tx,
    uint16_t pos_kp,
    uint16_t pos_ti,
    uint16_t pos_td,
    int32_t pos_dest,
    uint16_t pos_tim,
    int32_t pos_offsref,
    uint16_t can_nbt,
    uint16_t ref_reso_edge,
    int16_t speed_1,
    int16_t speed_2,
    int16_t pos_tol_win,
    int32_t pos_preset_val,
    int32_t pos_nd_scale,
    int32_t pos_nd_offset,
    int32_t fb2_scale_ext,
    int32_t pos_offset_slack,
    int16_t pos_diff_slack,
    uint8_t eprom131,
    uint8_t eprom132,
    uint16_t fun_special,
    uint32_t can_id_2_rx,
    uint32_t can_id_2_tx,
    int16_t v_ref,
    uint16_t v_kp,
    uint16_t v_ti,
    uint16_t clear_errors,
    int16_t m_setdig__iq,
    uint16_t i_red_tm,
    uint16_t m_temp,
    uint8_t mo_feedback_1,
    uint16_t dc_bus_min_lim,
    uint16_t fb_incr_mot,
    uint16_t fb_pole,
    float motor_lsq,
    int16_t id_nom,
    float motor_lm,
    uint16_t motor_rr,
    int16_t id_min,
    int16_t motor_tr,
    float motor_lsd,
    uint16_t motor_rs,
    float motor_ts,
    uint16_t def_end_1,
    uint16_t def_end_2,
    uint16_t def_din_1,
    uint16_t def_din_2,
    uint8_t operand194,
    uint8_t operand195,
    uint8_t operand218,
    uint8_t operand219,
    float i_max_pk,
    float i_con_eff,
    float i_device,
    uint16_t n_r_lim,
    int16_t nmax100perc,
    uint16_t pid_i__xkp__iq,
    float bat_opr_limit__mot,
    uint16_t pid_i__kf__iq,
    uint8_t cmc__bit0__dc_current_sens_ena,
    int16_t can_rxtimeout,
    int32_t var_1,
    int32_t var_2,
    int32_t var_3,
    int32_t var_4,
    int16_t ain_in_2_offsetval,
    uint8_t dup__bit7_0__dac_source_channel,
    uint16_t n_r_dec,
    uint16_t v_shunt,
    uint16_t t_peak,
    uint16_t brake_delay,
    uint32_t axis,
    uint8_t km_speed_0,
    uint8_t ballast_ext,
    uint8_t cmc__bit1__idc_limit_ena,
    uint8_t cs_ain_2_format,
    uint8_t km_frg_off,
    uint8_t fb_special,
    uint8_t cmc__bit2__pdc_limit_usage,
    uint8_t km_cal_off,
    uint8_t coaststop,
    uint8_t cmc__bit3__torqueval_init_ena,
    uint8_t cs_ain_1_mode,
    uint8_t km_tx_tog_stat,
    uint8_t i_ist_inverse,
    uint8_t compare_var194,
    uint8_t compare_var195,
    uint8_t compare_var218,
    uint8_t compare_var219,
    uint8_t cmc__bit4__dig_m_rcpramp_ena,
    uint8_t km_i_limit,
    uint8_t refsoft,
    uint8_t mo_feedback_2,
    uint8_t cmc__bit5__reset_nramp_atnzero,
    uint8_t km_n_clip,
    uint8_t no_uesp_btb,
    uint8_t cmc__bit6__torquetimeout_100ms_e,
    uint8_t cs_oora1,
    uint8_t km_mix_ana_on,
    uint8_t vdc_ana,
    uint8_t cmc__bit13_7__free,
    uint8_t cs_ain_2_mode,
    uint8_t ret_interval,
    uint8_t km_allow_sync,
    uint8_t i1_adc_ena,
    float ain_in_2_filter,
    uint8_t mo_sc1_reso,
    uint8_t source_id194,
    uint8_t source_id195,
    uint8_t source_id218,
    uint8_t source_id219,
    uint8_t dup__bit8__can_extended_0,
    uint8_t km_handwheel,
    uint8_t hxinv,
    uint8_t dup__bit9__generator,
    uint8_t km_phasing_extend,
    uint8_t h2inv,
    uint8_t dup__bit10__park_rms,
    uint8_t cs_oora2,
    uint8_t km_rsvd_11,
    uint8_t ol_comp,
    uint8_t mo_sc1_comp,
    uint8_t dup__bit11__dcbus_volts,
    uint8_t cs_cmd_type,
    uint8_t km_rsvd_12,
    uint8_t motortype,
    uint8_t mo_sc2_reso,
    uint8_t dup__bit12__boat_pedal,
    uint8_t km_rsvd_13,
    uint8_t dup__bit13__gen_autoiaclimit,
    uint8_t cs_ain_2__i_limit,
    uint8_t km_pseudo_enable,
    uint8_t ana_0up,
    uint8_t cmc__bit14__idc_limit_ena_v2,
    uint8_t dup__bit14__mtpa_reluct_enab,
    uint8_t cs_ain_1__n_limit,
    uint8_t km_debug_test,
    uint8_t lowbd,
    uint8_t mo_sc2_inv,
    uint8_t active190,
    uint8_t active191,
    uint8_t active192,
    uint8_t active193,
    uint8_t cmc__bit15__dig_e_brake_act,
    uint8_t dup__bit15__canopen_acv,
    uint16_t t_dc__stop,
    float v_dc__stop,
    int16_t special__stop,
    float v_min__stop,
    float f_min__stop,
    float v_corner__stop,
    float f_corner__stop,
    uint16_t pid_i__kp__id,
    uint16_t pid_i__ti__id,
    uint16_t pid_i__tim__id,
    float ain_in_1_scaleval,
    uint16_t m_r_acc,
    uint8_t sramp,
    uint16_t regen_r,
    uint16_t dc_bus_max_lim,
    uint16_t m_r_rcp,
    uint16_t pid_i__xkp__id,
    float bat_opr_limit__gen,
    uint16_t pid_i__kf__id,
    uint8_t cmc__bit17_16__checkipeak_config,
    float ain_in_2_scaleval,
    uint8_t dup__bit16__bamobil3_2_offcrct,
    uint16_t m_r_dec,
    uint8_t ramp4,
    uint8_t dup__bit19_17__ecode_redefine,
    uint8_t motbrake,
    uint8_t cmc__bit18__tractioncontrol_ena,
    uint8_t ac_dc,
    uint8_t cmc__bit20_19__tc_deltatime_conf,
    uint8_t pwm_freq,
    uint8_t dup__bit20__hal_extmr_acv,
    uint8_t cmc__bit22_21__tc_minspeed_conf,
    uint8_t dup__bit21__initwith_frg_off,
    uint16_t dup__bit31_22__free,
    uint8_t ntc,
    uint8_t cmc__bit23__tc_ncmdrestoption,
    uint8_t delta,
    uint8_t cmc__bit31_24__free,
    uint8_t dc_1qdirvolt,
    uint8_t dc_field,
    uint8_t dead_2,
    uint8_t block,
    uint8_t dc_1qmv,
    uint8_t dc_1q3p,
    uint8_t reducelosses
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_inverter_r_send_raw_to_conversion_struct(
    primary_inverter_r_send_converted_t *conversion, 
    const primary_inverter_r_send_t *raw);


void primary_inverter_r_send_conversion_to_raw_struct(
    primary_inverter_r_send_t *raw,
    const primary_inverter_r_send_converted_t *conversion);


int primary_inverter_r_send_converted_to_string(primary_inverter_r_send_converted_t *message, char *buffer);

int primary_inverter_r_send_converted_to_string_file(primary_inverter_r_send_converted_t *message, FILE *buffer);

int primary_inverter_r_send_fields(char *buffer);

int primary_inverter_r_send_fields_file(FILE *buffer);

/**
 * Pack message Inverter_R_Send.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_inverter_r_send_pack(
    uint8_t *dst_p,
    const primary_inverter_r_send_t *src_p,
    size_t size);

/**
 * Unpack message Inverter_R_Send.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_inverter_r_send_unpack(
    primary_inverter_r_send_t *dst_p,
    const uint8_t *src_p,
    size_t size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_send_mux_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_inverter_r_send_motor_f_n_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_r_send_motor_f_n_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_motor_f_n_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_t_dc__start_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t primary_inverter_r_send_v_dc__start_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_r_send_v_dc__start_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_v_dc__start_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_special__start_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t primary_inverter_r_send_v_min__start_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_r_send_v_min__start_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_v_min__start_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t primary_inverter_r_send_f_min__start_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_r_send_f_min__start_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_f_min__start_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t primary_inverter_r_send_v_corner__start_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_r_send_v_corner__start_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_v_corner__start_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t primary_inverter_r_send_f_corner__start_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_r_send_f_corner__start_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_f_corner__start_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_cos_phi_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_extra__start_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_capture_channel_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_trig_level_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_trig_edge_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_trig_source_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_oszi_source_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_oszi_skip_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_oszi_read_cmd_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_oszi_run_cmd_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_inverter_r_send_calib_ref_value_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_r_send_calib_ref_value_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_calib_ref_value_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_pid_i__kp__iq_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_pid_i__ti__iq_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_cutoffdig_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t primary_inverter_r_send_id_setdig__id_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_r_send_id_setdig__id_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_id_setdig__id_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_i_delta_ramp_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_pid_i__tim__iq_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_pid_n__kp_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_pid_n__ti_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_pid_n__td_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_ain_in_1_offsetval_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t primary_inverter_r_send_n_setdig_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_r_send_n_setdig_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_n_setdig_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t primary_inverter_r_send_n_lim_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_r_send_n_lim_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_n_lim_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_n_r_acc_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_cs_ain_1_format_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_pid_n__tim_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_inverter_r_send_i_red_n_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_r_send_i_red_n_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_i_red_n_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t primary_inverter_r_send_n_lim_minus_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_r_send_n_lim_minus_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_n_lim_minus_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t primary_inverter_r_send_n_lim_plus_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_r_send_n_lim_plus_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_n_lim_plus_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t primary_inverter_r_send_fb_offset_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_r_send_fb_offset_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_fb_offset_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_read_id_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t primary_inverter_r_send_i_lim_dig_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_r_send_i_lim_dig_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_i_lim_dig_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_i_red_te_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_inverter_r_send_i_max_eff_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_r_send_i_max_eff_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_i_max_eff_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_inverter_r_send_i_nom_eff_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_r_send_i_nom_eff_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_i_nom_eff_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_motor_pole_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_ain_in_1_cutoff_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_km_rsvd_0_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_ain_in_2_cutoff_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_i_red_td_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_n_nom_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_dc_bus_comp_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_pid_n__kacc_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_speed_filter_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t primary_inverter_r_send_ain_in_1_filter_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_r_send_ain_in_1_filter_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_ain_in_1_filter_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_snr_is_in_range(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_device_mains_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_regen_p_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_devicetype_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_can_id_rx_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_can_id_tx_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_pos_kp_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_pos_ti_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_pos_td_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_pos_dest_is_in_range(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_pos_tim_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_pos_offsref_is_in_range(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_can_nbt_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_ref_reso_edge_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_speed_1_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_speed_2_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_pos_tol_win_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_pos_preset_val_is_in_range(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_pos_nd_scale_is_in_range(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_pos_nd_offset_is_in_range(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_fb2_scale_ext_is_in_range(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_pos_offset_slack_is_in_range(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_pos_diff_slack_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_eprom131_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_eprom132_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_fun_special_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_can_id_2_rx_is_in_range(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_can_id_2_tx_is_in_range(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_v_ref_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_v_kp_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_v_ti_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_clear_errors_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_m_setdig__iq_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_i_red_tm_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_m_temp_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_mo_feedback_1_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_dc_bus_min_lim_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_fb_incr_mot_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_fb_pole_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_inverter_r_send_motor_lsq_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_r_send_motor_lsq_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_motor_lsq_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_id_nom_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_inverter_r_send_motor_lm_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_r_send_motor_lm_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_motor_lm_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_motor_rr_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_id_min_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_motor_tr_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_inverter_r_send_motor_lsd_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_r_send_motor_lsd_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_motor_lsd_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_motor_rs_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t primary_inverter_r_send_motor_ts_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_r_send_motor_ts_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_motor_ts_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_def_end_1_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_def_end_2_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_def_din_1_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_def_din_2_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_operand194_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_operand195_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_operand218_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_operand219_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_inverter_r_send_i_max_pk_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_r_send_i_max_pk_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_i_max_pk_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_inverter_r_send_i_con_eff_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_r_send_i_con_eff_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_i_con_eff_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_inverter_r_send_i_device_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_r_send_i_device_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_i_device_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_n_r_lim_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_nmax100perc_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_pid_i__xkp__iq_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_inverter_r_send_bat_opr_limit__mot_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_r_send_bat_opr_limit__mot_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_bat_opr_limit__mot_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_pid_i__kf__iq_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_cmc__bit0__dc_current_sens_ena_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_can_rxtimeout_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_var_1_is_in_range(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_var_2_is_in_range(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_var_3_is_in_range(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_var_4_is_in_range(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_ain_in_2_offsetval_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_dup__bit7_0__dac_source_channel_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_n_r_dec_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_v_shunt_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_t_peak_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_brake_delay_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_axis_is_in_range(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_km_speed_0_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_ballast_ext_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_cmc__bit1__idc_limit_ena_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_cs_ain_2_format_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_km_frg_off_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_fb_special_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_cmc__bit2__pdc_limit_usage_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_km_cal_off_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_coaststop_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_cmc__bit3__torqueval_init_ena_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_cs_ain_1_mode_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_km_tx_tog_stat_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_i_ist_inverse_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_compare_var194_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_compare_var195_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_compare_var218_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_compare_var219_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_cmc__bit4__dig_m_rcpramp_ena_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_km_i_limit_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_refsoft_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_mo_feedback_2_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_cmc__bit5__reset_nramp_atnzero_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_km_n_clip_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_no_uesp_btb_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_cmc__bit6__torquetimeout_100ms_e_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_cs_oora1_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_km_mix_ana_on_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_vdc_ana_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_cmc__bit13_7__free_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_cs_ain_2_mode_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_ret_interval_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_km_allow_sync_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_i1_adc_ena_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t primary_inverter_r_send_ain_in_2_filter_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_r_send_ain_in_2_filter_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_ain_in_2_filter_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_mo_sc1_reso_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_source_id194_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_source_id195_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_source_id218_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_source_id219_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_dup__bit8__can_extended_0_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_km_handwheel_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_hxinv_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_dup__bit9__generator_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_km_phasing_extend_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_h2inv_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_dup__bit10__park_rms_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_cs_oora2_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_km_rsvd_11_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_ol_comp_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_mo_sc1_comp_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_dup__bit11__dcbus_volts_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_cs_cmd_type_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_km_rsvd_12_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_motortype_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_mo_sc2_reso_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_dup__bit12__boat_pedal_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_km_rsvd_13_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_dup__bit13__gen_autoiaclimit_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_cs_ain_2__i_limit_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_km_pseudo_enable_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_ana_0up_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_cmc__bit14__idc_limit_ena_v2_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_dup__bit14__mtpa_reluct_enab_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_cs_ain_1__n_limit_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_km_debug_test_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_lowbd_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_mo_sc2_inv_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_active190_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_active191_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_active192_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_active193_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_cmc__bit15__dig_e_brake_act_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_dup__bit15__canopen_acv_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_t_dc__stop_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t primary_inverter_r_send_v_dc__stop_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_r_send_v_dc__stop_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_v_dc__stop_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_special__stop_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t primary_inverter_r_send_v_min__stop_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_r_send_v_min__stop_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_v_min__stop_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t primary_inverter_r_send_f_min__stop_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_r_send_f_min__stop_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_f_min__stop_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t primary_inverter_r_send_v_corner__stop_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_r_send_v_corner__stop_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_v_corner__stop_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t primary_inverter_r_send_f_corner__stop_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_r_send_f_corner__stop_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_f_corner__stop_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_pid_i__kp__id_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_pid_i__ti__id_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_pid_i__tim__id_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t primary_inverter_r_send_ain_in_1_scaleval_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_r_send_ain_in_1_scaleval_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_ain_in_1_scaleval_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_m_r_acc_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_sramp_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_regen_r_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_dc_bus_max_lim_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_m_r_rcp_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_pid_i__xkp__id_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_inverter_r_send_bat_opr_limit__gen_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_r_send_bat_opr_limit__gen_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_bat_opr_limit__gen_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_pid_i__kf__id_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_cmc__bit17_16__checkipeak_config_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t primary_inverter_r_send_ain_in_2_scaleval_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_r_send_ain_in_2_scaleval_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_ain_in_2_scaleval_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_dup__bit16__bamobil3_2_offcrct_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_m_r_dec_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_ramp4_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_dup__bit19_17__ecode_redefine_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_motbrake_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_cmc__bit18__tractioncontrol_ena_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_ac_dc_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_cmc__bit20_19__tc_deltatime_conf_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_pwm_freq_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_dup__bit20__hal_extmr_acv_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_cmc__bit22_21__tc_minspeed_conf_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_dup__bit21__initwith_frg_off_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_dup__bit31_22__free_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_ntc_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_cmc__bit23__tc_ncmdrestoption_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_delta_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_cmc__bit31_24__free_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_dc_1qdirvolt_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_dc_field_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_dead_2_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_block_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_dc_1qmv_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_dc_1q3p_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_send_reducelosses_is_in_range(uint8_t value);


void primary_inverter_r_rcv_raw_to_conversion(
    primary_inverter_r_rcv_converted_t *conversion,
    uint8_t rcv_mux,
    float n_actual,
    uint16_t n_r_dec,
    uint16_t n_r_lim,
    float n_actual_filt,
    uint16_t firmware,
    uint8_t devicetype,
    uint32_t snr,
    uint32_t axis,
    float i_device,
    uint16_t v_shunt,
    uint16_t i_200perc,
    uint8_t dc_bus_comp,
    uint8_t ena64,
    uint8_t err_badparas,
    uint8_t lmt1,
    int16_t ain_in_1_raw,
    int16_t ain_in_2_raw,
    int16_t nmax100perc,
    float n_setdig,
    int16_t n_cmd,
    float n_cmd_ramp,
    float n_lim,
    float n_error,
    int16_t m_setdig__iq,
    float id_setdig__id,
    float i_max_pk,
    float i_con_eff,
    float i_max_eff,
    float i_nom_eff,
    float i_limit_inuse,
    float i_cmd,
    float i_cmd_ramp,
    float i_actual,
    float i_actual_filt,
    float iq_actual,
    float id_actual,
    float iq_error,
    float id_error,
    float i1_actual,
    float i2_actual,
    float i3_actual,
    uint16_t i3_adc,
    uint16_t i2_adc,
    int16_t vq,
    int16_t vd,
    int16_t vout,
    uint16_t t_motor,
    uint16_t t_igbt,
    int16_t t_air,
    float vdc_bus_filt,
    uint8_t end_1,
    uint8_t din_1,
    uint8_t end_2,
    uint8_t din_2,
    uint8_t run232,
    uint8_t dout_1,
    uint8_t dout_2,
    uint8_t dout_3,
    uint8_t rdy_btb,
    uint8_t i_fault,
    uint8_t dout_4,
    float i_lim_dig,
    float i_red_n,
    uint16_t i_red_td,
    uint16_t i_red_te,
    uint16_t i_red_tm,
    uint8_t cs_ain_1_format,
    float id_ref,
    int16_t m_outdig__iq,
    int16_t ptr_1_debug,
    int16_t ptr_2_debug,
    int16_t temp_debug,
    float motor_f_n,
    uint16_t motor_v_n,
    uint16_t t_dc__start,
    float v_dc__start,
    float v_min__start,
    float f_min__start,
    float v_corner__start,
    float f_corner__start,
    uint16_t cos_phi,
    uint16_t pwm_enum,
    float calib_ref_value,
    uint16_t pid_i__kp__iq,
    uint16_t pid_i__ti__iq,
    uint16_t cutoffdig,
    uint16_t i3_offset,
    int16_t i_delta_ramp,
    uint16_t pid_i__tim__iq,
    uint16_t pid_n__kp,
    uint16_t v_ti,
    uint16_t pid_n__td,
    int16_t ain_in_1_offsetval,
    int16_t ain_in_2_offsetval,
    uint16_t dzr_seq,
    uint16_t pid_n__tim,
    float n_lim_plus,
    float n_lim_minus,
    int16_t incr_delta,
    int16_t motorpos_mech,
    int16_t motorpos_elec,
    float fb_offset,
    int32_t it_rg_monitor,
    uint16_t motor_pole,
    int16_t ain_in_1_cutoff,
    uint8_t activecontrolmode,
    uint8_t km_rsvd_0,
    uint8_t ena82,
    int16_t ain_in_2_cutoff,
    float i_limit_inuse_ramp,
    uint16_t n_nom,
    int16_t pid_n__kacc,
    uint16_t rotor_signals,
    uint16_t speed_filter,
    float ain_in_1_filter,
    uint16_t ixt_monitor,
    uint8_t ecode_bit0_firsterrordtcd99,
    uint16_t device_mains,
    uint16_t regen_p,
    uint16_t can_id_rx,
    uint16_t can_id_tx,
    uint16_t pos_kp,
    uint16_t pos_ti,
    uint16_t pos_td,
    int32_t pos_actual,
    int32_t pos_dest,
    int32_t pos_actual_2,
    int32_t pos_error,
    uint16_t pos_tim,
    int32_t pos_offsref,
    uint16_t can_nbt,
    uint16_t pos_zero_capture,
    uint16_t ref_reso_edge,
    int16_t speed_1,
    int16_t speed_2,
    int16_t pos_tol_win,
    int32_t pos_preset_val,
    int32_t pos_zero_offset,
    int32_t pos_nd_scale,
    int32_t pos_nd_offset,
    int32_t fb2_scale_ext,
    int32_t pos_offset_slack,
    int16_t pos_diff_slack,
    uint16_t fun_para_read,
    uint16_t fun_para_write,
    uint16_t fun_special,
    uint32_t can_id_2_rx,
    uint32_t can_id_2_tx,
    int16_t v_ref,
    uint16_t v_kp,
    uint16_t pid_n__ti,
    uint16_t clear_errors,
    int32_t pos_cmd,
    uint16_t can_error_busoff,
    uint16_t can_error_writetime,
    uint8_t ecode_bit0_firsterrordtcd148,
    uint16_t can_error_no_ack,
    uint16_t can_error_crc_check150,
    uint16_t can_error_crc_check151,
    uint16_t info_timer_diff,
    int16_t ballastcount,
    uint16_t m_temp,
    uint8_t mo_feedback_1,
    uint16_t dc_bus_min_lim,
    uint16_t fb_incr_mot,
    uint16_t fb_pole,
    uint16_t logic_freq,
    int16_t pwm_1,
    int16_t pwm_2,
    int16_t pwm_3,
    int16_t timer_delta,
    float motor_lsq,
    float motor_lsd,
    int16_t id_nom,
    float motor_lm,
    uint16_t motor_rr,
    int16_t id_min,
    int16_t motor_tr,
    uint16_t motor_rs,
    float motor_ts,
    uint16_t def_end_1,
    uint16_t def_end_2,
    uint16_t def_din_1,
    uint16_t def_din_2,
    uint8_t operand194,
    float i_max_inuse,
    uint8_t signal_go,
    uint8_t signal_brake,
    uint8_t signal_icns,
    uint8_t signal_lessn0,
    uint8_t signal_postolerance,
    int16_t ain_in_1_scaled251,
    int16_t ain_in_2_scaled252,
    uint8_t operand195,
    uint8_t operand218,
    uint8_t operand219,
    uint16_t pid_i__xkp__iq,
    float bat_opr_limit__mot,
    uint16_t pid_i__kf__iq,
    uint8_t dc_current_sens_ena_set,
    uint8_t cmc__bit0__dc_current_sens_ena,
    int16_t n_rpm_maxint,
    int32_t var_1,
    int16_t can_rxtimeout,
    int32_t var_2,
    int32_t var_3,
    int32_t var_4,
    uint8_t dup__bit7_0__dac_source_channel,
    uint8_t fb_lossofsignal,
    uint8_t no_hw_fault,
    uint16_t t_peak,
    uint16_t brake_delay,
    int16_t power,
    int16_t work,
    int16_t extra__start,
    int16_t capture_channel,
    int16_t trig_level,
    int16_t trig_edge,
    uint16_t trig_source,
    uint16_t oszi_source,
    uint16_t oszi_skip,
    uint16_t oszi_run_cmd,
    uint16_t oszi_read_cmd,
    int16_t pos_ref_start,
    float vdc_bus,
    int16_t m_cmd_ramp,
    uint8_t lmt_1,
    uint8_t out_1,
    uint16_t subversion_nr,
    uint8_t ballast_ext,
    uint8_t ncr064,
    uint8_t err_powerfault,
    uint8_t lmt2,
    uint8_t km_speed_0,
    uint8_t ncr082,
    uint8_t ecode_bit1__hw1_state99,
    uint8_t ecode_bit1__hw1_state148,
    uint8_t dc_i_sensena_set,
    uint8_t cmc__bit1__idc_limit_ena,
    uint8_t lmt_2,
    uint8_t out_2,
    uint8_t fb_special,
    uint8_t lim_plus64,
    uint8_t err_rfe_fault,
    uint8_t in2,
    uint8_t cs_ain_2_format,
    uint8_t km_frg_off,
    uint8_t lim_plus82,
    uint8_t ecode_bit2__hw0_state99,
    uint8_t ecode_bit2__hw0_state148,
    uint8_t op_mode_quadrant,
    uint8_t cmc__bit2__pdc_limit_usage,
    uint8_t in_2,
    uint8_t rdy155,
    uint8_t coaststop,
    uint8_t lim_minus64,
    uint8_t err_bustimeout,
    uint8_t in1,
    uint8_t km_cal_off,
    uint8_t lim_minus82,
    uint8_t ecode_bit3__free99,
    uint8_t ecode_bit3__free148,
    uint8_t cmc__bit3__torqueval_init_ena,
    uint8_t in_1,
    uint8_t go155,
    uint8_t i_ist_inverse,
    uint8_t ok64,
    uint8_t err_feedbacksignal,
    uint8_t frgrun,
    uint8_t cs_ain_1_mode,
    uint8_t km_tx_tog_stat,
    uint8_t ok82,
    uint8_t ecode_bit4__rdy399,
    uint8_t ecode_bit4__rdy3148,
    uint8_t compare_var194,
    uint8_t compare_var195,
    uint8_t compare_var218,
    uint8_t compare_var219,
    uint8_t cmc__bit4__dig_m_rcpramp_ena,
    uint8_t run152,
    uint8_t out_3,
    uint8_t refsoft,
    uint8_t icns64,
    uint8_t err_powervoltage_low,
    uint8_t rfe216,
    uint8_t km_i_limit,
    uint8_t icns82,
    uint8_t ecode_bit5__n_fail99,
    uint8_t ecode_bit5__n_fail148,
    uint8_t mo_feedback_2,
    uint8_t recup_is_acv,
    uint8_t cmc__bit5__reset_nramp_atnzero,
    uint8_t rfe152,
    uint8_t out_4,
    uint8_t no_uesp_btb,
    uint8_t tnlim64,
    uint8_t err_motortemp,
    uint8_t km_n_clip,
    uint8_t tnlim82,
    uint8_t ecode_bit6__flths99,
    uint8_t ecode_bit6__flths148,
    uint8_t i_dc_limit_is_acv,
    uint8_t cmc__bit6__torquetimeout_100ms_e,
    uint8_t rsvd,
    uint8_t rsvd1,
    uint8_t vdc_ana,
    uint8_t pn64,
    uint8_t err_devicetemp,
    uint8_t cs_oora1,
    uint8_t km_mix_ana_on,
    uint8_t pn82,
    uint8_t ecode_bit7__fltls99,
    uint8_t ecode_bit7__fltls148,
    uint8_t cmc__bit13_7__free,
    uint8_t brk1155,
    uint8_t i1_adc_ena,
    uint8_t ni64,
    uint8_t err_overvoltage,
    uint8_t out1,
    uint8_t cs_ain_2_mode,
    uint8_t ctrlsubmode,
    uint8_t km_allow_sync,
    uint8_t ni82,
    float ain_in_2_filter,
    uint8_t ecode_bit8__fail_idc99,
    uint8_t ecode_bit8__fail_idc148,
    uint8_t mo_sc1_reso,
    uint8_t source_id194,
    uint8_t source_id195,
    uint8_t source_id218,
    uint8_t source_id219,
    uint8_t dup__bit8__can_extended_0,
    uint8_t hxinv,
    uint8_t _n064,
    uint8_t err_ipeak,
    uint8_t out2,
    uint8_t km_handwheel,
    uint8_t _n082,
    uint8_t ecode_bit9__fail_i99,
    uint8_t ecode_bit9__fail_i148,
    uint8_t dup__bit9__generator,
    uint8_t h2inv,
    uint8_t rsw64,
    uint8_t err_raceaway,
    uint8_t btbrdy,
    uint8_t km_phasing_extend,
    uint8_t rsw82,
    uint8_t ecode_bit10__vccm99,
    uint8_t ecode_bit10__vccm148,
    uint8_t dup__bit10__park_rms,
    uint8_t ol_comp,
    uint8_t cal064,
    uint8_t err_user,
    uint8_t go216,
    uint8_t cs_oora2,
    uint8_t km_rsvd_11,
    uint8_t cal082,
    uint8_t ecode_bit11__15m_minus99,
    uint8_t ecode_bit11__15m_minus148,
    uint8_t mo_sc1_comp,
    uint8_t dup__bit11__dcbus_volts,
    uint8_t test,
    uint8_t motortype,
    uint8_t cal64,
    uint8_t out3,
    uint8_t cs_cmd_type,
    uint8_t currentmode,
    uint8_t km_rsvd_12,
    uint8_t cal82,
    uint8_t ecode_bit12__15m_plus99,
    uint8_t ecode_bit12__15m_plus148,
    uint8_t mo_sc2_reso,
    uint8_t dup__bit12__boat_pedal,
    uint8_t tol64,
    uint8_t out4,
    uint8_t km_rsvd_13,
    uint8_t tol82,
    uint8_t ecode_bit13__18m_plus99,
    uint8_t ecode_bit13__18m_plus148,
    uint8_t dup__bit13__gen_autoiaclimit,
    uint8_t ana_0up,
    uint8_t rdy64,
    uint8_t err_hwerr,
    uint8_t goff,
    uint8_t cs_ain_2__i_limit,
    uint8_t km_pseudo_enable,
    uint8_t rdy82,
    uint8_t ecode_bit14__ubmam99,
    uint8_t ecode_bit14__ubmam148,
    uint8_t cmc__bit14__idc_limit_ena_v2,
    uint8_t dup__bit14__mtpa_reluct_enab,
    uint8_t lowbd,
    uint8_t brk064,
    uint8_t err_ballast,
    uint8_t brk1216,
    uint8_t cs_ain_1__n_limit,
    uint8_t km_debug_test,
    uint8_t brk082,
    uint8_t ecode_bit15__t_igbt99,
    uint8_t ecode_bit15__t_igbt148,
    uint8_t mo_sc2_inv,
    uint8_t active190,
    uint8_t active191,
    uint8_t active192,
    uint8_t active193,
    uint8_t gen_autoiaclimit_is_acv,
    uint8_t cmc__bit15__dig_e_brake_act,
    uint8_t dup__bit15__canopen_acv,
    uint16_t m_r_dec,
    uint16_t m_r_rcp,
    uint8_t sramp,
    uint8_t signmag64,
    uint8_t warn_warning_0,
    int16_t ain_in_1_scaled213,
    int16_t ain_in_2_scaled214,
    uint16_t t_dc__stop,
    float v_dc__stop,
    float v_min__stop,
    float f_min__stop,
    float v_corner__stop,
    float f_corner__stop,
    uint16_t pid_i__kp__id,
    uint16_t pid_i__ti__id,
    uint16_t pid_i__tim__id,
    float ain_in_1_scaleval,
    float ain_in_2_scaleval,
    uint8_t signmag82,
    uint16_t regen_r,
    uint16_t dc_bus_max_lim,
    uint16_t pid_i__xkp__id,
    float bat_opr_limit__gen,
    uint16_t pid_i__kf__id,
    uint8_t cmc__bit17_16__checkipeak_config,
    uint8_t dup__bit16__bamobil3_2_offcrct,
    int16_t special__stop,
    int16_t free,
    uint16_t svnrevision_nr,
    uint8_t ramp4,
    uint8_t nclip64,
    uint8_t warn_illegal_status,
    uint8_t nclip82,
    uint8_t dup__bit19_17__ecode_redefine,
    uint8_t motbrake,
    uint8_t nclip_minus64,
    uint8_t warn_safe_in,
    uint8_t nclip_minus82,
    uint8_t cmc__bit18__tractioncontrol_ena,
    uint8_t ac_dc,
    uint8_t nclip_plus64,
    uint8_t nclip_plus82,
    uint8_t cmc__bit20_19__tc_deltatime_conf,
    uint8_t pwm_freq,
    uint8_t irddig64,
    uint8_t irddig82,
    uint8_t dup__bit20__hal_extmr_acv,
    uint8_t iuserchd64,
    uint8_t iuserchd82,
    uint8_t cmc__bit22_21__tc_minspeed_conf,
    uint8_t dup__bit21__initwith_frg_off,
    uint8_t irdn64,
    uint8_t warn_motortemp,
    uint8_t irdn82,
    uint16_t dup__bit31_22__free,
    uint8_t ntc,
    uint8_t irdti64,
    uint8_t warn_devicetemp,
    uint8_t irdti82,
    uint8_t cmc__bit23__tc_ncmdrestoption,
    uint16_t m_r_acc,
    uint8_t delta,
    uint8_t irdtir64,
    uint8_t warn_vout_sat,
    uint8_t irdtir82,
    uint8_t cmc__bit31_24__free,
    uint8_t dc_1qdirvolt,
    uint8_t _10hz64,
    uint8_t warn_ipeak,
    uint8_t _10hz82,
    uint8_t dc_field,
    uint8_t irdtm64,
    uint8_t warn_raceaway,
    uint8_t irdtm82,
    uint8_t dead_2,
    uint8_t irdana64,
    uint8_t irdana82,
    uint8_t block,
    uint8_t iwcns64,
    uint8_t iwcns82,
    uint8_t dc_1qmv,
    uint8_t rfepulse64,
    uint8_t rfepulse82,
    uint8_t dc_1q3p,
    uint8_t md64,
    uint8_t md82,
    uint8_t reducelosses,
    uint8_t hndwhl64,
    uint8_t warn_ballast,
    uint8_t hndwhl82
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_inverter_r_rcv_conversion_to_raw(
    primary_inverter_r_rcv_t *raw,
    uint8_t rcv_mux,
    float n_actual,
    uint16_t n_r_dec,
    uint16_t n_r_lim,
    float n_actual_filt,
    uint16_t firmware,
    uint8_t devicetype,
    uint32_t snr,
    uint32_t axis,
    float i_device,
    uint16_t v_shunt,
    uint16_t i_200perc,
    uint8_t dc_bus_comp,
    uint8_t ena64,
    uint8_t err_badparas,
    uint8_t lmt1,
    int16_t ain_in_1_raw,
    int16_t ain_in_2_raw,
    int16_t nmax100perc,
    float n_setdig,
    int16_t n_cmd,
    float n_cmd_ramp,
    float n_lim,
    float n_error,
    int16_t m_setdig__iq,
    float id_setdig__id,
    float i_max_pk,
    float i_con_eff,
    float i_max_eff,
    float i_nom_eff,
    float i_limit_inuse,
    float i_cmd,
    float i_cmd_ramp,
    float i_actual,
    float i_actual_filt,
    float iq_actual,
    float id_actual,
    float iq_error,
    float id_error,
    float i1_actual,
    float i2_actual,
    float i3_actual,
    uint16_t i3_adc,
    uint16_t i2_adc,
    int16_t vq,
    int16_t vd,
    int16_t vout,
    uint16_t t_motor,
    uint16_t t_igbt,
    int16_t t_air,
    float vdc_bus_filt,
    uint8_t end_1,
    uint8_t din_1,
    uint8_t end_2,
    uint8_t din_2,
    uint8_t run232,
    uint8_t dout_1,
    uint8_t dout_2,
    uint8_t dout_3,
    uint8_t rdy_btb,
    uint8_t i_fault,
    uint8_t dout_4,
    float i_lim_dig,
    float i_red_n,
    uint16_t i_red_td,
    uint16_t i_red_te,
    uint16_t i_red_tm,
    uint8_t cs_ain_1_format,
    float id_ref,
    int16_t m_outdig__iq,
    int16_t ptr_1_debug,
    int16_t ptr_2_debug,
    int16_t temp_debug,
    float motor_f_n,
    uint16_t motor_v_n,
    uint16_t t_dc__start,
    float v_dc__start,
    float v_min__start,
    float f_min__start,
    float v_corner__start,
    float f_corner__start,
    uint16_t cos_phi,
    uint16_t pwm_enum,
    float calib_ref_value,
    uint16_t pid_i__kp__iq,
    uint16_t pid_i__ti__iq,
    uint16_t cutoffdig,
    uint16_t i3_offset,
    int16_t i_delta_ramp,
    uint16_t pid_i__tim__iq,
    uint16_t pid_n__kp,
    uint16_t v_ti,
    uint16_t pid_n__td,
    int16_t ain_in_1_offsetval,
    int16_t ain_in_2_offsetval,
    uint16_t dzr_seq,
    uint16_t pid_n__tim,
    float n_lim_plus,
    float n_lim_minus,
    int16_t incr_delta,
    int16_t motorpos_mech,
    int16_t motorpos_elec,
    float fb_offset,
    int32_t it_rg_monitor,
    uint16_t motor_pole,
    int16_t ain_in_1_cutoff,
    uint8_t activecontrolmode,
    uint8_t km_rsvd_0,
    uint8_t ena82,
    int16_t ain_in_2_cutoff,
    float i_limit_inuse_ramp,
    uint16_t n_nom,
    int16_t pid_n__kacc,
    uint16_t rotor_signals,
    uint16_t speed_filter,
    float ain_in_1_filter,
    uint16_t ixt_monitor,
    uint8_t ecode_bit0_firsterrordtcd99,
    uint16_t device_mains,
    uint16_t regen_p,
    uint16_t can_id_rx,
    uint16_t can_id_tx,
    uint16_t pos_kp,
    uint16_t pos_ti,
    uint16_t pos_td,
    int32_t pos_actual,
    int32_t pos_dest,
    int32_t pos_actual_2,
    int32_t pos_error,
    uint16_t pos_tim,
    int32_t pos_offsref,
    uint16_t can_nbt,
    uint16_t pos_zero_capture,
    uint16_t ref_reso_edge,
    int16_t speed_1,
    int16_t speed_2,
    int16_t pos_tol_win,
    int32_t pos_preset_val,
    int32_t pos_zero_offset,
    int32_t pos_nd_scale,
    int32_t pos_nd_offset,
    int32_t fb2_scale_ext,
    int32_t pos_offset_slack,
    int16_t pos_diff_slack,
    uint16_t fun_para_read,
    uint16_t fun_para_write,
    uint16_t fun_special,
    uint32_t can_id_2_rx,
    uint32_t can_id_2_tx,
    int16_t v_ref,
    uint16_t v_kp,
    uint16_t pid_n__ti,
    uint16_t clear_errors,
    int32_t pos_cmd,
    uint16_t can_error_busoff,
    uint16_t can_error_writetime,
    uint8_t ecode_bit0_firsterrordtcd148,
    uint16_t can_error_no_ack,
    uint16_t can_error_crc_check150,
    uint16_t can_error_crc_check151,
    uint16_t info_timer_diff,
    int16_t ballastcount,
    uint16_t m_temp,
    uint8_t mo_feedback_1,
    uint16_t dc_bus_min_lim,
    uint16_t fb_incr_mot,
    uint16_t fb_pole,
    uint16_t logic_freq,
    int16_t pwm_1,
    int16_t pwm_2,
    int16_t pwm_3,
    int16_t timer_delta,
    float motor_lsq,
    float motor_lsd,
    int16_t id_nom,
    float motor_lm,
    uint16_t motor_rr,
    int16_t id_min,
    int16_t motor_tr,
    uint16_t motor_rs,
    float motor_ts,
    uint16_t def_end_1,
    uint16_t def_end_2,
    uint16_t def_din_1,
    uint16_t def_din_2,
    uint8_t operand194,
    float i_max_inuse,
    uint8_t signal_go,
    uint8_t signal_brake,
    uint8_t signal_icns,
    uint8_t signal_lessn0,
    uint8_t signal_postolerance,
    int16_t ain_in_1_scaled251,
    int16_t ain_in_2_scaled252,
    uint8_t operand195,
    uint8_t operand218,
    uint8_t operand219,
    uint16_t pid_i__xkp__iq,
    float bat_opr_limit__mot,
    uint16_t pid_i__kf__iq,
    uint8_t dc_current_sens_ena_set,
    uint8_t cmc__bit0__dc_current_sens_ena,
    int16_t n_rpm_maxint,
    int32_t var_1,
    int16_t can_rxtimeout,
    int32_t var_2,
    int32_t var_3,
    int32_t var_4,
    uint8_t dup__bit7_0__dac_source_channel,
    uint8_t fb_lossofsignal,
    uint8_t no_hw_fault,
    uint16_t t_peak,
    uint16_t brake_delay,
    int16_t power,
    int16_t work,
    int16_t extra__start,
    int16_t capture_channel,
    int16_t trig_level,
    int16_t trig_edge,
    uint16_t trig_source,
    uint16_t oszi_source,
    uint16_t oszi_skip,
    uint16_t oszi_run_cmd,
    uint16_t oszi_read_cmd,
    int16_t pos_ref_start,
    float vdc_bus,
    int16_t m_cmd_ramp,
    uint8_t lmt_1,
    uint8_t out_1,
    uint16_t subversion_nr,
    uint8_t ballast_ext,
    uint8_t ncr064,
    uint8_t err_powerfault,
    uint8_t lmt2,
    uint8_t km_speed_0,
    uint8_t ncr082,
    uint8_t ecode_bit1__hw1_state99,
    uint8_t ecode_bit1__hw1_state148,
    uint8_t dc_i_sensena_set,
    uint8_t cmc__bit1__idc_limit_ena,
    uint8_t lmt_2,
    uint8_t out_2,
    uint8_t fb_special,
    uint8_t lim_plus64,
    uint8_t err_rfe_fault,
    uint8_t in2,
    uint8_t cs_ain_2_format,
    uint8_t km_frg_off,
    uint8_t lim_plus82,
    uint8_t ecode_bit2__hw0_state99,
    uint8_t ecode_bit2__hw0_state148,
    uint8_t op_mode_quadrant,
    uint8_t cmc__bit2__pdc_limit_usage,
    uint8_t in_2,
    uint8_t rdy155,
    uint8_t coaststop,
    uint8_t lim_minus64,
    uint8_t err_bustimeout,
    uint8_t in1,
    uint8_t km_cal_off,
    uint8_t lim_minus82,
    uint8_t ecode_bit3__free99,
    uint8_t ecode_bit3__free148,
    uint8_t cmc__bit3__torqueval_init_ena,
    uint8_t in_1,
    uint8_t go155,
    uint8_t i_ist_inverse,
    uint8_t ok64,
    uint8_t err_feedbacksignal,
    uint8_t frgrun,
    uint8_t cs_ain_1_mode,
    uint8_t km_tx_tog_stat,
    uint8_t ok82,
    uint8_t ecode_bit4__rdy399,
    uint8_t ecode_bit4__rdy3148,
    uint8_t compare_var194,
    uint8_t compare_var195,
    uint8_t compare_var218,
    uint8_t compare_var219,
    uint8_t cmc__bit4__dig_m_rcpramp_ena,
    uint8_t run152,
    uint8_t out_3,
    uint8_t refsoft,
    uint8_t icns64,
    uint8_t err_powervoltage_low,
    uint8_t rfe216,
    uint8_t km_i_limit,
    uint8_t icns82,
    uint8_t ecode_bit5__n_fail99,
    uint8_t ecode_bit5__n_fail148,
    uint8_t mo_feedback_2,
    uint8_t recup_is_acv,
    uint8_t cmc__bit5__reset_nramp_atnzero,
    uint8_t rfe152,
    uint8_t out_4,
    uint8_t no_uesp_btb,
    uint8_t tnlim64,
    uint8_t err_motortemp,
    uint8_t km_n_clip,
    uint8_t tnlim82,
    uint8_t ecode_bit6__flths99,
    uint8_t ecode_bit6__flths148,
    uint8_t i_dc_limit_is_acv,
    uint8_t cmc__bit6__torquetimeout_100ms_e,
    uint8_t rsvd,
    uint8_t rsvd1,
    uint8_t vdc_ana,
    uint8_t pn64,
    uint8_t err_devicetemp,
    uint8_t cs_oora1,
    uint8_t km_mix_ana_on,
    uint8_t pn82,
    uint8_t ecode_bit7__fltls99,
    uint8_t ecode_bit7__fltls148,
    uint8_t cmc__bit13_7__free,
    uint8_t brk1155,
    uint8_t i1_adc_ena,
    uint8_t ni64,
    uint8_t err_overvoltage,
    uint8_t out1,
    uint8_t cs_ain_2_mode,
    uint8_t ctrlsubmode,
    uint8_t km_allow_sync,
    uint8_t ni82,
    float ain_in_2_filter,
    uint8_t ecode_bit8__fail_idc99,
    uint8_t ecode_bit8__fail_idc148,
    uint8_t mo_sc1_reso,
    uint8_t source_id194,
    uint8_t source_id195,
    uint8_t source_id218,
    uint8_t source_id219,
    uint8_t dup__bit8__can_extended_0,
    uint8_t hxinv,
    uint8_t _n064,
    uint8_t err_ipeak,
    uint8_t out2,
    uint8_t km_handwheel,
    uint8_t _n082,
    uint8_t ecode_bit9__fail_i99,
    uint8_t ecode_bit9__fail_i148,
    uint8_t dup__bit9__generator,
    uint8_t h2inv,
    uint8_t rsw64,
    uint8_t err_raceaway,
    uint8_t btbrdy,
    uint8_t km_phasing_extend,
    uint8_t rsw82,
    uint8_t ecode_bit10__vccm99,
    uint8_t ecode_bit10__vccm148,
    uint8_t dup__bit10__park_rms,
    uint8_t ol_comp,
    uint8_t cal064,
    uint8_t err_user,
    uint8_t go216,
    uint8_t cs_oora2,
    uint8_t km_rsvd_11,
    uint8_t cal082,
    uint8_t ecode_bit11__15m_minus99,
    uint8_t ecode_bit11__15m_minus148,
    uint8_t mo_sc1_comp,
    uint8_t dup__bit11__dcbus_volts,
    uint8_t test,
    uint8_t motortype,
    uint8_t cal64,
    uint8_t out3,
    uint8_t cs_cmd_type,
    uint8_t currentmode,
    uint8_t km_rsvd_12,
    uint8_t cal82,
    uint8_t ecode_bit12__15m_plus99,
    uint8_t ecode_bit12__15m_plus148,
    uint8_t mo_sc2_reso,
    uint8_t dup__bit12__boat_pedal,
    uint8_t tol64,
    uint8_t out4,
    uint8_t km_rsvd_13,
    uint8_t tol82,
    uint8_t ecode_bit13__18m_plus99,
    uint8_t ecode_bit13__18m_plus148,
    uint8_t dup__bit13__gen_autoiaclimit,
    uint8_t ana_0up,
    uint8_t rdy64,
    uint8_t err_hwerr,
    uint8_t goff,
    uint8_t cs_ain_2__i_limit,
    uint8_t km_pseudo_enable,
    uint8_t rdy82,
    uint8_t ecode_bit14__ubmam99,
    uint8_t ecode_bit14__ubmam148,
    uint8_t cmc__bit14__idc_limit_ena_v2,
    uint8_t dup__bit14__mtpa_reluct_enab,
    uint8_t lowbd,
    uint8_t brk064,
    uint8_t err_ballast,
    uint8_t brk1216,
    uint8_t cs_ain_1__n_limit,
    uint8_t km_debug_test,
    uint8_t brk082,
    uint8_t ecode_bit15__t_igbt99,
    uint8_t ecode_bit15__t_igbt148,
    uint8_t mo_sc2_inv,
    uint8_t active190,
    uint8_t active191,
    uint8_t active192,
    uint8_t active193,
    uint8_t gen_autoiaclimit_is_acv,
    uint8_t cmc__bit15__dig_e_brake_act,
    uint8_t dup__bit15__canopen_acv,
    uint16_t m_r_dec,
    uint16_t m_r_rcp,
    uint8_t sramp,
    uint8_t signmag64,
    uint8_t warn_warning_0,
    int16_t ain_in_1_scaled213,
    int16_t ain_in_2_scaled214,
    uint16_t t_dc__stop,
    float v_dc__stop,
    float v_min__stop,
    float f_min__stop,
    float v_corner__stop,
    float f_corner__stop,
    uint16_t pid_i__kp__id,
    uint16_t pid_i__ti__id,
    uint16_t pid_i__tim__id,
    float ain_in_1_scaleval,
    float ain_in_2_scaleval,
    uint8_t signmag82,
    uint16_t regen_r,
    uint16_t dc_bus_max_lim,
    uint16_t pid_i__xkp__id,
    float bat_opr_limit__gen,
    uint16_t pid_i__kf__id,
    uint8_t cmc__bit17_16__checkipeak_config,
    uint8_t dup__bit16__bamobil3_2_offcrct,
    int16_t special__stop,
    int16_t free,
    uint16_t svnrevision_nr,
    uint8_t ramp4,
    uint8_t nclip64,
    uint8_t warn_illegal_status,
    uint8_t nclip82,
    uint8_t dup__bit19_17__ecode_redefine,
    uint8_t motbrake,
    uint8_t nclip_minus64,
    uint8_t warn_safe_in,
    uint8_t nclip_minus82,
    uint8_t cmc__bit18__tractioncontrol_ena,
    uint8_t ac_dc,
    uint8_t nclip_plus64,
    uint8_t nclip_plus82,
    uint8_t cmc__bit20_19__tc_deltatime_conf,
    uint8_t pwm_freq,
    uint8_t irddig64,
    uint8_t irddig82,
    uint8_t dup__bit20__hal_extmr_acv,
    uint8_t iuserchd64,
    uint8_t iuserchd82,
    uint8_t cmc__bit22_21__tc_minspeed_conf,
    uint8_t dup__bit21__initwith_frg_off,
    uint8_t irdn64,
    uint8_t warn_motortemp,
    uint8_t irdn82,
    uint16_t dup__bit31_22__free,
    uint8_t ntc,
    uint8_t irdti64,
    uint8_t warn_devicetemp,
    uint8_t irdti82,
    uint8_t cmc__bit23__tc_ncmdrestoption,
    uint16_t m_r_acc,
    uint8_t delta,
    uint8_t irdtir64,
    uint8_t warn_vout_sat,
    uint8_t irdtir82,
    uint8_t cmc__bit31_24__free,
    uint8_t dc_1qdirvolt,
    uint8_t _10hz64,
    uint8_t warn_ipeak,
    uint8_t _10hz82,
    uint8_t dc_field,
    uint8_t irdtm64,
    uint8_t warn_raceaway,
    uint8_t irdtm82,
    uint8_t dead_2,
    uint8_t irdana64,
    uint8_t irdana82,
    uint8_t block,
    uint8_t iwcns64,
    uint8_t iwcns82,
    uint8_t dc_1qmv,
    uint8_t rfepulse64,
    uint8_t rfepulse82,
    uint8_t dc_1q3p,
    uint8_t md64,
    uint8_t md82,
    uint8_t reducelosses,
    uint8_t hndwhl64,
    uint8_t warn_ballast,
    uint8_t hndwhl82
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_inverter_r_rcv_raw_to_conversion_struct(
    primary_inverter_r_rcv_converted_t *conversion, 
    const primary_inverter_r_rcv_t *raw);


void primary_inverter_r_rcv_conversion_to_raw_struct(
    primary_inverter_r_rcv_t *raw,
    const primary_inverter_r_rcv_converted_t *conversion);


int primary_inverter_r_rcv_converted_to_string(primary_inverter_r_rcv_converted_t *message, char *buffer);

int primary_inverter_r_rcv_converted_to_string_file(primary_inverter_r_rcv_converted_t *message, FILE *buffer);

int primary_inverter_r_rcv_fields(char *buffer);

int primary_inverter_r_rcv_fields_file(FILE *buffer);

/**
 * Pack message Inverter_R_Rcv.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_inverter_r_rcv_pack(
    uint8_t *dst_p,
    const primary_inverter_r_rcv_t *src_p,
    size_t size);

/**
 * Unpack message Inverter_R_Rcv.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_inverter_r_rcv_unpack(
    primary_inverter_r_rcv_t *dst_p,
    const uint8_t *src_p,
    size_t size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_rcv_mux_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t primary_inverter_r_rcv_n_actual_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_r_rcv_n_actual_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_n_actual_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_n_r_dec_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_n_r_lim_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t primary_inverter_r_rcv_n_actual_filt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_r_rcv_n_actual_filt_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_n_actual_filt_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_firmware_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_devicetype_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_snr_is_in_range(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_axis_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_inverter_r_rcv_i_device_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_r_rcv_i_device_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_i_device_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_v_shunt_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_i_200perc_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_dc_bus_comp_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_ena64_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_err_badparas_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_lmt1_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_ain_in_1_raw_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_ain_in_2_raw_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_nmax100perc_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t primary_inverter_r_rcv_n_setdig_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_r_rcv_n_setdig_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_n_setdig_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_n_cmd_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t primary_inverter_r_rcv_n_cmd_ramp_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_r_rcv_n_cmd_ramp_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_n_cmd_ramp_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t primary_inverter_r_rcv_n_lim_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_r_rcv_n_lim_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_n_lim_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t primary_inverter_r_rcv_n_error_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_r_rcv_n_error_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_n_error_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_m_setdig__iq_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t primary_inverter_r_rcv_id_setdig__id_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_r_rcv_id_setdig__id_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_id_setdig__id_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_inverter_r_rcv_i_max_pk_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_r_rcv_i_max_pk_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_i_max_pk_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_inverter_r_rcv_i_con_eff_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_r_rcv_i_con_eff_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_i_con_eff_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_inverter_r_rcv_i_max_eff_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_r_rcv_i_max_eff_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_i_max_eff_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_inverter_r_rcv_i_nom_eff_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_r_rcv_i_nom_eff_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_i_nom_eff_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t primary_inverter_r_rcv_i_limit_inuse_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_r_rcv_i_limit_inuse_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_i_limit_inuse_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t primary_inverter_r_rcv_i_cmd_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_r_rcv_i_cmd_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_i_cmd_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t primary_inverter_r_rcv_i_cmd_ramp_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_r_rcv_i_cmd_ramp_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_i_cmd_ramp_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t primary_inverter_r_rcv_i_actual_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_r_rcv_i_actual_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_i_actual_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t primary_inverter_r_rcv_i_actual_filt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_r_rcv_i_actual_filt_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_i_actual_filt_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t primary_inverter_r_rcv_iq_actual_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_r_rcv_iq_actual_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_iq_actual_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t primary_inverter_r_rcv_id_actual_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_r_rcv_id_actual_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_id_actual_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t primary_inverter_r_rcv_iq_error_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_r_rcv_iq_error_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_iq_error_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t primary_inverter_r_rcv_id_error_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_r_rcv_id_error_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_id_error_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t primary_inverter_r_rcv_i1_actual_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_r_rcv_i1_actual_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_i1_actual_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t primary_inverter_r_rcv_i2_actual_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_r_rcv_i2_actual_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_i2_actual_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t primary_inverter_r_rcv_i3_actual_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_r_rcv_i3_actual_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_i3_actual_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_i3_adc_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_i2_adc_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_vq_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_vd_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_vout_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_t_motor_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_t_igbt_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_t_air_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_inverter_r_rcv_vdc_bus_filt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_r_rcv_vdc_bus_filt_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_vdc_bus_filt_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_end_1_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_din_1_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_end_2_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_din_2_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_run232_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_dout_1_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_dout_2_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_dout_3_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_rdy_btb_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_i_fault_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_dout_4_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t primary_inverter_r_rcv_i_lim_dig_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_r_rcv_i_lim_dig_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_i_lim_dig_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_inverter_r_rcv_i_red_n_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_r_rcv_i_red_n_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_i_red_n_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_i_red_td_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_i_red_te_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_i_red_tm_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_cs_ain_1_format_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t primary_inverter_r_rcv_id_ref_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_r_rcv_id_ref_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_id_ref_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_m_outdig__iq_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_ptr_1_debug_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_ptr_2_debug_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_temp_debug_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_inverter_r_rcv_motor_f_n_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_r_rcv_motor_f_n_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_motor_f_n_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_motor_v_n_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_t_dc__start_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t primary_inverter_r_rcv_v_dc__start_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_r_rcv_v_dc__start_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_v_dc__start_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t primary_inverter_r_rcv_v_min__start_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_r_rcv_v_min__start_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_v_min__start_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t primary_inverter_r_rcv_f_min__start_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_r_rcv_f_min__start_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_f_min__start_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t primary_inverter_r_rcv_v_corner__start_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_r_rcv_v_corner__start_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_v_corner__start_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t primary_inverter_r_rcv_f_corner__start_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_r_rcv_f_corner__start_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_f_corner__start_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_cos_phi_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_pwm_enum_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_inverter_r_rcv_calib_ref_value_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_r_rcv_calib_ref_value_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_calib_ref_value_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_pid_i__kp__iq_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_pid_i__ti__iq_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_cutoffdig_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_i3_offset_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_i_delta_ramp_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_pid_i__tim__iq_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_pid_n__kp_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_v_ti_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_pid_n__td_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_ain_in_1_offsetval_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_ain_in_2_offsetval_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_dzr_seq_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_pid_n__tim_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t primary_inverter_r_rcv_n_lim_plus_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_r_rcv_n_lim_plus_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_n_lim_plus_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t primary_inverter_r_rcv_n_lim_minus_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_r_rcv_n_lim_minus_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_n_lim_minus_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_incr_delta_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_motorpos_mech_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_motorpos_elec_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t primary_inverter_r_rcv_fb_offset_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_r_rcv_fb_offset_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_fb_offset_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_it_rg_monitor_is_in_range(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_motor_pole_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_ain_in_1_cutoff_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_activecontrolmode_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_km_rsvd_0_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_ena82_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_ain_in_2_cutoff_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t primary_inverter_r_rcv_i_limit_inuse_ramp_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_r_rcv_i_limit_inuse_ramp_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_i_limit_inuse_ramp_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_n_nom_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_pid_n__kacc_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_rotor_signals_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_speed_filter_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t primary_inverter_r_rcv_ain_in_1_filter_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_r_rcv_ain_in_1_filter_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_ain_in_1_filter_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_ixt_monitor_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_ecode_bit0_firsterrordtcd99_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_device_mains_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_regen_p_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_can_id_rx_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_can_id_tx_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_pos_kp_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_pos_ti_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_pos_td_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_pos_actual_is_in_range(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_pos_dest_is_in_range(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_pos_actual_2_is_in_range(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_pos_error_is_in_range(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_pos_tim_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_pos_offsref_is_in_range(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_can_nbt_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_pos_zero_capture_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_ref_reso_edge_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_speed_1_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_speed_2_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_pos_tol_win_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_pos_preset_val_is_in_range(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_pos_zero_offset_is_in_range(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_pos_nd_scale_is_in_range(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_pos_nd_offset_is_in_range(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_fb2_scale_ext_is_in_range(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_pos_offset_slack_is_in_range(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_pos_diff_slack_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_fun_para_read_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_fun_para_write_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_fun_special_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_can_id_2_rx_is_in_range(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_can_id_2_tx_is_in_range(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_v_ref_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_v_kp_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_pid_n__ti_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_clear_errors_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_pos_cmd_is_in_range(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_can_error_busoff_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_can_error_writetime_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_ecode_bit0_firsterrordtcd148_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_can_error_no_ack_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_can_error_crc_check150_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_can_error_crc_check151_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_info_timer_diff_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_ballastcount_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_m_temp_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_mo_feedback_1_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_dc_bus_min_lim_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_fb_incr_mot_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_fb_pole_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_logic_freq_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_pwm_1_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_pwm_2_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_pwm_3_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_timer_delta_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_inverter_r_rcv_motor_lsq_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_r_rcv_motor_lsq_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_motor_lsq_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_inverter_r_rcv_motor_lsd_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_r_rcv_motor_lsd_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_motor_lsd_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_id_nom_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_inverter_r_rcv_motor_lm_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_r_rcv_motor_lm_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_motor_lm_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_motor_rr_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_id_min_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_motor_tr_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_motor_rs_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t primary_inverter_r_rcv_motor_ts_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_r_rcv_motor_ts_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_motor_ts_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_def_end_1_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_def_end_2_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_def_din_1_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_def_din_2_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_operand194_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t primary_inverter_r_rcv_i_max_inuse_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_r_rcv_i_max_inuse_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_i_max_inuse_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_signal_go_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_signal_brake_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_signal_icns_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_signal_lessn0_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_signal_postolerance_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_ain_in_1_scaled251_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_ain_in_2_scaled252_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_operand195_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_operand218_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_operand219_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_pid_i__xkp__iq_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_inverter_r_rcv_bat_opr_limit__mot_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_r_rcv_bat_opr_limit__mot_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_bat_opr_limit__mot_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_pid_i__kf__iq_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_dc_current_sens_ena_set_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_cmc__bit0__dc_current_sens_ena_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_n_rpm_maxint_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_var_1_is_in_range(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_can_rxtimeout_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_var_2_is_in_range(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_var_3_is_in_range(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_var_4_is_in_range(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_dup__bit7_0__dac_source_channel_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_fb_lossofsignal_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_no_hw_fault_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_t_peak_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_brake_delay_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_power_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_work_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_extra__start_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_capture_channel_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_trig_level_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_trig_edge_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_trig_source_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_oszi_source_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_oszi_skip_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_oszi_run_cmd_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_oszi_read_cmd_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_pos_ref_start_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_inverter_r_rcv_vdc_bus_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_r_rcv_vdc_bus_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_vdc_bus_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_m_cmd_ramp_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_lmt_1_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_out_1_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_subversion_nr_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_ballast_ext_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_ncr064_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_err_powerfault_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_lmt2_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_km_speed_0_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_ncr082_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_ecode_bit1__hw1_state99_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_ecode_bit1__hw1_state148_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_dc_i_sensena_set_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_cmc__bit1__idc_limit_ena_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_lmt_2_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_out_2_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_fb_special_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_lim_plus64_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_err_rfe_fault_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_in2_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_cs_ain_2_format_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_km_frg_off_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_lim_plus82_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_ecode_bit2__hw0_state99_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_ecode_bit2__hw0_state148_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_op_mode_quadrant_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_cmc__bit2__pdc_limit_usage_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_in_2_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_rdy155_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_coaststop_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_lim_minus64_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_err_bustimeout_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_in1_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_km_cal_off_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_lim_minus82_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_ecode_bit3__free99_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_ecode_bit3__free148_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_cmc__bit3__torqueval_init_ena_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_in_1_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_go155_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_i_ist_inverse_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_ok64_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_err_feedbacksignal_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_frgrun_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_cs_ain_1_mode_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_km_tx_tog_stat_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_ok82_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_ecode_bit4__rdy399_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_ecode_bit4__rdy3148_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_compare_var194_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_compare_var195_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_compare_var218_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_compare_var219_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_cmc__bit4__dig_m_rcpramp_ena_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_run152_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_out_3_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_refsoft_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_icns64_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_err_powervoltage_low_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_rfe216_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_km_i_limit_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_icns82_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_ecode_bit5__n_fail99_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_ecode_bit5__n_fail148_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_mo_feedback_2_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_recup_is_acv_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_cmc__bit5__reset_nramp_atnzero_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_rfe152_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_out_4_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_no_uesp_btb_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_tnlim64_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_err_motortemp_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_km_n_clip_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_tnlim82_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_ecode_bit6__flths99_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_ecode_bit6__flths148_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_i_dc_limit_is_acv_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_cmc__bit6__torquetimeout_100ms_e_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_rsvd_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_rsvd1_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_vdc_ana_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_pn64_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_err_devicetemp_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_cs_oora1_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_km_mix_ana_on_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_pn82_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_ecode_bit7__fltls99_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_ecode_bit7__fltls148_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_cmc__bit13_7__free_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_brk1155_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_i1_adc_ena_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_ni64_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_err_overvoltage_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_out1_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_cs_ain_2_mode_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_ctrlsubmode_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_km_allow_sync_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_ni82_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t primary_inverter_r_rcv_ain_in_2_filter_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_r_rcv_ain_in_2_filter_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_ain_in_2_filter_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_ecode_bit8__fail_idc99_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_ecode_bit8__fail_idc148_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_mo_sc1_reso_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_source_id194_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_source_id195_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_source_id218_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_source_id219_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_dup__bit8__can_extended_0_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_hxinv_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv__n064_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_err_ipeak_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_out2_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_km_handwheel_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv__n082_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_ecode_bit9__fail_i99_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_ecode_bit9__fail_i148_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_dup__bit9__generator_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_h2inv_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_rsw64_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_err_raceaway_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_btbrdy_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_km_phasing_extend_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_rsw82_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_ecode_bit10__vccm99_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_ecode_bit10__vccm148_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_dup__bit10__park_rms_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_ol_comp_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_cal064_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_err_user_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_go216_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_cs_oora2_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_km_rsvd_11_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_cal082_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_ecode_bit11__15m_minus99_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_ecode_bit11__15m_minus148_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_mo_sc1_comp_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_dup__bit11__dcbus_volts_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_test_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_motortype_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_cal64_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_out3_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_cs_cmd_type_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_currentmode_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_km_rsvd_12_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_cal82_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_ecode_bit12__15m_plus99_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_ecode_bit12__15m_plus148_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_mo_sc2_reso_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_dup__bit12__boat_pedal_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_tol64_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_out4_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_km_rsvd_13_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_tol82_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_ecode_bit13__18m_plus99_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_ecode_bit13__18m_plus148_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_dup__bit13__gen_autoiaclimit_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_ana_0up_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_rdy64_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_err_hwerr_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_goff_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_cs_ain_2__i_limit_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_km_pseudo_enable_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_rdy82_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_ecode_bit14__ubmam99_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_ecode_bit14__ubmam148_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_cmc__bit14__idc_limit_ena_v2_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_dup__bit14__mtpa_reluct_enab_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_lowbd_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_brk064_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_err_ballast_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_brk1216_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_cs_ain_1__n_limit_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_km_debug_test_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_brk082_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_ecode_bit15__t_igbt99_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_ecode_bit15__t_igbt148_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_mo_sc2_inv_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_active190_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_active191_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_active192_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_active193_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_gen_autoiaclimit_is_acv_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_cmc__bit15__dig_e_brake_act_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_dup__bit15__canopen_acv_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_m_r_dec_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_m_r_rcp_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_sramp_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_signmag64_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_warn_warning_0_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_ain_in_1_scaled213_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_ain_in_2_scaled214_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_t_dc__stop_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t primary_inverter_r_rcv_v_dc__stop_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_r_rcv_v_dc__stop_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_v_dc__stop_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t primary_inverter_r_rcv_v_min__stop_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_r_rcv_v_min__stop_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_v_min__stop_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t primary_inverter_r_rcv_f_min__stop_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_r_rcv_f_min__stop_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_f_min__stop_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t primary_inverter_r_rcv_v_corner__stop_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_r_rcv_v_corner__stop_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_v_corner__stop_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t primary_inverter_r_rcv_f_corner__stop_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_r_rcv_f_corner__stop_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_f_corner__stop_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_pid_i__kp__id_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_pid_i__ti__id_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_pid_i__tim__id_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t primary_inverter_r_rcv_ain_in_1_scaleval_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_r_rcv_ain_in_1_scaleval_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_ain_in_1_scaleval_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t primary_inverter_r_rcv_ain_in_2_scaleval_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_r_rcv_ain_in_2_scaleval_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_ain_in_2_scaleval_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_signmag82_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_regen_r_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_dc_bus_max_lim_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_pid_i__xkp__id_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_inverter_r_rcv_bat_opr_limit__gen_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_inverter_r_rcv_bat_opr_limit__gen_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_bat_opr_limit__gen_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_pid_i__kf__id_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_cmc__bit17_16__checkipeak_config_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_dup__bit16__bamobil3_2_offcrct_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_special__stop_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_free_is_in_range(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_svnrevision_nr_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_ramp4_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_nclip64_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_warn_illegal_status_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_nclip82_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_dup__bit19_17__ecode_redefine_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_motbrake_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_nclip_minus64_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_warn_safe_in_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_nclip_minus82_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_cmc__bit18__tractioncontrol_ena_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_ac_dc_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_nclip_plus64_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_nclip_plus82_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_cmc__bit20_19__tc_deltatime_conf_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_pwm_freq_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_irddig64_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_irddig82_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_dup__bit20__hal_extmr_acv_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_iuserchd64_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_iuserchd82_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_cmc__bit22_21__tc_minspeed_conf_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_dup__bit21__initwith_frg_off_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_irdn64_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_warn_motortemp_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_irdn82_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_dup__bit31_22__free_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_ntc_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_irdti64_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_warn_devicetemp_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_irdti82_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_cmc__bit23__tc_ncmdrestoption_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_m_r_acc_is_in_range(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_delta_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_irdtir64_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_warn_vout_sat_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_irdtir82_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_cmc__bit31_24__free_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_dc_1qdirvolt_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv__10hz64_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_warn_ipeak_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv__10hz82_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_dc_field_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_irdtm64_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_warn_raceaway_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_irdtm82_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_dead_2_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_irdana64_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_irdana82_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_block_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_iwcns64_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_iwcns82_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_dc_1qmv_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_rfepulse64_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_rfepulse82_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_dc_1q3p_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_md64_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_md82_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_reducelosses_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_hndwhl64_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_warn_ballast_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_r_rcv_hndwhl82_is_in_range(uint8_t value);


;


;


void primary_bms_hv_jmp_to_blt_raw_to_conversion_struct(
    primary_bms_hv_jmp_to_blt_converted_t *conversion, 
    const primary_bms_hv_jmp_to_blt_t *raw);


void primary_bms_hv_jmp_to_blt_conversion_to_raw_struct(
    primary_bms_hv_jmp_to_blt_t *raw,
    const primary_bms_hv_jmp_to_blt_converted_t *conversion);


int primary_bms_hv_jmp_to_blt_to_string(primary_bms_hv_jmp_to_blt_t *message, char *buffer);

int primary_bms_hv_jmp_to_blt_to_string_file(primary_bms_hv_jmp_to_blt_t *message, FILE *buffer);

int primary_bms_hv_jmp_to_blt_fields(char *buffer);

int primary_bms_hv_jmp_to_blt_fields_file(FILE *buffer);

/**
 * Pack message BMS_HV_JMP_TO_BLT.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_bms_hv_jmp_to_blt_pack(
    uint8_t *dst_p,
    const primary_bms_hv_jmp_to_blt_t *src_p,
    size_t size);

/**
 * Unpack message BMS_HV_JMP_TO_BLT.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_bms_hv_jmp_to_blt_unpack(
    primary_bms_hv_jmp_to_blt_t *dst_p,
    const uint8_t *src_p,
    size_t size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void primary_bms_lv_jmp_to_blt_raw_to_conversion_struct(
    primary_bms_lv_jmp_to_blt_converted_t *conversion, 
    const primary_bms_lv_jmp_to_blt_t *raw);


void primary_bms_lv_jmp_to_blt_conversion_to_raw_struct(
    primary_bms_lv_jmp_to_blt_t *raw,
    const primary_bms_lv_jmp_to_blt_converted_t *conversion);


int primary_bms_lv_jmp_to_blt_to_string(primary_bms_lv_jmp_to_blt_t *message, char *buffer);

int primary_bms_lv_jmp_to_blt_to_string_file(primary_bms_lv_jmp_to_blt_t *message, FILE *buffer);

int primary_bms_lv_jmp_to_blt_fields(char *buffer);

int primary_bms_lv_jmp_to_blt_fields_file(FILE *buffer);

/**
 * Pack message BMS_LV_JMP_TO_BLT.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_bms_lv_jmp_to_blt_pack(
    uint8_t *dst_p,
    const primary_bms_lv_jmp_to_blt_t *src_p,
    size_t size);

/**
 * Unpack message BMS_LV_JMP_TO_BLT.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_bms_lv_jmp_to_blt_unpack(
    primary_bms_lv_jmp_to_blt_t *dst_p,
    const uint8_t *src_p,
    size_t size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


void primary_steer_version_raw_to_conversion(
    primary_steer_version_converted_t *conversion,
    uint8_t component_version,
    uint32_t canlib_build_time
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_steer_version_conversion_to_raw(
    primary_steer_version_t *raw,
    uint8_t component_version,
    uint32_t canlib_build_time
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_steer_version_raw_to_conversion_struct(
    primary_steer_version_converted_t *conversion, 
    const primary_steer_version_t *raw);


void primary_steer_version_conversion_to_raw_struct(
    primary_steer_version_t *raw,
    const primary_steer_version_converted_t *conversion);


int primary_steer_version_to_string(primary_steer_version_t *message, char *buffer);

int primary_steer_version_to_string_file(primary_steer_version_t *message, FILE *buffer);

int primary_steer_version_fields(char *buffer);

int primary_steer_version_fields_file(FILE *buffer);

/**
 * Pack message STEER_VERSION.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_steer_version_pack(
    uint8_t *dst_p,
    const primary_steer_version_t *src_p,
    size_t size);

/**
 * Unpack message STEER_VERSION.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_steer_version_unpack(
    primary_steer_version_t *dst_p,
    const uint8_t *src_p,
    size_t size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_steer_version_component_version_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_steer_version_canlib_build_time_is_in_range(uint32_t value);


void primary_das_version_raw_to_conversion(
    primary_das_version_converted_t *conversion,
    uint8_t component_version,
    uint32_t canlib_build_time
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_das_version_conversion_to_raw(
    primary_das_version_t *raw,
    uint8_t component_version,
    uint32_t canlib_build_time
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_das_version_raw_to_conversion_struct(
    primary_das_version_converted_t *conversion, 
    const primary_das_version_t *raw);


void primary_das_version_conversion_to_raw_struct(
    primary_das_version_t *raw,
    const primary_das_version_converted_t *conversion);


int primary_das_version_to_string(primary_das_version_t *message, char *buffer);

int primary_das_version_to_string_file(primary_das_version_t *message, FILE *buffer);

int primary_das_version_fields(char *buffer);

int primary_das_version_fields_file(FILE *buffer);

/**
 * Pack message DAS_VERSION.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_das_version_pack(
    uint8_t *dst_p,
    const primary_das_version_t *src_p,
    size_t size);

/**
 * Unpack message DAS_VERSION.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_das_version_unpack(
    primary_das_version_t *dst_p,
    const uint8_t *src_p,
    size_t size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_das_version_component_version_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_das_version_canlib_build_time_is_in_range(uint32_t value);


void primary_hv_version_raw_to_conversion(
    primary_hv_version_converted_t *conversion,
    uint8_t component_version,
    uint32_t canlib_build_time
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_hv_version_conversion_to_raw(
    primary_hv_version_t *raw,
    uint8_t component_version,
    uint32_t canlib_build_time
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_hv_version_raw_to_conversion_struct(
    primary_hv_version_converted_t *conversion, 
    const primary_hv_version_t *raw);


void primary_hv_version_conversion_to_raw_struct(
    primary_hv_version_t *raw,
    const primary_hv_version_converted_t *conversion);


int primary_hv_version_to_string(primary_hv_version_t *message, char *buffer);

int primary_hv_version_to_string_file(primary_hv_version_t *message, FILE *buffer);

int primary_hv_version_fields(char *buffer);

int primary_hv_version_fields_file(FILE *buffer);

/**
 * Pack message HV_VERSION.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_hv_version_pack(
    uint8_t *dst_p,
    const primary_hv_version_t *src_p,
    size_t size);

/**
 * Unpack message HV_VERSION.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_hv_version_unpack(
    primary_hv_version_t *dst_p,
    const uint8_t *src_p,
    size_t size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_version_component_version_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_version_canlib_build_time_is_in_range(uint32_t value);


void primary_lv_version_raw_to_conversion(
    primary_lv_version_converted_t *conversion,
    uint8_t component_version,
    uint32_t canlib_build_time
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_lv_version_conversion_to_raw(
    primary_lv_version_t *raw,
    uint8_t component_version,
    uint32_t canlib_build_time
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_lv_version_raw_to_conversion_struct(
    primary_lv_version_converted_t *conversion, 
    const primary_lv_version_t *raw);


void primary_lv_version_conversion_to_raw_struct(
    primary_lv_version_t *raw,
    const primary_lv_version_converted_t *conversion);


int primary_lv_version_to_string(primary_lv_version_t *message, char *buffer);

int primary_lv_version_to_string_file(primary_lv_version_t *message, FILE *buffer);

int primary_lv_version_fields(char *buffer);

int primary_lv_version_fields_file(FILE *buffer);

/**
 * Pack message LV_VERSION.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_lv_version_pack(
    uint8_t *dst_p,
    const primary_lv_version_t *src_p,
    size_t size);

/**
 * Unpack message LV_VERSION.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_lv_version_unpack(
    primary_lv_version_t *dst_p,
    const uint8_t *src_p,
    size_t size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_version_component_version_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_version_canlib_build_time_is_in_range(uint32_t value);


void primary_tlm_version_raw_to_conversion(
    primary_tlm_version_converted_t *conversion,
    uint8_t component_version,
    uint32_t canlib_build_time
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_tlm_version_conversion_to_raw(
    primary_tlm_version_t *raw,
    uint8_t component_version,
    uint32_t canlib_build_time
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_tlm_version_raw_to_conversion_struct(
    primary_tlm_version_converted_t *conversion, 
    const primary_tlm_version_t *raw);


void primary_tlm_version_conversion_to_raw_struct(
    primary_tlm_version_t *raw,
    const primary_tlm_version_converted_t *conversion);


int primary_tlm_version_to_string(primary_tlm_version_t *message, char *buffer);

int primary_tlm_version_to_string_file(primary_tlm_version_t *message, FILE *buffer);

int primary_tlm_version_fields(char *buffer);

int primary_tlm_version_fields_file(FILE *buffer);

/**
 * Pack message TLM_VERSION.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_tlm_version_pack(
    uint8_t *dst_p,
    const primary_tlm_version_t *src_p,
    size_t size);

/**
 * Unpack message TLM_VERSION.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_tlm_version_unpack(
    primary_tlm_version_t *dst_p,
    const uint8_t *src_p,
    size_t size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_tlm_version_component_version_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_tlm_version_canlib_build_time_is_in_range(uint32_t value);


void primary_timestamp_raw_to_conversion(
    primary_timestamp_converted_t *conversion,
    uint32_t timestamp
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_timestamp_conversion_to_raw(
    primary_timestamp_t *raw,
    uint32_t timestamp
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_timestamp_raw_to_conversion_struct(
    primary_timestamp_converted_t *conversion, 
    const primary_timestamp_t *raw);


void primary_timestamp_conversion_to_raw_struct(
    primary_timestamp_t *raw,
    const primary_timestamp_converted_t *conversion);


int primary_timestamp_to_string(primary_timestamp_t *message, char *buffer);

int primary_timestamp_to_string_file(primary_timestamp_t *message, FILE *buffer);

int primary_timestamp_fields(char *buffer);

int primary_timestamp_fields_file(FILE *buffer);

/**
 * Pack message TIMESTAMP.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_timestamp_pack(
    uint8_t *dst_p,
    const primary_timestamp_t *src_p,
    size_t size);

/**
 * Unpack message TIMESTAMP.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_timestamp_unpack(
    primary_timestamp_t *dst_p,
    const uint8_t *src_p,
    size_t size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_timestamp_timestamp_is_in_range(uint32_t value);


void primary_ambient_temperature_raw_to_conversion(
    primary_ambient_temperature_converted_t *conversion,
    int16_t temp
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_ambient_temperature_conversion_to_raw(
    primary_ambient_temperature_t *raw,
    int16_t temp
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_ambient_temperature_raw_to_conversion_struct(
    primary_ambient_temperature_converted_t *conversion, 
    const primary_ambient_temperature_t *raw);


void primary_ambient_temperature_conversion_to_raw_struct(
    primary_ambient_temperature_t *raw,
    const primary_ambient_temperature_converted_t *conversion);


int primary_ambient_temperature_to_string(primary_ambient_temperature_t *message, char *buffer);

int primary_ambient_temperature_to_string_file(primary_ambient_temperature_t *message, FILE *buffer);

int primary_ambient_temperature_fields(char *buffer);

int primary_ambient_temperature_fields_file(FILE *buffer);

/**
 * Pack message AMBIENT_TEMPERATURE.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_ambient_temperature_pack(
    uint8_t *dst_p,
    const primary_ambient_temperature_t *src_p,
    size_t size);

/**
 * Unpack message AMBIENT_TEMPERATURE.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_ambient_temperature_unpack(
    primary_ambient_temperature_t *dst_p,
    const uint8_t *src_p,
    size_t size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_ambient_temperature_temp_is_in_range(int16_t value);


void primary_data_logger_raw_to_conversion(
    primary_data_logger_converted_t *conversion,
    uint32_t placeholder1,
    uint32_t placeholder2
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_data_logger_conversion_to_raw(
    primary_data_logger_t *raw,
    uint32_t placeholder1,
    uint32_t placeholder2
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_data_logger_raw_to_conversion_struct(
    primary_data_logger_converted_t *conversion, 
    const primary_data_logger_t *raw);


void primary_data_logger_conversion_to_raw_struct(
    primary_data_logger_t *raw,
    const primary_data_logger_converted_t *conversion);


int primary_data_logger_to_string(primary_data_logger_t *message, char *buffer);

int primary_data_logger_to_string_file(primary_data_logger_t *message, FILE *buffer);

int primary_data_logger_fields(char *buffer);

int primary_data_logger_fields_file(FILE *buffer);

/**
 * Pack message DATA_LOGGER.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_data_logger_pack(
    uint8_t *dst_p,
    const primary_data_logger_t *src_p,
    size_t size);

/**
 * Unpack message DATA_LOGGER.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_data_logger_unpack(
    primary_data_logger_t *dst_p,
    const uint8_t *src_p,
    size_t size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_data_logger_placeholder1_is_in_range(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_data_logger_placeholder2_is_in_range(uint32_t value);


void primary_set_tlm_status_raw_to_conversion(
    primary_set_tlm_status_converted_t *conversion,
    primary_set_tlm_status_tlm_status tlm_status
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_set_tlm_status_conversion_to_raw(
    primary_set_tlm_status_t *raw,
    primary_set_tlm_status_tlm_status tlm_status
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_set_tlm_status_raw_to_conversion_struct(
    primary_set_tlm_status_converted_t *conversion, 
    const primary_set_tlm_status_t *raw);


void primary_set_tlm_status_conversion_to_raw_struct(
    primary_set_tlm_status_t *raw,
    const primary_set_tlm_status_converted_t *conversion);

int primary_set_tlm_status_tlm_status_enum_to_string(primary_set_tlm_status_tlm_status value, char *buffer);

int primary_set_tlm_status_to_string(primary_set_tlm_status_t *message, char *buffer);

int primary_set_tlm_status_to_string_file(primary_set_tlm_status_t *message, FILE *buffer);

int primary_set_tlm_status_fields(char *buffer);

int primary_set_tlm_status_fields_file(FILE *buffer);

/**
 * Pack message SET_TLM_STATUS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_set_tlm_status_pack(
    uint8_t *dst_p,
    const primary_set_tlm_status_t *src_p,
    size_t size);

/**
 * Unpack message SET_TLM_STATUS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_set_tlm_status_unpack(
    primary_set_tlm_status_t *dst_p,
    const uint8_t *src_p,
    size_t size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_set_tlm_status_tlm_status_is_in_range(uint8_t value);


void primary_tlm_status_raw_to_conversion(
    primary_tlm_status_converted_t *conversion,
    primary_tlm_status_tlm_status tlm_status
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_tlm_status_conversion_to_raw(
    primary_tlm_status_t *raw,
    primary_tlm_status_tlm_status tlm_status
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_tlm_status_raw_to_conversion_struct(
    primary_tlm_status_converted_t *conversion, 
    const primary_tlm_status_t *raw);


void primary_tlm_status_conversion_to_raw_struct(
    primary_tlm_status_t *raw,
    const primary_tlm_status_converted_t *conversion);

int primary_tlm_status_tlm_status_enum_to_string(primary_tlm_status_tlm_status value, char *buffer);

int primary_tlm_status_to_string(primary_tlm_status_t *message, char *buffer);

int primary_tlm_status_to_string_file(primary_tlm_status_t *message, FILE *buffer);

int primary_tlm_status_fields(char *buffer);

int primary_tlm_status_fields_file(FILE *buffer);

/**
 * Pack message TLM_STATUS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_tlm_status_pack(
    uint8_t *dst_p,
    const primary_tlm_status_t *src_p,
    size_t size);

/**
 * Unpack message TLM_STATUS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_tlm_status_unpack(
    primary_tlm_status_t *dst_p,
    const uint8_t *src_p,
    size_t size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_tlm_status_tlm_status_is_in_range(uint8_t value);


void primary_steer_system_status_raw_to_conversion(
    primary_steer_system_status_converted_t *conversion,
    uint8_t soc_temp
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_steer_system_status_conversion_to_raw(
    primary_steer_system_status_t *raw,
    uint8_t soc_temp
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_steer_system_status_raw_to_conversion_struct(
    primary_steer_system_status_converted_t *conversion, 
    const primary_steer_system_status_t *raw);


void primary_steer_system_status_conversion_to_raw_struct(
    primary_steer_system_status_t *raw,
    const primary_steer_system_status_converted_t *conversion);


int primary_steer_system_status_to_string(primary_steer_system_status_t *message, char *buffer);

int primary_steer_system_status_to_string_file(primary_steer_system_status_t *message, FILE *buffer);

int primary_steer_system_status_fields(char *buffer);

int primary_steer_system_status_fields_file(FILE *buffer);

/**
 * Pack message STEER_SYSTEM_STATUS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_steer_system_status_pack(
    uint8_t *dst_p,
    const primary_steer_system_status_t *src_p,
    size_t size);

/**
 * Unpack message STEER_SYSTEM_STATUS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_steer_system_status_unpack(
    primary_steer_system_status_t *dst_p,
    const uint8_t *src_p,
    size_t size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_steer_system_status_soc_temp_is_in_range(uint8_t value);


void primary_hv_voltage_raw_to_conversion(
    primary_hv_voltage_converted_t *conversion,
    float pack_voltage,
    float bus_voltage,
    float max_cell_voltage,
    float min_cell_voltage
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_hv_voltage_conversion_to_raw(
    primary_hv_voltage_t *raw,
    float pack_voltage,
    float bus_voltage,
    float max_cell_voltage,
    float min_cell_voltage
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_hv_voltage_raw_to_conversion_struct(
    primary_hv_voltage_converted_t *conversion, 
    const primary_hv_voltage_t *raw);


void primary_hv_voltage_conversion_to_raw_struct(
    primary_hv_voltage_t *raw,
    const primary_hv_voltage_converted_t *conversion);


int primary_hv_voltage_converted_to_string(primary_hv_voltage_converted_t *message, char *buffer);

int primary_hv_voltage_converted_to_string_file(primary_hv_voltage_converted_t *message, FILE *buffer);

int primary_hv_voltage_fields(char *buffer);

int primary_hv_voltage_fields_file(FILE *buffer);

/**
 * Pack message HV_VOLTAGE.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_hv_voltage_pack(
    uint8_t *dst_p,
    const primary_hv_voltage_t *src_p,
    size_t size);

/**
 * Unpack message HV_VOLTAGE.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_hv_voltage_unpack(
    primary_hv_voltage_t *dst_p,
    const uint8_t *src_p,
    size_t size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t primary_hv_voltage_pack_voltage_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_hv_voltage_pack_voltage_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_voltage_pack_voltage_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t primary_hv_voltage_bus_voltage_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_hv_voltage_bus_voltage_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_voltage_bus_voltage_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t primary_hv_voltage_max_cell_voltage_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_hv_voltage_max_cell_voltage_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_voltage_max_cell_voltage_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t primary_hv_voltage_min_cell_voltage_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_hv_voltage_min_cell_voltage_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_voltage_min_cell_voltage_is_in_range(uint8_t value);


void primary_hv_current_raw_to_conversion(
    primary_hv_current_converted_t *conversion,
    float current,
    float power,
    float energy,
    float soc
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_hv_current_conversion_to_raw(
    primary_hv_current_t *raw,
    float current,
    float power,
    float energy,
    float soc
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_hv_current_raw_to_conversion_struct(
    primary_hv_current_converted_t *conversion, 
    const primary_hv_current_t *raw);


void primary_hv_current_conversion_to_raw_struct(
    primary_hv_current_t *raw,
    const primary_hv_current_converted_t *conversion);


int primary_hv_current_converted_to_string(primary_hv_current_converted_t *message, char *buffer);

int primary_hv_current_converted_to_string_file(primary_hv_current_converted_t *message, FILE *buffer);

int primary_hv_current_fields(char *buffer);

int primary_hv_current_fields_file(FILE *buffer);

/**
 * Pack message HV_CURRENT.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_hv_current_pack(
    uint8_t *dst_p,
    const primary_hv_current_t *src_p,
    size_t size);

/**
 * Unpack message HV_CURRENT.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_hv_current_unpack(
    primary_hv_current_t *dst_p,
    const uint8_t *src_p,
    size_t size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t primary_hv_current_current_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_hv_current_current_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_current_current_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t primary_hv_current_power_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_hv_current_power_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_current_power_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t primary_hv_current_energy_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_hv_current_energy_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_current_energy_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_hv_current_soc_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_hv_current_soc_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_current_soc_is_in_range(uint16_t value);


void primary_hv_temp_raw_to_conversion(
    primary_hv_temp_converted_t *conversion,
    float average_temp,
    float max_temp,
    float min_temp
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_hv_temp_conversion_to_raw(
    primary_hv_temp_t *raw,
    float average_temp,
    float max_temp,
    float min_temp
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_hv_temp_raw_to_conversion_struct(
    primary_hv_temp_converted_t *conversion, 
    const primary_hv_temp_t *raw);


void primary_hv_temp_conversion_to_raw_struct(
    primary_hv_temp_t *raw,
    const primary_hv_temp_converted_t *conversion);


int primary_hv_temp_converted_to_string(primary_hv_temp_converted_t *message, char *buffer);

int primary_hv_temp_converted_to_string_file(primary_hv_temp_converted_t *message, FILE *buffer);

int primary_hv_temp_fields(char *buffer);

int primary_hv_temp_fields_file(FILE *buffer);

/**
 * Pack message HV_TEMP.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_hv_temp_pack(
    uint8_t *dst_p,
    const primary_hv_temp_t *src_p,
    size_t size);

/**
 * Unpack message HV_TEMP.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_hv_temp_unpack(
    primary_hv_temp_t *dst_p,
    const uint8_t *src_p,
    size_t size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_hv_temp_average_temp_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_hv_temp_average_temp_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_temp_average_temp_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_hv_temp_max_temp_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_hv_temp_max_temp_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_temp_max_temp_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_hv_temp_min_temp_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_hv_temp_min_temp_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_temp_min_temp_is_in_range(uint16_t value);


void primary_hv_errors_raw_to_conversion(
    primary_hv_errors_converted_t *conversion,
    uint8_t warnings_cell_low_voltage,
    uint8_t warnings_cell_under_voltage,
    uint8_t warnings_cell_over_voltage,
    uint8_t warnings_cell_high_temperature,
    uint8_t warnings_cell_over_temperature,
    uint8_t warnings_over_current,
    uint8_t warnings_can,
    uint8_t warnings_int_voltage_mismatch,
    uint8_t warnings_cellboard_comm,
    uint8_t warnings_cellboard_internal,
    uint8_t warnings_feedback,
    uint8_t warnings_feedback_circuitry,
    uint8_t warnings_eeprom_comm,
    uint8_t warnings_eeprom_write,
    uint8_t errors_cell_low_voltage,
    uint8_t errors_cell_under_voltage,
    uint8_t errors_cell_over_voltage,
    uint8_t errors_cell_high_temperature,
    uint8_t errors_cell_over_temperature,
    uint8_t errors_over_current,
    uint8_t errors_can,
    uint8_t errors_int_voltage_mismatch,
    uint8_t errors_cellboard_comm,
    uint8_t errors_cellboard_internal,
    uint8_t errors_feedback,
    uint8_t errors_feedback_circuitry,
    uint8_t errors_eeprom_comm,
    uint8_t errors_eeprom_write
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_hv_errors_conversion_to_raw(
    primary_hv_errors_t *raw,
    uint8_t warnings_cell_low_voltage,
    uint8_t warnings_cell_under_voltage,
    uint8_t warnings_cell_over_voltage,
    uint8_t warnings_cell_high_temperature,
    uint8_t warnings_cell_over_temperature,
    uint8_t warnings_over_current,
    uint8_t warnings_can,
    uint8_t warnings_int_voltage_mismatch,
    uint8_t warnings_cellboard_comm,
    uint8_t warnings_cellboard_internal,
    uint8_t warnings_feedback,
    uint8_t warnings_feedback_circuitry,
    uint8_t warnings_eeprom_comm,
    uint8_t warnings_eeprom_write,
    uint8_t errors_cell_low_voltage,
    uint8_t errors_cell_under_voltage,
    uint8_t errors_cell_over_voltage,
    uint8_t errors_cell_high_temperature,
    uint8_t errors_cell_over_temperature,
    uint8_t errors_over_current,
    uint8_t errors_can,
    uint8_t errors_int_voltage_mismatch,
    uint8_t errors_cellboard_comm,
    uint8_t errors_cellboard_internal,
    uint8_t errors_feedback,
    uint8_t errors_feedback_circuitry,
    uint8_t errors_eeprom_comm,
    uint8_t errors_eeprom_write
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_hv_errors_raw_to_conversion_struct(
    primary_hv_errors_converted_t *conversion, 
    const primary_hv_errors_t *raw);


void primary_hv_errors_conversion_to_raw_struct(
    primary_hv_errors_t *raw,
    const primary_hv_errors_converted_t *conversion);


int primary_hv_errors_to_string(primary_hv_errors_t *message, char *buffer);

int primary_hv_errors_to_string_file(primary_hv_errors_t *message, FILE *buffer);

int primary_hv_errors_fields(char *buffer);

int primary_hv_errors_fields_file(FILE *buffer);

/**
 * Pack message HV_ERRORS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_hv_errors_pack(
    uint8_t *dst_p,
    const primary_hv_errors_t *src_p,
    size_t size);

/**
 * Unpack message HV_ERRORS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_hv_errors_unpack(
    primary_hv_errors_t *dst_p,
    const uint8_t *src_p,
    size_t size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_errors_warnings_cell_low_voltage_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_errors_warnings_cell_under_voltage_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_errors_warnings_cell_over_voltage_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_errors_warnings_cell_high_temperature_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_errors_warnings_cell_over_temperature_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_errors_warnings_over_current_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_errors_warnings_can_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_errors_warnings_int_voltage_mismatch_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_errors_warnings_cellboard_comm_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_errors_warnings_cellboard_internal_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_errors_warnings_feedback_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_errors_warnings_feedback_circuitry_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_errors_warnings_eeprom_comm_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_errors_warnings_eeprom_write_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_errors_errors_cell_low_voltage_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_errors_errors_cell_under_voltage_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_errors_errors_cell_over_voltage_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_errors_errors_cell_high_temperature_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_errors_errors_cell_over_temperature_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_errors_errors_over_current_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_errors_errors_can_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_errors_errors_int_voltage_mismatch_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_errors_errors_cellboard_comm_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_errors_errors_cellboard_internal_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_errors_errors_feedback_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_errors_errors_feedback_circuitry_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_errors_errors_eeprom_comm_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_errors_errors_eeprom_write_is_in_range(uint8_t value);


void primary_hv_can_forward_raw_to_conversion(
    primary_hv_can_forward_converted_t *conversion,
    primary_hv_can_forward_can_forward_set can_forward_set
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_hv_can_forward_conversion_to_raw(
    primary_hv_can_forward_t *raw,
    primary_hv_can_forward_can_forward_set can_forward_set
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_hv_can_forward_raw_to_conversion_struct(
    primary_hv_can_forward_converted_t *conversion, 
    const primary_hv_can_forward_t *raw);


void primary_hv_can_forward_conversion_to_raw_struct(
    primary_hv_can_forward_t *raw,
    const primary_hv_can_forward_converted_t *conversion);

int primary_hv_can_forward_can_forward_set_enum_to_string(primary_hv_can_forward_can_forward_set value, char *buffer);

int primary_hv_can_forward_to_string(primary_hv_can_forward_t *message, char *buffer);

int primary_hv_can_forward_to_string_file(primary_hv_can_forward_t *message, FILE *buffer);

int primary_hv_can_forward_fields(char *buffer);

int primary_hv_can_forward_fields_file(FILE *buffer);

/**
 * Pack message HV_CAN_FORWARD.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_hv_can_forward_pack(
    uint8_t *dst_p,
    const primary_hv_can_forward_t *src_p,
    size_t size);

/**
 * Unpack message HV_CAN_FORWARD.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_hv_can_forward_unpack(
    primary_hv_can_forward_t *dst_p,
    const uint8_t *src_p,
    size_t size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_can_forward_can_forward_set_is_in_range(uint8_t value);


void primary_hv_fans_override_raw_to_conversion(
    primary_hv_fans_override_converted_t *conversion,
    primary_hv_fans_override_fans_override fans_override,
    float fans_speed
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_hv_fans_override_conversion_to_raw(
    primary_hv_fans_override_t *raw,
    primary_hv_fans_override_fans_override fans_override,
    float fans_speed
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_hv_fans_override_raw_to_conversion_struct(
    primary_hv_fans_override_converted_t *conversion, 
    const primary_hv_fans_override_t *raw);


void primary_hv_fans_override_conversion_to_raw_struct(
    primary_hv_fans_override_t *raw,
    const primary_hv_fans_override_converted_t *conversion);

int primary_hv_fans_override_fans_override_enum_to_string(primary_hv_fans_override_fans_override value, char *buffer);

int primary_hv_fans_override_converted_to_string(primary_hv_fans_override_converted_t *message, char *buffer);

int primary_hv_fans_override_converted_to_string_file(primary_hv_fans_override_converted_t *message, FILE *buffer);

int primary_hv_fans_override_fields(char *buffer);

int primary_hv_fans_override_fields_file(FILE *buffer);

/**
 * Pack message HV_FANS_OVERRIDE.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_hv_fans_override_pack(
    uint8_t *dst_p,
    const primary_hv_fans_override_t *src_p,
    size_t size);

/**
 * Unpack message HV_FANS_OVERRIDE.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_hv_fans_override_unpack(
    primary_hv_fans_override_t *dst_p,
    const uint8_t *src_p,
    size_t size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_fans_override_fans_override_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t primary_hv_fans_override_fans_speed_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_hv_fans_override_fans_speed_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_fans_override_fans_speed_is_in_range(uint32_t value);


void primary_hv_can_forward_status_raw_to_conversion(
    primary_hv_can_forward_status_converted_t *conversion,
    primary_hv_can_forward_status_can_forward_status can_forward_status
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_hv_can_forward_status_conversion_to_raw(
    primary_hv_can_forward_status_t *raw,
    primary_hv_can_forward_status_can_forward_status can_forward_status
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_hv_can_forward_status_raw_to_conversion_struct(
    primary_hv_can_forward_status_converted_t *conversion, 
    const primary_hv_can_forward_status_t *raw);


void primary_hv_can_forward_status_conversion_to_raw_struct(
    primary_hv_can_forward_status_t *raw,
    const primary_hv_can_forward_status_converted_t *conversion);

int primary_hv_can_forward_status_can_forward_status_enum_to_string(primary_hv_can_forward_status_can_forward_status value, char *buffer);

int primary_hv_can_forward_status_to_string(primary_hv_can_forward_status_t *message, char *buffer);

int primary_hv_can_forward_status_to_string_file(primary_hv_can_forward_status_t *message, FILE *buffer);

int primary_hv_can_forward_status_fields(char *buffer);

int primary_hv_can_forward_status_fields_file(FILE *buffer);

/**
 * Pack message HV_CAN_FORWARD_STATUS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_hv_can_forward_status_pack(
    uint8_t *dst_p,
    const primary_hv_can_forward_status_t *src_p,
    size_t size);

/**
 * Unpack message HV_CAN_FORWARD_STATUS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_hv_can_forward_status_unpack(
    primary_hv_can_forward_status_t *dst_p,
    const uint8_t *src_p,
    size_t size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_can_forward_status_can_forward_status_is_in_range(uint8_t value);


void primary_hv_fans_override_status_raw_to_conversion(
    primary_hv_fans_override_status_converted_t *conversion,
    primary_hv_fans_override_status_fans_override fans_override,
    float fans_speed
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_hv_fans_override_status_conversion_to_raw(
    primary_hv_fans_override_status_t *raw,
    primary_hv_fans_override_status_fans_override fans_override,
    float fans_speed
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_hv_fans_override_status_raw_to_conversion_struct(
    primary_hv_fans_override_status_converted_t *conversion, 
    const primary_hv_fans_override_status_t *raw);


void primary_hv_fans_override_status_conversion_to_raw_struct(
    primary_hv_fans_override_status_t *raw,
    const primary_hv_fans_override_status_converted_t *conversion);

int primary_hv_fans_override_status_fans_override_enum_to_string(primary_hv_fans_override_status_fans_override value, char *buffer);

int primary_hv_fans_override_status_converted_to_string(primary_hv_fans_override_status_converted_t *message, char *buffer);

int primary_hv_fans_override_status_converted_to_string_file(primary_hv_fans_override_status_converted_t *message, FILE *buffer);

int primary_hv_fans_override_status_fields(char *buffer);

int primary_hv_fans_override_status_fields_file(FILE *buffer);

/**
 * Pack message HV_FANS_OVERRIDE_STATUS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_hv_fans_override_status_pack(
    uint8_t *dst_p,
    const primary_hv_fans_override_status_t *src_p,
    size_t size);

/**
 * Unpack message HV_FANS_OVERRIDE_STATUS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_hv_fans_override_status_unpack(
    primary_hv_fans_override_status_t *dst_p,
    const uint8_t *src_p,
    size_t size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_fans_override_status_fans_override_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t primary_hv_fans_override_status_fans_speed_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_hv_fans_override_status_fans_speed_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_fans_override_status_fans_speed_is_in_range(uint32_t value);


void primary_hv_feedbacks_status_raw_to_conversion(
    primary_hv_feedbacks_status_converted_t *conversion,
    uint8_t feedbacks_status_feedback_tsal_green_fault,
    uint8_t feedbacks_status_feedback_imd_latched,
    uint8_t feedbacks_status_feedback_tsal_green_fault_latched,
    uint8_t feedbacks_status_feedback_bms_latched,
    uint8_t feedbacks_status_feedback_ext_latched,
    uint8_t feedbacks_status_feedback_tsal_green,
    uint8_t feedbacks_status_feedback_ts_over_60v_status,
    uint8_t feedbacks_status_feedback_airn_status,
    uint8_t feedbacks_status_feedback_airp_status,
    uint8_t feedbacks_status_feedback_airp_gate,
    uint8_t feedbacks_status_feedback_airn_gate,
    uint8_t feedbacks_status_feedback_precharge_status,
    uint8_t feedbacks_status_feedback_tsp_over_60v_status,
    uint8_t feedbacks_status_feedback_check_mux,
    uint8_t feedbacks_status_feedback_sd_in,
    uint8_t feedbacks_status_feedback_sd_out,
    uint8_t feedbacks_status_feedback_relay_sd,
    uint8_t feedbacks_status_feedback_imd_fault,
    uint8_t feedbacks_status_feedback_sd_end,
    uint8_t is_circuitry_error_feedback_tsal_green_fault,
    uint8_t is_circuitry_error_feedback_imd_latched,
    uint8_t is_circuitry_error_feedback_tsal_green_fault_latched,
    uint8_t is_circuitry_error_feedback_bms_latched,
    uint8_t is_circuitry_error_feedback_ext_latched,
    uint8_t is_circuitry_error_feedback_tsal_green,
    uint8_t is_circuitry_error_feedback_ts_over_60v_status,
    uint8_t is_circuitry_error_feedback_airn_status,
    uint8_t is_circuitry_error_feedback_airp_status,
    uint8_t is_circuitry_error_feedback_airp_gate,
    uint8_t is_circuitry_error_feedback_airn_gate,
    uint8_t is_circuitry_error_feedback_precharge_status,
    uint8_t is_circuitry_error_feedback_tsp_over_60v_status,
    uint8_t is_circuitry_error_feedback_check_mux,
    uint8_t is_circuitry_error_feedback_sd_in,
    uint8_t is_circuitry_error_feedback_sd_out,
    uint8_t is_circuitry_error_feedback_relay_sd,
    uint8_t is_circuitry_error_feedback_imd_fault,
    uint8_t is_circuitry_error_feedback_sd_end
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_hv_feedbacks_status_conversion_to_raw(
    primary_hv_feedbacks_status_t *raw,
    uint8_t feedbacks_status_feedback_tsal_green_fault,
    uint8_t feedbacks_status_feedback_imd_latched,
    uint8_t feedbacks_status_feedback_tsal_green_fault_latched,
    uint8_t feedbacks_status_feedback_bms_latched,
    uint8_t feedbacks_status_feedback_ext_latched,
    uint8_t feedbacks_status_feedback_tsal_green,
    uint8_t feedbacks_status_feedback_ts_over_60v_status,
    uint8_t feedbacks_status_feedback_airn_status,
    uint8_t feedbacks_status_feedback_airp_status,
    uint8_t feedbacks_status_feedback_airp_gate,
    uint8_t feedbacks_status_feedback_airn_gate,
    uint8_t feedbacks_status_feedback_precharge_status,
    uint8_t feedbacks_status_feedback_tsp_over_60v_status,
    uint8_t feedbacks_status_feedback_check_mux,
    uint8_t feedbacks_status_feedback_sd_in,
    uint8_t feedbacks_status_feedback_sd_out,
    uint8_t feedbacks_status_feedback_relay_sd,
    uint8_t feedbacks_status_feedback_imd_fault,
    uint8_t feedbacks_status_feedback_sd_end,
    uint8_t is_circuitry_error_feedback_tsal_green_fault,
    uint8_t is_circuitry_error_feedback_imd_latched,
    uint8_t is_circuitry_error_feedback_tsal_green_fault_latched,
    uint8_t is_circuitry_error_feedback_bms_latched,
    uint8_t is_circuitry_error_feedback_ext_latched,
    uint8_t is_circuitry_error_feedback_tsal_green,
    uint8_t is_circuitry_error_feedback_ts_over_60v_status,
    uint8_t is_circuitry_error_feedback_airn_status,
    uint8_t is_circuitry_error_feedback_airp_status,
    uint8_t is_circuitry_error_feedback_airp_gate,
    uint8_t is_circuitry_error_feedback_airn_gate,
    uint8_t is_circuitry_error_feedback_precharge_status,
    uint8_t is_circuitry_error_feedback_tsp_over_60v_status,
    uint8_t is_circuitry_error_feedback_check_mux,
    uint8_t is_circuitry_error_feedback_sd_in,
    uint8_t is_circuitry_error_feedback_sd_out,
    uint8_t is_circuitry_error_feedback_relay_sd,
    uint8_t is_circuitry_error_feedback_imd_fault,
    uint8_t is_circuitry_error_feedback_sd_end
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_hv_feedbacks_status_raw_to_conversion_struct(
    primary_hv_feedbacks_status_converted_t *conversion, 
    const primary_hv_feedbacks_status_t *raw);


void primary_hv_feedbacks_status_conversion_to_raw_struct(
    primary_hv_feedbacks_status_t *raw,
    const primary_hv_feedbacks_status_converted_t *conversion);


int primary_hv_feedbacks_status_to_string(primary_hv_feedbacks_status_t *message, char *buffer);

int primary_hv_feedbacks_status_to_string_file(primary_hv_feedbacks_status_t *message, FILE *buffer);

int primary_hv_feedbacks_status_fields(char *buffer);

int primary_hv_feedbacks_status_fields_file(FILE *buffer);

/**
 * Pack message HV_FEEDBACKS_STATUS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_hv_feedbacks_status_pack(
    uint8_t *dst_p,
    const primary_hv_feedbacks_status_t *src_p,
    size_t size);

/**
 * Unpack message HV_FEEDBACKS_STATUS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_hv_feedbacks_status_unpack(
    primary_hv_feedbacks_status_t *dst_p,
    const uint8_t *src_p,
    size_t size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedbacks_status_feedbacks_status_feedback_tsal_green_fault_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedbacks_status_feedbacks_status_feedback_imd_latched_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedbacks_status_feedbacks_status_feedback_tsal_green_fault_latched_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedbacks_status_feedbacks_status_feedback_bms_latched_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedbacks_status_feedbacks_status_feedback_ext_latched_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedbacks_status_feedbacks_status_feedback_tsal_green_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedbacks_status_feedbacks_status_feedback_ts_over_60v_status_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedbacks_status_feedbacks_status_feedback_airn_status_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedbacks_status_feedbacks_status_feedback_airp_status_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedbacks_status_feedbacks_status_feedback_airp_gate_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedbacks_status_feedbacks_status_feedback_airn_gate_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedbacks_status_feedbacks_status_feedback_precharge_status_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedbacks_status_feedbacks_status_feedback_tsp_over_60v_status_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedbacks_status_feedbacks_status_feedback_check_mux_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedbacks_status_feedbacks_status_feedback_sd_in_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedbacks_status_feedbacks_status_feedback_sd_out_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedbacks_status_feedbacks_status_feedback_relay_sd_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedbacks_status_feedbacks_status_feedback_imd_fault_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedbacks_status_feedbacks_status_feedback_sd_end_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedbacks_status_is_circuitry_error_feedback_tsal_green_fault_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedbacks_status_is_circuitry_error_feedback_imd_latched_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedbacks_status_is_circuitry_error_feedback_tsal_green_fault_latched_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedbacks_status_is_circuitry_error_feedback_bms_latched_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedbacks_status_is_circuitry_error_feedback_ext_latched_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedbacks_status_is_circuitry_error_feedback_tsal_green_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedbacks_status_is_circuitry_error_feedback_ts_over_60v_status_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedbacks_status_is_circuitry_error_feedback_airn_status_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedbacks_status_is_circuitry_error_feedback_airp_status_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedbacks_status_is_circuitry_error_feedback_airp_gate_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedbacks_status_is_circuitry_error_feedback_airn_gate_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedbacks_status_is_circuitry_error_feedback_precharge_status_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedbacks_status_is_circuitry_error_feedback_tsp_over_60v_status_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedbacks_status_is_circuitry_error_feedback_check_mux_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedbacks_status_is_circuitry_error_feedback_sd_in_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedbacks_status_is_circuitry_error_feedback_sd_out_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedbacks_status_is_circuitry_error_feedback_relay_sd_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedbacks_status_is_circuitry_error_feedback_imd_fault_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedbacks_status_is_circuitry_error_feedback_sd_end_is_in_range(uint8_t value);


void primary_hv_imd_status_raw_to_conversion(
    primary_hv_imd_status_converted_t *conversion,
    uint8_t imd_fault,
    primary_hv_imd_status_imd_status imd_status,
    int32_t imd_info
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_hv_imd_status_conversion_to_raw(
    primary_hv_imd_status_t *raw,
    uint8_t imd_fault,
    primary_hv_imd_status_imd_status imd_status,
    int32_t imd_info
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_hv_imd_status_raw_to_conversion_struct(
    primary_hv_imd_status_converted_t *conversion, 
    const primary_hv_imd_status_t *raw);


void primary_hv_imd_status_conversion_to_raw_struct(
    primary_hv_imd_status_t *raw,
    const primary_hv_imd_status_converted_t *conversion);

int primary_hv_imd_status_imd_status_enum_to_string(primary_hv_imd_status_imd_status value, char *buffer);

int primary_hv_imd_status_to_string(primary_hv_imd_status_t *message, char *buffer);

int primary_hv_imd_status_to_string_file(primary_hv_imd_status_t *message, FILE *buffer);

int primary_hv_imd_status_fields(char *buffer);

int primary_hv_imd_status_fields_file(FILE *buffer);

/**
 * Pack message HV_IMD_STATUS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_hv_imd_status_pack(
    uint8_t *dst_p,
    const primary_hv_imd_status_t *src_p,
    size_t size);

/**
 * Unpack message HV_IMD_STATUS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_hv_imd_status_unpack(
    primary_hv_imd_status_t *dst_p,
    const uint8_t *src_p,
    size_t size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_imd_status_imd_fault_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_imd_status_imd_status_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_imd_status_imd_info_is_in_range(int32_t value);


void primary_ts_status_das_raw_to_conversion(
    primary_ts_status_das_converted_t *conversion,
    primary_ts_status_das_ts_status ts_status
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_ts_status_das_conversion_to_raw(
    primary_ts_status_das_t *raw,
    primary_ts_status_das_ts_status ts_status
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_ts_status_das_raw_to_conversion_struct(
    primary_ts_status_das_converted_t *conversion, 
    const primary_ts_status_das_t *raw);


void primary_ts_status_das_conversion_to_raw_struct(
    primary_ts_status_das_t *raw,
    const primary_ts_status_das_converted_t *conversion);

int primary_ts_status_das_ts_status_enum_to_string(primary_ts_status_das_ts_status value, char *buffer);

int primary_ts_status_das_to_string(primary_ts_status_das_t *message, char *buffer);

int primary_ts_status_das_to_string_file(primary_ts_status_das_t *message, FILE *buffer);

int primary_ts_status_das_fields(char *buffer);

int primary_ts_status_das_fields_file(FILE *buffer);

/**
 * Pack message TS_STATUS_DAS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_ts_status_das_pack(
    uint8_t *dst_p,
    const primary_ts_status_das_t *src_p,
    size_t size);

/**
 * Unpack message TS_STATUS_DAS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_ts_status_das_unpack(
    primary_ts_status_das_t *dst_p,
    const uint8_t *src_p,
    size_t size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_ts_status_das_ts_status_is_in_range(uint8_t value);


void primary_ts_status_steer_raw_to_conversion(
    primary_ts_status_steer_converted_t *conversion,
    primary_ts_status_steer_ts_status ts_status
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_ts_status_steer_conversion_to_raw(
    primary_ts_status_steer_t *raw,
    primary_ts_status_steer_ts_status ts_status
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_ts_status_steer_raw_to_conversion_struct(
    primary_ts_status_steer_converted_t *conversion, 
    const primary_ts_status_steer_t *raw);


void primary_ts_status_steer_conversion_to_raw_struct(
    primary_ts_status_steer_t *raw,
    const primary_ts_status_steer_converted_t *conversion);

int primary_ts_status_steer_ts_status_enum_to_string(primary_ts_status_steer_ts_status value, char *buffer);

int primary_ts_status_steer_to_string(primary_ts_status_steer_t *message, char *buffer);

int primary_ts_status_steer_to_string_file(primary_ts_status_steer_t *message, FILE *buffer);

int primary_ts_status_steer_fields(char *buffer);

int primary_ts_status_steer_fields_file(FILE *buffer);

/**
 * Pack message TS_STATUS_STEER.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_ts_status_steer_pack(
    uint8_t *dst_p,
    const primary_ts_status_steer_t *src_p,
    size_t size);

/**
 * Unpack message TS_STATUS_STEER.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_ts_status_steer_unpack(
    primary_ts_status_steer_t *dst_p,
    const uint8_t *src_p,
    size_t size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_ts_status_steer_ts_status_is_in_range(uint8_t value);


void primary_ts_status_handcart_raw_to_conversion(
    primary_ts_status_handcart_converted_t *conversion,
    primary_ts_status_handcart_ts_status ts_status
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_ts_status_handcart_conversion_to_raw(
    primary_ts_status_handcart_t *raw,
    primary_ts_status_handcart_ts_status ts_status
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_ts_status_handcart_raw_to_conversion_struct(
    primary_ts_status_handcart_converted_t *conversion, 
    const primary_ts_status_handcart_t *raw);


void primary_ts_status_handcart_conversion_to_raw_struct(
    primary_ts_status_handcart_t *raw,
    const primary_ts_status_handcart_converted_t *conversion);

int primary_ts_status_handcart_ts_status_enum_to_string(primary_ts_status_handcart_ts_status value, char *buffer);

int primary_ts_status_handcart_to_string(primary_ts_status_handcart_t *message, char *buffer);

int primary_ts_status_handcart_to_string_file(primary_ts_status_handcart_t *message, FILE *buffer);

int primary_ts_status_handcart_fields(char *buffer);

int primary_ts_status_handcart_fields_file(FILE *buffer);

/**
 * Pack message TS_STATUS_HANDCART.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_ts_status_handcart_pack(
    uint8_t *dst_p,
    const primary_ts_status_handcart_t *src_p,
    size_t size);

/**
 * Unpack message TS_STATUS_HANDCART.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_ts_status_handcart_unpack(
    primary_ts_status_handcart_t *dst_p,
    const uint8_t *src_p,
    size_t size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_ts_status_handcart_ts_status_is_in_range(uint8_t value);


void primary_set_ts_status_das_raw_to_conversion(
    primary_set_ts_status_das_converted_t *conversion,
    primary_set_ts_status_das_ts_status_set ts_status_set
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_set_ts_status_das_conversion_to_raw(
    primary_set_ts_status_das_t *raw,
    primary_set_ts_status_das_ts_status_set ts_status_set
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_set_ts_status_das_raw_to_conversion_struct(
    primary_set_ts_status_das_converted_t *conversion, 
    const primary_set_ts_status_das_t *raw);


void primary_set_ts_status_das_conversion_to_raw_struct(
    primary_set_ts_status_das_t *raw,
    const primary_set_ts_status_das_converted_t *conversion);

int primary_set_ts_status_das_ts_status_set_enum_to_string(primary_set_ts_status_das_ts_status_set value, char *buffer);

int primary_set_ts_status_das_to_string(primary_set_ts_status_das_t *message, char *buffer);

int primary_set_ts_status_das_to_string_file(primary_set_ts_status_das_t *message, FILE *buffer);

int primary_set_ts_status_das_fields(char *buffer);

int primary_set_ts_status_das_fields_file(FILE *buffer);

/**
 * Pack message SET_TS_STATUS_DAS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_set_ts_status_das_pack(
    uint8_t *dst_p,
    const primary_set_ts_status_das_t *src_p,
    size_t size);

/**
 * Unpack message SET_TS_STATUS_DAS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_set_ts_status_das_unpack(
    primary_set_ts_status_das_t *dst_p,
    const uint8_t *src_p,
    size_t size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_set_ts_status_das_ts_status_set_is_in_range(uint8_t value);


void primary_set_ts_status_handcart_raw_to_conversion(
    primary_set_ts_status_handcart_converted_t *conversion,
    primary_set_ts_status_handcart_ts_status_set ts_status_set
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_set_ts_status_handcart_conversion_to_raw(
    primary_set_ts_status_handcart_t *raw,
    primary_set_ts_status_handcart_ts_status_set ts_status_set
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_set_ts_status_handcart_raw_to_conversion_struct(
    primary_set_ts_status_handcart_converted_t *conversion, 
    const primary_set_ts_status_handcart_t *raw);


void primary_set_ts_status_handcart_conversion_to_raw_struct(
    primary_set_ts_status_handcart_t *raw,
    const primary_set_ts_status_handcart_converted_t *conversion);

int primary_set_ts_status_handcart_ts_status_set_enum_to_string(primary_set_ts_status_handcart_ts_status_set value, char *buffer);

int primary_set_ts_status_handcart_to_string(primary_set_ts_status_handcart_t *message, char *buffer);

int primary_set_ts_status_handcart_to_string_file(primary_set_ts_status_handcart_t *message, FILE *buffer);

int primary_set_ts_status_handcart_fields(char *buffer);

int primary_set_ts_status_handcart_fields_file(FILE *buffer);

/**
 * Pack message SET_TS_STATUS_HANDCART.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_set_ts_status_handcart_pack(
    uint8_t *dst_p,
    const primary_set_ts_status_handcart_t *src_p,
    size_t size);

/**
 * Unpack message SET_TS_STATUS_HANDCART.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_set_ts_status_handcart_unpack(
    primary_set_ts_status_handcart_t *dst_p,
    const uint8_t *src_p,
    size_t size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_set_ts_status_handcart_ts_status_set_is_in_range(uint8_t value);


void primary_steer_status_raw_to_conversion(
    primary_steer_status_converted_t *conversion,
    float map_pw,
    uint8_t map_sc,
    uint8_t map_tv
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_steer_status_conversion_to_raw(
    primary_steer_status_t *raw,
    float map_pw,
    uint8_t map_sc,
    uint8_t map_tv
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_steer_status_raw_to_conversion_struct(
    primary_steer_status_converted_t *conversion, 
    const primary_steer_status_t *raw);


void primary_steer_status_conversion_to_raw_struct(
    primary_steer_status_t *raw,
    const primary_steer_status_converted_t *conversion);


int primary_steer_status_converted_to_string(primary_steer_status_converted_t *message, char *buffer);

int primary_steer_status_converted_to_string_file(primary_steer_status_converted_t *message, FILE *buffer);

int primary_steer_status_fields(char *buffer);

int primary_steer_status_fields_file(FILE *buffer);

/**
 * Pack message STEER_STATUS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_steer_status_pack(
    uint8_t *dst_p,
    const primary_steer_status_t *src_p,
    size_t size);

/**
 * Unpack message STEER_STATUS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_steer_status_unpack(
    primary_steer_status_t *dst_p,
    const uint8_t *src_p,
    size_t size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t primary_steer_status_map_pw_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_steer_status_map_pw_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_steer_status_map_pw_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_steer_status_map_sc_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_steer_status_map_tv_is_in_range(uint8_t value);


void primary_set_car_status_raw_to_conversion(
    primary_set_car_status_converted_t *conversion,
    primary_set_car_status_car_status_set car_status_set
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_set_car_status_conversion_to_raw(
    primary_set_car_status_t *raw,
    primary_set_car_status_car_status_set car_status_set
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_set_car_status_raw_to_conversion_struct(
    primary_set_car_status_converted_t *conversion, 
    const primary_set_car_status_t *raw);


void primary_set_car_status_conversion_to_raw_struct(
    primary_set_car_status_t *raw,
    const primary_set_car_status_converted_t *conversion);

int primary_set_car_status_car_status_set_enum_to_string(primary_set_car_status_car_status_set value, char *buffer);

int primary_set_car_status_to_string(primary_set_car_status_t *message, char *buffer);

int primary_set_car_status_to_string_file(primary_set_car_status_t *message, FILE *buffer);

int primary_set_car_status_fields(char *buffer);

int primary_set_car_status_fields_file(FILE *buffer);

/**
 * Pack message SET_CAR_STATUS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_set_car_status_pack(
    uint8_t *dst_p,
    const primary_set_car_status_t *src_p,
    size_t size);

/**
 * Unpack message SET_CAR_STATUS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_set_car_status_unpack(
    primary_set_car_status_t *dst_p,
    const uint8_t *src_p,
    size_t size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_set_car_status_car_status_set_is_in_range(uint8_t value);


void primary_set_pedals_range_raw_to_conversion(
    primary_set_pedals_range_converted_t *conversion,
    primary_set_pedals_range_bound bound,
    primary_set_pedals_range_pedal pedal
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_set_pedals_range_conversion_to_raw(
    primary_set_pedals_range_t *raw,
    primary_set_pedals_range_bound bound,
    primary_set_pedals_range_pedal pedal
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_set_pedals_range_raw_to_conversion_struct(
    primary_set_pedals_range_converted_t *conversion, 
    const primary_set_pedals_range_t *raw);


void primary_set_pedals_range_conversion_to_raw_struct(
    primary_set_pedals_range_t *raw,
    const primary_set_pedals_range_converted_t *conversion);

int primary_set_pedals_range_bound_enum_to_string(primary_set_pedals_range_bound value, char *buffer);
int primary_set_pedals_range_pedal_enum_to_string(primary_set_pedals_range_pedal value, char *buffer);

int primary_set_pedals_range_to_string(primary_set_pedals_range_t *message, char *buffer);

int primary_set_pedals_range_to_string_file(primary_set_pedals_range_t *message, FILE *buffer);

int primary_set_pedals_range_fields(char *buffer);

int primary_set_pedals_range_fields_file(FILE *buffer);

/**
 * Pack message SET_PEDALS_RANGE.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_set_pedals_range_pack(
    uint8_t *dst_p,
    const primary_set_pedals_range_t *src_p,
    size_t size);

/**
 * Unpack message SET_PEDALS_RANGE.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_set_pedals_range_unpack(
    primary_set_pedals_range_t *dst_p,
    const uint8_t *src_p,
    size_t size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_set_pedals_range_bound_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_set_pedals_range_pedal_is_in_range(uint8_t value);


void primary_set_steering_angle_range_raw_to_conversion(
    primary_set_steering_angle_range_converted_t *conversion,
    primary_set_steering_angle_range_bound bound
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_set_steering_angle_range_conversion_to_raw(
    primary_set_steering_angle_range_t *raw,
    primary_set_steering_angle_range_bound bound
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_set_steering_angle_range_raw_to_conversion_struct(
    primary_set_steering_angle_range_converted_t *conversion, 
    const primary_set_steering_angle_range_t *raw);


void primary_set_steering_angle_range_conversion_to_raw_struct(
    primary_set_steering_angle_range_t *raw,
    const primary_set_steering_angle_range_converted_t *conversion);

int primary_set_steering_angle_range_bound_enum_to_string(primary_set_steering_angle_range_bound value, char *buffer);

int primary_set_steering_angle_range_to_string(primary_set_steering_angle_range_t *message, char *buffer);

int primary_set_steering_angle_range_to_string_file(primary_set_steering_angle_range_t *message, FILE *buffer);

int primary_set_steering_angle_range_fields(char *buffer);

int primary_set_steering_angle_range_fields_file(FILE *buffer);

/**
 * Pack message SET_STEERING_ANGLE_RANGE.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_set_steering_angle_range_pack(
    uint8_t *dst_p,
    const primary_set_steering_angle_range_t *src_p,
    size_t size);

/**
 * Unpack message SET_STEERING_ANGLE_RANGE.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_set_steering_angle_range_unpack(
    primary_set_steering_angle_range_t *dst_p,
    const uint8_t *src_p,
    size_t size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_set_steering_angle_range_bound_is_in_range(uint8_t value);


void primary_car_status_raw_to_conversion(
    primary_car_status_converted_t *conversion,
    primary_car_status_inverter_l inverter_l,
    primary_car_status_inverter_r inverter_r,
    primary_car_status_car_status car_status
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_car_status_conversion_to_raw(
    primary_car_status_t *raw,
    primary_car_status_inverter_l inverter_l,
    primary_car_status_inverter_r inverter_r,
    primary_car_status_car_status car_status
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_car_status_raw_to_conversion_struct(
    primary_car_status_converted_t *conversion, 
    const primary_car_status_t *raw);


void primary_car_status_conversion_to_raw_struct(
    primary_car_status_t *raw,
    const primary_car_status_converted_t *conversion);

int primary_car_status_inverter_l_enum_to_string(primary_car_status_inverter_l value, char *buffer);
int primary_car_status_inverter_r_enum_to_string(primary_car_status_inverter_r value, char *buffer);
int primary_car_status_car_status_enum_to_string(primary_car_status_car_status value, char *buffer);

int primary_car_status_to_string(primary_car_status_t *message, char *buffer);

int primary_car_status_to_string_file(primary_car_status_t *message, FILE *buffer);

int primary_car_status_fields(char *buffer);

int primary_car_status_fields_file(FILE *buffer);

/**
 * Pack message CAR_STATUS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_car_status_pack(
    uint8_t *dst_p,
    const primary_car_status_t *src_p,
    size_t size);

/**
 * Unpack message CAR_STATUS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_car_status_unpack(
    primary_car_status_t *dst_p,
    const uint8_t *src_p,
    size_t size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_car_status_inverter_l_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_car_status_inverter_r_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_car_status_car_status_is_in_range(uint8_t value);


void primary_das_errors_raw_to_conversion(
    primary_das_errors_converted_t *conversion,
    uint8_t das_error_pedal_adc,
    uint8_t das_error_pedal_implausibility,
    uint8_t das_error_imu_tout,
    uint8_t das_error_irts_tout,
    uint8_t das_error_ts_tout,
    uint8_t das_error_invl_tout,
    uint8_t das_error_invr_tout,
    uint8_t das_error_steer_tout,
    uint8_t das_error_fsm
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_das_errors_conversion_to_raw(
    primary_das_errors_t *raw,
    uint8_t das_error_pedal_adc,
    uint8_t das_error_pedal_implausibility,
    uint8_t das_error_imu_tout,
    uint8_t das_error_irts_tout,
    uint8_t das_error_ts_tout,
    uint8_t das_error_invl_tout,
    uint8_t das_error_invr_tout,
    uint8_t das_error_steer_tout,
    uint8_t das_error_fsm
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_das_errors_raw_to_conversion_struct(
    primary_das_errors_converted_t *conversion, 
    const primary_das_errors_t *raw);


void primary_das_errors_conversion_to_raw_struct(
    primary_das_errors_t *raw,
    const primary_das_errors_converted_t *conversion);


int primary_das_errors_to_string(primary_das_errors_t *message, char *buffer);

int primary_das_errors_to_string_file(primary_das_errors_t *message, FILE *buffer);

int primary_das_errors_fields(char *buffer);

int primary_das_errors_fields_file(FILE *buffer);

/**
 * Pack message DAS_ERRORS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_das_errors_pack(
    uint8_t *dst_p,
    const primary_das_errors_t *src_p,
    size_t size);

/**
 * Unpack message DAS_ERRORS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_das_errors_unpack(
    primary_das_errors_t *dst_p,
    const uint8_t *src_p,
    size_t size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_das_errors_das_error_pedal_adc_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_das_errors_das_error_pedal_implausibility_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_das_errors_das_error_imu_tout_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_das_errors_das_error_irts_tout_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_das_errors_das_error_ts_tout_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_das_errors_das_error_invl_tout_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_das_errors_das_error_invr_tout_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_das_errors_das_error_steer_tout_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_das_errors_das_error_fsm_is_in_range(uint8_t value);


void primary_lv_current_raw_to_conversion(
    primary_lv_current_converted_t *conversion,
    float current
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_lv_current_conversion_to_raw(
    primary_lv_current_t *raw,
    float current
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_lv_current_raw_to_conversion_struct(
    primary_lv_current_converted_t *conversion, 
    const primary_lv_current_t *raw);


void primary_lv_current_conversion_to_raw_struct(
    primary_lv_current_t *raw,
    const primary_lv_current_converted_t *conversion);


int primary_lv_current_converted_to_string(primary_lv_current_converted_t *message, char *buffer);

int primary_lv_current_converted_to_string_file(primary_lv_current_converted_t *message, FILE *buffer);

int primary_lv_current_fields(char *buffer);

int primary_lv_current_fields_file(FILE *buffer);

/**
 * Pack message LV_CURRENT.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_lv_current_pack(
    uint8_t *dst_p,
    const primary_lv_current_t *src_p,
    size_t size);

/**
 * Unpack message LV_CURRENT.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_lv_current_unpack(
    primary_lv_current_t *dst_p,
    const uint8_t *src_p,
    size_t size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t primary_lv_current_current_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_lv_current_current_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_current_current_is_in_range(uint32_t value);


void primary_lv_voltage_raw_to_conversion(
    primary_lv_voltage_converted_t *conversion,
    float voltage_1,
    float voltage_2,
    float voltage_3,
    float voltage_4
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_lv_voltage_conversion_to_raw(
    primary_lv_voltage_t *raw,
    float voltage_1,
    float voltage_2,
    float voltage_3,
    float voltage_4
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_lv_voltage_raw_to_conversion_struct(
    primary_lv_voltage_converted_t *conversion, 
    const primary_lv_voltage_t *raw);


void primary_lv_voltage_conversion_to_raw_struct(
    primary_lv_voltage_t *raw,
    const primary_lv_voltage_converted_t *conversion);


int primary_lv_voltage_converted_to_string(primary_lv_voltage_converted_t *message, char *buffer);

int primary_lv_voltage_converted_to_string_file(primary_lv_voltage_converted_t *message, FILE *buffer);

int primary_lv_voltage_fields(char *buffer);

int primary_lv_voltage_fields_file(FILE *buffer);

/**
 * Pack message LV_VOLTAGE.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_lv_voltage_pack(
    uint8_t *dst_p,
    const primary_lv_voltage_t *src_p,
    size_t size);

/**
 * Unpack message LV_VOLTAGE.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_lv_voltage_unpack(
    primary_lv_voltage_t *dst_p,
    const uint8_t *src_p,
    size_t size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t primary_lv_voltage_voltage_1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_lv_voltage_voltage_1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_voltage_voltage_1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t primary_lv_voltage_voltage_2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_lv_voltage_voltage_2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_voltage_voltage_2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t primary_lv_voltage_voltage_3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_lv_voltage_voltage_3_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_voltage_voltage_3_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t primary_lv_voltage_voltage_4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_lv_voltage_voltage_4_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_voltage_voltage_4_is_in_range(uint8_t value);


void primary_lv_total_voltage_raw_to_conversion(
    primary_lv_total_voltage_converted_t *conversion,
    float total_voltage
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_lv_total_voltage_conversion_to_raw(
    primary_lv_total_voltage_t *raw,
    float total_voltage
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_lv_total_voltage_raw_to_conversion_struct(
    primary_lv_total_voltage_converted_t *conversion, 
    const primary_lv_total_voltage_t *raw);


void primary_lv_total_voltage_conversion_to_raw_struct(
    primary_lv_total_voltage_t *raw,
    const primary_lv_total_voltage_converted_t *conversion);


int primary_lv_total_voltage_converted_to_string(primary_lv_total_voltage_converted_t *message, char *buffer);

int primary_lv_total_voltage_converted_to_string_file(primary_lv_total_voltage_converted_t *message, FILE *buffer);

int primary_lv_total_voltage_fields(char *buffer);

int primary_lv_total_voltage_fields_file(FILE *buffer);

/**
 * Pack message LV_TOTAL_VOLTAGE.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_lv_total_voltage_pack(
    uint8_t *dst_p,
    const primary_lv_total_voltage_t *src_p,
    size_t size);

/**
 * Unpack message LV_TOTAL_VOLTAGE.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_lv_total_voltage_unpack(
    primary_lv_total_voltage_t *dst_p,
    const uint8_t *src_p,
    size_t size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t primary_lv_total_voltage_total_voltage_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_lv_total_voltage_total_voltage_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_total_voltage_total_voltage_is_in_range(uint8_t value);


void primary_lv_temperature_raw_to_conversion(
    primary_lv_temperature_converted_t *conversion,
    float bp_temperature_1,
    float bp_temperature_2,
    float dcdc12_temperature,
    float dcdc24_temperature
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_lv_temperature_conversion_to_raw(
    primary_lv_temperature_t *raw,
    float bp_temperature_1,
    float bp_temperature_2,
    float dcdc12_temperature,
    float dcdc24_temperature
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_lv_temperature_raw_to_conversion_struct(
    primary_lv_temperature_converted_t *conversion, 
    const primary_lv_temperature_t *raw);


void primary_lv_temperature_conversion_to_raw_struct(
    primary_lv_temperature_t *raw,
    const primary_lv_temperature_converted_t *conversion);


int primary_lv_temperature_converted_to_string(primary_lv_temperature_converted_t *message, char *buffer);

int primary_lv_temperature_converted_to_string_file(primary_lv_temperature_converted_t *message, FILE *buffer);

int primary_lv_temperature_fields(char *buffer);

int primary_lv_temperature_fields_file(FILE *buffer);

/**
 * Pack message LV_TEMPERATURE.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_lv_temperature_pack(
    uint8_t *dst_p,
    const primary_lv_temperature_t *src_p,
    size_t size);

/**
 * Unpack message LV_TEMPERATURE.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_lv_temperature_unpack(
    primary_lv_temperature_t *dst_p,
    const uint8_t *src_p,
    size_t size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t primary_lv_temperature_bp_temperature_1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_lv_temperature_bp_temperature_1_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_temperature_bp_temperature_1_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t primary_lv_temperature_bp_temperature_2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_lv_temperature_bp_temperature_2_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_temperature_bp_temperature_2_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t primary_lv_temperature_dcdc12_temperature_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_lv_temperature_dcdc12_temperature_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_temperature_dcdc12_temperature_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t primary_lv_temperature_dcdc24_temperature_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_lv_temperature_dcdc24_temperature_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_temperature_dcdc24_temperature_is_in_range(uint32_t value);


void primary_cooling_status_raw_to_conversion(
    primary_cooling_status_converted_t *conversion,
    float radiators_speed,
    float pumps_speed
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_cooling_status_conversion_to_raw(
    primary_cooling_status_t *raw,
    float radiators_speed,
    float pumps_speed
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_cooling_status_raw_to_conversion_struct(
    primary_cooling_status_converted_t *conversion, 
    const primary_cooling_status_t *raw);


void primary_cooling_status_conversion_to_raw_struct(
    primary_cooling_status_t *raw,
    const primary_cooling_status_converted_t *conversion);


int primary_cooling_status_converted_to_string(primary_cooling_status_converted_t *message, char *buffer);

int primary_cooling_status_converted_to_string_file(primary_cooling_status_converted_t *message, FILE *buffer);

int primary_cooling_status_fields(char *buffer);

int primary_cooling_status_fields_file(FILE *buffer);

/**
 * Pack message COOLING_STATUS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_cooling_status_pack(
    uint8_t *dst_p,
    const primary_cooling_status_t *src_p,
    size_t size);

/**
 * Unpack message COOLING_STATUS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_cooling_status_unpack(
    primary_cooling_status_t *dst_p,
    const uint8_t *src_p,
    size_t size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t primary_cooling_status_radiators_speed_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_cooling_status_radiators_speed_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_cooling_status_radiators_speed_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t primary_cooling_status_pumps_speed_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_cooling_status_pumps_speed_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_cooling_status_pumps_speed_is_in_range(uint32_t value);


void primary_set_radiator_speed_raw_to_conversion(
    primary_set_radiator_speed_converted_t *conversion,
    float radiators_speed
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_set_radiator_speed_conversion_to_raw(
    primary_set_radiator_speed_t *raw,
    float radiators_speed
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_set_radiator_speed_raw_to_conversion_struct(
    primary_set_radiator_speed_converted_t *conversion, 
    const primary_set_radiator_speed_t *raw);


void primary_set_radiator_speed_conversion_to_raw_struct(
    primary_set_radiator_speed_t *raw,
    const primary_set_radiator_speed_converted_t *conversion);


int primary_set_radiator_speed_converted_to_string(primary_set_radiator_speed_converted_t *message, char *buffer);

int primary_set_radiator_speed_converted_to_string_file(primary_set_radiator_speed_converted_t *message, FILE *buffer);

int primary_set_radiator_speed_fields(char *buffer);

int primary_set_radiator_speed_fields_file(FILE *buffer);

/**
 * Pack message SET_RADIATOR_SPEED.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_set_radiator_speed_pack(
    uint8_t *dst_p,
    const primary_set_radiator_speed_t *src_p,
    size_t size);

/**
 * Unpack message SET_RADIATOR_SPEED.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_set_radiator_speed_unpack(
    primary_set_radiator_speed_t *dst_p,
    const uint8_t *src_p,
    size_t size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t primary_set_radiator_speed_radiators_speed_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_set_radiator_speed_radiators_speed_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_set_radiator_speed_radiators_speed_is_in_range(uint32_t value);


void primary_set_pumps_speed_raw_to_conversion(
    primary_set_pumps_speed_converted_t *conversion,
    float pumps_speed
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_set_pumps_speed_conversion_to_raw(
    primary_set_pumps_speed_t *raw,
    float pumps_speed
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_set_pumps_speed_raw_to_conversion_struct(
    primary_set_pumps_speed_converted_t *conversion, 
    const primary_set_pumps_speed_t *raw);


void primary_set_pumps_speed_conversion_to_raw_struct(
    primary_set_pumps_speed_t *raw,
    const primary_set_pumps_speed_converted_t *conversion);


int primary_set_pumps_speed_converted_to_string(primary_set_pumps_speed_converted_t *message, char *buffer);

int primary_set_pumps_speed_converted_to_string_file(primary_set_pumps_speed_converted_t *message, FILE *buffer);

int primary_set_pumps_speed_fields(char *buffer);

int primary_set_pumps_speed_fields_file(FILE *buffer);

/**
 * Pack message SET_PUMPS_SPEED.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_set_pumps_speed_pack(
    uint8_t *dst_p,
    const primary_set_pumps_speed_t *src_p,
    size_t size);

/**
 * Unpack message SET_PUMPS_SPEED.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_set_pumps_speed_unpack(
    primary_set_pumps_speed_t *dst_p,
    const uint8_t *src_p,
    size_t size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t primary_set_pumps_speed_pumps_speed_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_set_pumps_speed_pumps_speed_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_set_pumps_speed_pumps_speed_is_in_range(uint32_t value);


void primary_set_inverter_connection_status_raw_to_conversion(
    primary_set_inverter_connection_status_converted_t *conversion,
    primary_set_inverter_connection_status_status status
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_set_inverter_connection_status_conversion_to_raw(
    primary_set_inverter_connection_status_t *raw,
    primary_set_inverter_connection_status_status status
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_set_inverter_connection_status_raw_to_conversion_struct(
    primary_set_inverter_connection_status_converted_t *conversion, 
    const primary_set_inverter_connection_status_t *raw);


void primary_set_inverter_connection_status_conversion_to_raw_struct(
    primary_set_inverter_connection_status_t *raw,
    const primary_set_inverter_connection_status_converted_t *conversion);

int primary_set_inverter_connection_status_status_enum_to_string(primary_set_inverter_connection_status_status value, char *buffer);

int primary_set_inverter_connection_status_to_string(primary_set_inverter_connection_status_t *message, char *buffer);

int primary_set_inverter_connection_status_to_string_file(primary_set_inverter_connection_status_t *message, FILE *buffer);

int primary_set_inverter_connection_status_fields(char *buffer);

int primary_set_inverter_connection_status_fields_file(FILE *buffer);

/**
 * Pack message SET_INVERTER_CONNECTION_STATUS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_set_inverter_connection_status_pack(
    uint8_t *dst_p,
    const primary_set_inverter_connection_status_t *src_p,
    size_t size);

/**
 * Unpack message SET_INVERTER_CONNECTION_STATUS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_set_inverter_connection_status_unpack(
    primary_set_inverter_connection_status_t *dst_p,
    const uint8_t *src_p,
    size_t size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_set_inverter_connection_status_status_is_in_range(uint8_t value);


void primary_inverter_connection_status_raw_to_conversion(
    primary_inverter_connection_status_converted_t *conversion,
    primary_inverter_connection_status_status status
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_inverter_connection_status_conversion_to_raw(
    primary_inverter_connection_status_t *raw,
    primary_inverter_connection_status_status status
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_inverter_connection_status_raw_to_conversion_struct(
    primary_inverter_connection_status_converted_t *conversion, 
    const primary_inverter_connection_status_t *raw);


void primary_inverter_connection_status_conversion_to_raw_struct(
    primary_inverter_connection_status_t *raw,
    const primary_inverter_connection_status_converted_t *conversion);

int primary_inverter_connection_status_status_enum_to_string(primary_inverter_connection_status_status value, char *buffer);

int primary_inverter_connection_status_to_string(primary_inverter_connection_status_t *message, char *buffer);

int primary_inverter_connection_status_to_string_file(primary_inverter_connection_status_t *message, FILE *buffer);

int primary_inverter_connection_status_fields(char *buffer);

int primary_inverter_connection_status_fields_file(FILE *buffer);

/**
 * Pack message INVERTER_CONNECTION_STATUS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_inverter_connection_status_pack(
    uint8_t *dst_p,
    const primary_inverter_connection_status_t *src_p,
    size_t size);

/**
 * Unpack message INVERTER_CONNECTION_STATUS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_inverter_connection_status_unpack(
    primary_inverter_connection_status_t *dst_p,
    const uint8_t *src_p,
    size_t size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_connection_status_status_is_in_range(uint8_t value);


void primary_lv_errors_raw_to_conversion(
    primary_lv_errors_converted_t *conversion,
    uint8_t warnings_cell_undervoltage,
    uint8_t warnings_cell_overvoltage,
    uint8_t warnings_open_wire,
    uint8_t warnings_can,
    uint8_t warnings_spi,
    uint8_t warnings_over_current,
    uint8_t warnings_dcdc12_under_temperature,
    uint8_t warnings_dcdc12_over_temperature,
    uint8_t warnings_dcdc24_under_temperature,
    uint8_t warnings_dcdc24_over_temperature,
    uint8_t warnings_cell_under_temperature,
    uint8_t warnings_cell_over_temperature,
    uint8_t warnings_relay,
    uint8_t warnings_ltc6810,
    uint8_t warnings_voltages_not_ready,
    uint8_t warnings_mcp23017,
    uint8_t warnings_radiator,
    uint8_t warnings_fan,
    uint8_t warnings_pump,
    uint8_t warnings_adc_init,
    uint8_t warnings_dcdc12,
    uint8_t warnings_dcdc24,
    uint8_t errors_cell_undervoltage,
    uint8_t errors_cell_overvoltage,
    uint8_t errors_open_wire,
    uint8_t errors_can,
    uint8_t errors_spi,
    uint8_t errors_over_current,
    uint8_t errors_dcdc12_under_temperature,
    uint8_t errors_dcdc12_over_temperature,
    uint8_t errors_dcdc24_under_temperature,
    uint8_t errors_dcdc24_over_temperature,
    uint8_t errors_cell_under_temperature,
    uint8_t errors_cell_over_temperature,
    uint8_t errors_relay,
    uint8_t errors_ltc6810,
    uint8_t errors_voltages_not_ready,
    uint8_t errors_mcp23017,
    uint8_t errors_radiator,
    uint8_t errors_fan,
    uint8_t errors_pump,
    uint8_t errors_adc_init,
    uint8_t errors_dcdc12,
    uint8_t errors_dcdc24
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_lv_errors_conversion_to_raw(
    primary_lv_errors_t *raw,
    uint8_t warnings_cell_undervoltage,
    uint8_t warnings_cell_overvoltage,
    uint8_t warnings_open_wire,
    uint8_t warnings_can,
    uint8_t warnings_spi,
    uint8_t warnings_over_current,
    uint8_t warnings_dcdc12_under_temperature,
    uint8_t warnings_dcdc12_over_temperature,
    uint8_t warnings_dcdc24_under_temperature,
    uint8_t warnings_dcdc24_over_temperature,
    uint8_t warnings_cell_under_temperature,
    uint8_t warnings_cell_over_temperature,
    uint8_t warnings_relay,
    uint8_t warnings_ltc6810,
    uint8_t warnings_voltages_not_ready,
    uint8_t warnings_mcp23017,
    uint8_t warnings_radiator,
    uint8_t warnings_fan,
    uint8_t warnings_pump,
    uint8_t warnings_adc_init,
    uint8_t warnings_dcdc12,
    uint8_t warnings_dcdc24,
    uint8_t errors_cell_undervoltage,
    uint8_t errors_cell_overvoltage,
    uint8_t errors_open_wire,
    uint8_t errors_can,
    uint8_t errors_spi,
    uint8_t errors_over_current,
    uint8_t errors_dcdc12_under_temperature,
    uint8_t errors_dcdc12_over_temperature,
    uint8_t errors_dcdc24_under_temperature,
    uint8_t errors_dcdc24_over_temperature,
    uint8_t errors_cell_under_temperature,
    uint8_t errors_cell_over_temperature,
    uint8_t errors_relay,
    uint8_t errors_ltc6810,
    uint8_t errors_voltages_not_ready,
    uint8_t errors_mcp23017,
    uint8_t errors_radiator,
    uint8_t errors_fan,
    uint8_t errors_pump,
    uint8_t errors_adc_init,
    uint8_t errors_dcdc12,
    uint8_t errors_dcdc24
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_lv_errors_raw_to_conversion_struct(
    primary_lv_errors_converted_t *conversion, 
    const primary_lv_errors_t *raw);


void primary_lv_errors_conversion_to_raw_struct(
    primary_lv_errors_t *raw,
    const primary_lv_errors_converted_t *conversion);


int primary_lv_errors_to_string(primary_lv_errors_t *message, char *buffer);

int primary_lv_errors_to_string_file(primary_lv_errors_t *message, FILE *buffer);

int primary_lv_errors_fields(char *buffer);

int primary_lv_errors_fields_file(FILE *buffer);

/**
 * Pack message LV_ERRORS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_lv_errors_pack(
    uint8_t *dst_p,
    const primary_lv_errors_t *src_p,
    size_t size);

/**
 * Unpack message LV_ERRORS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_lv_errors_unpack(
    primary_lv_errors_t *dst_p,
    const uint8_t *src_p,
    size_t size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_errors_warnings_cell_undervoltage_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_errors_warnings_cell_overvoltage_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_errors_warnings_open_wire_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_errors_warnings_can_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_errors_warnings_spi_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_errors_warnings_over_current_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_errors_warnings_dcdc12_under_temperature_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_errors_warnings_dcdc12_over_temperature_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_errors_warnings_dcdc24_under_temperature_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_errors_warnings_dcdc24_over_temperature_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_errors_warnings_cell_under_temperature_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_errors_warnings_cell_over_temperature_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_errors_warnings_relay_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_errors_warnings_ltc6810_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_errors_warnings_voltages_not_ready_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_errors_warnings_mcp23017_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_errors_warnings_radiator_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_errors_warnings_fan_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_errors_warnings_pump_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_errors_warnings_adc_init_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_errors_warnings_dcdc12_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_errors_warnings_dcdc24_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_errors_errors_cell_undervoltage_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_errors_errors_cell_overvoltage_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_errors_errors_open_wire_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_errors_errors_can_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_errors_errors_spi_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_errors_errors_over_current_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_errors_errors_dcdc12_under_temperature_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_errors_errors_dcdc12_over_temperature_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_errors_errors_dcdc24_under_temperature_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_errors_errors_dcdc24_over_temperature_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_errors_errors_cell_under_temperature_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_errors_errors_cell_over_temperature_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_errors_errors_relay_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_errors_errors_ltc6810_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_errors_errors_voltages_not_ready_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_errors_errors_mcp23017_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_errors_errors_radiator_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_errors_errors_fan_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_errors_errors_pump_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_errors_errors_adc_init_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_errors_errors_dcdc12_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_errors_errors_dcdc24_is_in_range(uint8_t value);


void primary_shutdown_status_raw_to_conversion(
    primary_shutdown_status_converted_t *conversion,
    uint8_t input,
    uint8_t output
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_shutdown_status_conversion_to_raw(
    primary_shutdown_status_t *raw,
    uint8_t input,
    uint8_t output
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_shutdown_status_raw_to_conversion_struct(
    primary_shutdown_status_converted_t *conversion, 
    const primary_shutdown_status_t *raw);


void primary_shutdown_status_conversion_to_raw_struct(
    primary_shutdown_status_t *raw,
    const primary_shutdown_status_converted_t *conversion);


int primary_shutdown_status_to_string(primary_shutdown_status_t *message, char *buffer);

int primary_shutdown_status_to_string_file(primary_shutdown_status_t *message, FILE *buffer);

int primary_shutdown_status_fields(char *buffer);

int primary_shutdown_status_fields_file(FILE *buffer);

/**
 * Pack message SHUTDOWN_STATUS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_shutdown_status_pack(
    uint8_t *dst_p,
    const primary_shutdown_status_t *src_p,
    size_t size);

/**
 * Unpack message SHUTDOWN_STATUS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_shutdown_status_unpack(
    primary_shutdown_status_t *dst_p,
    const uint8_t *src_p,
    size_t size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_shutdown_status_input_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_shutdown_status_output_is_in_range(uint8_t value);


;


;


void primary_marker_raw_to_conversion_struct(
    primary_marker_converted_t *conversion, 
    const primary_marker_t *raw);


void primary_marker_conversion_to_raw_struct(
    primary_marker_t *raw,
    const primary_marker_converted_t *conversion);


int primary_marker_to_string(primary_marker_t *message, char *buffer);

int primary_marker_to_string_file(primary_marker_t *message, FILE *buffer);

int primary_marker_fields(char *buffer);

int primary_marker_fields_file(FILE *buffer);

/**
 * Pack message MARKER.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_marker_pack(
    uint8_t *dst_p,
    const primary_marker_t *src_p,
    size_t size);

/**
 * Unpack message MARKER.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_marker_unpack(
    primary_marker_t *dst_p,
    const uint8_t *src_p,
    size_t size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


void primary_hv_cells_voltage_raw_to_conversion(
    primary_hv_cells_voltage_converted_t *conversion,
    uint8_t start_index,
    float voltage_0,
    float voltage_1,
    float voltage_2
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_hv_cells_voltage_conversion_to_raw(
    primary_hv_cells_voltage_t *raw,
    uint8_t start_index,
    float voltage_0,
    float voltage_1,
    float voltage_2
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_hv_cells_voltage_raw_to_conversion_struct(
    primary_hv_cells_voltage_converted_t *conversion, 
    const primary_hv_cells_voltage_t *raw);


void primary_hv_cells_voltage_conversion_to_raw_struct(
    primary_hv_cells_voltage_t *raw,
    const primary_hv_cells_voltage_converted_t *conversion);


int primary_hv_cells_voltage_converted_to_string(primary_hv_cells_voltage_converted_t *message, char *buffer);

int primary_hv_cells_voltage_converted_to_string_file(primary_hv_cells_voltage_converted_t *message, FILE *buffer);

int primary_hv_cells_voltage_fields(char *buffer);

int primary_hv_cells_voltage_fields_file(FILE *buffer);

/**
 * Pack message HV_CELLS_VOLTAGE.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_hv_cells_voltage_pack(
    uint8_t *dst_p,
    const primary_hv_cells_voltage_t *src_p,
    size_t size);

/**
 * Unpack message HV_CELLS_VOLTAGE.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_hv_cells_voltage_unpack(
    primary_hv_cells_voltage_t *dst_p,
    const uint8_t *src_p,
    size_t size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_cells_voltage_start_index_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t primary_hv_cells_voltage_voltage_0_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_hv_cells_voltage_voltage_0_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_cells_voltage_voltage_0_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t primary_hv_cells_voltage_voltage_1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_hv_cells_voltage_voltage_1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_cells_voltage_voltage_1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t primary_hv_cells_voltage_voltage_2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_hv_cells_voltage_voltage_2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_cells_voltage_voltage_2_is_in_range(uint8_t value);


void primary_hv_cells_temp_raw_to_conversion(
    primary_hv_cells_temp_converted_t *conversion,
    uint8_t start_index,
    float temp_0,
    float temp_1,
    float temp_2,
    float temp_3,
    float temp_4,
    float temp_5
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_hv_cells_temp_conversion_to_raw(
    primary_hv_cells_temp_t *raw,
    uint8_t start_index,
    float temp_0,
    float temp_1,
    float temp_2,
    float temp_3,
    float temp_4,
    float temp_5
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_hv_cells_temp_raw_to_conversion_struct(
    primary_hv_cells_temp_converted_t *conversion, 
    const primary_hv_cells_temp_t *raw);


void primary_hv_cells_temp_conversion_to_raw_struct(
    primary_hv_cells_temp_t *raw,
    const primary_hv_cells_temp_converted_t *conversion);


int primary_hv_cells_temp_converted_to_string(primary_hv_cells_temp_converted_t *message, char *buffer);

int primary_hv_cells_temp_converted_to_string_file(primary_hv_cells_temp_converted_t *message, FILE *buffer);

int primary_hv_cells_temp_fields(char *buffer);

int primary_hv_cells_temp_fields_file(FILE *buffer);

/**
 * Pack message HV_CELLS_TEMP.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_hv_cells_temp_pack(
    uint8_t *dst_p,
    const primary_hv_cells_temp_t *src_p,
    size_t size);

/**
 * Unpack message HV_CELLS_TEMP.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_hv_cells_temp_unpack(
    primary_hv_cells_temp_t *dst_p,
    const uint8_t *src_p,
    size_t size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_cells_temp_start_index_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_hv_cells_temp_temp_0_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_hv_cells_temp_temp_0_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_cells_temp_temp_0_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_hv_cells_temp_temp_1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_hv_cells_temp_temp_1_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_cells_temp_temp_1_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_hv_cells_temp_temp_2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_hv_cells_temp_temp_2_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_cells_temp_temp_2_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_hv_cells_temp_temp_3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_hv_cells_temp_temp_3_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_cells_temp_temp_3_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_hv_cells_temp_temp_4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_hv_cells_temp_temp_4_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_cells_temp_temp_4_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_hv_cells_temp_temp_5_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_hv_cells_temp_temp_5_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_cells_temp_temp_5_is_in_range(uint16_t value);


void primary_hv_cell_balancing_status_raw_to_conversion(
    primary_hv_cell_balancing_status_converted_t *conversion,
    primary_hv_cell_balancing_status_balancing_status balancing_status
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_hv_cell_balancing_status_conversion_to_raw(
    primary_hv_cell_balancing_status_t *raw,
    primary_hv_cell_balancing_status_balancing_status balancing_status
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_hv_cell_balancing_status_raw_to_conversion_struct(
    primary_hv_cell_balancing_status_converted_t *conversion, 
    const primary_hv_cell_balancing_status_t *raw);


void primary_hv_cell_balancing_status_conversion_to_raw_struct(
    primary_hv_cell_balancing_status_t *raw,
    const primary_hv_cell_balancing_status_converted_t *conversion);

int primary_hv_cell_balancing_status_balancing_status_enum_to_string(primary_hv_cell_balancing_status_balancing_status value, char *buffer);

int primary_hv_cell_balancing_status_to_string(primary_hv_cell_balancing_status_t *message, char *buffer);

int primary_hv_cell_balancing_status_to_string_file(primary_hv_cell_balancing_status_t *message, FILE *buffer);

int primary_hv_cell_balancing_status_fields(char *buffer);

int primary_hv_cell_balancing_status_fields_file(FILE *buffer);

/**
 * Pack message HV_CELL_BALANCING_STATUS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_hv_cell_balancing_status_pack(
    uint8_t *dst_p,
    const primary_hv_cell_balancing_status_t *src_p,
    size_t size);

/**
 * Unpack message HV_CELL_BALANCING_STATUS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_hv_cell_balancing_status_unpack(
    primary_hv_cell_balancing_status_t *dst_p,
    const uint8_t *src_p,
    size_t size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_cell_balancing_status_balancing_status_is_in_range(uint8_t value);


void primary_set_cell_balancing_status_raw_to_conversion(
    primary_set_cell_balancing_status_converted_t *conversion,
    primary_set_cell_balancing_status_set_balancing_status set_balancing_status
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_set_cell_balancing_status_conversion_to_raw(
    primary_set_cell_balancing_status_t *raw,
    primary_set_cell_balancing_status_set_balancing_status set_balancing_status
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_set_cell_balancing_status_raw_to_conversion_struct(
    primary_set_cell_balancing_status_converted_t *conversion, 
    const primary_set_cell_balancing_status_t *raw);


void primary_set_cell_balancing_status_conversion_to_raw_struct(
    primary_set_cell_balancing_status_t *raw,
    const primary_set_cell_balancing_status_converted_t *conversion);

int primary_set_cell_balancing_status_set_balancing_status_enum_to_string(primary_set_cell_balancing_status_set_balancing_status value, char *buffer);

int primary_set_cell_balancing_status_to_string(primary_set_cell_balancing_status_t *message, char *buffer);

int primary_set_cell_balancing_status_to_string_file(primary_set_cell_balancing_status_t *message, FILE *buffer);

int primary_set_cell_balancing_status_fields(char *buffer);

int primary_set_cell_balancing_status_fields_file(FILE *buffer);

/**
 * Pack message SET_CELL_BALANCING_STATUS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_set_cell_balancing_status_pack(
    uint8_t *dst_p,
    const primary_set_cell_balancing_status_t *src_p,
    size_t size);

/**
 * Unpack message SET_CELL_BALANCING_STATUS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_set_cell_balancing_status_unpack(
    primary_set_cell_balancing_status_t *dst_p,
    const uint8_t *src_p,
    size_t size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_set_cell_balancing_status_set_balancing_status_is_in_range(uint8_t value);


void primary_handcart_status_raw_to_conversion(
    primary_handcart_status_converted_t *conversion,
    uint8_t connected
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_handcart_status_conversion_to_raw(
    primary_handcart_status_t *raw,
    uint8_t connected
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_handcart_status_raw_to_conversion_struct(
    primary_handcart_status_converted_t *conversion, 
    const primary_handcart_status_t *raw);


void primary_handcart_status_conversion_to_raw_struct(
    primary_handcart_status_t *raw,
    const primary_handcart_status_converted_t *conversion);


int primary_handcart_status_to_string(primary_handcart_status_t *message, char *buffer);

int primary_handcart_status_to_string_file(primary_handcart_status_t *message, FILE *buffer);

int primary_handcart_status_fields(char *buffer);

int primary_handcart_status_fields_file(FILE *buffer);

/**
 * Pack message HANDCART_STATUS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_handcart_status_pack(
    uint8_t *dst_p,
    const primary_handcart_status_t *src_p,
    size_t size);

/**
 * Unpack message HANDCART_STATUS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_handcart_status_unpack(
    primary_handcart_status_t *dst_p,
    const uint8_t *src_p,
    size_t size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_handcart_status_connected_is_in_range(uint8_t value);


void primary_speed_raw_to_conversion(
    primary_speed_converted_t *conversion,
    float encoder_r,
    float encoder_l,
    float inverter_r,
    float inverter_l
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_speed_conversion_to_raw(
    primary_speed_t *raw,
    float encoder_r,
    float encoder_l,
    float inverter_r,
    float inverter_l
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_speed_raw_to_conversion_struct(
    primary_speed_converted_t *conversion, 
    const primary_speed_t *raw);


void primary_speed_conversion_to_raw_struct(
    primary_speed_t *raw,
    const primary_speed_converted_t *conversion);


int primary_speed_converted_to_string(primary_speed_converted_t *message, char *buffer);

int primary_speed_converted_to_string_file(primary_speed_converted_t *message, FILE *buffer);

int primary_speed_fields(char *buffer);

int primary_speed_fields_file(FILE *buffer);

/**
 * Pack message SPEED.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_speed_pack(
    uint8_t *dst_p,
    const primary_speed_t *src_p,
    size_t size);

/**
 * Unpack message SPEED.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_speed_unpack(
    primary_speed_t *dst_p,
    const uint8_t *src_p,
    size_t size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t primary_speed_encoder_r_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_speed_encoder_r_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_speed_encoder_r_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t primary_speed_encoder_l_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_speed_encoder_l_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_speed_encoder_l_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t primary_speed_inverter_r_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_speed_inverter_r_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_speed_inverter_r_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t primary_speed_inverter_l_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_speed_inverter_l_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_speed_inverter_l_is_in_range(uint32_t value);


void primary_inv_l_request_raw_to_conversion(
    primary_inv_l_request_converted_t *conversion,
    uint8_t data_0,
    uint8_t data_1,
    uint8_t data_2,
    uint8_t data_3,
    uint8_t data_4,
    uint8_t data_5,
    uint8_t data_6,
    uint8_t data_7
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_inv_l_request_conversion_to_raw(
    primary_inv_l_request_t *raw,
    uint8_t data_0,
    uint8_t data_1,
    uint8_t data_2,
    uint8_t data_3,
    uint8_t data_4,
    uint8_t data_5,
    uint8_t data_6,
    uint8_t data_7
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_inv_l_request_raw_to_conversion_struct(
    primary_inv_l_request_converted_t *conversion, 
    const primary_inv_l_request_t *raw);


void primary_inv_l_request_conversion_to_raw_struct(
    primary_inv_l_request_t *raw,
    const primary_inv_l_request_converted_t *conversion);


int primary_inv_l_request_to_string(primary_inv_l_request_t *message, char *buffer);

int primary_inv_l_request_to_string_file(primary_inv_l_request_t *message, FILE *buffer);

int primary_inv_l_request_fields(char *buffer);

int primary_inv_l_request_fields_file(FILE *buffer);

/**
 * Pack message INV_L_REQUEST.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_inv_l_request_pack(
    uint8_t *dst_p,
    const primary_inv_l_request_t *src_p,
    size_t size);

/**
 * Unpack message INV_L_REQUEST.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_inv_l_request_unpack(
    primary_inv_l_request_t *dst_p,
    const uint8_t *src_p,
    size_t size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inv_l_request_data_0_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inv_l_request_data_1_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inv_l_request_data_2_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inv_l_request_data_3_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inv_l_request_data_4_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inv_l_request_data_5_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inv_l_request_data_6_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inv_l_request_data_7_is_in_range(uint8_t value);


void primary_inv_r_request_raw_to_conversion(
    primary_inv_r_request_converted_t *conversion,
    uint8_t data_0,
    uint8_t data_1,
    uint8_t data_2,
    uint8_t data_3,
    uint8_t data_4,
    uint8_t data_5,
    uint8_t data_6,
    uint8_t data_7
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_inv_r_request_conversion_to_raw(
    primary_inv_r_request_t *raw,
    uint8_t data_0,
    uint8_t data_1,
    uint8_t data_2,
    uint8_t data_3,
    uint8_t data_4,
    uint8_t data_5,
    uint8_t data_6,
    uint8_t data_7
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_inv_r_request_raw_to_conversion_struct(
    primary_inv_r_request_converted_t *conversion, 
    const primary_inv_r_request_t *raw);


void primary_inv_r_request_conversion_to_raw_struct(
    primary_inv_r_request_t *raw,
    const primary_inv_r_request_converted_t *conversion);


int primary_inv_r_request_to_string(primary_inv_r_request_t *message, char *buffer);

int primary_inv_r_request_to_string_file(primary_inv_r_request_t *message, FILE *buffer);

int primary_inv_r_request_fields(char *buffer);

int primary_inv_r_request_fields_file(FILE *buffer);

/**
 * Pack message INV_R_REQUEST.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_inv_r_request_pack(
    uint8_t *dst_p,
    const primary_inv_r_request_t *src_p,
    size_t size);

/**
 * Unpack message INV_R_REQUEST.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_inv_r_request_unpack(
    primary_inv_r_request_t *dst_p,
    const uint8_t *src_p,
    size_t size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inv_r_request_data_0_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inv_r_request_data_1_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inv_r_request_data_2_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inv_r_request_data_3_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inv_r_request_data_4_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inv_r_request_data_5_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inv_r_request_data_6_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inv_r_request_data_7_is_in_range(uint8_t value);


void primary_inv_l_response_raw_to_conversion(
    primary_inv_l_response_converted_t *conversion,
    uint8_t reg_id,
    uint8_t data_0,
    uint8_t data_1,
    uint8_t data_2,
    uint8_t data_3,
    uint8_t data_4,
    uint8_t data_5,
    uint8_t data_6
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_inv_l_response_conversion_to_raw(
    primary_inv_l_response_t *raw,
    uint8_t reg_id,
    uint8_t data_0,
    uint8_t data_1,
    uint8_t data_2,
    uint8_t data_3,
    uint8_t data_4,
    uint8_t data_5,
    uint8_t data_6
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_inv_l_response_raw_to_conversion_struct(
    primary_inv_l_response_converted_t *conversion, 
    const primary_inv_l_response_t *raw);


void primary_inv_l_response_conversion_to_raw_struct(
    primary_inv_l_response_t *raw,
    const primary_inv_l_response_converted_t *conversion);


int primary_inv_l_response_to_string(primary_inv_l_response_t *message, char *buffer);

int primary_inv_l_response_to_string_file(primary_inv_l_response_t *message, FILE *buffer);

int primary_inv_l_response_fields(char *buffer);

int primary_inv_l_response_fields_file(FILE *buffer);

/**
 * Pack message INV_L_RESPONSE.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_inv_l_response_pack(
    uint8_t *dst_p,
    const primary_inv_l_response_t *src_p,
    size_t size);

/**
 * Unpack message INV_L_RESPONSE.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_inv_l_response_unpack(
    primary_inv_l_response_t *dst_p,
    const uint8_t *src_p,
    size_t size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inv_l_response_reg_id_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inv_l_response_data_0_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inv_l_response_data_1_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inv_l_response_data_2_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inv_l_response_data_3_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inv_l_response_data_4_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inv_l_response_data_5_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inv_l_response_data_6_is_in_range(uint8_t value);


void primary_inv_r_response_raw_to_conversion(
    primary_inv_r_response_converted_t *conversion,
    uint8_t reg_id,
    uint8_t data_0,
    uint8_t data_1,
    uint8_t data_2,
    uint8_t data_3,
    uint8_t data_4,
    uint8_t data_5,
    uint8_t data_6
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_inv_r_response_conversion_to_raw(
    primary_inv_r_response_t *raw,
    uint8_t reg_id,
    uint8_t data_0,
    uint8_t data_1,
    uint8_t data_2,
    uint8_t data_3,
    uint8_t data_4,
    uint8_t data_5,
    uint8_t data_6
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_inv_r_response_raw_to_conversion_struct(
    primary_inv_r_response_converted_t *conversion, 
    const primary_inv_r_response_t *raw);


void primary_inv_r_response_conversion_to_raw_struct(
    primary_inv_r_response_t *raw,
    const primary_inv_r_response_converted_t *conversion);


int primary_inv_r_response_to_string(primary_inv_r_response_t *message, char *buffer);

int primary_inv_r_response_to_string_file(primary_inv_r_response_t *message, FILE *buffer);

int primary_inv_r_response_fields(char *buffer);

int primary_inv_r_response_fields_file(FILE *buffer);

/**
 * Pack message INV_R_RESPONSE.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_inv_r_response_pack(
    uint8_t *dst_p,
    const primary_inv_r_response_t *src_p,
    size_t size);

/**
 * Unpack message INV_R_RESPONSE.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_inv_r_response_unpack(
    primary_inv_r_response_t *dst_p,
    const uint8_t *src_p,
    size_t size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inv_r_response_reg_id_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inv_r_response_data_0_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inv_r_response_data_1_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inv_r_response_data_2_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inv_r_response_data_3_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inv_r_response_data_4_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inv_r_response_data_5_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inv_r_response_data_6_is_in_range(uint8_t value);


;


;


void primary_flash_cellboard_0_tx_raw_to_conversion_struct(
    primary_flash_cellboard_0_tx_converted_t *conversion, 
    const primary_flash_cellboard_0_tx_t *raw);


void primary_flash_cellboard_0_tx_conversion_to_raw_struct(
    primary_flash_cellboard_0_tx_t *raw,
    const primary_flash_cellboard_0_tx_converted_t *conversion);


int primary_flash_cellboard_0_tx_to_string(primary_flash_cellboard_0_tx_t *message, char *buffer);

int primary_flash_cellboard_0_tx_to_string_file(primary_flash_cellboard_0_tx_t *message, FILE *buffer);

int primary_flash_cellboard_0_tx_fields(char *buffer);

int primary_flash_cellboard_0_tx_fields_file(FILE *buffer);

/**
 * Pack message FLASH_CELLBOARD_0_TX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_flash_cellboard_0_tx_pack(
    uint8_t *dst_p,
    const primary_flash_cellboard_0_tx_t *src_p,
    size_t size);

/**
 * Unpack message FLASH_CELLBOARD_0_TX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_flash_cellboard_0_tx_unpack(
    primary_flash_cellboard_0_tx_t *dst_p,
    const uint8_t *src_p,
    size_t size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void primary_flash_cellboard_0_rx_raw_to_conversion_struct(
    primary_flash_cellboard_0_rx_converted_t *conversion, 
    const primary_flash_cellboard_0_rx_t *raw);


void primary_flash_cellboard_0_rx_conversion_to_raw_struct(
    primary_flash_cellboard_0_rx_t *raw,
    const primary_flash_cellboard_0_rx_converted_t *conversion);


int primary_flash_cellboard_0_rx_to_string(primary_flash_cellboard_0_rx_t *message, char *buffer);

int primary_flash_cellboard_0_rx_to_string_file(primary_flash_cellboard_0_rx_t *message, FILE *buffer);

int primary_flash_cellboard_0_rx_fields(char *buffer);

int primary_flash_cellboard_0_rx_fields_file(FILE *buffer);

/**
 * Pack message FLASH_CELLBOARD_0_RX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_flash_cellboard_0_rx_pack(
    uint8_t *dst_p,
    const primary_flash_cellboard_0_rx_t *src_p,
    size_t size);

/**
 * Unpack message FLASH_CELLBOARD_0_RX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_flash_cellboard_0_rx_unpack(
    primary_flash_cellboard_0_rx_t *dst_p,
    const uint8_t *src_p,
    size_t size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void primary_flash_cellboard_1_tx_raw_to_conversion_struct(
    primary_flash_cellboard_1_tx_converted_t *conversion, 
    const primary_flash_cellboard_1_tx_t *raw);


void primary_flash_cellboard_1_tx_conversion_to_raw_struct(
    primary_flash_cellboard_1_tx_t *raw,
    const primary_flash_cellboard_1_tx_converted_t *conversion);


int primary_flash_cellboard_1_tx_to_string(primary_flash_cellboard_1_tx_t *message, char *buffer);

int primary_flash_cellboard_1_tx_to_string_file(primary_flash_cellboard_1_tx_t *message, FILE *buffer);

int primary_flash_cellboard_1_tx_fields(char *buffer);

int primary_flash_cellboard_1_tx_fields_file(FILE *buffer);

/**
 * Pack message FLASH_CELLBOARD_1_TX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_flash_cellboard_1_tx_pack(
    uint8_t *dst_p,
    const primary_flash_cellboard_1_tx_t *src_p,
    size_t size);

/**
 * Unpack message FLASH_CELLBOARD_1_TX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_flash_cellboard_1_tx_unpack(
    primary_flash_cellboard_1_tx_t *dst_p,
    const uint8_t *src_p,
    size_t size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void primary_flash_cellboard_1_rx_raw_to_conversion_struct(
    primary_flash_cellboard_1_rx_converted_t *conversion, 
    const primary_flash_cellboard_1_rx_t *raw);


void primary_flash_cellboard_1_rx_conversion_to_raw_struct(
    primary_flash_cellboard_1_rx_t *raw,
    const primary_flash_cellboard_1_rx_converted_t *conversion);


int primary_flash_cellboard_1_rx_to_string(primary_flash_cellboard_1_rx_t *message, char *buffer);

int primary_flash_cellboard_1_rx_to_string_file(primary_flash_cellboard_1_rx_t *message, FILE *buffer);

int primary_flash_cellboard_1_rx_fields(char *buffer);

int primary_flash_cellboard_1_rx_fields_file(FILE *buffer);

/**
 * Pack message FLASH_CELLBOARD_1_RX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_flash_cellboard_1_rx_pack(
    uint8_t *dst_p,
    const primary_flash_cellboard_1_rx_t *src_p,
    size_t size);

/**
 * Unpack message FLASH_CELLBOARD_1_RX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_flash_cellboard_1_rx_unpack(
    primary_flash_cellboard_1_rx_t *dst_p,
    const uint8_t *src_p,
    size_t size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void primary_flash_cellboard_2_tx_raw_to_conversion_struct(
    primary_flash_cellboard_2_tx_converted_t *conversion, 
    const primary_flash_cellboard_2_tx_t *raw);


void primary_flash_cellboard_2_tx_conversion_to_raw_struct(
    primary_flash_cellboard_2_tx_t *raw,
    const primary_flash_cellboard_2_tx_converted_t *conversion);


int primary_flash_cellboard_2_tx_to_string(primary_flash_cellboard_2_tx_t *message, char *buffer);

int primary_flash_cellboard_2_tx_to_string_file(primary_flash_cellboard_2_tx_t *message, FILE *buffer);

int primary_flash_cellboard_2_tx_fields(char *buffer);

int primary_flash_cellboard_2_tx_fields_file(FILE *buffer);

/**
 * Pack message FLASH_CELLBOARD_2_TX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_flash_cellboard_2_tx_pack(
    uint8_t *dst_p,
    const primary_flash_cellboard_2_tx_t *src_p,
    size_t size);

/**
 * Unpack message FLASH_CELLBOARD_2_TX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_flash_cellboard_2_tx_unpack(
    primary_flash_cellboard_2_tx_t *dst_p,
    const uint8_t *src_p,
    size_t size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void primary_flash_cellboard_2_rx_raw_to_conversion_struct(
    primary_flash_cellboard_2_rx_converted_t *conversion, 
    const primary_flash_cellboard_2_rx_t *raw);


void primary_flash_cellboard_2_rx_conversion_to_raw_struct(
    primary_flash_cellboard_2_rx_t *raw,
    const primary_flash_cellboard_2_rx_converted_t *conversion);


int primary_flash_cellboard_2_rx_to_string(primary_flash_cellboard_2_rx_t *message, char *buffer);

int primary_flash_cellboard_2_rx_to_string_file(primary_flash_cellboard_2_rx_t *message, FILE *buffer);

int primary_flash_cellboard_2_rx_fields(char *buffer);

int primary_flash_cellboard_2_rx_fields_file(FILE *buffer);

/**
 * Pack message FLASH_CELLBOARD_2_RX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_flash_cellboard_2_rx_pack(
    uint8_t *dst_p,
    const primary_flash_cellboard_2_rx_t *src_p,
    size_t size);

/**
 * Unpack message FLASH_CELLBOARD_2_RX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_flash_cellboard_2_rx_unpack(
    primary_flash_cellboard_2_rx_t *dst_p,
    const uint8_t *src_p,
    size_t size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void primary_flash_cellboard_3_tx_raw_to_conversion_struct(
    primary_flash_cellboard_3_tx_converted_t *conversion, 
    const primary_flash_cellboard_3_tx_t *raw);


void primary_flash_cellboard_3_tx_conversion_to_raw_struct(
    primary_flash_cellboard_3_tx_t *raw,
    const primary_flash_cellboard_3_tx_converted_t *conversion);


int primary_flash_cellboard_3_tx_to_string(primary_flash_cellboard_3_tx_t *message, char *buffer);

int primary_flash_cellboard_3_tx_to_string_file(primary_flash_cellboard_3_tx_t *message, FILE *buffer);

int primary_flash_cellboard_3_tx_fields(char *buffer);

int primary_flash_cellboard_3_tx_fields_file(FILE *buffer);

/**
 * Pack message FLASH_CELLBOARD_3_TX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_flash_cellboard_3_tx_pack(
    uint8_t *dst_p,
    const primary_flash_cellboard_3_tx_t *src_p,
    size_t size);

/**
 * Unpack message FLASH_CELLBOARD_3_TX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_flash_cellboard_3_tx_unpack(
    primary_flash_cellboard_3_tx_t *dst_p,
    const uint8_t *src_p,
    size_t size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void primary_flash_cellboard_3_rx_raw_to_conversion_struct(
    primary_flash_cellboard_3_rx_converted_t *conversion, 
    const primary_flash_cellboard_3_rx_t *raw);


void primary_flash_cellboard_3_rx_conversion_to_raw_struct(
    primary_flash_cellboard_3_rx_t *raw,
    const primary_flash_cellboard_3_rx_converted_t *conversion);


int primary_flash_cellboard_3_rx_to_string(primary_flash_cellboard_3_rx_t *message, char *buffer);

int primary_flash_cellboard_3_rx_to_string_file(primary_flash_cellboard_3_rx_t *message, FILE *buffer);

int primary_flash_cellboard_3_rx_fields(char *buffer);

int primary_flash_cellboard_3_rx_fields_file(FILE *buffer);

/**
 * Pack message FLASH_CELLBOARD_3_RX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_flash_cellboard_3_rx_pack(
    uint8_t *dst_p,
    const primary_flash_cellboard_3_rx_t *src_p,
    size_t size);

/**
 * Unpack message FLASH_CELLBOARD_3_RX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_flash_cellboard_3_rx_unpack(
    primary_flash_cellboard_3_rx_t *dst_p,
    const uint8_t *src_p,
    size_t size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void primary_flash_cellboard_4_tx_raw_to_conversion_struct(
    primary_flash_cellboard_4_tx_converted_t *conversion, 
    const primary_flash_cellboard_4_tx_t *raw);


void primary_flash_cellboard_4_tx_conversion_to_raw_struct(
    primary_flash_cellboard_4_tx_t *raw,
    const primary_flash_cellboard_4_tx_converted_t *conversion);


int primary_flash_cellboard_4_tx_to_string(primary_flash_cellboard_4_tx_t *message, char *buffer);

int primary_flash_cellboard_4_tx_to_string_file(primary_flash_cellboard_4_tx_t *message, FILE *buffer);

int primary_flash_cellboard_4_tx_fields(char *buffer);

int primary_flash_cellboard_4_tx_fields_file(FILE *buffer);

/**
 * Pack message FLASH_CELLBOARD_4_TX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_flash_cellboard_4_tx_pack(
    uint8_t *dst_p,
    const primary_flash_cellboard_4_tx_t *src_p,
    size_t size);

/**
 * Unpack message FLASH_CELLBOARD_4_TX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_flash_cellboard_4_tx_unpack(
    primary_flash_cellboard_4_tx_t *dst_p,
    const uint8_t *src_p,
    size_t size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void primary_flash_cellboard_4_rx_raw_to_conversion_struct(
    primary_flash_cellboard_4_rx_converted_t *conversion, 
    const primary_flash_cellboard_4_rx_t *raw);


void primary_flash_cellboard_4_rx_conversion_to_raw_struct(
    primary_flash_cellboard_4_rx_t *raw,
    const primary_flash_cellboard_4_rx_converted_t *conversion);


int primary_flash_cellboard_4_rx_to_string(primary_flash_cellboard_4_rx_t *message, char *buffer);

int primary_flash_cellboard_4_rx_to_string_file(primary_flash_cellboard_4_rx_t *message, FILE *buffer);

int primary_flash_cellboard_4_rx_fields(char *buffer);

int primary_flash_cellboard_4_rx_fields_file(FILE *buffer);

/**
 * Pack message FLASH_CELLBOARD_4_RX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_flash_cellboard_4_rx_pack(
    uint8_t *dst_p,
    const primary_flash_cellboard_4_rx_t *src_p,
    size_t size);

/**
 * Unpack message FLASH_CELLBOARD_4_RX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_flash_cellboard_4_rx_unpack(
    primary_flash_cellboard_4_rx_t *dst_p,
    const uint8_t *src_p,
    size_t size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void primary_flash_cellboard_5_tx_raw_to_conversion_struct(
    primary_flash_cellboard_5_tx_converted_t *conversion, 
    const primary_flash_cellboard_5_tx_t *raw);


void primary_flash_cellboard_5_tx_conversion_to_raw_struct(
    primary_flash_cellboard_5_tx_t *raw,
    const primary_flash_cellboard_5_tx_converted_t *conversion);


int primary_flash_cellboard_5_tx_to_string(primary_flash_cellboard_5_tx_t *message, char *buffer);

int primary_flash_cellboard_5_tx_to_string_file(primary_flash_cellboard_5_tx_t *message, FILE *buffer);

int primary_flash_cellboard_5_tx_fields(char *buffer);

int primary_flash_cellboard_5_tx_fields_file(FILE *buffer);

/**
 * Pack message FLASH_CELLBOARD_5_TX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_flash_cellboard_5_tx_pack(
    uint8_t *dst_p,
    const primary_flash_cellboard_5_tx_t *src_p,
    size_t size);

/**
 * Unpack message FLASH_CELLBOARD_5_TX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_flash_cellboard_5_tx_unpack(
    primary_flash_cellboard_5_tx_t *dst_p,
    const uint8_t *src_p,
    size_t size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void primary_flash_cellboard_5_rx_raw_to_conversion_struct(
    primary_flash_cellboard_5_rx_converted_t *conversion, 
    const primary_flash_cellboard_5_rx_t *raw);


void primary_flash_cellboard_5_rx_conversion_to_raw_struct(
    primary_flash_cellboard_5_rx_t *raw,
    const primary_flash_cellboard_5_rx_converted_t *conversion);


int primary_flash_cellboard_5_rx_to_string(primary_flash_cellboard_5_rx_t *message, char *buffer);

int primary_flash_cellboard_5_rx_to_string_file(primary_flash_cellboard_5_rx_t *message, FILE *buffer);

int primary_flash_cellboard_5_rx_fields(char *buffer);

int primary_flash_cellboard_5_rx_fields_file(FILE *buffer);

/**
 * Pack message FLASH_CELLBOARD_5_RX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_flash_cellboard_5_rx_pack(
    uint8_t *dst_p,
    const primary_flash_cellboard_5_rx_t *src_p,
    size_t size);

/**
 * Unpack message FLASH_CELLBOARD_5_RX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_flash_cellboard_5_rx_unpack(
    primary_flash_cellboard_5_rx_t *dst_p,
    const uint8_t *src_p,
    size_t size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void primary_flash_bms_hv_tx_raw_to_conversion_struct(
    primary_flash_bms_hv_tx_converted_t *conversion, 
    const primary_flash_bms_hv_tx_t *raw);


void primary_flash_bms_hv_tx_conversion_to_raw_struct(
    primary_flash_bms_hv_tx_t *raw,
    const primary_flash_bms_hv_tx_converted_t *conversion);


int primary_flash_bms_hv_tx_to_string(primary_flash_bms_hv_tx_t *message, char *buffer);

int primary_flash_bms_hv_tx_to_string_file(primary_flash_bms_hv_tx_t *message, FILE *buffer);

int primary_flash_bms_hv_tx_fields(char *buffer);

int primary_flash_bms_hv_tx_fields_file(FILE *buffer);

/**
 * Pack message FLASH_BMS_HV_TX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_flash_bms_hv_tx_pack(
    uint8_t *dst_p,
    const primary_flash_bms_hv_tx_t *src_p,
    size_t size);

/**
 * Unpack message FLASH_BMS_HV_TX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_flash_bms_hv_tx_unpack(
    primary_flash_bms_hv_tx_t *dst_p,
    const uint8_t *src_p,
    size_t size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void primary_flash_bms_hv_rx_raw_to_conversion_struct(
    primary_flash_bms_hv_rx_converted_t *conversion, 
    const primary_flash_bms_hv_rx_t *raw);


void primary_flash_bms_hv_rx_conversion_to_raw_struct(
    primary_flash_bms_hv_rx_t *raw,
    const primary_flash_bms_hv_rx_converted_t *conversion);


int primary_flash_bms_hv_rx_to_string(primary_flash_bms_hv_rx_t *message, char *buffer);

int primary_flash_bms_hv_rx_to_string_file(primary_flash_bms_hv_rx_t *message, FILE *buffer);

int primary_flash_bms_hv_rx_fields(char *buffer);

int primary_flash_bms_hv_rx_fields_file(FILE *buffer);

/**
 * Pack message FLASH_BMS_HV_RX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_flash_bms_hv_rx_pack(
    uint8_t *dst_p,
    const primary_flash_bms_hv_rx_t *src_p,
    size_t size);

/**
 * Unpack message FLASH_BMS_HV_RX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_flash_bms_hv_rx_unpack(
    primary_flash_bms_hv_rx_t *dst_p,
    const uint8_t *src_p,
    size_t size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void primary_flash_bms_lv_tx_raw_to_conversion_struct(
    primary_flash_bms_lv_tx_converted_t *conversion, 
    const primary_flash_bms_lv_tx_t *raw);


void primary_flash_bms_lv_tx_conversion_to_raw_struct(
    primary_flash_bms_lv_tx_t *raw,
    const primary_flash_bms_lv_tx_converted_t *conversion);


int primary_flash_bms_lv_tx_to_string(primary_flash_bms_lv_tx_t *message, char *buffer);

int primary_flash_bms_lv_tx_to_string_file(primary_flash_bms_lv_tx_t *message, FILE *buffer);

int primary_flash_bms_lv_tx_fields(char *buffer);

int primary_flash_bms_lv_tx_fields_file(FILE *buffer);

/**
 * Pack message FLASH_BMS_LV_TX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_flash_bms_lv_tx_pack(
    uint8_t *dst_p,
    const primary_flash_bms_lv_tx_t *src_p,
    size_t size);

/**
 * Unpack message FLASH_BMS_LV_TX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_flash_bms_lv_tx_unpack(
    primary_flash_bms_lv_tx_t *dst_p,
    const uint8_t *src_p,
    size_t size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void primary_flash_bms_lv_rx_raw_to_conversion_struct(
    primary_flash_bms_lv_rx_converted_t *conversion, 
    const primary_flash_bms_lv_rx_t *raw);


void primary_flash_bms_lv_rx_conversion_to_raw_struct(
    primary_flash_bms_lv_rx_t *raw,
    const primary_flash_bms_lv_rx_converted_t *conversion);


int primary_flash_bms_lv_rx_to_string(primary_flash_bms_lv_rx_t *message, char *buffer);

int primary_flash_bms_lv_rx_to_string_file(primary_flash_bms_lv_rx_t *message, FILE *buffer);

int primary_flash_bms_lv_rx_fields(char *buffer);

int primary_flash_bms_lv_rx_fields_file(FILE *buffer);

/**
 * Pack message FLASH_BMS_LV_RX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_flash_bms_lv_rx_pack(
    uint8_t *dst_p,
    const primary_flash_bms_lv_rx_t *src_p,
    size_t size);

/**
 * Unpack message FLASH_BMS_LV_RX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_flash_bms_lv_rx_unpack(
    primary_flash_bms_lv_rx_t *dst_p,
    const uint8_t *src_p,
    size_t size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void primary_brusa_nlg5_ctl_raw_to_conversion_struct(
    primary_brusa_nlg5_ctl_converted_t *conversion, 
    const primary_brusa_nlg5_ctl_t *raw);


void primary_brusa_nlg5_ctl_conversion_to_raw_struct(
    primary_brusa_nlg5_ctl_t *raw,
    const primary_brusa_nlg5_ctl_converted_t *conversion);


int primary_brusa_nlg5_ctl_to_string(primary_brusa_nlg5_ctl_t *message, char *buffer);

int primary_brusa_nlg5_ctl_to_string_file(primary_brusa_nlg5_ctl_t *message, FILE *buffer);

int primary_brusa_nlg5_ctl_fields(char *buffer);

int primary_brusa_nlg5_ctl_fields_file(FILE *buffer);

/**
 * Pack message BRUSA_NLG5_CTL.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_brusa_nlg5_ctl_pack(
    uint8_t *dst_p,
    const primary_brusa_nlg5_ctl_t *src_p,
    size_t size);

/**
 * Unpack message BRUSA_NLG5_CTL.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_brusa_nlg5_ctl_unpack(
    primary_brusa_nlg5_ctl_t *dst_p,
    const uint8_t *src_p,
    size_t size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void primary_brusa_st_raw_to_conversion_struct(
    primary_brusa_st_converted_t *conversion, 
    const primary_brusa_st_t *raw);


void primary_brusa_st_conversion_to_raw_struct(
    primary_brusa_st_t *raw,
    const primary_brusa_st_converted_t *conversion);


int primary_brusa_st_to_string(primary_brusa_st_t *message, char *buffer);

int primary_brusa_st_to_string_file(primary_brusa_st_t *message, FILE *buffer);

int primary_brusa_st_fields(char *buffer);

int primary_brusa_st_fields_file(FILE *buffer);

/**
 * Pack message BRUSA_ST.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_brusa_st_pack(
    uint8_t *dst_p,
    const primary_brusa_st_t *src_p,
    size_t size);

/**
 * Unpack message BRUSA_ST.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_brusa_st_unpack(
    primary_brusa_st_t *dst_p,
    const uint8_t *src_p,
    size_t size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void primary_brusa_act_i_raw_to_conversion_struct(
    primary_brusa_act_i_converted_t *conversion, 
    const primary_brusa_act_i_t *raw);


void primary_brusa_act_i_conversion_to_raw_struct(
    primary_brusa_act_i_t *raw,
    const primary_brusa_act_i_converted_t *conversion);


int primary_brusa_act_i_to_string(primary_brusa_act_i_t *message, char *buffer);

int primary_brusa_act_i_to_string_file(primary_brusa_act_i_t *message, FILE *buffer);

int primary_brusa_act_i_fields(char *buffer);

int primary_brusa_act_i_fields_file(FILE *buffer);

/**
 * Pack message BRUSA_ACT_I.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_brusa_act_i_pack(
    uint8_t *dst_p,
    const primary_brusa_act_i_t *src_p,
    size_t size);

/**
 * Unpack message BRUSA_ACT_I.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_brusa_act_i_unpack(
    primary_brusa_act_i_t *dst_p,
    const uint8_t *src_p,
    size_t size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void primary_brusa_act_ii_raw_to_conversion_struct(
    primary_brusa_act_ii_converted_t *conversion, 
    const primary_brusa_act_ii_t *raw);


void primary_brusa_act_ii_conversion_to_raw_struct(
    primary_brusa_act_ii_t *raw,
    const primary_brusa_act_ii_converted_t *conversion);


int primary_brusa_act_ii_to_string(primary_brusa_act_ii_t *message, char *buffer);

int primary_brusa_act_ii_to_string_file(primary_brusa_act_ii_t *message, FILE *buffer);

int primary_brusa_act_ii_fields(char *buffer);

int primary_brusa_act_ii_fields_file(FILE *buffer);

/**
 * Pack message BRUSA_ACT_II.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_brusa_act_ii_pack(
    uint8_t *dst_p,
    const primary_brusa_act_ii_t *src_p,
    size_t size);

/**
 * Unpack message BRUSA_ACT_II.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_brusa_act_ii_unpack(
    primary_brusa_act_ii_t *dst_p,
    const uint8_t *src_p,
    size_t size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void primary_brusa_temp_raw_to_conversion_struct(
    primary_brusa_temp_converted_t *conversion, 
    const primary_brusa_temp_t *raw);


void primary_brusa_temp_conversion_to_raw_struct(
    primary_brusa_temp_t *raw,
    const primary_brusa_temp_converted_t *conversion);


int primary_brusa_temp_to_string(primary_brusa_temp_t *message, char *buffer);

int primary_brusa_temp_to_string_file(primary_brusa_temp_t *message, FILE *buffer);

int primary_brusa_temp_fields(char *buffer);

int primary_brusa_temp_fields_file(FILE *buffer);

/**
 * Pack message BRUSA_TEMP.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_brusa_temp_pack(
    uint8_t *dst_p,
    const primary_brusa_temp_t *src_p,
    size_t size);

/**
 * Unpack message BRUSA_TEMP.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_brusa_temp_unpack(
    primary_brusa_temp_t *dst_p,
    const uint8_t *src_p,
    size_t size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void primary_brusa_err_raw_to_conversion_struct(
    primary_brusa_err_converted_t *conversion, 
    const primary_brusa_err_t *raw);


void primary_brusa_err_conversion_to_raw_struct(
    primary_brusa_err_t *raw,
    const primary_brusa_err_converted_t *conversion);


int primary_brusa_err_to_string(primary_brusa_err_t *message, char *buffer);

int primary_brusa_err_to_string_file(primary_brusa_err_t *message, FILE *buffer);

int primary_brusa_err_fields(char *buffer);

int primary_brusa_err_fields_file(FILE *buffer);

/**
 * Pack message BRUSA_ERR.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_brusa_err_pack(
    uint8_t *dst_p,
    const primary_brusa_err_t *src_p,
    size_t size);

/**
 * Unpack message BRUSA_ERR.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_brusa_err_unpack(
    primary_brusa_err_t *dst_p,
    const uint8_t *src_p,
    size_t size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


void primary_control_output_raw_to_conversion(
    primary_control_output_converted_t *conversion,
    float estimated_velocity,
    float tmax_r,
    float tmax_l,
    float torque_l,
    float torque_r
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_control_output_conversion_to_raw(
    primary_control_output_t *raw,
    float estimated_velocity,
    float tmax_r,
    float tmax_l,
    float torque_l,
    float torque_r
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_control_output_raw_to_conversion_struct(
    primary_control_output_converted_t *conversion, 
    const primary_control_output_t *raw);


void primary_control_output_conversion_to_raw_struct(
    primary_control_output_t *raw,
    const primary_control_output_converted_t *conversion);


int primary_control_output_converted_to_string(primary_control_output_converted_t *message, char *buffer);

int primary_control_output_converted_to_string_file(primary_control_output_converted_t *message, FILE *buffer);

int primary_control_output_fields(char *buffer);

int primary_control_output_fields_file(FILE *buffer);

/**
 * Pack message CONTROL_OUTPUT.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_control_output_pack(
    uint8_t *dst_p,
    const primary_control_output_t *src_p,
    size_t size);

/**
 * Unpack message CONTROL_OUTPUT.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_control_output_unpack(
    primary_control_output_t *dst_p,
    const uint8_t *src_p,
    size_t size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t primary_control_output_estimated_velocity_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_control_output_estimated_velocity_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_control_output_estimated_velocity_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_control_output_tmax_r_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_control_output_tmax_r_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_control_output_tmax_r_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_control_output_tmax_l_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_control_output_tmax_l_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_control_output_tmax_l_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t primary_control_output_torque_l_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_control_output_torque_l_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_control_output_torque_l_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t primary_control_output_torque_r_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double primary_control_output_torque_r_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_control_output_torque_r_is_in_range(uint32_t value);


;


;


void primary_lc_reset_raw_to_conversion_struct(
    primary_lc_reset_converted_t *conversion, 
    const primary_lc_reset_t *raw);


void primary_lc_reset_conversion_to_raw_struct(
    primary_lc_reset_t *raw,
    const primary_lc_reset_converted_t *conversion);


int primary_lc_reset_to_string(primary_lc_reset_t *message, char *buffer);

int primary_lc_reset_to_string_file(primary_lc_reset_t *message, FILE *buffer);

int primary_lc_reset_fields(char *buffer);

int primary_lc_reset_fields_file(FILE *buffer);

/**
 * Pack message LC_RESET.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_lc_reset_pack(
    uint8_t *dst_p,
    const primary_lc_reset_t *src_p,
    size_t size);

/**
 * Unpack message LC_RESET.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_lc_reset_unpack(
    primary_lc_reset_t *dst_p,
    const uint8_t *src_p,
    size_t size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

bool primary_id_is_message(uint16_t id);

int primary_to_string_from_id(uint16_t message_id, void* message, char* buffer);
int primary_fields_from_id(uint16_t message_id, char* buffer);
int primary_to_string_file_from_id(uint16_t message_id, void* message, FILE* buffer);
int primary_fields_file_from_id(uint16_t message_id, FILE* buffer);

#ifdef __cplusplus
}
#endif

#endif
