/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2018-2019 Erik Moqvist
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/**
 * This file was generated by cantools version 38.0.2 Tue Jun  6 16:05:33 2023.
 */

#ifndef PRIMARY_H
#define PRIMARY_H

#include <stdio.h>
#include <stdlib.h>
#include <inttypes.h>

#ifdef __cplusplus
extern "C" {
#endif

#include <stdint.h>
#include <stdbool.h>
#include <stddef.h>

#ifndef CANLIB_BUILD
#define CANLIB_BUILD
#define CANLIB_BUILD_TIME 1686067533
#endif // CANLIB_BUILD

#ifndef CANLIB_PARKING
/* We know it's PACKING but PARKING sounds a bit better ;) */
#if defined(__MINGW32__)
#define CANLIB_PARKING                                                           __attribute__((__gcc_struct__, __packed__)) // , __aligned__(1)))
#else
#define CANLIB_PARKING __attribute__((__packed__)) // , __aligned__(1)))
#endif                                             // defined(__MINGW32__)
#endif                                             // CANLIB_PARKING

#ifndef EINVAL
#    define EINVAL 22
#endif

/* Frame ids. */
#define PRIMARY_BMS_HV_JMP_TO_BLT_FRAME_ID (0x04u)
#define PRIMARY_BMS_LV_JMP_TO_BLT_FRAME_ID (0x24u)
#define PRIMARY_STEER_VERSION_FRAME_ID (0x406u)
#define PRIMARY_DAS_VERSION_FRAME_ID (0x426u)
#define PRIMARY_HV_VERSION_FRAME_ID (0x446u)
#define PRIMARY_LV_VERSION_FRAME_ID (0x466u)
#define PRIMARY_TLM_VERSION_FRAME_ID (0x486u)
#define PRIMARY_TIMESTAMP_FRAME_ID (0x106u)
#define PRIMARY_AMBIENT_TEMPERATURE_FRAME_ID (0x126u)
#define PRIMARY_DATA_LOGGER_FRAME_ID (0x430u)
#define PRIMARY_SET_TLM_STATUS_FRAME_ID (0x100u)
#define PRIMARY_TLM_STATUS_FRAME_ID (0x103u)
#define PRIMARY_STEER_SYSTEM_STATUS_FRAME_ID (0x700u)
#define PRIMARY_HV_VOLTAGE_FRAME_ID (0x309u)
#define PRIMARY_HV_CURRENT_FRAME_ID (0x329u)
#define PRIMARY_HV_TEMP_FRAME_ID (0x349u)
#define PRIMARY_HV_ERRORS_FRAME_ID (0x09u)
#define PRIMARY_HV_CAN_FORWARD_FRAME_ID (0x08u)
#define PRIMARY_HV_FANS_OVERRIDE_FRAME_ID (0x28u)
#define PRIMARY_HV_CAN_FORWARD_STATUS_FRAME_ID (0x01u)
#define PRIMARY_HV_FANS_OVERRIDE_STATUS_FRAME_ID (0x301u)
#define PRIMARY_HV_FEEDBACKS_STATUS_FRAME_ID (0x302u)
#define PRIMARY_HV_IMD_STATUS_FRAME_ID (0x322u)
#define PRIMARY_TS_STATUS_FRAME_ID (0x29u)
#define PRIMARY_SET_TS_STATUS_DAS_FRAME_ID (0x48u)
#define PRIMARY_SET_TS_STATUS_HANDCART_FRAME_ID (0x68u)
#define PRIMARY_STEER_STATUS_FRAME_ID (0x107u)
#define PRIMARY_SET_CAR_STATUS_FRAME_ID (0x307u)
#define PRIMARY_SET_PEDALS_RANGE_FRAME_ID (0x407u)
#define PRIMARY_SET_STEERING_ANGLE_RANGE_FRAME_ID (0x427u)
#define PRIMARY_CAR_STATUS_FRAME_ID (0x203u)
#define PRIMARY_DAS_ERRORS_FRAME_ID (0x03u)
#define PRIMARY_LV_CURRENT_FRAME_ID (0x342u)
#define PRIMARY_LV_VOLTAGE_FRAME_ID (0x362u)
#define PRIMARY_LV_TOTAL_VOLTAGE_FRAME_ID (0x382u)
#define PRIMARY_LV_TEMPERATURE_FRAME_ID (0x3a2u)
#define PRIMARY_COOLING_STATUS_FRAME_ID (0x3c2u)
#define PRIMARY_SET_RADIATOR_SPEED_FRAME_ID (0x305u)
#define PRIMARY_SET_PUMPS_SPEED_FRAME_ID (0x325u)
#define PRIMARY_SET_INVERTER_CONNECTION_STATUS_FRAME_ID (0x105u)
#define PRIMARY_INVERTER_CONNECTION_STATUS_FRAME_ID (0x102u)
#define PRIMARY_LV_ERRORS_FRAME_ID (0x02u)
#define PRIMARY_SHUTDOWN_STATUS_FRAME_ID (0x122u)
#define PRIMARY_MARKER_FRAME_ID (0x00u)
#define PRIMARY_HV_CELLS_VOLTAGE_FRAME_ID (0x221u)
#define PRIMARY_HV_CELLS_TEMP_FRAME_ID (0x241u)
#define PRIMARY_HV_CELL_BALANCING_STATUS_FRAME_ID (0x261u)
#define PRIMARY_SET_CELL_BALANCING_STATUS_FRAME_ID (0x208u)
#define PRIMARY_HANDCART_STATUS_FRAME_ID (0x308u)
#define PRIMARY_SPEED_FRAME_ID (0x223u)
#define PRIMARY_INV_L_REQUEST_FRAME_ID (0x201u)
#define PRIMARY_INV_R_REQUEST_FRAME_ID (0x202u)
#define PRIMARY_INV_L_RESPONSE_FRAME_ID (0x181u)
#define PRIMARY_INV_R_RESPONSE_FRAME_ID (0x182u)
#define PRIMARY_FLASH_CELLBOARD_0_TX_FRAME_ID (0x10u)
#define PRIMARY_FLASH_CELLBOARD_0_RX_FRAME_ID (0x11u)
#define PRIMARY_FLASH_CELLBOARD_1_TX_FRAME_ID (0x12u)
#define PRIMARY_FLASH_CELLBOARD_1_RX_FRAME_ID (0x13u)
#define PRIMARY_FLASH_CELLBOARD_2_TX_FRAME_ID (0x14u)
#define PRIMARY_FLASH_CELLBOARD_2_RX_FRAME_ID (0x15u)
#define PRIMARY_FLASH_CELLBOARD_3_TX_FRAME_ID (0x16u)
#define PRIMARY_FLASH_CELLBOARD_3_RX_FRAME_ID (0x17u)
#define PRIMARY_FLASH_CELLBOARD_4_TX_FRAME_ID (0x18u)
#define PRIMARY_FLASH_CELLBOARD_4_RX_FRAME_ID (0x19u)
#define PRIMARY_FLASH_CELLBOARD_5_TX_FRAME_ID (0x1au)
#define PRIMARY_FLASH_CELLBOARD_5_RX_FRAME_ID (0x1bu)
#define PRIMARY_FLASH_BMS_HV_TX_FRAME_ID (0x7e1u)
#define PRIMARY_FLASH_BMS_HV_RX_FRAME_ID (0x667u)
#define PRIMARY_FLASH_BMS_LV_TX_FRAME_ID (0x7f1u)
#define PRIMARY_FLASH_BMS_LV_RX_FRAME_ID (0x677u)
#define PRIMARY_BRUSA_NLG5_CTL_FRAME_ID (0x26au)
#define PRIMARY_BRUSA_ST_FRAME_ID (0x262u)
#define PRIMARY_BRUSA_ACT_I_FRAME_ID (0x263u)
#define PRIMARY_BRUSA_ACT_II_FRAME_ID (0x264u)
#define PRIMARY_BRUSA_TEMP_FRAME_ID (0x265u)
#define PRIMARY_BRUSA_ERR_FRAME_ID (0x266u)
#define PRIMARY_CONTROL_OUTPUT_FRAME_ID (0x123u)
#define PRIMARY_LC_RESET_FRAME_ID (0x20au)

/* Frame lengths in bytes. */
#define PRIMARY_BMS_HV_JMP_TO_BLT_BYTE_SIZE (0u)
#define PRIMARY_BMS_LV_JMP_TO_BLT_BYTE_SIZE (0u)
#define PRIMARY_STEER_VERSION_BYTE_SIZE (5u)
#define PRIMARY_DAS_VERSION_BYTE_SIZE (5u)
#define PRIMARY_HV_VERSION_BYTE_SIZE (5u)
#define PRIMARY_LV_VERSION_BYTE_SIZE (5u)
#define PRIMARY_TLM_VERSION_BYTE_SIZE (5u)
#define PRIMARY_TIMESTAMP_BYTE_SIZE (4u)
#define PRIMARY_AMBIENT_TEMPERATURE_BYTE_SIZE (2u)
#define PRIMARY_DATA_LOGGER_BYTE_SIZE (8u)
#define PRIMARY_SET_TLM_STATUS_BYTE_SIZE (1u)
#define PRIMARY_TLM_STATUS_BYTE_SIZE (1u)
#define PRIMARY_STEER_SYSTEM_STATUS_BYTE_SIZE (1u)
#define PRIMARY_HV_VOLTAGE_BYTE_SIZE (8u)
#define PRIMARY_HV_CURRENT_BYTE_SIZE (7u)
#define PRIMARY_HV_TEMP_BYTE_SIZE (3u)
#define PRIMARY_HV_ERRORS_BYTE_SIZE (4u)
#define PRIMARY_HV_CAN_FORWARD_BYTE_SIZE (1u)
#define PRIMARY_HV_FANS_OVERRIDE_BYTE_SIZE (3u)
#define PRIMARY_HV_CAN_FORWARD_STATUS_BYTE_SIZE (1u)
#define PRIMARY_HV_FANS_OVERRIDE_STATUS_BYTE_SIZE (3u)
#define PRIMARY_HV_FEEDBACKS_STATUS_BYTE_SIZE (5u)
#define PRIMARY_HV_IMD_STATUS_BYTE_SIZE (5u)
#define PRIMARY_TS_STATUS_BYTE_SIZE (1u)
#define PRIMARY_SET_TS_STATUS_DAS_BYTE_SIZE (1u)
#define PRIMARY_SET_TS_STATUS_HANDCART_BYTE_SIZE (1u)
#define PRIMARY_STEER_STATUS_BYTE_SIZE (3u)
#define PRIMARY_SET_CAR_STATUS_BYTE_SIZE (1u)
#define PRIMARY_SET_PEDALS_RANGE_BYTE_SIZE (1u)
#define PRIMARY_SET_STEERING_ANGLE_RANGE_BYTE_SIZE (1u)
#define PRIMARY_CAR_STATUS_BYTE_SIZE (1u)
#define PRIMARY_DAS_ERRORS_BYTE_SIZE (2u)
#define PRIMARY_LV_CURRENT_BYTE_SIZE (2u)
#define PRIMARY_LV_VOLTAGE_BYTE_SIZE (8u)
#define PRIMARY_LV_TOTAL_VOLTAGE_BYTE_SIZE (4u)
#define PRIMARY_LV_TEMPERATURE_BYTE_SIZE (8u)
#define PRIMARY_COOLING_STATUS_BYTE_SIZE (4u)
#define PRIMARY_SET_RADIATOR_SPEED_BYTE_SIZE (2u)
#define PRIMARY_SET_PUMPS_SPEED_BYTE_SIZE (2u)
#define PRIMARY_SET_INVERTER_CONNECTION_STATUS_BYTE_SIZE (1u)
#define PRIMARY_INVERTER_CONNECTION_STATUS_BYTE_SIZE (1u)
#define PRIMARY_LV_ERRORS_BYTE_SIZE (6u)
#define PRIMARY_SHUTDOWN_STATUS_BYTE_SIZE (1u)
#define PRIMARY_MARKER_BYTE_SIZE (0u)
#define PRIMARY_HV_CELLS_VOLTAGE_BYTE_SIZE (7u)
#define PRIMARY_HV_CELLS_TEMP_BYTE_SIZE (7u)
#define PRIMARY_HV_CELL_BALANCING_STATUS_BYTE_SIZE (1u)
#define PRIMARY_SET_CELL_BALANCING_STATUS_BYTE_SIZE (1u)
#define PRIMARY_HANDCART_STATUS_BYTE_SIZE (1u)
#define PRIMARY_SPEED_BYTE_SIZE (8u)
#define PRIMARY_INV_L_REQUEST_BYTE_SIZE (8u)
#define PRIMARY_INV_R_REQUEST_BYTE_SIZE (8u)
#define PRIMARY_INV_L_RESPONSE_BYTE_SIZE (8u)
#define PRIMARY_INV_R_RESPONSE_BYTE_SIZE (8u)
#define PRIMARY_FLASH_CELLBOARD_0_TX_BYTE_SIZE (0u)
#define PRIMARY_FLASH_CELLBOARD_0_RX_BYTE_SIZE (0u)
#define PRIMARY_FLASH_CELLBOARD_1_TX_BYTE_SIZE (0u)
#define PRIMARY_FLASH_CELLBOARD_1_RX_BYTE_SIZE (0u)
#define PRIMARY_FLASH_CELLBOARD_2_TX_BYTE_SIZE (0u)
#define PRIMARY_FLASH_CELLBOARD_2_RX_BYTE_SIZE (0u)
#define PRIMARY_FLASH_CELLBOARD_3_TX_BYTE_SIZE (0u)
#define PRIMARY_FLASH_CELLBOARD_3_RX_BYTE_SIZE (0u)
#define PRIMARY_FLASH_CELLBOARD_4_TX_BYTE_SIZE (0u)
#define PRIMARY_FLASH_CELLBOARD_4_RX_BYTE_SIZE (0u)
#define PRIMARY_FLASH_CELLBOARD_5_TX_BYTE_SIZE (0u)
#define PRIMARY_FLASH_CELLBOARD_5_RX_BYTE_SIZE (0u)
#define PRIMARY_FLASH_BMS_HV_TX_BYTE_SIZE (0u)
#define PRIMARY_FLASH_BMS_HV_RX_BYTE_SIZE (0u)
#define PRIMARY_FLASH_BMS_LV_TX_BYTE_SIZE (0u)
#define PRIMARY_FLASH_BMS_LV_RX_BYTE_SIZE (0u)
#define PRIMARY_BRUSA_NLG5_CTL_BYTE_SIZE (0u)
#define PRIMARY_BRUSA_ST_BYTE_SIZE (0u)
#define PRIMARY_BRUSA_ACT_I_BYTE_SIZE (0u)
#define PRIMARY_BRUSA_ACT_II_BYTE_SIZE (0u)
#define PRIMARY_BRUSA_TEMP_BYTE_SIZE (0u)
#define PRIMARY_BRUSA_ERR_BYTE_SIZE (0u)
#define PRIMARY_CONTROL_OUTPUT_BYTE_SIZE (8u)
#define PRIMARY_LC_RESET_BYTE_SIZE (0u)

/* Extended or standard frame types. */
#define PRIMARY_BMS_HV_JMP_TO_BLT_IS_EXTENDED (0)
#define PRIMARY_BMS_LV_JMP_TO_BLT_IS_EXTENDED (0)
#define PRIMARY_STEER_VERSION_IS_EXTENDED (0)
#define PRIMARY_DAS_VERSION_IS_EXTENDED (0)
#define PRIMARY_HV_VERSION_IS_EXTENDED (0)
#define PRIMARY_LV_VERSION_IS_EXTENDED (0)
#define PRIMARY_TLM_VERSION_IS_EXTENDED (0)
#define PRIMARY_TIMESTAMP_IS_EXTENDED (0)
#define PRIMARY_AMBIENT_TEMPERATURE_IS_EXTENDED (0)
#define PRIMARY_DATA_LOGGER_IS_EXTENDED (0)
#define PRIMARY_SET_TLM_STATUS_IS_EXTENDED (0)
#define PRIMARY_TLM_STATUS_IS_EXTENDED (0)
#define PRIMARY_STEER_SYSTEM_STATUS_IS_EXTENDED (0)
#define PRIMARY_HV_VOLTAGE_IS_EXTENDED (0)
#define PRIMARY_HV_CURRENT_IS_EXTENDED (0)
#define PRIMARY_HV_TEMP_IS_EXTENDED (0)
#define PRIMARY_HV_ERRORS_IS_EXTENDED (0)
#define PRIMARY_HV_CAN_FORWARD_IS_EXTENDED (0)
#define PRIMARY_HV_FANS_OVERRIDE_IS_EXTENDED (0)
#define PRIMARY_HV_CAN_FORWARD_STATUS_IS_EXTENDED (0)
#define PRIMARY_HV_FANS_OVERRIDE_STATUS_IS_EXTENDED (0)
#define PRIMARY_HV_FEEDBACKS_STATUS_IS_EXTENDED (0)
#define PRIMARY_HV_IMD_STATUS_IS_EXTENDED (0)
#define PRIMARY_TS_STATUS_IS_EXTENDED (0)
#define PRIMARY_SET_TS_STATUS_DAS_IS_EXTENDED (0)
#define PRIMARY_SET_TS_STATUS_HANDCART_IS_EXTENDED (0)
#define PRIMARY_STEER_STATUS_IS_EXTENDED (0)
#define PRIMARY_SET_CAR_STATUS_IS_EXTENDED (0)
#define PRIMARY_SET_PEDALS_RANGE_IS_EXTENDED (0)
#define PRIMARY_SET_STEERING_ANGLE_RANGE_IS_EXTENDED (0)
#define PRIMARY_CAR_STATUS_IS_EXTENDED (0)
#define PRIMARY_DAS_ERRORS_IS_EXTENDED (0)
#define PRIMARY_LV_CURRENT_IS_EXTENDED (0)
#define PRIMARY_LV_VOLTAGE_IS_EXTENDED (0)
#define PRIMARY_LV_TOTAL_VOLTAGE_IS_EXTENDED (0)
#define PRIMARY_LV_TEMPERATURE_IS_EXTENDED (0)
#define PRIMARY_COOLING_STATUS_IS_EXTENDED (0)
#define PRIMARY_SET_RADIATOR_SPEED_IS_EXTENDED (0)
#define PRIMARY_SET_PUMPS_SPEED_IS_EXTENDED (0)
#define PRIMARY_SET_INVERTER_CONNECTION_STATUS_IS_EXTENDED (0)
#define PRIMARY_INVERTER_CONNECTION_STATUS_IS_EXTENDED (0)
#define PRIMARY_LV_ERRORS_IS_EXTENDED (0)
#define PRIMARY_SHUTDOWN_STATUS_IS_EXTENDED (0)
#define PRIMARY_MARKER_IS_EXTENDED (0)
#define PRIMARY_HV_CELLS_VOLTAGE_IS_EXTENDED (0)
#define PRIMARY_HV_CELLS_TEMP_IS_EXTENDED (0)
#define PRIMARY_HV_CELL_BALANCING_STATUS_IS_EXTENDED (0)
#define PRIMARY_SET_CELL_BALANCING_STATUS_IS_EXTENDED (0)
#define PRIMARY_HANDCART_STATUS_IS_EXTENDED (0)
#define PRIMARY_SPEED_IS_EXTENDED (0)
#define PRIMARY_INV_L_REQUEST_IS_EXTENDED (0)
#define PRIMARY_INV_R_REQUEST_IS_EXTENDED (0)
#define PRIMARY_INV_L_RESPONSE_IS_EXTENDED (0)
#define PRIMARY_INV_R_RESPONSE_IS_EXTENDED (0)
#define PRIMARY_FLASH_CELLBOARD_0_TX_IS_EXTENDED (0)
#define PRIMARY_FLASH_CELLBOARD_0_RX_IS_EXTENDED (0)
#define PRIMARY_FLASH_CELLBOARD_1_TX_IS_EXTENDED (0)
#define PRIMARY_FLASH_CELLBOARD_1_RX_IS_EXTENDED (0)
#define PRIMARY_FLASH_CELLBOARD_2_TX_IS_EXTENDED (0)
#define PRIMARY_FLASH_CELLBOARD_2_RX_IS_EXTENDED (0)
#define PRIMARY_FLASH_CELLBOARD_3_TX_IS_EXTENDED (0)
#define PRIMARY_FLASH_CELLBOARD_3_RX_IS_EXTENDED (0)
#define PRIMARY_FLASH_CELLBOARD_4_TX_IS_EXTENDED (0)
#define PRIMARY_FLASH_CELLBOARD_4_RX_IS_EXTENDED (0)
#define PRIMARY_FLASH_CELLBOARD_5_TX_IS_EXTENDED (0)
#define PRIMARY_FLASH_CELLBOARD_5_RX_IS_EXTENDED (0)
#define PRIMARY_FLASH_BMS_HV_TX_IS_EXTENDED (0)
#define PRIMARY_FLASH_BMS_HV_RX_IS_EXTENDED (0)
#define PRIMARY_FLASH_BMS_LV_TX_IS_EXTENDED (0)
#define PRIMARY_FLASH_BMS_LV_RX_IS_EXTENDED (0)
#define PRIMARY_BRUSA_NLG5_CTL_IS_EXTENDED (0)
#define PRIMARY_BRUSA_ST_IS_EXTENDED (0)
#define PRIMARY_BRUSA_ACT_I_IS_EXTENDED (0)
#define PRIMARY_BRUSA_ACT_II_IS_EXTENDED (0)
#define PRIMARY_BRUSA_TEMP_IS_EXTENDED (0)
#define PRIMARY_BRUSA_ERR_IS_EXTENDED (0)
#define PRIMARY_CONTROL_OUTPUT_IS_EXTENDED (0)
#define PRIMARY_LC_RESET_IS_EXTENDED (0)

/* Frame cycle times in milliseconds. */
#define PRIMARY_STEER_VERSION_CYCLE_TIME_MS (1000u)
#define PRIMARY_DAS_VERSION_CYCLE_TIME_MS (1000u)
#define PRIMARY_HV_VERSION_CYCLE_TIME_MS (1000u)
#define PRIMARY_LV_VERSION_CYCLE_TIME_MS (1000u)
#define PRIMARY_TLM_VERSION_CYCLE_TIME_MS (1000u)
#define PRIMARY_TIMESTAMP_CYCLE_TIME_MS (1000u)
#define PRIMARY_AMBIENT_TEMPERATURE_CYCLE_TIME_MS (1000u)
#define PRIMARY_DATA_LOGGER_CYCLE_TIME_MS (1000u)
#define PRIMARY_TLM_STATUS_CYCLE_TIME_MS (1000u)
#define PRIMARY_STEER_SYSTEM_STATUS_CYCLE_TIME_MS (1000u)
#define PRIMARY_HV_VOLTAGE_CYCLE_TIME_MS (10u)
#define PRIMARY_HV_CURRENT_CYCLE_TIME_MS (10u)
#define PRIMARY_HV_TEMP_CYCLE_TIME_MS (100u)
#define PRIMARY_HV_ERRORS_CYCLE_TIME_MS (10u)
#define PRIMARY_TS_STATUS_CYCLE_TIME_MS (10u)
#define PRIMARY_SET_TS_STATUS_DAS_CYCLE_TIME_MS (100u)
#define PRIMARY_SET_TS_STATUS_HANDCART_CYCLE_TIME_MS (100u)
#define PRIMARY_STEER_STATUS_CYCLE_TIME_MS (100u)
#define PRIMARY_CAR_STATUS_CYCLE_TIME_MS (100u)
#define PRIMARY_DAS_ERRORS_CYCLE_TIME_MS (10u)
#define PRIMARY_LV_CURRENT_CYCLE_TIME_MS (500u)
#define PRIMARY_LV_VOLTAGE_CYCLE_TIME_MS (100u)
#define PRIMARY_LV_TOTAL_VOLTAGE_CYCLE_TIME_MS (100u)
#define PRIMARY_LV_TEMPERATURE_CYCLE_TIME_MS (100u)
#define PRIMARY_COOLING_STATUS_CYCLE_TIME_MS (1000u)
#define PRIMARY_SET_INVERTER_CONNECTION_STATUS_CYCLE_TIME_MS (100u)
#define PRIMARY_INVERTER_CONNECTION_STATUS_CYCLE_TIME_MS (100u)
#define PRIMARY_LV_ERRORS_CYCLE_TIME_MS (10u)
#define PRIMARY_SHUTDOWN_STATUS_CYCLE_TIME_MS (500u)
#define PRIMARY_HV_CELLS_VOLTAGE_CYCLE_TIME_MS (100u)
#define PRIMARY_HV_CELLS_TEMP_CYCLE_TIME_MS (100u)
#define PRIMARY_HV_CELL_BALANCING_STATUS_CYCLE_TIME_MS (500u)
#define PRIMARY_HANDCART_STATUS_CYCLE_TIME_MS (500u)
#define PRIMARY_SPEED_CYCLE_TIME_MS (10u)
#define PRIMARY_INV_L_REQUEST_CYCLE_TIME_MS (10u)
#define PRIMARY_INV_R_REQUEST_CYCLE_TIME_MS (10u)
#define PRIMARY_INV_L_RESPONSE_CYCLE_TIME_MS (100u)
#define PRIMARY_INV_R_RESPONSE_CYCLE_TIME_MS (100u)
#define PRIMARY_CONTROL_OUTPUT_CYCLE_TIME_MS (100u)

/* Signal choices. */
#define PRIMARY_SET_TLM_STATUS_TLM_STATUS_OFF_CHOICE (0u)
#define PRIMARY_SET_TLM_STATUS_TLM_STATUS_ON_CHOICE (1u)

#define PRIMARY_TLM_STATUS_TLM_STATUS_OFF_CHOICE (0u)
#define PRIMARY_TLM_STATUS_TLM_STATUS_ON_CHOICE (1u)

#define PRIMARY_HV_CAN_FORWARD_CAN_FORWARD_SET_OFF_CHOICE (0u)
#define PRIMARY_HV_CAN_FORWARD_CAN_FORWARD_SET_ON_CHOICE (1u)

#define PRIMARY_HV_FANS_OVERRIDE_FANS_OVERRIDE_OFF_CHOICE (0u)
#define PRIMARY_HV_FANS_OVERRIDE_FANS_OVERRIDE_ON_CHOICE (1u)

#define PRIMARY_HV_CAN_FORWARD_STATUS_CAN_FORWARD_STATUS_OFF_CHOICE (0u)
#define PRIMARY_HV_CAN_FORWARD_STATUS_CAN_FORWARD_STATUS_ON_CHOICE (1u)

#define PRIMARY_HV_FANS_OVERRIDE_STATUS_FANS_OVERRIDE_OFF_CHOICE (0u)
#define PRIMARY_HV_FANS_OVERRIDE_STATUS_FANS_OVERRIDE_ON_CHOICE (1u)

#define PRIMARY_HV_IMD_STATUS_IMD_STATUS_IMD_SC_CHOICE (0u)
#define PRIMARY_HV_IMD_STATUS_IMD_STATUS_IMD_NORMAL_CHOICE (1u)
#define PRIMARY_HV_IMD_STATUS_IMD_STATUS_IMD_UNDER_VOLTAGE_CHOICE (2u)
#define PRIMARY_HV_IMD_STATUS_IMD_STATUS_IMD_START_MEASURE_CHOICE (3u)
#define PRIMARY_HV_IMD_STATUS_IMD_STATUS_IMD_DEVICE_ERROR_CHOICE (4u)
#define PRIMARY_HV_IMD_STATUS_IMD_STATUS_IMD_EARTH_FAULT_CHOICE (5u)

#define PRIMARY_TS_STATUS_TS_STATUS_OFF_CHOICE (0u)
#define PRIMARY_TS_STATUS_TS_STATUS_PRECHARGE_CHOICE (1u)
#define PRIMARY_TS_STATUS_TS_STATUS_ON_CHOICE (2u)
#define PRIMARY_TS_STATUS_TS_STATUS_FATAL_CHOICE (3u)

#define PRIMARY_SET_TS_STATUS_DAS_TS_STATUS_SET_OFF_CHOICE (0u)
#define PRIMARY_SET_TS_STATUS_DAS_TS_STATUS_SET_ON_CHOICE (1u)

#define PRIMARY_SET_TS_STATUS_HANDCART_TS_STATUS_SET_OFF_CHOICE (0u)
#define PRIMARY_SET_TS_STATUS_HANDCART_TS_STATUS_SET_ON_CHOICE (1u)

#define PRIMARY_SET_CAR_STATUS_CAR_STATUS_SET_IDLE_CHOICE (0u)
#define PRIMARY_SET_CAR_STATUS_CAR_STATUS_SET_READY_CHOICE (1u)
#define PRIMARY_SET_CAR_STATUS_CAR_STATUS_SET_DRIVE_CHOICE (2u)

#define PRIMARY_SET_PEDALS_RANGE_BOUND_SET_MAX_CHOICE (0u)
#define PRIMARY_SET_PEDALS_RANGE_BOUND_SET_MIN_CHOICE (1u)

#define PRIMARY_SET_PEDALS_RANGE_PEDAL_ACCELERATOR_CHOICE (0u)
#define PRIMARY_SET_PEDALS_RANGE_PEDAL_BRAKE_CHOICE (1u)

#define PRIMARY_SET_STEERING_ANGLE_RANGE_BOUND_SET_MAX_CHOICE (0u)
#define PRIMARY_SET_STEERING_ANGLE_RANGE_BOUND_SET_MIN_CHOICE (1u)

#define PRIMARY_CAR_STATUS_INVERTER_L_OFF_CHOICE (0u)
#define PRIMARY_CAR_STATUS_INVERTER_L_IDLE_CHOICE (1u)
#define PRIMARY_CAR_STATUS_INVERTER_L_ON_CHOICE (2u)

#define PRIMARY_CAR_STATUS_INVERTER_R_OFF_CHOICE (0u)
#define PRIMARY_CAR_STATUS_INVERTER_R_IDLE_CHOICE (1u)
#define PRIMARY_CAR_STATUS_INVERTER_R_ON_CHOICE (2u)

#define PRIMARY_CAR_STATUS_CAR_STATUS_IDLE_CHOICE (0u)
#define PRIMARY_CAR_STATUS_CAR_STATUS_PRE_SETUP_CHOICE (1u)
#define PRIMARY_CAR_STATUS_CAR_STATUS_TS_ON_CHOICE (2u)
#define PRIMARY_CAR_STATUS_CAR_STATUS_POST_SETUP_CHOICE (3u)
#define PRIMARY_CAR_STATUS_CAR_STATUS_DRIVE_CHOICE (4u)
#define PRIMARY_CAR_STATUS_CAR_STATUS_TEARDOWN_CHOICE (5u)

#define PRIMARY_SET_INVERTER_CONNECTION_STATUS_STATUS_OFF_CHOICE (0u)
#define PRIMARY_SET_INVERTER_CONNECTION_STATUS_STATUS_ON_CHOICE (1u)

#define PRIMARY_INVERTER_CONNECTION_STATUS_STATUS_OFF_CHOICE (0u)
#define PRIMARY_INVERTER_CONNECTION_STATUS_STATUS_ON_CHOICE (1u)

#define PRIMARY_HV_CELL_BALANCING_STATUS_BALANCING_STATUS_OFF_CHOICE (0u)
#define PRIMARY_HV_CELL_BALANCING_STATUS_BALANCING_STATUS_ON_CHOICE (1u)

#define PRIMARY_SET_CELL_BALANCING_STATUS_SET_BALANCING_STATUS_OFF_CHOICE (0u)
#define PRIMARY_SET_CELL_BALANCING_STATUS_SET_BALANCING_STATUS_ON_CHOICE (1u)

/* Indexes */
#define PRIMARY_BMS_HV_JMP_TO_BLT_INDEX 0
#define PRIMARY_BMS_LV_JMP_TO_BLT_INDEX 1
#define PRIMARY_STEER_VERSION_INDEX 2
#define PRIMARY_DAS_VERSION_INDEX 3
#define PRIMARY_HV_VERSION_INDEX 4
#define PRIMARY_LV_VERSION_INDEX 5
#define PRIMARY_TLM_VERSION_INDEX 6
#define PRIMARY_TIMESTAMP_INDEX 7
#define PRIMARY_AMBIENT_TEMPERATURE_INDEX 8
#define PRIMARY_DATA_LOGGER_INDEX 9
#define PRIMARY_SET_TLM_STATUS_INDEX 10
#define PRIMARY_TLM_STATUS_INDEX 11
#define PRIMARY_STEER_SYSTEM_STATUS_INDEX 12
#define PRIMARY_HV_VOLTAGE_INDEX 13
#define PRIMARY_HV_CURRENT_INDEX 14
#define PRIMARY_HV_TEMP_INDEX 15
#define PRIMARY_HV_ERRORS_INDEX 16
#define PRIMARY_HV_CAN_FORWARD_INDEX 17
#define PRIMARY_HV_FANS_OVERRIDE_INDEX 18
#define PRIMARY_HV_CAN_FORWARD_STATUS_INDEX 19
#define PRIMARY_HV_FANS_OVERRIDE_STATUS_INDEX 20
#define PRIMARY_HV_FEEDBACKS_STATUS_INDEX 21
#define PRIMARY_HV_IMD_STATUS_INDEX 22
#define PRIMARY_TS_STATUS_INDEX 23
#define PRIMARY_SET_TS_STATUS_DAS_INDEX 24
#define PRIMARY_SET_TS_STATUS_HANDCART_INDEX 25
#define PRIMARY_STEER_STATUS_INDEX 26
#define PRIMARY_SET_CAR_STATUS_INDEX 27
#define PRIMARY_SET_PEDALS_RANGE_INDEX 28
#define PRIMARY_SET_STEERING_ANGLE_RANGE_INDEX 29
#define PRIMARY_CAR_STATUS_INDEX 30
#define PRIMARY_DAS_ERRORS_INDEX 31
#define PRIMARY_LV_CURRENT_INDEX 32
#define PRIMARY_LV_VOLTAGE_INDEX 33
#define PRIMARY_LV_TOTAL_VOLTAGE_INDEX 34
#define PRIMARY_LV_TEMPERATURE_INDEX 35
#define PRIMARY_COOLING_STATUS_INDEX 36
#define PRIMARY_SET_RADIATOR_SPEED_INDEX 37
#define PRIMARY_SET_PUMPS_SPEED_INDEX 38
#define PRIMARY_SET_INVERTER_CONNECTION_STATUS_INDEX 39
#define PRIMARY_INVERTER_CONNECTION_STATUS_INDEX 40
#define PRIMARY_LV_ERRORS_INDEX 41
#define PRIMARY_SHUTDOWN_STATUS_INDEX 42
#define PRIMARY_MARKER_INDEX 43
#define PRIMARY_HV_CELLS_VOLTAGE_INDEX 44
#define PRIMARY_HV_CELLS_TEMP_INDEX 45
#define PRIMARY_HV_CELL_BALANCING_STATUS_INDEX 46
#define PRIMARY_SET_CELL_BALANCING_STATUS_INDEX 47
#define PRIMARY_HANDCART_STATUS_INDEX 48
#define PRIMARY_SPEED_INDEX 49
#define PRIMARY_INV_L_REQUEST_INDEX 50
#define PRIMARY_INV_R_REQUEST_INDEX 51
#define PRIMARY_INV_L_RESPONSE_INDEX 52
#define PRIMARY_INV_R_RESPONSE_INDEX 53
#define PRIMARY_FLASH_CELLBOARD_0_TX_INDEX 54
#define PRIMARY_FLASH_CELLBOARD_0_RX_INDEX 55
#define PRIMARY_FLASH_CELLBOARD_1_TX_INDEX 56
#define PRIMARY_FLASH_CELLBOARD_1_RX_INDEX 57
#define PRIMARY_FLASH_CELLBOARD_2_TX_INDEX 58
#define PRIMARY_FLASH_CELLBOARD_2_RX_INDEX 59
#define PRIMARY_FLASH_CELLBOARD_3_TX_INDEX 60
#define PRIMARY_FLASH_CELLBOARD_3_RX_INDEX 61
#define PRIMARY_FLASH_CELLBOARD_4_TX_INDEX 62
#define PRIMARY_FLASH_CELLBOARD_4_RX_INDEX 63
#define PRIMARY_FLASH_CELLBOARD_5_TX_INDEX 64
#define PRIMARY_FLASH_CELLBOARD_5_RX_INDEX 65
#define PRIMARY_FLASH_BMS_HV_TX_INDEX 66
#define PRIMARY_FLASH_BMS_HV_RX_INDEX 67
#define PRIMARY_FLASH_BMS_LV_TX_INDEX 68
#define PRIMARY_FLASH_BMS_LV_RX_INDEX 69
#define PRIMARY_BRUSA_NLG5_CTL_INDEX 70
#define PRIMARY_BRUSA_ST_INDEX 71
#define PRIMARY_BRUSA_ACT_I_INDEX 72
#define PRIMARY_BRUSA_ACT_II_INDEX 73
#define PRIMARY_BRUSA_TEMP_INDEX 74
#define PRIMARY_BRUSA_ERR_INDEX 75
#define PRIMARY_CONTROL_OUTPUT_INDEX 76
#define PRIMARY_LC_RESET_INDEX 77


#define primary_MESSAGE_COUNT 78

#ifndef CANLIB_DEVICES_STRUCT
#define CANLIB_DEVICES_STRUCT
typedef struct {
    uint16_t id;
    void* message_raw;
    void* message_conversion;
} devices_t;
#endif // CANLIB_DEVICES_STRUCT

typedef devices_t primary_devices[primary_MESSAGE_COUNT];


primary_devices* primary_devices_new();
void primary_devices_free(primary_devices* devices);
void primary_devices_deserialize_from_id(
    primary_devices* devices,
    uint16_t message_id,
    uint8_t* data
#ifdef CANLIB_TIMESTAMP
    , uint64_t timestamp
#endif // CANLIB_TIMESTAMP
);

int primary_message_name_from_id(uint16_t id, char* buffer);
int primary_index_from_id(uint16_t id);
int primary_id_from_index(int index);

typedef enum {
	primary_set_tlm_status_tlm_status_OFF = 0,
	primary_set_tlm_status_tlm_status_ON = 1,
} primary_set_tlm_status_tlm_status;

typedef enum {
	primary_tlm_status_tlm_status_OFF = 0,
	primary_tlm_status_tlm_status_ON = 1,
} primary_tlm_status_tlm_status;

typedef enum {
	primary_hv_can_forward_can_forward_set_OFF = 0,
	primary_hv_can_forward_can_forward_set_ON = 1,
} primary_hv_can_forward_can_forward_set;

typedef enum {
	primary_hv_fans_override_fans_override_OFF = 0,
	primary_hv_fans_override_fans_override_ON = 1,
} primary_hv_fans_override_fans_override;

typedef enum {
	primary_hv_can_forward_status_can_forward_status_OFF = 0,
	primary_hv_can_forward_status_can_forward_status_ON = 1,
} primary_hv_can_forward_status_can_forward_status;

typedef enum {
	primary_hv_fans_override_status_fans_override_OFF = 0,
	primary_hv_fans_override_status_fans_override_ON = 1,
} primary_hv_fans_override_status_fans_override;

typedef enum {
	primary_hv_imd_status_imd_status_IMD_SC = 0,
	primary_hv_imd_status_imd_status_IMD_NORMAL = 1,
	primary_hv_imd_status_imd_status_IMD_UNDER_VOLTAGE = 2,
	primary_hv_imd_status_imd_status_IMD_START_MEASURE = 3,
	primary_hv_imd_status_imd_status_IMD_DEVICE_ERROR = 4,
	primary_hv_imd_status_imd_status_IMD_EARTH_FAULT = 5,
} primary_hv_imd_status_imd_status;

typedef enum {
	primary_ts_status_ts_status_OFF = 0,
	primary_ts_status_ts_status_PRECHARGE = 1,
	primary_ts_status_ts_status_ON = 2,
	primary_ts_status_ts_status_FATAL = 3,
} primary_ts_status_ts_status;

typedef enum {
	primary_set_ts_status_das_ts_status_set_OFF = 0,
	primary_set_ts_status_das_ts_status_set_ON = 1,
} primary_set_ts_status_das_ts_status_set;

typedef enum {
	primary_set_ts_status_handcart_ts_status_set_OFF = 0,
	primary_set_ts_status_handcart_ts_status_set_ON = 1,
} primary_set_ts_status_handcart_ts_status_set;

typedef enum {
	primary_set_car_status_car_status_set_IDLE = 0,
	primary_set_car_status_car_status_set_READY = 1,
	primary_set_car_status_car_status_set_DRIVE = 2,
} primary_set_car_status_car_status_set;

typedef enum {
	primary_set_pedals_range_bound_SET_MAX = 0,
	primary_set_pedals_range_bound_SET_MIN = 1,
} primary_set_pedals_range_bound;

typedef enum {
	primary_set_pedals_range_pedal_ACCELERATOR = 0,
	primary_set_pedals_range_pedal_BRAKE = 1,
} primary_set_pedals_range_pedal;

typedef enum {
	primary_set_steering_angle_range_bound_SET_MAX = 0,
	primary_set_steering_angle_range_bound_SET_MIN = 1,
} primary_set_steering_angle_range_bound;

typedef enum {
	primary_car_status_inverter_l_OFF = 0,
	primary_car_status_inverter_l_IDLE = 1,
	primary_car_status_inverter_l_ON = 2,
} primary_car_status_inverter_l;

typedef enum {
	primary_car_status_inverter_r_OFF = 0,
	primary_car_status_inverter_r_IDLE = 1,
	primary_car_status_inverter_r_ON = 2,
} primary_car_status_inverter_r;

typedef enum {
	primary_car_status_car_status_IDLE = 0,
	primary_car_status_car_status_PRE_SETUP = 1,
	primary_car_status_car_status_TS_ON = 2,
	primary_car_status_car_status_POST_SETUP = 3,
	primary_car_status_car_status_DRIVE = 4,
	primary_car_status_car_status_TEARDOWN = 5,
} primary_car_status_car_status;

typedef enum {
	primary_set_inverter_connection_status_status_OFF = 0,
	primary_set_inverter_connection_status_status_ON = 1,
} primary_set_inverter_connection_status_status;

typedef enum {
	primary_inverter_connection_status_status_OFF = 0,
	primary_inverter_connection_status_status_ON = 1,
} primary_inverter_connection_status_status;

typedef enum {
	primary_hv_cell_balancing_status_balancing_status_OFF = 0,
	primary_hv_cell_balancing_status_balancing_status_ON = 1,
} primary_hv_cell_balancing_status_balancing_status;

typedef enum {
	primary_set_cell_balancing_status_set_balancing_status_OFF = 0,
	primary_set_cell_balancing_status_set_balancing_status_ON = 1,
} primary_set_cell_balancing_status_set_balancing_status;

/**
 * Signals in message BMS_HV_JMP_TO_BLT.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_bms_hv_jmp_to_blt_t;

/**
 * Signals in message BMS_HV_JMP_TO_BLT.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_bms_hv_jmp_to_blt_converted_t;

/**
 * Signals in message BMS_LV_JMP_TO_BLT.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_bms_lv_jmp_to_blt_t;

/**
 * Signals in message BMS_LV_JMP_TO_BLT.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_bms_lv_jmp_to_blt_converted_t;

/**
 * Signals in message STEER_VERSION.
 *
 * periodic message containing current can definitions version
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t component_version;

    /**
     * Range: 0..4294967295 (0..4294967295 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t canlib_build_time;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_steer_version_t;

/**
 * Signals in message STEER_VERSION.
 *
 * periodic message containing current can definitions version
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t component_version;

    /**
     * Range: 0..4294967295 (0..4294967295 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t canlib_build_time;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_steer_version_converted_t;

/**
 * Signals in message DAS_VERSION.
 *
 * periodic message containing current can definitions version
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t component_version;

    /**
     * Range: 0..4294967295 (0..4294967295 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t canlib_build_time;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_das_version_t;

/**
 * Signals in message DAS_VERSION.
 *
 * periodic message containing current can definitions version
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t component_version;

    /**
     * Range: 0..4294967295 (0..4294967295 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t canlib_build_time;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_das_version_converted_t;

/**
 * Signals in message HV_VERSION.
 *
 * periodic message containing current can definitions version
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t component_version;

    /**
     * Range: 0..4294967295 (0..4294967295 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t canlib_build_time;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_version_t;

/**
 * Signals in message HV_VERSION.
 *
 * periodic message containing current can definitions version
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t component_version;

    /**
     * Range: 0..4294967295 (0..4294967295 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t canlib_build_time;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_version_converted_t;

/**
 * Signals in message LV_VERSION.
 *
 * periodic message containing current can definitions version
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t component_version;

    /**
     * Range: 0..4294967295 (0..4294967295 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t canlib_build_time;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_lv_version_t;

/**
 * Signals in message LV_VERSION.
 *
 * periodic message containing current can definitions version
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t component_version;

    /**
     * Range: 0..4294967295 (0..4294967295 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t canlib_build_time;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_lv_version_converted_t;

/**
 * Signals in message TLM_VERSION.
 *
 * periodic message containing current can definitions version
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t component_version;

    /**
     * Range: 0..4294967295 (0..4294967295 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t canlib_build_time;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_tlm_version_t;

/**
 * Signals in message TLM_VERSION.
 *
 * periodic message containing current can definitions version
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t component_version;

    /**
     * Range: 0..4294967295 (0..4294967295 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t canlib_build_time;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_tlm_version_converted_t;

/**
 * Signals in message TIMESTAMP.
 *
 * every second unix encoded time and date used by logging devices to sync
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..4294967295 (0..4294967295 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t timestamp;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_timestamp_t;

/**
 * Signals in message TIMESTAMP.
 *
 * every second unix encoded time and date used by logging devices to sync
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..4294967295 (0..4294967295 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t timestamp;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_timestamp_converted_t;

/**
 * Signals in message AMBIENT_TEMPERATURE.
 *
 * ambient temperature as send from IMU
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (-32768..32767 -)
     * Scale: 1
     * Offset: -32768
     */
    int16_t temp;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_ambient_temperature_t;

/**
 * Signals in message AMBIENT_TEMPERATURE.
 *
 * ambient temperature as send from IMU
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (-32768..32767 -)
     * Scale: 1
     * Offset: -32768
     */
    int16_t temp;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_ambient_temperature_converted_t;

/**
 * Signals in message DATA_LOGGER.
 *
 * data logger message
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..4294967295 (0..4294967295 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t placeholder1;

    /**
     * Range: 0..4294967295 (0..4294967295 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t placeholder2;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_data_logger_t;

/**
 * Signals in message DATA_LOGGER.
 *
 * data logger message
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..4294967295 (0..4294967295 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t placeholder1;

    /**
     * Range: 0..4294967295 (0..4294967295 -)
     * Scale: 1
     * Offset: 0
     */
    uint32_t placeholder2;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_data_logger_converted_t;

/**
 * Signals in message SET_TLM_STATUS.
 *
 * Ask telemetry to turn on/off and send a tuple containing the current{test, driver, map); only once
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_set_tlm_status_tlm_status tlm_status;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_set_tlm_status_t;

/**
 * Signals in message SET_TLM_STATUS.
 *
 * Ask telemetry to turn on/off and send a tuple containing the current{test, driver, map); only once
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_set_tlm_status_tlm_status tlm_status;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_set_tlm_status_converted_t;

/**
 * Signals in message TLM_STATUS.
 *
 * The answer to the steering wheel's message that changes the status of the telemetry
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_tlm_status_tlm_status tlm_status;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_tlm_status_t;

/**
 * Signals in message TLM_STATUS.
 *
 * The answer to the steering wheel's message that changes the status of the telemetry
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_tlm_status_tlm_status tlm_status;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_tlm_status_converted_t;

/**
 * Signals in message STEER_SYSTEM_STATUS.
 *
 * System stats of the raspberry pi inside the steering wheel
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t soc_temp;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_steer_system_status_t;

/**
 * Signals in message STEER_SYSTEM_STATUS.
 *
 * System stats of the raspberry pi inside the steering wheel
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t soc_temp;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_steer_system_status_converted_t;

/**
 * Signals in message HV_VOLTAGE.
 *
 * Pack stats
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (0..460 -)
     * Scale: 0.007019150072480354
     * Offset: 0
     */
    uint16_t pack_voltage;

    /**
     * Range: 0..65535 (0..460 -)
     * Scale: 0.007019150072480354
     * Offset: 0
     */
    uint16_t bus_voltage;

    /**
     * Range: 0..65535 (0..5 -)
     * Scale: 7.629510948348211e-05
     * Offset: 0
     */
    uint16_t max_cell_voltage;

    /**
     * Range: 0..65535 (0..5 -)
     * Scale: 7.629510948348211e-05
     * Offset: 0
     */
    uint16_t min_cell_voltage;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_voltage_t;

/**
 * Signals in message HV_VOLTAGE.
 *
 * Pack stats
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (0..460 -)
     * Scale: 0.007019150072480354
     * Offset: 0
     */
    float pack_voltage;

    /**
     * Range: 0..65535 (0..460 -)
     * Scale: 0.007019150072480354
     * Offset: 0
     */
    float bus_voltage;

    /**
     * Range: 0..65535 (0..5 -)
     * Scale: 7.629510948348211e-05
     * Offset: 0
     */
    float max_cell_voltage;

    /**
     * Range: 0..65535 (0..5 -)
     * Scale: 7.629510948348211e-05
     * Offset: 0
     */
    float min_cell_voltage;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_voltage_converted_t;

/**
 * Signals in message HV_CURRENT.
 *
 * Current and power supplied by the pack, energy and state of charge of the pack
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (-10..200 -)
     * Scale: 0.0032043945983062485
     * Offset: -10
     */
    uint16_t current;

    /**
     * Range: 0..65535 (0..100 -)
     * Scale: 0.0015259021896696422
     * Offset: 0
     */
    uint16_t power;

    /**
     * Range: 0..65535 (0..7000 -)
     * Scale: 0.10681315327687495
     * Offset: 0
     */
    uint16_t energy;

    /**
     * Range: 0..255 (0..100 -)
     * Scale: 0.39215686274509803
     * Offset: 0
     */
    uint8_t soc;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_current_t;

/**
 * Signals in message HV_CURRENT.
 *
 * Current and power supplied by the pack, energy and state of charge of the pack
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (-10..200 -)
     * Scale: 0.0032043945983062485
     * Offset: -10
     */
    float current;

    /**
     * Range: 0..65535 (0..100 -)
     * Scale: 0.0015259021896696422
     * Offset: 0
     */
    float power;

    /**
     * Range: 0..65535 (0..7000 -)
     * Scale: 0.10681315327687495
     * Offset: 0
     */
    float energy;

    /**
     * Range: 0..255 (0..100 -)
     * Scale: 0.39215686274509803
     * Offset: 0
     */
    float soc;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_current_converted_t;

/**
 * Signals in message HV_TEMP.
 *
 * Cell temperatures
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..255 (-20..80 -)
     * Scale: 0.39215686274509803
     * Offset: -20
     */
    uint8_t average_temp;

    /**
     * Range: 0..255 (-20..80 -)
     * Scale: 0.39215686274509803
     * Offset: -20
     */
    uint8_t max_temp;

    /**
     * Range: 0..255 (-20..80 -)
     * Scale: 0.39215686274509803
     * Offset: -20
     */
    uint8_t min_temp;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_temp_t;

/**
 * Signals in message HV_TEMP.
 *
 * Cell temperatures
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..255 (-20..80 -)
     * Scale: 0.39215686274509803
     * Offset: -20
     */
    float average_temp;

    /**
     * Range: 0..255 (-20..80 -)
     * Scale: 0.39215686274509803
     * Offset: -20
     */
    float max_temp;

    /**
     * Range: 0..255 (-20..80 -)
     * Scale: 0.39215686274509803
     * Offset: -20
     */
    float min_temp;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_temp_converted_t;

/**
 * Signals in message HV_ERRORS.
 *
 * Battery-related errors
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t warnings_cell_low_voltage;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t warnings_cell_under_voltage;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t warnings_cell_over_voltage;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t warnings_cell_high_temperature;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t warnings_cell_over_temperature;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t warnings_over_current;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t warnings_can;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t warnings_int_voltage_mismatch;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t warnings_cellboard_comm;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t warnings_cellboard_internal;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t warnings_feedback;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t warnings_feedback_circuitry;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t warnings_eeprom_comm;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t warnings_eeprom_write;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_cell_low_voltage;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_cell_under_voltage;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_cell_over_voltage;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_cell_high_temperature;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_cell_over_temperature;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_over_current;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_can;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_int_voltage_mismatch;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_cellboard_comm;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_cellboard_internal;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_feedback;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_feedback_circuitry;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_eeprom_comm;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_eeprom_write;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_errors_t;

/**
 * Signals in message HV_ERRORS.
 *
 * Battery-related errors
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int warnings_cell_low_voltage : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int warnings_cell_under_voltage : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int warnings_cell_over_voltage : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int warnings_cell_high_temperature : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int warnings_cell_over_temperature : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int warnings_over_current : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int warnings_can : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int warnings_int_voltage_mismatch : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int warnings_cellboard_comm : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int warnings_cellboard_internal : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int warnings_feedback : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int warnings_feedback_circuitry : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int warnings_eeprom_comm : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int warnings_eeprom_write : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_cell_low_voltage : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_cell_under_voltage : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_cell_over_voltage : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_cell_high_temperature : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_cell_over_temperature : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_over_current : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_can : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_int_voltage_mismatch : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_cellboard_comm : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_cellboard_internal : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_feedback : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_feedback_circuitry : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_eeprom_comm : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_eeprom_write : 1;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_errors_converted_t;

/**
 * Signals in message HV_CAN_FORWARD.
 *
 * Enable/disable can forwarding to internal bms network
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_hv_can_forward_can_forward_set can_forward_set;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_can_forward_t;

/**
 * Signals in message HV_CAN_FORWARD.
 *
 * Enable/disable can forwarding to internal bms network
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_hv_can_forward_can_forward_set can_forward_set;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_can_forward_converted_t;

/**
 * Signals in message HV_FANS_OVERRIDE.
 *
 * override fans speed
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_hv_fans_override_fans_override fans_override;

    /**
     * Range: 0..65535 (0..1 -)
     * Scale: 1.5259021896696422e-05
     * Offset: 0
     */
    uint16_t fans_speed;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_fans_override_t;

/**
 * Signals in message HV_FANS_OVERRIDE.
 *
 * override fans speed
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_hv_fans_override_fans_override fans_override;

    /**
     * Range: 0..65535 (0..1 -)
     * Scale: 1.5259021896696422e-05
     * Offset: 0
     */
    float fans_speed;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_fans_override_converted_t;

/**
 * Signals in message HV_CAN_FORWARD_STATUS.
 *
 * Status of can forwarding to internal bms network
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_hv_can_forward_status_can_forward_status can_forward_status;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_can_forward_status_t;

/**
 * Signals in message HV_CAN_FORWARD_STATUS.
 *
 * Status of can forwarding to internal bms network
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_hv_can_forward_status_can_forward_status can_forward_status;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_can_forward_status_converted_t;

/**
 * Signals in message HV_FANS_OVERRIDE_STATUS.
 *
 * Status of fans override
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_hv_fans_override_status_fans_override fans_override;

    /**
     * Range: 0..65535 (0..1 -)
     * Scale: 1.5259021896696422e-05
     * Offset: 0
     */
    uint16_t fans_speed;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_fans_override_status_t;

/**
 * Signals in message HV_FANS_OVERRIDE_STATUS.
 *
 * Status of fans override
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_hv_fans_override_status_fans_override fans_override;

    /**
     * Range: 0..65535 (0..1 -)
     * Scale: 1.5259021896696422e-05
     * Offset: 0
     */
    float fans_speed;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_fans_override_status_converted_t;

/**
 * Signals in message HV_FEEDBACKS_STATUS.
 *
 * Errors on the feedbacks checks
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t feedbacks_status_feedback_tsal_green_fault;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t feedbacks_status_feedback_imd_latched;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t feedbacks_status_feedback_tsal_green_fault_latched;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t feedbacks_status_feedback_bms_latched;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t feedbacks_status_feedback_ext_latched;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t feedbacks_status_feedback_tsal_green;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t feedbacks_status_feedback_ts_over_60v_status;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t feedbacks_status_feedback_airn_status;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t feedbacks_status_feedback_airp_status;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t feedbacks_status_feedback_airp_gate;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t feedbacks_status_feedback_airn_gate;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t feedbacks_status_feedback_precharge_status;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t feedbacks_status_feedback_tsp_over_60v_status;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t feedbacks_status_feedback_check_mux;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t feedbacks_status_feedback_sd_in;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t feedbacks_status_feedback_sd_out;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t feedbacks_status_feedback_relay_sd;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t feedbacks_status_feedback_imd_fault;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t feedbacks_status_feedback_sd_end;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t is_circuitry_error_feedback_tsal_green_fault;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t is_circuitry_error_feedback_imd_latched;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t is_circuitry_error_feedback_tsal_green_fault_latched;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t is_circuitry_error_feedback_bms_latched;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t is_circuitry_error_feedback_ext_latched;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t is_circuitry_error_feedback_tsal_green;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t is_circuitry_error_feedback_ts_over_60v_status;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t is_circuitry_error_feedback_airn_status;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t is_circuitry_error_feedback_airp_status;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t is_circuitry_error_feedback_airp_gate;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t is_circuitry_error_feedback_airn_gate;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t is_circuitry_error_feedback_precharge_status;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t is_circuitry_error_feedback_tsp_over_60v_status;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t is_circuitry_error_feedback_check_mux;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t is_circuitry_error_feedback_sd_in;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t is_circuitry_error_feedback_sd_out;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t is_circuitry_error_feedback_relay_sd;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t is_circuitry_error_feedback_imd_fault;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t is_circuitry_error_feedback_sd_end;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_feedbacks_status_t;

/**
 * Signals in message HV_FEEDBACKS_STATUS.
 *
 * Errors on the feedbacks checks
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int feedbacks_status_feedback_tsal_green_fault : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int feedbacks_status_feedback_imd_latched : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int feedbacks_status_feedback_tsal_green_fault_latched : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int feedbacks_status_feedback_bms_latched : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int feedbacks_status_feedback_ext_latched : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int feedbacks_status_feedback_tsal_green : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int feedbacks_status_feedback_ts_over_60v_status : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int feedbacks_status_feedback_airn_status : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int feedbacks_status_feedback_airp_status : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int feedbacks_status_feedback_airp_gate : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int feedbacks_status_feedback_airn_gate : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int feedbacks_status_feedback_precharge_status : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int feedbacks_status_feedback_tsp_over_60v_status : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int feedbacks_status_feedback_check_mux : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int feedbacks_status_feedback_sd_in : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int feedbacks_status_feedback_sd_out : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int feedbacks_status_feedback_relay_sd : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int feedbacks_status_feedback_imd_fault : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int feedbacks_status_feedback_sd_end : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int is_circuitry_error_feedback_tsal_green_fault : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int is_circuitry_error_feedback_imd_latched : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int is_circuitry_error_feedback_tsal_green_fault_latched : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int is_circuitry_error_feedback_bms_latched : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int is_circuitry_error_feedback_ext_latched : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int is_circuitry_error_feedback_tsal_green : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int is_circuitry_error_feedback_ts_over_60v_status : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int is_circuitry_error_feedback_airn_status : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int is_circuitry_error_feedback_airp_status : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int is_circuitry_error_feedback_airp_gate : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int is_circuitry_error_feedback_airn_gate : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int is_circuitry_error_feedback_precharge_status : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int is_circuitry_error_feedback_tsp_over_60v_status : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int is_circuitry_error_feedback_check_mux : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int is_circuitry_error_feedback_sd_in : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int is_circuitry_error_feedback_sd_out : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int is_circuitry_error_feedback_relay_sd : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int is_circuitry_error_feedback_imd_fault : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int is_circuitry_error_feedback_sd_end : 1;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_feedbacks_status_converted_t;

/**
 * Signals in message HV_IMD_STATUS.
 *
 * Status of fans override
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t imd_fault;

    /**
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    primary_hv_imd_status_imd_status imd_status;

    /**
     * Range: 0..4294967295 (-2147483648..2147483647 -)
     * Scale: 1
     * Offset: -2147483648
     */
    int32_t imd_info;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_imd_status_t;

/**
 * Signals in message HV_IMD_STATUS.
 *
 * Status of fans override
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int imd_fault : 1;

    /**
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    primary_hv_imd_status_imd_status imd_status;

    /**
     * Range: 0..4294967295 (-2147483648..2147483647 -)
     * Scale: 1
     * Offset: -2147483648
     */
    int32_t imd_info;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_imd_status_converted_t;

/**
 * Signals in message TS_STATUS.
 *
 * BMS status
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    primary_ts_status_ts_status ts_status;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_ts_status_t;

/**
 * Signals in message TS_STATUS.
 *
 * BMS status
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    primary_ts_status_ts_status ts_status;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_ts_status_converted_t;

/**
 * Signals in message SET_TS_STATUS_DAS.
 *
 * Requests a TS status; only once
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_set_ts_status_das_ts_status_set ts_status_set;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_set_ts_status_das_t;

/**
 * Signals in message SET_TS_STATUS_DAS.
 *
 * Requests a TS status; only once
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_set_ts_status_das_ts_status_set ts_status_set;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_set_ts_status_das_converted_t;

/**
 * Signals in message SET_TS_STATUS_HANDCART.
 *
 * Requests a TS status; only once
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_set_ts_status_handcart_ts_status_set ts_status_set;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_set_ts_status_handcart_t;

/**
 * Signals in message SET_TS_STATUS_HANDCART.
 *
 * Requests a TS status; only once
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_set_ts_status_handcart_ts_status_set ts_status_set;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_set_ts_status_handcart_converted_t;

/**
 * Signals in message STEER_STATUS.
 *
 * Send update of the tuneable values from the steering wheel
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..15 (-0.5..1 -)
     * Scale: 0.1
     * Offset: -0.5
     */
    uint8_t map_pw;

    /**
     * Range: 0..15 (0..1 -)
     * Scale: 0.06666666666666667
     * Offset: 0
     */
    uint8_t map_sc;

    /**
     * Range: 0..15 (0..1 -)
     * Scale: 0.06666666666666667
     * Offset: 0
     */
    uint8_t map_tv;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_steer_status_t;

/**
 * Signals in message STEER_STATUS.
 *
 * Send update of the tuneable values from the steering wheel
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..15 (-0.5..1 -)
     * Scale: 0.1
     * Offset: -0.5
     */
    float map_pw;

    /**
     * Range: 0..15 (0..1 -)
     * Scale: 0.06666666666666667
     * Offset: 0
     */
    float map_sc;

    /**
     * Range: 0..15 (0..1 -)
     * Scale: 0.06666666666666667
     * Offset: 0
     */
    float map_tv;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_steer_status_converted_t;

/**
 * Signals in message SET_CAR_STATUS.
 *
 * Ask to DAS to change car status; only once
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    primary_set_car_status_car_status_set car_status_set;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_set_car_status_t;

/**
 * Signals in message SET_CAR_STATUS.
 *
 * Ask to DAS to change car status; only once
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    primary_set_car_status_car_status_set car_status_set;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_set_car_status_converted_t;

/**
 * Signals in message SET_PEDALS_RANGE.
 *
 * Ask to calibrate pedals by specifying which pedal to calibrate and if the value is max or min
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_set_pedals_range_bound bound;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_set_pedals_range_pedal pedal;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_set_pedals_range_t;

/**
 * Signals in message SET_PEDALS_RANGE.
 *
 * Ask to calibrate pedals by specifying which pedal to calibrate and if the value is max or min
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_set_pedals_range_bound bound;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_set_pedals_range_pedal pedal;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_set_pedals_range_converted_t;

/**
 * Signals in message SET_STEERING_ANGLE_RANGE.
 *
 * Ask to calibrate steering encoder by specifying if the value is max or min
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_set_steering_angle_range_bound bound;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_set_steering_angle_range_t;

/**
 * Signals in message SET_STEERING_ANGLE_RANGE.
 *
 * Ask to calibrate steering encoder by specifying if the value is max or min
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_set_steering_angle_range_bound bound;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_set_steering_angle_range_converted_t;

/**
 * Signals in message CAR_STATUS.
 *
 * Car status, all states managed by the DAS will be send (car status, inverters status)
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    primary_car_status_inverter_l inverter_l;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    primary_car_status_inverter_r inverter_r;

    /**
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    primary_car_status_car_status car_status;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_car_status_t;

/**
 * Signals in message CAR_STATUS.
 *
 * Car status, all states managed by the DAS will be send (car status, inverters status)
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    primary_car_status_inverter_l inverter_l;

    /**
     * Range: 0..3 (0..3 -)
     * Scale: 1
     * Offset: 0
     */
    primary_car_status_inverter_r inverter_r;

    /**
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    primary_car_status_car_status car_status;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_car_status_converted_t;

/**
 * Signals in message DAS_ERRORS.
 *
 * DAS errors messages
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t das_error_pedal_adc;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t das_error_pedal_implausibility;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t das_error_imu_tout;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t das_error_irts_tout;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t das_error_ts_tout;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t das_error_invl_tout;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t das_error_invr_tout;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t das_error_steer_tout;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t das_error_fsm;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_das_errors_t;

/**
 * Signals in message DAS_ERRORS.
 *
 * DAS errors messages
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int das_error_pedal_adc : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int das_error_pedal_implausibility : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int das_error_imu_tout : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int das_error_irts_tout : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int das_error_ts_tout : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int das_error_invl_tout : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int das_error_invr_tout : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int das_error_steer_tout : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int das_error_fsm : 1;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_das_errors_converted_t;

/**
 * Signals in message LV_CURRENT.
 *
 * Current of LV battery pack: total current taken from the battery itself
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (-10..50 -)
     * Scale: 0.0009155413138017853
     * Offset: -10
     */
    uint16_t current;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_lv_current_t;

/**
 * Signals in message LV_CURRENT.
 *
 * Current of LV battery pack: total current taken from the battery itself
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (-10..50 -)
     * Scale: 0.0009155413138017853
     * Offset: -10
     */
    float current;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_lv_current_converted_t;

/**
 * Signals in message LV_VOLTAGE.
 *
 * Voltages of LV battery pack: 4x single cell voltage 8bit [3.3,4.2]V 0.005mV/bit (no additional info, 0x000 is 3V 0xFFFF is 4.2V)
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (0..5 -)
     * Scale: 7.629510948348211e-05
     * Offset: 0
     */
    uint16_t voltage_1;

    /**
     * Range: 0..65535 (0..5 -)
     * Scale: 7.629510948348211e-05
     * Offset: 0
     */
    uint16_t voltage_2;

    /**
     * Range: 0..65535 (0..5 -)
     * Scale: 7.629510948348211e-05
     * Offset: 0
     */
    uint16_t voltage_3;

    /**
     * Range: 0..65535 (0..5 -)
     * Scale: 7.629510948348211e-05
     * Offset: 0
     */
    uint16_t voltage_4;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_lv_voltage_t;

/**
 * Signals in message LV_VOLTAGE.
 *
 * Voltages of LV battery pack: 4x single cell voltage 8bit [3.3,4.2]V 0.005mV/bit (no additional info, 0x000 is 3V 0xFFFF is 4.2V)
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (0..5 -)
     * Scale: 7.629510948348211e-05
     * Offset: 0
     */
    float voltage_1;

    /**
     * Range: 0..65535 (0..5 -)
     * Scale: 7.629510948348211e-05
     * Offset: 0
     */
    float voltage_2;

    /**
     * Range: 0..65535 (0..5 -)
     * Scale: 7.629510948348211e-05
     * Offset: 0
     */
    float voltage_3;

    /**
     * Range: 0..65535 (0..5 -)
     * Scale: 7.629510948348211e-05
     * Offset: 0
     */
    float voltage_4;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_lv_voltage_converted_t;

/**
 * Signals in message LV_TOTAL_VOLTAGE.
 *
 * Voltage of LV battery pack: total voltage 16 bit [12,17.2]V (0x0000 under_voltage,0xFFFF over_voltage
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..262143 (0..16 -)
     * Scale: 6.103538908153183e-05
     * Offset: 0
     */
    uint32_t total_voltage;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_lv_total_voltage_t;

/**
 * Signals in message LV_TOTAL_VOLTAGE.
 *
 * Voltage of LV battery pack: total voltage 16 bit [12,17.2]V (0x0000 under_voltage,0xFFFF over_voltage
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..262143 (0..16 -)
     * Scale: 6.103538908153183e-05
     * Offset: 0
     */
    float total_voltage;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_lv_total_voltage_converted_t;

/**
 * Signals in message LV_TEMPERATURE.
 *
 * Temperature of LV battery pack (two sensors),[-20,80] Celsius. Temperature of dcdc12V and dcdc24V converter
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (-20..80 -)
     * Scale: 0.0015259021896696422
     * Offset: -20
     */
    uint16_t bp_temperature_1;

    /**
     * Range: 0..65535 (-20..80 -)
     * Scale: 0.0015259021896696422
     * Offset: -20
     */
    uint16_t bp_temperature_2;

    /**
     * Range: 0..65535 (-20..80 -)
     * Scale: 0.0015259021896696422
     * Offset: -20
     */
    uint16_t dcdc12_temperature;

    /**
     * Range: 0..65535 (-20..80 -)
     * Scale: 0.0015259021896696422
     * Offset: -20
     */
    uint16_t dcdc24_temperature;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_lv_temperature_t;

/**
 * Signals in message LV_TEMPERATURE.
 *
 * Temperature of LV battery pack (two sensors),[-20,80] Celsius. Temperature of dcdc12V and dcdc24V converter
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (-20..80 -)
     * Scale: 0.0015259021896696422
     * Offset: -20
     */
    float bp_temperature_1;

    /**
     * Range: 0..65535 (-20..80 -)
     * Scale: 0.0015259021896696422
     * Offset: -20
     */
    float bp_temperature_2;

    /**
     * Range: 0..65535 (-20..80 -)
     * Scale: 0.0015259021896696422
     * Offset: -20
     */
    float dcdc12_temperature;

    /**
     * Range: 0..65535 (-20..80 -)
     * Scale: 0.0015259021896696422
     * Offset: -20
     */
    float dcdc24_temperature;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_lv_temperature_converted_t;

/**
 * Signals in message COOLING_STATUS.
 *
 * Percentage value from 0% to 100% of radiator fans and pumps speed, 8bit
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (-1..1 -)
     * Scale: 3.0518043793392844e-05
     * Offset: -1
     */
    uint16_t radiators_speed;

    /**
     * Range: 0..65535 (-1..1 -)
     * Scale: 3.0518043793392844e-05
     * Offset: -1
     */
    uint16_t pumps_speed;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_cooling_status_t;

/**
 * Signals in message COOLING_STATUS.
 *
 * Percentage value from 0% to 100% of radiator fans and pumps speed, 8bit
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (-1..1 -)
     * Scale: 3.0518043793392844e-05
     * Offset: -1
     */
    float radiators_speed;

    /**
     * Range: 0..65535 (-1..1 -)
     * Scale: 3.0518043793392844e-05
     * Offset: -1
     */
    float pumps_speed;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_cooling_status_converted_t;

/**
 * Signals in message SET_RADIATOR_SPEED.
 *
 * Set both radiators speed
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (-1..1 -)
     * Scale: 3.0518043793392844e-05
     * Offset: -1
     */
    uint16_t radiators_speed;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_set_radiator_speed_t;

/**
 * Signals in message SET_RADIATOR_SPEED.
 *
 * Set both radiators speed
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (-1..1 -)
     * Scale: 3.0518043793392844e-05
     * Offset: -1
     */
    float radiators_speed;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_set_radiator_speed_converted_t;

/**
 * Signals in message SET_PUMPS_SPEED.
 *
 * Set both pumps speed
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (-1..1 -)
     * Scale: 3.0518043793392844e-05
     * Offset: -1
     */
    uint16_t pumps_speed;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_set_pumps_speed_t;

/**
 * Signals in message SET_PUMPS_SPEED.
 *
 * Set both pumps speed
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (-1..1 -)
     * Scale: 3.0518043793392844e-05
     * Offset: -1
     */
    float pumps_speed;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_set_pumps_speed_converted_t;

/**
 * Signals in message SET_INVERTER_CONNECTION_STATUS.
 *
 * Set the status of the inverter inputs RFE and RUN
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_set_inverter_connection_status_status status;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_set_inverter_connection_status_t;

/**
 * Signals in message SET_INVERTER_CONNECTION_STATUS.
 *
 * Set the status of the inverter inputs RFE and RUN
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_set_inverter_connection_status_status status;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_set_inverter_connection_status_converted_t;

/**
 * Signals in message INVERTER_CONNECTION_STATUS.
 *
 * Inverter status
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_connection_status_status status;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_inverter_connection_status_t;

/**
 * Signals in message INVERTER_CONNECTION_STATUS.
 *
 * Inverter status
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_inverter_connection_status_status status;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_inverter_connection_status_converted_t;

/**
 * Signals in message LV_ERRORS.
 *
 * LV Battery-related errors
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t warnings_cell_undervoltage;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t warnings_cell_overvoltage;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t warnings_open_wire;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t warnings_can;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t warnings_spi;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t warnings_over_current;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t warnings_dcdc12_under_temperature;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t warnings_dcdc12_over_temperature;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t warnings_dcdc24_under_temperature;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t warnings_dcdc24_over_temperature;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t warnings_cell_under_temperature;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t warnings_cell_over_temperature;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t warnings_relay;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t warnings_ltc6810;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t warnings_voltages_not_ready;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t warnings_mcp23017;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t warnings_radiator;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t warnings_fan;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t warnings_pump;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t warnings_adc_init;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t warnings_dcdc12;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t warnings_dcdc24;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_cell_undervoltage;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_cell_overvoltage;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_open_wire;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_can;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_spi;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_over_current;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_dcdc12_under_temperature;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_dcdc12_over_temperature;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_dcdc24_under_temperature;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_dcdc24_over_temperature;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_cell_under_temperature;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_cell_over_temperature;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_relay;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_ltc6810;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_voltages_not_ready;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_mcp23017;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_radiator;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_fan;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_pump;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_adc_init;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_dcdc12;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t errors_dcdc24;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_lv_errors_t;

/**
 * Signals in message LV_ERRORS.
 *
 * LV Battery-related errors
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int warnings_cell_undervoltage : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int warnings_cell_overvoltage : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int warnings_open_wire : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int warnings_can : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int warnings_spi : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int warnings_over_current : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int warnings_dcdc12_under_temperature : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int warnings_dcdc12_over_temperature : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int warnings_dcdc24_under_temperature : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int warnings_dcdc24_over_temperature : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int warnings_cell_under_temperature : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int warnings_cell_over_temperature : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int warnings_relay : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int warnings_ltc6810 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int warnings_voltages_not_ready : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int warnings_mcp23017 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int warnings_radiator : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int warnings_fan : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int warnings_pump : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int warnings_adc_init : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int warnings_dcdc12 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int warnings_dcdc24 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_cell_undervoltage : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_cell_overvoltage : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_open_wire : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_can : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_spi : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_over_current : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_dcdc12_under_temperature : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_dcdc12_over_temperature : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_dcdc24_under_temperature : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_dcdc24_over_temperature : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_cell_under_temperature : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_cell_over_temperature : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_relay : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_ltc6810 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_voltages_not_ready : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_mcp23017 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_radiator : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_fan : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_pump : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_adc_init : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_dcdc12 : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int errors_dcdc24 : 1;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_lv_errors_converted_t;

/**
 * Signals in message SHUTDOWN_STATUS.
 *
 * Shutdown status
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t input;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t output;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_shutdown_status_t;

/**
 * Signals in message SHUTDOWN_STATUS.
 *
 * Shutdown status
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int input : 1;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int output : 1;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_shutdown_status_converted_t;

/**
 * Signals in message MARKER.
 *
 * Send a marker to telemetry
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_marker_t;

/**
 * Signals in message MARKER.
 *
 * Send a marker to telemetry
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_marker_converted_t;

/**
 * Signals in message HV_CELLS_VOLTAGE.
 *
 * Voltages for each cell
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t start_index;

    /**
     * Range: 0..65535 (0..5 -)
     * Scale: 7.629510948348211e-05
     * Offset: 0
     */
    uint16_t voltage_0;

    /**
     * Range: 0..65535 (0..5 -)
     * Scale: 7.629510948348211e-05
     * Offset: 0
     */
    uint16_t voltage_1;

    /**
     * Range: 0..65535 (0..5 -)
     * Scale: 7.629510948348211e-05
     * Offset: 0
     */
    uint16_t voltage_2;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_cells_voltage_t;

/**
 * Signals in message HV_CELLS_VOLTAGE.
 *
 * Voltages for each cell
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t start_index;

    /**
     * Range: 0..65535 (0..5 -)
     * Scale: 7.629510948348211e-05
     * Offset: 0
     */
    float voltage_0;

    /**
     * Range: 0..65535 (0..5 -)
     * Scale: 7.629510948348211e-05
     * Offset: 0
     */
    float voltage_1;

    /**
     * Range: 0..65535 (0..5 -)
     * Scale: 7.629510948348211e-05
     * Offset: 0
     */
    float voltage_2;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_cells_voltage_converted_t;

/**
 * Signals in message HV_CELLS_TEMP.
 *
 * Cell temperatures
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t start_index;

    /**
     * Range: 0..255 (-20..80 -)
     * Scale: 0.39215686274509803
     * Offset: -20
     */
    uint8_t temp_0;

    /**
     * Range: 0..255 (-20..80 -)
     * Scale: 0.39215686274509803
     * Offset: -20
     */
    uint8_t temp_1;

    /**
     * Range: 0..255 (-20..80 -)
     * Scale: 0.39215686274509803
     * Offset: -20
     */
    uint8_t temp_2;

    /**
     * Range: 0..255 (-20..80 -)
     * Scale: 0.39215686274509803
     * Offset: -20
     */
    uint8_t temp_3;

    /**
     * Range: 0..255 (-20..80 -)
     * Scale: 0.39215686274509803
     * Offset: -20
     */
    uint8_t temp_4;

    /**
     * Range: 0..255 (-20..80 -)
     * Scale: 0.39215686274509803
     * Offset: -20
     */
    uint8_t temp_5;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_cells_temp_t;

/**
 * Signals in message HV_CELLS_TEMP.
 *
 * Cell temperatures
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t start_index;

    /**
     * Range: 0..255 (-20..80 -)
     * Scale: 0.39215686274509803
     * Offset: -20
     */
    float temp_0;

    /**
     * Range: 0..255 (-20..80 -)
     * Scale: 0.39215686274509803
     * Offset: -20
     */
    float temp_1;

    /**
     * Range: 0..255 (-20..80 -)
     * Scale: 0.39215686274509803
     * Offset: -20
     */
    float temp_2;

    /**
     * Range: 0..255 (-20..80 -)
     * Scale: 0.39215686274509803
     * Offset: -20
     */
    float temp_3;

    /**
     * Range: 0..255 (-20..80 -)
     * Scale: 0.39215686274509803
     * Offset: -20
     */
    float temp_4;

    /**
     * Range: 0..255 (-20..80 -)
     * Scale: 0.39215686274509803
     * Offset: -20
     */
    float temp_5;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_cells_temp_converted_t;

/**
 * Signals in message HV_CELL_BALANCING_STATUS.
 *
 * Cell balancing status
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_hv_cell_balancing_status_balancing_status balancing_status;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_cell_balancing_status_t;

/**
 * Signals in message HV_CELL_BALANCING_STATUS.
 *
 * Cell balancing status
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_hv_cell_balancing_status_balancing_status balancing_status;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_hv_cell_balancing_status_converted_t;

/**
 * Signals in message SET_CELL_BALANCING_STATUS.
 *
 * Set cell balancing status; only once
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_set_cell_balancing_status_set_balancing_status set_balancing_status;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_set_cell_balancing_status_t;

/**
 * Signals in message SET_CELL_BALANCING_STATUS.
 *
 * Set cell balancing status; only once
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    primary_set_cell_balancing_status_set_balancing_status set_balancing_status;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_set_cell_balancing_status_converted_t;

/**
 * Signals in message HANDCART_STATUS.
 *
 * Sends updates on the presence of the handcart
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t connected;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_handcart_status_t;

/**
 * Signals in message HANDCART_STATUS.
 *
 * Sends updates on the presence of the handcart
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    unsigned int connected : 1;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_handcart_status_converted_t;

/**
 * Signals in message SPEED.
 *
 * Encoder and inverter speed in rad/sec
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (-200..200 -)
     * Scale: 0.006103608758678569
     * Offset: -200
     */
    uint16_t encoder_r;

    /**
     * Range: 0..65535 (-200..200 -)
     * Scale: 0.006103608758678569
     * Offset: -200
     */
    uint16_t encoder_l;

    /**
     * Range: 0..65535 (-200..200 -)
     * Scale: 0.006103608758678569
     * Offset: -200
     */
    uint16_t inverter_r;

    /**
     * Range: 0..65535 (-200..200 -)
     * Scale: 0.006103608758678569
     * Offset: -200
     */
    uint16_t inverter_l;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_speed_t;

/**
 * Signals in message SPEED.
 *
 * Encoder and inverter speed in rad/sec
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (-200..200 -)
     * Scale: 0.006103608758678569
     * Offset: -200
     */
    float encoder_r;

    /**
     * Range: 0..65535 (-200..200 -)
     * Scale: 0.006103608758678569
     * Offset: -200
     */
    float encoder_l;

    /**
     * Range: 0..65535 (-200..200 -)
     * Scale: 0.006103608758678569
     * Offset: -200
     */
    float inverter_r;

    /**
     * Range: 0..65535 (-200..200 -)
     * Scale: 0.006103608758678569
     * Offset: -200
     */
    float inverter_l;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_speed_converted_t;

/**
 * Signals in message INV_L_REQUEST.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_0;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_1;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_2;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_3;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_4;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_5;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_6;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_7;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_inv_l_request_t;

/**
 * Signals in message INV_L_REQUEST.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_0;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_1;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_2;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_3;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_4;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_5;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_6;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_7;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_inv_l_request_converted_t;

/**
 * Signals in message INV_R_REQUEST.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_0;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_1;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_2;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_3;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_4;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_5;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_6;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_7;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_inv_r_request_t;

/**
 * Signals in message INV_R_REQUEST.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_0;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_1;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_2;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_3;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_4;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_5;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_6;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_7;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_inv_r_request_converted_t;

/**
 * Signals in message INV_L_RESPONSE.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t reg_id;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_0;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_1;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_2;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_3;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_4;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_5;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_6;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_inv_l_response_t;

/**
 * Signals in message INV_L_RESPONSE.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t reg_id;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_0;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_1;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_2;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_3;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_4;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_5;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_6;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_inv_l_response_converted_t;

/**
 * Signals in message INV_R_RESPONSE.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t reg_id;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_0;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_1;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_2;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_3;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_4;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_5;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_6;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_inv_r_response_t;

/**
 * Signals in message INV_R_RESPONSE.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t reg_id;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_0;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_1;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_2;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_3;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_4;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_5;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t data_6;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_inv_r_response_converted_t;

/**
 * Signals in message FLASH_CELLBOARD_0_TX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_flash_cellboard_0_tx_t;

/**
 * Signals in message FLASH_CELLBOARD_0_TX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_flash_cellboard_0_tx_converted_t;

/**
 * Signals in message FLASH_CELLBOARD_0_RX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_flash_cellboard_0_rx_t;

/**
 * Signals in message FLASH_CELLBOARD_0_RX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_flash_cellboard_0_rx_converted_t;

/**
 * Signals in message FLASH_CELLBOARD_1_TX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_flash_cellboard_1_tx_t;

/**
 * Signals in message FLASH_CELLBOARD_1_TX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_flash_cellboard_1_tx_converted_t;

/**
 * Signals in message FLASH_CELLBOARD_1_RX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_flash_cellboard_1_rx_t;

/**
 * Signals in message FLASH_CELLBOARD_1_RX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_flash_cellboard_1_rx_converted_t;

/**
 * Signals in message FLASH_CELLBOARD_2_TX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_flash_cellboard_2_tx_t;

/**
 * Signals in message FLASH_CELLBOARD_2_TX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_flash_cellboard_2_tx_converted_t;

/**
 * Signals in message FLASH_CELLBOARD_2_RX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_flash_cellboard_2_rx_t;

/**
 * Signals in message FLASH_CELLBOARD_2_RX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_flash_cellboard_2_rx_converted_t;

/**
 * Signals in message FLASH_CELLBOARD_3_TX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_flash_cellboard_3_tx_t;

/**
 * Signals in message FLASH_CELLBOARD_3_TX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_flash_cellboard_3_tx_converted_t;

/**
 * Signals in message FLASH_CELLBOARD_3_RX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_flash_cellboard_3_rx_t;

/**
 * Signals in message FLASH_CELLBOARD_3_RX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_flash_cellboard_3_rx_converted_t;

/**
 * Signals in message FLASH_CELLBOARD_4_TX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_flash_cellboard_4_tx_t;

/**
 * Signals in message FLASH_CELLBOARD_4_TX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_flash_cellboard_4_tx_converted_t;

/**
 * Signals in message FLASH_CELLBOARD_4_RX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_flash_cellboard_4_rx_t;

/**
 * Signals in message FLASH_CELLBOARD_4_RX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_flash_cellboard_4_rx_converted_t;

/**
 * Signals in message FLASH_CELLBOARD_5_TX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_flash_cellboard_5_tx_t;

/**
 * Signals in message FLASH_CELLBOARD_5_TX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_flash_cellboard_5_tx_converted_t;

/**
 * Signals in message FLASH_CELLBOARD_5_RX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_flash_cellboard_5_rx_t;

/**
 * Signals in message FLASH_CELLBOARD_5_RX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_flash_cellboard_5_rx_converted_t;

/**
 * Signals in message FLASH_BMS_HV_TX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_flash_bms_hv_tx_t;

/**
 * Signals in message FLASH_BMS_HV_TX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_flash_bms_hv_tx_converted_t;

/**
 * Signals in message FLASH_BMS_HV_RX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_flash_bms_hv_rx_t;

/**
 * Signals in message FLASH_BMS_HV_RX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_flash_bms_hv_rx_converted_t;

/**
 * Signals in message FLASH_BMS_LV_TX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_flash_bms_lv_tx_t;

/**
 * Signals in message FLASH_BMS_LV_TX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_flash_bms_lv_tx_converted_t;

/**
 * Signals in message FLASH_BMS_LV_RX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_flash_bms_lv_rx_t;

/**
 * Signals in message FLASH_BMS_LV_RX.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_flash_bms_lv_rx_converted_t;

/**
 * Signals in message BRUSA_NLG5_CTL.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_brusa_nlg5_ctl_t;

/**
 * Signals in message BRUSA_NLG5_CTL.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_brusa_nlg5_ctl_converted_t;

/**
 * Signals in message BRUSA_ST.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_brusa_st_t;

/**
 * Signals in message BRUSA_ST.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_brusa_st_converted_t;

/**
 * Signals in message BRUSA_ACT_I.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_brusa_act_i_t;

/**
 * Signals in message BRUSA_ACT_I.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_brusa_act_i_converted_t;

/**
 * Signals in message BRUSA_ACT_II.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_brusa_act_ii_t;

/**
 * Signals in message BRUSA_ACT_II.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_brusa_act_ii_converted_t;

/**
 * Signals in message BRUSA_TEMP.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_brusa_temp_t;

/**
 * Signals in message BRUSA_TEMP.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_brusa_temp_converted_t;

/**
 * Signals in message BRUSA_ERR.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_brusa_err_t;

/**
 * Signals in message BRUSA_ERR.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_brusa_err_converted_t;

/**
 * Signals in message CONTROL_OUTPUT.
 *
 * Control output, N*m
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (-10..50 -)
     * Scale: 0.0009155413138017853
     * Offset: -10
     */
    uint16_t estimated_velocity;

    /**
     * Range: 0..255 (0..80 -)
     * Scale: 0.3137254901960784
     * Offset: 0
     */
    uint8_t tmax_r;

    /**
     * Range: 0..255 (0..80 -)
     * Scale: 0.3137254901960784
     * Offset: 0
     */
    uint8_t tmax_l;

    /**
     * Range: 0..65535 (0..80 -)
     * Scale: 0.0012207217517357137
     * Offset: 0
     */
    uint16_t torque_l;

    /**
     * Range: 0..65535 (0..80 -)
     * Scale: 0.0012207217517357137
     * Offset: 0
     */
    uint16_t torque_r;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_control_output_t;

/**
 * Signals in message CONTROL_OUTPUT.
 *
 * Control output, N*m
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Range: 0..65535 (-10..50 -)
     * Scale: 0.0009155413138017853
     * Offset: -10
     */
    float estimated_velocity;

    /**
     * Range: 0..255 (0..80 -)
     * Scale: 0.3137254901960784
     * Offset: 0
     */
    float tmax_r;

    /**
     * Range: 0..255 (0..80 -)
     * Scale: 0.3137254901960784
     * Offset: 0
     */
    float tmax_l;

    /**
     * Range: 0..65535 (0..80 -)
     * Scale: 0.0012207217517357137
     * Offset: 0
     */
    float torque_l;

    /**
     * Range: 0..65535 (0..80 -)
     * Scale: 0.0012207217517357137
     * Offset: 0
     */
    float torque_r;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_control_output_converted_t;

/**
 * Signals in message LC_RESET.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_lc_reset_t;

/**
 * Signals in message LC_RESET.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
typedef struct CANLIB_PARKING {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;

#ifdef CANLIB_TIMESTAMP
    uint64_t _timestamp;
#endif // CANLIB_TIMESTAMP
} primary_lc_reset_converted_t;


;


;


void primary_bms_hv_jmp_to_blt_raw_to_conversion_struct(
    primary_bms_hv_jmp_to_blt_converted_t *conversion, 
    const primary_bms_hv_jmp_to_blt_t *raw);


void primary_bms_hv_jmp_to_blt_conversion_to_raw_struct(
    primary_bms_hv_jmp_to_blt_t *raw,
    const primary_bms_hv_jmp_to_blt_converted_t *conversion);


int primary_bms_hv_jmp_to_blt_to_string(primary_bms_hv_jmp_to_blt_t *message, char *buffer);

int primary_bms_hv_jmp_to_blt_to_string_file(primary_bms_hv_jmp_to_blt_t *message, FILE *buffer);

int primary_bms_hv_jmp_to_blt_fields(char *buffer);

int primary_bms_hv_jmp_to_blt_fields_file(FILE *buffer);

/**
 * Pack message BMS_HV_JMP_TO_BLT.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_bms_hv_jmp_to_blt_pack(
    uint8_t *dst_p,
    const primary_bms_hv_jmp_to_blt_t *src_p,
    size_t bit_size);

/**
 * Unpack message BMS_HV_JMP_TO_BLT.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_bms_hv_jmp_to_blt_unpack(
    primary_bms_hv_jmp_to_blt_t *dst_p,
    const uint8_t *src_p,
    size_t bit_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void primary_bms_lv_jmp_to_blt_raw_to_conversion_struct(
    primary_bms_lv_jmp_to_blt_converted_t *conversion, 
    const primary_bms_lv_jmp_to_blt_t *raw);


void primary_bms_lv_jmp_to_blt_conversion_to_raw_struct(
    primary_bms_lv_jmp_to_blt_t *raw,
    const primary_bms_lv_jmp_to_blt_converted_t *conversion);


int primary_bms_lv_jmp_to_blt_to_string(primary_bms_lv_jmp_to_blt_t *message, char *buffer);

int primary_bms_lv_jmp_to_blt_to_string_file(primary_bms_lv_jmp_to_blt_t *message, FILE *buffer);

int primary_bms_lv_jmp_to_blt_fields(char *buffer);

int primary_bms_lv_jmp_to_blt_fields_file(FILE *buffer);

/**
 * Pack message BMS_LV_JMP_TO_BLT.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_bms_lv_jmp_to_blt_pack(
    uint8_t *dst_p,
    const primary_bms_lv_jmp_to_blt_t *src_p,
    size_t bit_size);

/**
 * Unpack message BMS_LV_JMP_TO_BLT.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_bms_lv_jmp_to_blt_unpack(
    primary_bms_lv_jmp_to_blt_t *dst_p,
    const uint8_t *src_p,
    size_t bit_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


void primary_steer_version_raw_to_conversion(
    primary_steer_version_converted_t *conversion,
    uint8_t component_version,
    uint32_t canlib_build_time
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_steer_version_conversion_to_raw(
    primary_steer_version_t *raw,
    uint8_t component_version,
    uint32_t canlib_build_time
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_steer_version_raw_to_conversion_struct(
    primary_steer_version_converted_t *conversion, 
    const primary_steer_version_t *raw);


void primary_steer_version_conversion_to_raw_struct(
    primary_steer_version_t *raw,
    const primary_steer_version_converted_t *conversion);


int primary_steer_version_to_string(primary_steer_version_t *message, char *buffer);

int primary_steer_version_to_string_file(primary_steer_version_t *message, FILE *buffer);

int primary_steer_version_fields(char *buffer);

int primary_steer_version_fields_file(FILE *buffer);

/**
 * Pack message STEER_VERSION.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_steer_version_pack(
    uint8_t *dst_p,
    const primary_steer_version_t *src_p,
    size_t bit_size);

/**
 * Unpack message STEER_VERSION.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_steer_version_unpack(
    primary_steer_version_t *dst_p,
    const uint8_t *src_p,
    size_t bit_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_steer_version_component_version_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_steer_version_canlib_build_time_is_in_range(uint32_t value);


void primary_das_version_raw_to_conversion(
    primary_das_version_converted_t *conversion,
    uint8_t component_version,
    uint32_t canlib_build_time
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_das_version_conversion_to_raw(
    primary_das_version_t *raw,
    uint8_t component_version,
    uint32_t canlib_build_time
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_das_version_raw_to_conversion_struct(
    primary_das_version_converted_t *conversion, 
    const primary_das_version_t *raw);


void primary_das_version_conversion_to_raw_struct(
    primary_das_version_t *raw,
    const primary_das_version_converted_t *conversion);


int primary_das_version_to_string(primary_das_version_t *message, char *buffer);

int primary_das_version_to_string_file(primary_das_version_t *message, FILE *buffer);

int primary_das_version_fields(char *buffer);

int primary_das_version_fields_file(FILE *buffer);

/**
 * Pack message DAS_VERSION.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_das_version_pack(
    uint8_t *dst_p,
    const primary_das_version_t *src_p,
    size_t bit_size);

/**
 * Unpack message DAS_VERSION.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_das_version_unpack(
    primary_das_version_t *dst_p,
    const uint8_t *src_p,
    size_t bit_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_das_version_component_version_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_das_version_canlib_build_time_is_in_range(uint32_t value);


void primary_hv_version_raw_to_conversion(
    primary_hv_version_converted_t *conversion,
    uint8_t component_version,
    uint32_t canlib_build_time
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_hv_version_conversion_to_raw(
    primary_hv_version_t *raw,
    uint8_t component_version,
    uint32_t canlib_build_time
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_hv_version_raw_to_conversion_struct(
    primary_hv_version_converted_t *conversion, 
    const primary_hv_version_t *raw);


void primary_hv_version_conversion_to_raw_struct(
    primary_hv_version_t *raw,
    const primary_hv_version_converted_t *conversion);


int primary_hv_version_to_string(primary_hv_version_t *message, char *buffer);

int primary_hv_version_to_string_file(primary_hv_version_t *message, FILE *buffer);

int primary_hv_version_fields(char *buffer);

int primary_hv_version_fields_file(FILE *buffer);

/**
 * Pack message HV_VERSION.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_hv_version_pack(
    uint8_t *dst_p,
    const primary_hv_version_t *src_p,
    size_t bit_size);

/**
 * Unpack message HV_VERSION.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_hv_version_unpack(
    primary_hv_version_t *dst_p,
    const uint8_t *src_p,
    size_t bit_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_version_component_version_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_version_canlib_build_time_is_in_range(uint32_t value);


void primary_lv_version_raw_to_conversion(
    primary_lv_version_converted_t *conversion,
    uint8_t component_version,
    uint32_t canlib_build_time
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_lv_version_conversion_to_raw(
    primary_lv_version_t *raw,
    uint8_t component_version,
    uint32_t canlib_build_time
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_lv_version_raw_to_conversion_struct(
    primary_lv_version_converted_t *conversion, 
    const primary_lv_version_t *raw);


void primary_lv_version_conversion_to_raw_struct(
    primary_lv_version_t *raw,
    const primary_lv_version_converted_t *conversion);


int primary_lv_version_to_string(primary_lv_version_t *message, char *buffer);

int primary_lv_version_to_string_file(primary_lv_version_t *message, FILE *buffer);

int primary_lv_version_fields(char *buffer);

int primary_lv_version_fields_file(FILE *buffer);

/**
 * Pack message LV_VERSION.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_lv_version_pack(
    uint8_t *dst_p,
    const primary_lv_version_t *src_p,
    size_t bit_size);

/**
 * Unpack message LV_VERSION.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_lv_version_unpack(
    primary_lv_version_t *dst_p,
    const uint8_t *src_p,
    size_t bit_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_version_component_version_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_version_canlib_build_time_is_in_range(uint32_t value);


void primary_tlm_version_raw_to_conversion(
    primary_tlm_version_converted_t *conversion,
    uint8_t component_version,
    uint32_t canlib_build_time
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_tlm_version_conversion_to_raw(
    primary_tlm_version_t *raw,
    uint8_t component_version,
    uint32_t canlib_build_time
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_tlm_version_raw_to_conversion_struct(
    primary_tlm_version_converted_t *conversion, 
    const primary_tlm_version_t *raw);


void primary_tlm_version_conversion_to_raw_struct(
    primary_tlm_version_t *raw,
    const primary_tlm_version_converted_t *conversion);


int primary_tlm_version_to_string(primary_tlm_version_t *message, char *buffer);

int primary_tlm_version_to_string_file(primary_tlm_version_t *message, FILE *buffer);

int primary_tlm_version_fields(char *buffer);

int primary_tlm_version_fields_file(FILE *buffer);

/**
 * Pack message TLM_VERSION.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_tlm_version_pack(
    uint8_t *dst_p,
    const primary_tlm_version_t *src_p,
    size_t bit_size);

/**
 * Unpack message TLM_VERSION.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_tlm_version_unpack(
    primary_tlm_version_t *dst_p,
    const uint8_t *src_p,
    size_t bit_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_tlm_version_component_version_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_tlm_version_canlib_build_time_is_in_range(uint32_t value);


void primary_timestamp_raw_to_conversion(
    primary_timestamp_converted_t *conversion,
    uint32_t timestamp
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_timestamp_conversion_to_raw(
    primary_timestamp_t *raw,
    uint32_t timestamp
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_timestamp_raw_to_conversion_struct(
    primary_timestamp_converted_t *conversion, 
    const primary_timestamp_t *raw);


void primary_timestamp_conversion_to_raw_struct(
    primary_timestamp_t *raw,
    const primary_timestamp_converted_t *conversion);


int primary_timestamp_to_string(primary_timestamp_t *message, char *buffer);

int primary_timestamp_to_string_file(primary_timestamp_t *message, FILE *buffer);

int primary_timestamp_fields(char *buffer);

int primary_timestamp_fields_file(FILE *buffer);

/**
 * Pack message TIMESTAMP.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_timestamp_pack(
    uint8_t *dst_p,
    const primary_timestamp_t *src_p,
    size_t bit_size);

/**
 * Unpack message TIMESTAMP.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_timestamp_unpack(
    primary_timestamp_t *dst_p,
    const uint8_t *src_p,
    size_t bit_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_timestamp_timestamp_is_in_range(uint32_t value);


void primary_ambient_temperature_raw_to_conversion(
    primary_ambient_temperature_converted_t *conversion,
    int16_t temp
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_ambient_temperature_conversion_to_raw(
    primary_ambient_temperature_t *raw,
    int16_t temp
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_ambient_temperature_raw_to_conversion_struct(
    primary_ambient_temperature_converted_t *conversion, 
    const primary_ambient_temperature_t *raw);


void primary_ambient_temperature_conversion_to_raw_struct(
    primary_ambient_temperature_t *raw,
    const primary_ambient_temperature_converted_t *conversion);


int primary_ambient_temperature_to_string(primary_ambient_temperature_t *message, char *buffer);

int primary_ambient_temperature_to_string_file(primary_ambient_temperature_t *message, FILE *buffer);

int primary_ambient_temperature_fields(char *buffer);

int primary_ambient_temperature_fields_file(FILE *buffer);

/**
 * Pack message AMBIENT_TEMPERATURE.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_ambient_temperature_pack(
    uint8_t *dst_p,
    const primary_ambient_temperature_t *src_p,
    size_t bit_size);

/**
 * Unpack message AMBIENT_TEMPERATURE.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_ambient_temperature_unpack(
    primary_ambient_temperature_t *dst_p,
    const uint8_t *src_p,
    size_t bit_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_ambient_temperature_temp_is_in_range(int16_t value);


void primary_data_logger_raw_to_conversion(
    primary_data_logger_converted_t *conversion,
    uint32_t placeholder1,
    uint32_t placeholder2
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_data_logger_conversion_to_raw(
    primary_data_logger_t *raw,
    uint32_t placeholder1,
    uint32_t placeholder2
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_data_logger_raw_to_conversion_struct(
    primary_data_logger_converted_t *conversion, 
    const primary_data_logger_t *raw);


void primary_data_logger_conversion_to_raw_struct(
    primary_data_logger_t *raw,
    const primary_data_logger_converted_t *conversion);


int primary_data_logger_to_string(primary_data_logger_t *message, char *buffer);

int primary_data_logger_to_string_file(primary_data_logger_t *message, FILE *buffer);

int primary_data_logger_fields(char *buffer);

int primary_data_logger_fields_file(FILE *buffer);

/**
 * Pack message DATA_LOGGER.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_data_logger_pack(
    uint8_t *dst_p,
    const primary_data_logger_t *src_p,
    size_t bit_size);

/**
 * Unpack message DATA_LOGGER.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_data_logger_unpack(
    primary_data_logger_t *dst_p,
    const uint8_t *src_p,
    size_t bit_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_data_logger_placeholder1_is_in_range(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_data_logger_placeholder2_is_in_range(uint32_t value);


void primary_set_tlm_status_raw_to_conversion(
    primary_set_tlm_status_converted_t *conversion,
    primary_set_tlm_status_tlm_status tlm_status
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_set_tlm_status_conversion_to_raw(
    primary_set_tlm_status_t *raw,
    primary_set_tlm_status_tlm_status tlm_status
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_set_tlm_status_raw_to_conversion_struct(
    primary_set_tlm_status_converted_t *conversion, 
    const primary_set_tlm_status_t *raw);


void primary_set_tlm_status_conversion_to_raw_struct(
    primary_set_tlm_status_t *raw,
    const primary_set_tlm_status_converted_t *conversion);

int primary_set_tlm_status_tlm_status_enum_to_string(primary_set_tlm_status_tlm_status value, char *buffer);

int primary_set_tlm_status_to_string(primary_set_tlm_status_t *message, char *buffer);

int primary_set_tlm_status_to_string_file(primary_set_tlm_status_t *message, FILE *buffer);

int primary_set_tlm_status_fields(char *buffer);

int primary_set_tlm_status_fields_file(FILE *buffer);

/**
 * Pack message SET_TLM_STATUS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_set_tlm_status_pack(
    uint8_t *dst_p,
    const primary_set_tlm_status_t *src_p,
    size_t bit_size);

/**
 * Unpack message SET_TLM_STATUS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_set_tlm_status_unpack(
    primary_set_tlm_status_t *dst_p,
    const uint8_t *src_p,
    size_t bit_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_set_tlm_status_tlm_status_is_in_range(uint8_t value);


void primary_tlm_status_raw_to_conversion(
    primary_tlm_status_converted_t *conversion,
    primary_tlm_status_tlm_status tlm_status
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_tlm_status_conversion_to_raw(
    primary_tlm_status_t *raw,
    primary_tlm_status_tlm_status tlm_status
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_tlm_status_raw_to_conversion_struct(
    primary_tlm_status_converted_t *conversion, 
    const primary_tlm_status_t *raw);


void primary_tlm_status_conversion_to_raw_struct(
    primary_tlm_status_t *raw,
    const primary_tlm_status_converted_t *conversion);

int primary_tlm_status_tlm_status_enum_to_string(primary_tlm_status_tlm_status value, char *buffer);

int primary_tlm_status_to_string(primary_tlm_status_t *message, char *buffer);

int primary_tlm_status_to_string_file(primary_tlm_status_t *message, FILE *buffer);

int primary_tlm_status_fields(char *buffer);

int primary_tlm_status_fields_file(FILE *buffer);

/**
 * Pack message TLM_STATUS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_tlm_status_pack(
    uint8_t *dst_p,
    const primary_tlm_status_t *src_p,
    size_t bit_size);

/**
 * Unpack message TLM_STATUS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_tlm_status_unpack(
    primary_tlm_status_t *dst_p,
    const uint8_t *src_p,
    size_t bit_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_tlm_status_tlm_status_is_in_range(uint8_t value);


void primary_steer_system_status_raw_to_conversion(
    primary_steer_system_status_converted_t *conversion,
    uint8_t soc_temp
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_steer_system_status_conversion_to_raw(
    primary_steer_system_status_t *raw,
    uint8_t soc_temp
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_steer_system_status_raw_to_conversion_struct(
    primary_steer_system_status_converted_t *conversion, 
    const primary_steer_system_status_t *raw);


void primary_steer_system_status_conversion_to_raw_struct(
    primary_steer_system_status_t *raw,
    const primary_steer_system_status_converted_t *conversion);


int primary_steer_system_status_to_string(primary_steer_system_status_t *message, char *buffer);

int primary_steer_system_status_to_string_file(primary_steer_system_status_t *message, FILE *buffer);

int primary_steer_system_status_fields(char *buffer);

int primary_steer_system_status_fields_file(FILE *buffer);

/**
 * Pack message STEER_SYSTEM_STATUS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_steer_system_status_pack(
    uint8_t *dst_p,
    const primary_steer_system_status_t *src_p,
    size_t bit_size);

/**
 * Unpack message STEER_SYSTEM_STATUS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_steer_system_status_unpack(
    primary_steer_system_status_t *dst_p,
    const uint8_t *src_p,
    size_t bit_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_steer_system_status_soc_temp_is_in_range(uint8_t value);


void primary_hv_voltage_raw_to_conversion(
    primary_hv_voltage_converted_t *conversion,
    float pack_voltage,
    float bus_voltage,
    float max_cell_voltage,
    float min_cell_voltage
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_hv_voltage_conversion_to_raw(
    primary_hv_voltage_t *raw,
    float pack_voltage,
    float bus_voltage,
    float max_cell_voltage,
    float min_cell_voltage
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_hv_voltage_raw_to_conversion_struct(
    primary_hv_voltage_converted_t *conversion, 
    const primary_hv_voltage_t *raw);


void primary_hv_voltage_conversion_to_raw_struct(
    primary_hv_voltage_t *raw,
    const primary_hv_voltage_converted_t *conversion);


int primary_hv_voltage_converted_to_string(primary_hv_voltage_converted_t *message, char *buffer);

int primary_hv_voltage_converted_to_string_file(primary_hv_voltage_converted_t *message, FILE *buffer);

int primary_hv_voltage_fields(char *buffer);

int primary_hv_voltage_fields_file(FILE *buffer);

/**
 * Pack message HV_VOLTAGE.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_hv_voltage_pack(
    uint8_t *dst_p,
    const primary_hv_voltage_t *src_p,
    size_t bit_size);

/**
 * Unpack message HV_VOLTAGE.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_hv_voltage_unpack(
    primary_hv_voltage_t *dst_p,
    const uint8_t *src_p,
    size_t bit_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_hv_voltage_pack_voltage_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_hv_voltage_pack_voltage_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_voltage_pack_voltage_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_hv_voltage_bus_voltage_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_hv_voltage_bus_voltage_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_voltage_bus_voltage_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_hv_voltage_max_cell_voltage_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_hv_voltage_max_cell_voltage_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_voltage_max_cell_voltage_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_hv_voltage_min_cell_voltage_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_hv_voltage_min_cell_voltage_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_voltage_min_cell_voltage_is_in_range(uint16_t value);


void primary_hv_current_raw_to_conversion(
    primary_hv_current_converted_t *conversion,
    float current,
    float power,
    float energy,
    float soc
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_hv_current_conversion_to_raw(
    primary_hv_current_t *raw,
    float current,
    float power,
    float energy,
    float soc
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_hv_current_raw_to_conversion_struct(
    primary_hv_current_converted_t *conversion, 
    const primary_hv_current_t *raw);


void primary_hv_current_conversion_to_raw_struct(
    primary_hv_current_t *raw,
    const primary_hv_current_converted_t *conversion);


int primary_hv_current_converted_to_string(primary_hv_current_converted_t *message, char *buffer);

int primary_hv_current_converted_to_string_file(primary_hv_current_converted_t *message, FILE *buffer);

int primary_hv_current_fields(char *buffer);

int primary_hv_current_fields_file(FILE *buffer);

/**
 * Pack message HV_CURRENT.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_hv_current_pack(
    uint8_t *dst_p,
    const primary_hv_current_t *src_p,
    size_t bit_size);

/**
 * Unpack message HV_CURRENT.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_hv_current_unpack(
    primary_hv_current_t *dst_p,
    const uint8_t *src_p,
    size_t bit_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_hv_current_current_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_hv_current_current_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_current_current_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_hv_current_power_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_hv_current_power_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_current_power_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_hv_current_energy_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_hv_current_energy_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_current_energy_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t primary_hv_current_soc_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_hv_current_soc_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_current_soc_is_in_range(uint8_t value);


void primary_hv_temp_raw_to_conversion(
    primary_hv_temp_converted_t *conversion,
    float average_temp,
    float max_temp,
    float min_temp
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_hv_temp_conversion_to_raw(
    primary_hv_temp_t *raw,
    float average_temp,
    float max_temp,
    float min_temp
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_hv_temp_raw_to_conversion_struct(
    primary_hv_temp_converted_t *conversion, 
    const primary_hv_temp_t *raw);


void primary_hv_temp_conversion_to_raw_struct(
    primary_hv_temp_t *raw,
    const primary_hv_temp_converted_t *conversion);


int primary_hv_temp_converted_to_string(primary_hv_temp_converted_t *message, char *buffer);

int primary_hv_temp_converted_to_string_file(primary_hv_temp_converted_t *message, FILE *buffer);

int primary_hv_temp_fields(char *buffer);

int primary_hv_temp_fields_file(FILE *buffer);

/**
 * Pack message HV_TEMP.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_hv_temp_pack(
    uint8_t *dst_p,
    const primary_hv_temp_t *src_p,
    size_t bit_size);

/**
 * Unpack message HV_TEMP.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_hv_temp_unpack(
    primary_hv_temp_t *dst_p,
    const uint8_t *src_p,
    size_t bit_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t primary_hv_temp_average_temp_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_hv_temp_average_temp_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_temp_average_temp_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t primary_hv_temp_max_temp_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_hv_temp_max_temp_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_temp_max_temp_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t primary_hv_temp_min_temp_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_hv_temp_min_temp_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_temp_min_temp_is_in_range(uint8_t value);


void primary_hv_errors_raw_to_conversion(
    primary_hv_errors_converted_t *conversion,
    uint8_t warnings_cell_low_voltage,
    uint8_t warnings_cell_under_voltage,
    uint8_t warnings_cell_over_voltage,
    uint8_t warnings_cell_high_temperature,
    uint8_t warnings_cell_over_temperature,
    uint8_t warnings_over_current,
    uint8_t warnings_can,
    uint8_t warnings_int_voltage_mismatch,
    uint8_t warnings_cellboard_comm,
    uint8_t warnings_cellboard_internal,
    uint8_t warnings_feedback,
    uint8_t warnings_feedback_circuitry,
    uint8_t warnings_eeprom_comm,
    uint8_t warnings_eeprom_write,
    uint8_t errors_cell_low_voltage,
    uint8_t errors_cell_under_voltage,
    uint8_t errors_cell_over_voltage,
    uint8_t errors_cell_high_temperature,
    uint8_t errors_cell_over_temperature,
    uint8_t errors_over_current,
    uint8_t errors_can,
    uint8_t errors_int_voltage_mismatch,
    uint8_t errors_cellboard_comm,
    uint8_t errors_cellboard_internal,
    uint8_t errors_feedback,
    uint8_t errors_feedback_circuitry,
    uint8_t errors_eeprom_comm,
    uint8_t errors_eeprom_write
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_hv_errors_conversion_to_raw(
    primary_hv_errors_t *raw,
    uint8_t warnings_cell_low_voltage,
    uint8_t warnings_cell_under_voltage,
    uint8_t warnings_cell_over_voltage,
    uint8_t warnings_cell_high_temperature,
    uint8_t warnings_cell_over_temperature,
    uint8_t warnings_over_current,
    uint8_t warnings_can,
    uint8_t warnings_int_voltage_mismatch,
    uint8_t warnings_cellboard_comm,
    uint8_t warnings_cellboard_internal,
    uint8_t warnings_feedback,
    uint8_t warnings_feedback_circuitry,
    uint8_t warnings_eeprom_comm,
    uint8_t warnings_eeprom_write,
    uint8_t errors_cell_low_voltage,
    uint8_t errors_cell_under_voltage,
    uint8_t errors_cell_over_voltage,
    uint8_t errors_cell_high_temperature,
    uint8_t errors_cell_over_temperature,
    uint8_t errors_over_current,
    uint8_t errors_can,
    uint8_t errors_int_voltage_mismatch,
    uint8_t errors_cellboard_comm,
    uint8_t errors_cellboard_internal,
    uint8_t errors_feedback,
    uint8_t errors_feedback_circuitry,
    uint8_t errors_eeprom_comm,
    uint8_t errors_eeprom_write
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_hv_errors_raw_to_conversion_struct(
    primary_hv_errors_converted_t *conversion, 
    const primary_hv_errors_t *raw);


void primary_hv_errors_conversion_to_raw_struct(
    primary_hv_errors_t *raw,
    const primary_hv_errors_converted_t *conversion);


int primary_hv_errors_to_string(primary_hv_errors_t *message, char *buffer);

int primary_hv_errors_to_string_file(primary_hv_errors_t *message, FILE *buffer);

int primary_hv_errors_fields(char *buffer);

int primary_hv_errors_fields_file(FILE *buffer);

/**
 * Pack message HV_ERRORS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_hv_errors_pack(
    uint8_t *dst_p,
    const primary_hv_errors_t *src_p,
    size_t bit_size);

/**
 * Unpack message HV_ERRORS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_hv_errors_unpack(
    primary_hv_errors_t *dst_p,
    const uint8_t *src_p,
    size_t bit_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_errors_warnings_cell_low_voltage_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_errors_warnings_cell_under_voltage_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_errors_warnings_cell_over_voltage_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_errors_warnings_cell_high_temperature_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_errors_warnings_cell_over_temperature_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_errors_warnings_over_current_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_errors_warnings_can_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_errors_warnings_int_voltage_mismatch_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_errors_warnings_cellboard_comm_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_errors_warnings_cellboard_internal_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_errors_warnings_feedback_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_errors_warnings_feedback_circuitry_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_errors_warnings_eeprom_comm_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_errors_warnings_eeprom_write_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_errors_errors_cell_low_voltage_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_errors_errors_cell_under_voltage_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_errors_errors_cell_over_voltage_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_errors_errors_cell_high_temperature_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_errors_errors_cell_over_temperature_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_errors_errors_over_current_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_errors_errors_can_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_errors_errors_int_voltage_mismatch_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_errors_errors_cellboard_comm_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_errors_errors_cellboard_internal_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_errors_errors_feedback_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_errors_errors_feedback_circuitry_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_errors_errors_eeprom_comm_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_errors_errors_eeprom_write_is_in_range(uint8_t value);


void primary_hv_can_forward_raw_to_conversion(
    primary_hv_can_forward_converted_t *conversion,
    primary_hv_can_forward_can_forward_set can_forward_set
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_hv_can_forward_conversion_to_raw(
    primary_hv_can_forward_t *raw,
    primary_hv_can_forward_can_forward_set can_forward_set
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_hv_can_forward_raw_to_conversion_struct(
    primary_hv_can_forward_converted_t *conversion, 
    const primary_hv_can_forward_t *raw);


void primary_hv_can_forward_conversion_to_raw_struct(
    primary_hv_can_forward_t *raw,
    const primary_hv_can_forward_converted_t *conversion);

int primary_hv_can_forward_can_forward_set_enum_to_string(primary_hv_can_forward_can_forward_set value, char *buffer);

int primary_hv_can_forward_to_string(primary_hv_can_forward_t *message, char *buffer);

int primary_hv_can_forward_to_string_file(primary_hv_can_forward_t *message, FILE *buffer);

int primary_hv_can_forward_fields(char *buffer);

int primary_hv_can_forward_fields_file(FILE *buffer);

/**
 * Pack message HV_CAN_FORWARD.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_hv_can_forward_pack(
    uint8_t *dst_p,
    const primary_hv_can_forward_t *src_p,
    size_t bit_size);

/**
 * Unpack message HV_CAN_FORWARD.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_hv_can_forward_unpack(
    primary_hv_can_forward_t *dst_p,
    const uint8_t *src_p,
    size_t bit_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_can_forward_can_forward_set_is_in_range(uint8_t value);


void primary_hv_fans_override_raw_to_conversion(
    primary_hv_fans_override_converted_t *conversion,
    primary_hv_fans_override_fans_override fans_override,
    float fans_speed
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_hv_fans_override_conversion_to_raw(
    primary_hv_fans_override_t *raw,
    primary_hv_fans_override_fans_override fans_override,
    float fans_speed
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_hv_fans_override_raw_to_conversion_struct(
    primary_hv_fans_override_converted_t *conversion, 
    const primary_hv_fans_override_t *raw);


void primary_hv_fans_override_conversion_to_raw_struct(
    primary_hv_fans_override_t *raw,
    const primary_hv_fans_override_converted_t *conversion);

int primary_hv_fans_override_fans_override_enum_to_string(primary_hv_fans_override_fans_override value, char *buffer);

int primary_hv_fans_override_converted_to_string(primary_hv_fans_override_converted_t *message, char *buffer);

int primary_hv_fans_override_converted_to_string_file(primary_hv_fans_override_converted_t *message, FILE *buffer);

int primary_hv_fans_override_fields(char *buffer);

int primary_hv_fans_override_fields_file(FILE *buffer);

/**
 * Pack message HV_FANS_OVERRIDE.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_hv_fans_override_pack(
    uint8_t *dst_p,
    const primary_hv_fans_override_t *src_p,
    size_t bit_size);

/**
 * Unpack message HV_FANS_OVERRIDE.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_hv_fans_override_unpack(
    primary_hv_fans_override_t *dst_p,
    const uint8_t *src_p,
    size_t bit_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_fans_override_fans_override_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_hv_fans_override_fans_speed_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_hv_fans_override_fans_speed_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_fans_override_fans_speed_is_in_range(uint16_t value);


void primary_hv_can_forward_status_raw_to_conversion(
    primary_hv_can_forward_status_converted_t *conversion,
    primary_hv_can_forward_status_can_forward_status can_forward_status
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_hv_can_forward_status_conversion_to_raw(
    primary_hv_can_forward_status_t *raw,
    primary_hv_can_forward_status_can_forward_status can_forward_status
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_hv_can_forward_status_raw_to_conversion_struct(
    primary_hv_can_forward_status_converted_t *conversion, 
    const primary_hv_can_forward_status_t *raw);


void primary_hv_can_forward_status_conversion_to_raw_struct(
    primary_hv_can_forward_status_t *raw,
    const primary_hv_can_forward_status_converted_t *conversion);

int primary_hv_can_forward_status_can_forward_status_enum_to_string(primary_hv_can_forward_status_can_forward_status value, char *buffer);

int primary_hv_can_forward_status_to_string(primary_hv_can_forward_status_t *message, char *buffer);

int primary_hv_can_forward_status_to_string_file(primary_hv_can_forward_status_t *message, FILE *buffer);

int primary_hv_can_forward_status_fields(char *buffer);

int primary_hv_can_forward_status_fields_file(FILE *buffer);

/**
 * Pack message HV_CAN_FORWARD_STATUS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_hv_can_forward_status_pack(
    uint8_t *dst_p,
    const primary_hv_can_forward_status_t *src_p,
    size_t bit_size);

/**
 * Unpack message HV_CAN_FORWARD_STATUS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_hv_can_forward_status_unpack(
    primary_hv_can_forward_status_t *dst_p,
    const uint8_t *src_p,
    size_t bit_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_can_forward_status_can_forward_status_is_in_range(uint8_t value);


void primary_hv_fans_override_status_raw_to_conversion(
    primary_hv_fans_override_status_converted_t *conversion,
    primary_hv_fans_override_status_fans_override fans_override,
    float fans_speed
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_hv_fans_override_status_conversion_to_raw(
    primary_hv_fans_override_status_t *raw,
    primary_hv_fans_override_status_fans_override fans_override,
    float fans_speed
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_hv_fans_override_status_raw_to_conversion_struct(
    primary_hv_fans_override_status_converted_t *conversion, 
    const primary_hv_fans_override_status_t *raw);


void primary_hv_fans_override_status_conversion_to_raw_struct(
    primary_hv_fans_override_status_t *raw,
    const primary_hv_fans_override_status_converted_t *conversion);

int primary_hv_fans_override_status_fans_override_enum_to_string(primary_hv_fans_override_status_fans_override value, char *buffer);

int primary_hv_fans_override_status_converted_to_string(primary_hv_fans_override_status_converted_t *message, char *buffer);

int primary_hv_fans_override_status_converted_to_string_file(primary_hv_fans_override_status_converted_t *message, FILE *buffer);

int primary_hv_fans_override_status_fields(char *buffer);

int primary_hv_fans_override_status_fields_file(FILE *buffer);

/**
 * Pack message HV_FANS_OVERRIDE_STATUS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_hv_fans_override_status_pack(
    uint8_t *dst_p,
    const primary_hv_fans_override_status_t *src_p,
    size_t bit_size);

/**
 * Unpack message HV_FANS_OVERRIDE_STATUS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_hv_fans_override_status_unpack(
    primary_hv_fans_override_status_t *dst_p,
    const uint8_t *src_p,
    size_t bit_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_fans_override_status_fans_override_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_hv_fans_override_status_fans_speed_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_hv_fans_override_status_fans_speed_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_fans_override_status_fans_speed_is_in_range(uint16_t value);


void primary_hv_feedbacks_status_raw_to_conversion(
    primary_hv_feedbacks_status_converted_t *conversion,
    uint8_t feedbacks_status_feedback_tsal_green_fault,
    uint8_t feedbacks_status_feedback_imd_latched,
    uint8_t feedbacks_status_feedback_tsal_green_fault_latched,
    uint8_t feedbacks_status_feedback_bms_latched,
    uint8_t feedbacks_status_feedback_ext_latched,
    uint8_t feedbacks_status_feedback_tsal_green,
    uint8_t feedbacks_status_feedback_ts_over_60v_status,
    uint8_t feedbacks_status_feedback_airn_status,
    uint8_t feedbacks_status_feedback_airp_status,
    uint8_t feedbacks_status_feedback_airp_gate,
    uint8_t feedbacks_status_feedback_airn_gate,
    uint8_t feedbacks_status_feedback_precharge_status,
    uint8_t feedbacks_status_feedback_tsp_over_60v_status,
    uint8_t feedbacks_status_feedback_check_mux,
    uint8_t feedbacks_status_feedback_sd_in,
    uint8_t feedbacks_status_feedback_sd_out,
    uint8_t feedbacks_status_feedback_relay_sd,
    uint8_t feedbacks_status_feedback_imd_fault,
    uint8_t feedbacks_status_feedback_sd_end,
    uint8_t is_circuitry_error_feedback_tsal_green_fault,
    uint8_t is_circuitry_error_feedback_imd_latched,
    uint8_t is_circuitry_error_feedback_tsal_green_fault_latched,
    uint8_t is_circuitry_error_feedback_bms_latched,
    uint8_t is_circuitry_error_feedback_ext_latched,
    uint8_t is_circuitry_error_feedback_tsal_green,
    uint8_t is_circuitry_error_feedback_ts_over_60v_status,
    uint8_t is_circuitry_error_feedback_airn_status,
    uint8_t is_circuitry_error_feedback_airp_status,
    uint8_t is_circuitry_error_feedback_airp_gate,
    uint8_t is_circuitry_error_feedback_airn_gate,
    uint8_t is_circuitry_error_feedback_precharge_status,
    uint8_t is_circuitry_error_feedback_tsp_over_60v_status,
    uint8_t is_circuitry_error_feedback_check_mux,
    uint8_t is_circuitry_error_feedback_sd_in,
    uint8_t is_circuitry_error_feedback_sd_out,
    uint8_t is_circuitry_error_feedback_relay_sd,
    uint8_t is_circuitry_error_feedback_imd_fault,
    uint8_t is_circuitry_error_feedback_sd_end
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_hv_feedbacks_status_conversion_to_raw(
    primary_hv_feedbacks_status_t *raw,
    uint8_t feedbacks_status_feedback_tsal_green_fault,
    uint8_t feedbacks_status_feedback_imd_latched,
    uint8_t feedbacks_status_feedback_tsal_green_fault_latched,
    uint8_t feedbacks_status_feedback_bms_latched,
    uint8_t feedbacks_status_feedback_ext_latched,
    uint8_t feedbacks_status_feedback_tsal_green,
    uint8_t feedbacks_status_feedback_ts_over_60v_status,
    uint8_t feedbacks_status_feedback_airn_status,
    uint8_t feedbacks_status_feedback_airp_status,
    uint8_t feedbacks_status_feedback_airp_gate,
    uint8_t feedbacks_status_feedback_airn_gate,
    uint8_t feedbacks_status_feedback_precharge_status,
    uint8_t feedbacks_status_feedback_tsp_over_60v_status,
    uint8_t feedbacks_status_feedback_check_mux,
    uint8_t feedbacks_status_feedback_sd_in,
    uint8_t feedbacks_status_feedback_sd_out,
    uint8_t feedbacks_status_feedback_relay_sd,
    uint8_t feedbacks_status_feedback_imd_fault,
    uint8_t feedbacks_status_feedback_sd_end,
    uint8_t is_circuitry_error_feedback_tsal_green_fault,
    uint8_t is_circuitry_error_feedback_imd_latched,
    uint8_t is_circuitry_error_feedback_tsal_green_fault_latched,
    uint8_t is_circuitry_error_feedback_bms_latched,
    uint8_t is_circuitry_error_feedback_ext_latched,
    uint8_t is_circuitry_error_feedback_tsal_green,
    uint8_t is_circuitry_error_feedback_ts_over_60v_status,
    uint8_t is_circuitry_error_feedback_airn_status,
    uint8_t is_circuitry_error_feedback_airp_status,
    uint8_t is_circuitry_error_feedback_airp_gate,
    uint8_t is_circuitry_error_feedback_airn_gate,
    uint8_t is_circuitry_error_feedback_precharge_status,
    uint8_t is_circuitry_error_feedback_tsp_over_60v_status,
    uint8_t is_circuitry_error_feedback_check_mux,
    uint8_t is_circuitry_error_feedback_sd_in,
    uint8_t is_circuitry_error_feedback_sd_out,
    uint8_t is_circuitry_error_feedback_relay_sd,
    uint8_t is_circuitry_error_feedback_imd_fault,
    uint8_t is_circuitry_error_feedback_sd_end
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_hv_feedbacks_status_raw_to_conversion_struct(
    primary_hv_feedbacks_status_converted_t *conversion, 
    const primary_hv_feedbacks_status_t *raw);


void primary_hv_feedbacks_status_conversion_to_raw_struct(
    primary_hv_feedbacks_status_t *raw,
    const primary_hv_feedbacks_status_converted_t *conversion);


int primary_hv_feedbacks_status_to_string(primary_hv_feedbacks_status_t *message, char *buffer);

int primary_hv_feedbacks_status_to_string_file(primary_hv_feedbacks_status_t *message, FILE *buffer);

int primary_hv_feedbacks_status_fields(char *buffer);

int primary_hv_feedbacks_status_fields_file(FILE *buffer);

/**
 * Pack message HV_FEEDBACKS_STATUS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_hv_feedbacks_status_pack(
    uint8_t *dst_p,
    const primary_hv_feedbacks_status_t *src_p,
    size_t bit_size);

/**
 * Unpack message HV_FEEDBACKS_STATUS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_hv_feedbacks_status_unpack(
    primary_hv_feedbacks_status_t *dst_p,
    const uint8_t *src_p,
    size_t bit_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedbacks_status_feedbacks_status_feedback_tsal_green_fault_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedbacks_status_feedbacks_status_feedback_imd_latched_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedbacks_status_feedbacks_status_feedback_tsal_green_fault_latched_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedbacks_status_feedbacks_status_feedback_bms_latched_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedbacks_status_feedbacks_status_feedback_ext_latched_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedbacks_status_feedbacks_status_feedback_tsal_green_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedbacks_status_feedbacks_status_feedback_ts_over_60v_status_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedbacks_status_feedbacks_status_feedback_airn_status_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedbacks_status_feedbacks_status_feedback_airp_status_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedbacks_status_feedbacks_status_feedback_airp_gate_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedbacks_status_feedbacks_status_feedback_airn_gate_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedbacks_status_feedbacks_status_feedback_precharge_status_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedbacks_status_feedbacks_status_feedback_tsp_over_60v_status_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedbacks_status_feedbacks_status_feedback_check_mux_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedbacks_status_feedbacks_status_feedback_sd_in_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedbacks_status_feedbacks_status_feedback_sd_out_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedbacks_status_feedbacks_status_feedback_relay_sd_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedbacks_status_feedbacks_status_feedback_imd_fault_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedbacks_status_feedbacks_status_feedback_sd_end_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedbacks_status_is_circuitry_error_feedback_tsal_green_fault_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedbacks_status_is_circuitry_error_feedback_imd_latched_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedbacks_status_is_circuitry_error_feedback_tsal_green_fault_latched_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedbacks_status_is_circuitry_error_feedback_bms_latched_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedbacks_status_is_circuitry_error_feedback_ext_latched_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedbacks_status_is_circuitry_error_feedback_tsal_green_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedbacks_status_is_circuitry_error_feedback_ts_over_60v_status_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedbacks_status_is_circuitry_error_feedback_airn_status_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedbacks_status_is_circuitry_error_feedback_airp_status_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedbacks_status_is_circuitry_error_feedback_airp_gate_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedbacks_status_is_circuitry_error_feedback_airn_gate_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedbacks_status_is_circuitry_error_feedback_precharge_status_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedbacks_status_is_circuitry_error_feedback_tsp_over_60v_status_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedbacks_status_is_circuitry_error_feedback_check_mux_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedbacks_status_is_circuitry_error_feedback_sd_in_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedbacks_status_is_circuitry_error_feedback_sd_out_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedbacks_status_is_circuitry_error_feedback_relay_sd_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedbacks_status_is_circuitry_error_feedback_imd_fault_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_feedbacks_status_is_circuitry_error_feedback_sd_end_is_in_range(uint8_t value);


void primary_hv_imd_status_raw_to_conversion(
    primary_hv_imd_status_converted_t *conversion,
    uint8_t imd_fault,
    primary_hv_imd_status_imd_status imd_status,
    int32_t imd_info
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_hv_imd_status_conversion_to_raw(
    primary_hv_imd_status_t *raw,
    uint8_t imd_fault,
    primary_hv_imd_status_imd_status imd_status,
    int32_t imd_info
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_hv_imd_status_raw_to_conversion_struct(
    primary_hv_imd_status_converted_t *conversion, 
    const primary_hv_imd_status_t *raw);


void primary_hv_imd_status_conversion_to_raw_struct(
    primary_hv_imd_status_t *raw,
    const primary_hv_imd_status_converted_t *conversion);

int primary_hv_imd_status_imd_status_enum_to_string(primary_hv_imd_status_imd_status value, char *buffer);

int primary_hv_imd_status_to_string(primary_hv_imd_status_t *message, char *buffer);

int primary_hv_imd_status_to_string_file(primary_hv_imd_status_t *message, FILE *buffer);

int primary_hv_imd_status_fields(char *buffer);

int primary_hv_imd_status_fields_file(FILE *buffer);

/**
 * Pack message HV_IMD_STATUS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_hv_imd_status_pack(
    uint8_t *dst_p,
    const primary_hv_imd_status_t *src_p,
    size_t bit_size);

/**
 * Unpack message HV_IMD_STATUS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_hv_imd_status_unpack(
    primary_hv_imd_status_t *dst_p,
    const uint8_t *src_p,
    size_t bit_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_imd_status_imd_fault_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_imd_status_imd_status_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_imd_status_imd_info_is_in_range(int32_t value);


void primary_ts_status_raw_to_conversion(
    primary_ts_status_converted_t *conversion,
    primary_ts_status_ts_status ts_status
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_ts_status_conversion_to_raw(
    primary_ts_status_t *raw,
    primary_ts_status_ts_status ts_status
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_ts_status_raw_to_conversion_struct(
    primary_ts_status_converted_t *conversion, 
    const primary_ts_status_t *raw);


void primary_ts_status_conversion_to_raw_struct(
    primary_ts_status_t *raw,
    const primary_ts_status_converted_t *conversion);

int primary_ts_status_ts_status_enum_to_string(primary_ts_status_ts_status value, char *buffer);

int primary_ts_status_to_string(primary_ts_status_t *message, char *buffer);

int primary_ts_status_to_string_file(primary_ts_status_t *message, FILE *buffer);

int primary_ts_status_fields(char *buffer);

int primary_ts_status_fields_file(FILE *buffer);

/**
 * Pack message TS_STATUS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_ts_status_pack(
    uint8_t *dst_p,
    const primary_ts_status_t *src_p,
    size_t bit_size);

/**
 * Unpack message TS_STATUS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_ts_status_unpack(
    primary_ts_status_t *dst_p,
    const uint8_t *src_p,
    size_t bit_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_ts_status_ts_status_is_in_range(uint8_t value);


void primary_set_ts_status_das_raw_to_conversion(
    primary_set_ts_status_das_converted_t *conversion,
    primary_set_ts_status_das_ts_status_set ts_status_set
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_set_ts_status_das_conversion_to_raw(
    primary_set_ts_status_das_t *raw,
    primary_set_ts_status_das_ts_status_set ts_status_set
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_set_ts_status_das_raw_to_conversion_struct(
    primary_set_ts_status_das_converted_t *conversion, 
    const primary_set_ts_status_das_t *raw);


void primary_set_ts_status_das_conversion_to_raw_struct(
    primary_set_ts_status_das_t *raw,
    const primary_set_ts_status_das_converted_t *conversion);

int primary_set_ts_status_das_ts_status_set_enum_to_string(primary_set_ts_status_das_ts_status_set value, char *buffer);

int primary_set_ts_status_das_to_string(primary_set_ts_status_das_t *message, char *buffer);

int primary_set_ts_status_das_to_string_file(primary_set_ts_status_das_t *message, FILE *buffer);

int primary_set_ts_status_das_fields(char *buffer);

int primary_set_ts_status_das_fields_file(FILE *buffer);

/**
 * Pack message SET_TS_STATUS_DAS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_set_ts_status_das_pack(
    uint8_t *dst_p,
    const primary_set_ts_status_das_t *src_p,
    size_t bit_size);

/**
 * Unpack message SET_TS_STATUS_DAS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_set_ts_status_das_unpack(
    primary_set_ts_status_das_t *dst_p,
    const uint8_t *src_p,
    size_t bit_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_set_ts_status_das_ts_status_set_is_in_range(uint8_t value);


void primary_set_ts_status_handcart_raw_to_conversion(
    primary_set_ts_status_handcart_converted_t *conversion,
    primary_set_ts_status_handcart_ts_status_set ts_status_set
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_set_ts_status_handcart_conversion_to_raw(
    primary_set_ts_status_handcart_t *raw,
    primary_set_ts_status_handcart_ts_status_set ts_status_set
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_set_ts_status_handcart_raw_to_conversion_struct(
    primary_set_ts_status_handcart_converted_t *conversion, 
    const primary_set_ts_status_handcart_t *raw);


void primary_set_ts_status_handcart_conversion_to_raw_struct(
    primary_set_ts_status_handcart_t *raw,
    const primary_set_ts_status_handcart_converted_t *conversion);

int primary_set_ts_status_handcart_ts_status_set_enum_to_string(primary_set_ts_status_handcart_ts_status_set value, char *buffer);

int primary_set_ts_status_handcart_to_string(primary_set_ts_status_handcart_t *message, char *buffer);

int primary_set_ts_status_handcart_to_string_file(primary_set_ts_status_handcart_t *message, FILE *buffer);

int primary_set_ts_status_handcart_fields(char *buffer);

int primary_set_ts_status_handcart_fields_file(FILE *buffer);

/**
 * Pack message SET_TS_STATUS_HANDCART.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_set_ts_status_handcart_pack(
    uint8_t *dst_p,
    const primary_set_ts_status_handcart_t *src_p,
    size_t bit_size);

/**
 * Unpack message SET_TS_STATUS_HANDCART.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_set_ts_status_handcart_unpack(
    primary_set_ts_status_handcart_t *dst_p,
    const uint8_t *src_p,
    size_t bit_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_set_ts_status_handcart_ts_status_set_is_in_range(uint8_t value);


void primary_steer_status_raw_to_conversion(
    primary_steer_status_converted_t *conversion,
    float map_pw,
    float map_sc,
    float map_tv
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_steer_status_conversion_to_raw(
    primary_steer_status_t *raw,
    float map_pw,
    float map_sc,
    float map_tv
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_steer_status_raw_to_conversion_struct(
    primary_steer_status_converted_t *conversion, 
    const primary_steer_status_t *raw);


void primary_steer_status_conversion_to_raw_struct(
    primary_steer_status_t *raw,
    const primary_steer_status_converted_t *conversion);


int primary_steer_status_converted_to_string(primary_steer_status_converted_t *message, char *buffer);

int primary_steer_status_converted_to_string_file(primary_steer_status_converted_t *message, FILE *buffer);

int primary_steer_status_fields(char *buffer);

int primary_steer_status_fields_file(FILE *buffer);

/**
 * Pack message STEER_STATUS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_steer_status_pack(
    uint8_t *dst_p,
    const primary_steer_status_t *src_p,
    size_t bit_size);

/**
 * Unpack message STEER_STATUS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_steer_status_unpack(
    primary_steer_status_t *dst_p,
    const uint8_t *src_p,
    size_t bit_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t primary_steer_status_map_pw_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_steer_status_map_pw_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_steer_status_map_pw_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t primary_steer_status_map_sc_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_steer_status_map_sc_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_steer_status_map_sc_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t primary_steer_status_map_tv_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_steer_status_map_tv_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_steer_status_map_tv_is_in_range(uint8_t value);


void primary_set_car_status_raw_to_conversion(
    primary_set_car_status_converted_t *conversion,
    primary_set_car_status_car_status_set car_status_set
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_set_car_status_conversion_to_raw(
    primary_set_car_status_t *raw,
    primary_set_car_status_car_status_set car_status_set
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_set_car_status_raw_to_conversion_struct(
    primary_set_car_status_converted_t *conversion, 
    const primary_set_car_status_t *raw);


void primary_set_car_status_conversion_to_raw_struct(
    primary_set_car_status_t *raw,
    const primary_set_car_status_converted_t *conversion);

int primary_set_car_status_car_status_set_enum_to_string(primary_set_car_status_car_status_set value, char *buffer);

int primary_set_car_status_to_string(primary_set_car_status_t *message, char *buffer);

int primary_set_car_status_to_string_file(primary_set_car_status_t *message, FILE *buffer);

int primary_set_car_status_fields(char *buffer);

int primary_set_car_status_fields_file(FILE *buffer);

/**
 * Pack message SET_CAR_STATUS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_set_car_status_pack(
    uint8_t *dst_p,
    const primary_set_car_status_t *src_p,
    size_t bit_size);

/**
 * Unpack message SET_CAR_STATUS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_set_car_status_unpack(
    primary_set_car_status_t *dst_p,
    const uint8_t *src_p,
    size_t bit_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_set_car_status_car_status_set_is_in_range(uint8_t value);


void primary_set_pedals_range_raw_to_conversion(
    primary_set_pedals_range_converted_t *conversion,
    primary_set_pedals_range_bound bound,
    primary_set_pedals_range_pedal pedal
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_set_pedals_range_conversion_to_raw(
    primary_set_pedals_range_t *raw,
    primary_set_pedals_range_bound bound,
    primary_set_pedals_range_pedal pedal
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_set_pedals_range_raw_to_conversion_struct(
    primary_set_pedals_range_converted_t *conversion, 
    const primary_set_pedals_range_t *raw);


void primary_set_pedals_range_conversion_to_raw_struct(
    primary_set_pedals_range_t *raw,
    const primary_set_pedals_range_converted_t *conversion);

int primary_set_pedals_range_bound_enum_to_string(primary_set_pedals_range_bound value, char *buffer);
int primary_set_pedals_range_pedal_enum_to_string(primary_set_pedals_range_pedal value, char *buffer);

int primary_set_pedals_range_to_string(primary_set_pedals_range_t *message, char *buffer);

int primary_set_pedals_range_to_string_file(primary_set_pedals_range_t *message, FILE *buffer);

int primary_set_pedals_range_fields(char *buffer);

int primary_set_pedals_range_fields_file(FILE *buffer);

/**
 * Pack message SET_PEDALS_RANGE.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_set_pedals_range_pack(
    uint8_t *dst_p,
    const primary_set_pedals_range_t *src_p,
    size_t bit_size);

/**
 * Unpack message SET_PEDALS_RANGE.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_set_pedals_range_unpack(
    primary_set_pedals_range_t *dst_p,
    const uint8_t *src_p,
    size_t bit_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_set_pedals_range_bound_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_set_pedals_range_pedal_is_in_range(uint8_t value);


void primary_set_steering_angle_range_raw_to_conversion(
    primary_set_steering_angle_range_converted_t *conversion,
    primary_set_steering_angle_range_bound bound
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_set_steering_angle_range_conversion_to_raw(
    primary_set_steering_angle_range_t *raw,
    primary_set_steering_angle_range_bound bound
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_set_steering_angle_range_raw_to_conversion_struct(
    primary_set_steering_angle_range_converted_t *conversion, 
    const primary_set_steering_angle_range_t *raw);


void primary_set_steering_angle_range_conversion_to_raw_struct(
    primary_set_steering_angle_range_t *raw,
    const primary_set_steering_angle_range_converted_t *conversion);

int primary_set_steering_angle_range_bound_enum_to_string(primary_set_steering_angle_range_bound value, char *buffer);

int primary_set_steering_angle_range_to_string(primary_set_steering_angle_range_t *message, char *buffer);

int primary_set_steering_angle_range_to_string_file(primary_set_steering_angle_range_t *message, FILE *buffer);

int primary_set_steering_angle_range_fields(char *buffer);

int primary_set_steering_angle_range_fields_file(FILE *buffer);

/**
 * Pack message SET_STEERING_ANGLE_RANGE.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_set_steering_angle_range_pack(
    uint8_t *dst_p,
    const primary_set_steering_angle_range_t *src_p,
    size_t bit_size);

/**
 * Unpack message SET_STEERING_ANGLE_RANGE.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_set_steering_angle_range_unpack(
    primary_set_steering_angle_range_t *dst_p,
    const uint8_t *src_p,
    size_t bit_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_set_steering_angle_range_bound_is_in_range(uint8_t value);


void primary_car_status_raw_to_conversion(
    primary_car_status_converted_t *conversion,
    primary_car_status_inverter_l inverter_l,
    primary_car_status_inverter_r inverter_r,
    primary_car_status_car_status car_status
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_car_status_conversion_to_raw(
    primary_car_status_t *raw,
    primary_car_status_inverter_l inverter_l,
    primary_car_status_inverter_r inverter_r,
    primary_car_status_car_status car_status
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_car_status_raw_to_conversion_struct(
    primary_car_status_converted_t *conversion, 
    const primary_car_status_t *raw);


void primary_car_status_conversion_to_raw_struct(
    primary_car_status_t *raw,
    const primary_car_status_converted_t *conversion);

int primary_car_status_inverter_l_enum_to_string(primary_car_status_inverter_l value, char *buffer);
int primary_car_status_inverter_r_enum_to_string(primary_car_status_inverter_r value, char *buffer);
int primary_car_status_car_status_enum_to_string(primary_car_status_car_status value, char *buffer);

int primary_car_status_to_string(primary_car_status_t *message, char *buffer);

int primary_car_status_to_string_file(primary_car_status_t *message, FILE *buffer);

int primary_car_status_fields(char *buffer);

int primary_car_status_fields_file(FILE *buffer);

/**
 * Pack message CAR_STATUS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_car_status_pack(
    uint8_t *dst_p,
    const primary_car_status_t *src_p,
    size_t bit_size);

/**
 * Unpack message CAR_STATUS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_car_status_unpack(
    primary_car_status_t *dst_p,
    const uint8_t *src_p,
    size_t bit_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_car_status_inverter_l_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_car_status_inverter_r_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_car_status_car_status_is_in_range(uint8_t value);


void primary_das_errors_raw_to_conversion(
    primary_das_errors_converted_t *conversion,
    uint8_t das_error_pedal_adc,
    uint8_t das_error_pedal_implausibility,
    uint8_t das_error_imu_tout,
    uint8_t das_error_irts_tout,
    uint8_t das_error_ts_tout,
    uint8_t das_error_invl_tout,
    uint8_t das_error_invr_tout,
    uint8_t das_error_steer_tout,
    uint8_t das_error_fsm
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_das_errors_conversion_to_raw(
    primary_das_errors_t *raw,
    uint8_t das_error_pedal_adc,
    uint8_t das_error_pedal_implausibility,
    uint8_t das_error_imu_tout,
    uint8_t das_error_irts_tout,
    uint8_t das_error_ts_tout,
    uint8_t das_error_invl_tout,
    uint8_t das_error_invr_tout,
    uint8_t das_error_steer_tout,
    uint8_t das_error_fsm
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_das_errors_raw_to_conversion_struct(
    primary_das_errors_converted_t *conversion, 
    const primary_das_errors_t *raw);


void primary_das_errors_conversion_to_raw_struct(
    primary_das_errors_t *raw,
    const primary_das_errors_converted_t *conversion);


int primary_das_errors_to_string(primary_das_errors_t *message, char *buffer);

int primary_das_errors_to_string_file(primary_das_errors_t *message, FILE *buffer);

int primary_das_errors_fields(char *buffer);

int primary_das_errors_fields_file(FILE *buffer);

/**
 * Pack message DAS_ERRORS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_das_errors_pack(
    uint8_t *dst_p,
    const primary_das_errors_t *src_p,
    size_t bit_size);

/**
 * Unpack message DAS_ERRORS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_das_errors_unpack(
    primary_das_errors_t *dst_p,
    const uint8_t *src_p,
    size_t bit_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_das_errors_das_error_pedal_adc_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_das_errors_das_error_pedal_implausibility_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_das_errors_das_error_imu_tout_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_das_errors_das_error_irts_tout_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_das_errors_das_error_ts_tout_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_das_errors_das_error_invl_tout_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_das_errors_das_error_invr_tout_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_das_errors_das_error_steer_tout_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_das_errors_das_error_fsm_is_in_range(uint8_t value);


void primary_lv_current_raw_to_conversion(
    primary_lv_current_converted_t *conversion,
    float current
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_lv_current_conversion_to_raw(
    primary_lv_current_t *raw,
    float current
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_lv_current_raw_to_conversion_struct(
    primary_lv_current_converted_t *conversion, 
    const primary_lv_current_t *raw);


void primary_lv_current_conversion_to_raw_struct(
    primary_lv_current_t *raw,
    const primary_lv_current_converted_t *conversion);


int primary_lv_current_converted_to_string(primary_lv_current_converted_t *message, char *buffer);

int primary_lv_current_converted_to_string_file(primary_lv_current_converted_t *message, FILE *buffer);

int primary_lv_current_fields(char *buffer);

int primary_lv_current_fields_file(FILE *buffer);

/**
 * Pack message LV_CURRENT.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_lv_current_pack(
    uint8_t *dst_p,
    const primary_lv_current_t *src_p,
    size_t bit_size);

/**
 * Unpack message LV_CURRENT.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_lv_current_unpack(
    primary_lv_current_t *dst_p,
    const uint8_t *src_p,
    size_t bit_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_lv_current_current_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_lv_current_current_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_current_current_is_in_range(uint16_t value);


void primary_lv_voltage_raw_to_conversion(
    primary_lv_voltage_converted_t *conversion,
    float voltage_1,
    float voltage_2,
    float voltage_3,
    float voltage_4
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_lv_voltage_conversion_to_raw(
    primary_lv_voltage_t *raw,
    float voltage_1,
    float voltage_2,
    float voltage_3,
    float voltage_4
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_lv_voltage_raw_to_conversion_struct(
    primary_lv_voltage_converted_t *conversion, 
    const primary_lv_voltage_t *raw);


void primary_lv_voltage_conversion_to_raw_struct(
    primary_lv_voltage_t *raw,
    const primary_lv_voltage_converted_t *conversion);


int primary_lv_voltage_converted_to_string(primary_lv_voltage_converted_t *message, char *buffer);

int primary_lv_voltage_converted_to_string_file(primary_lv_voltage_converted_t *message, FILE *buffer);

int primary_lv_voltage_fields(char *buffer);

int primary_lv_voltage_fields_file(FILE *buffer);

/**
 * Pack message LV_VOLTAGE.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_lv_voltage_pack(
    uint8_t *dst_p,
    const primary_lv_voltage_t *src_p,
    size_t bit_size);

/**
 * Unpack message LV_VOLTAGE.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_lv_voltage_unpack(
    primary_lv_voltage_t *dst_p,
    const uint8_t *src_p,
    size_t bit_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_lv_voltage_voltage_1_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_lv_voltage_voltage_1_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_voltage_voltage_1_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_lv_voltage_voltage_2_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_lv_voltage_voltage_2_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_voltage_voltage_2_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_lv_voltage_voltage_3_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_lv_voltage_voltage_3_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_voltage_voltage_3_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_lv_voltage_voltage_4_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_lv_voltage_voltage_4_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_voltage_voltage_4_is_in_range(uint16_t value);


void primary_lv_total_voltage_raw_to_conversion(
    primary_lv_total_voltage_converted_t *conversion,
    float total_voltage
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_lv_total_voltage_conversion_to_raw(
    primary_lv_total_voltage_t *raw,
    float total_voltage
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_lv_total_voltage_raw_to_conversion_struct(
    primary_lv_total_voltage_converted_t *conversion, 
    const primary_lv_total_voltage_t *raw);


void primary_lv_total_voltage_conversion_to_raw_struct(
    primary_lv_total_voltage_t *raw,
    const primary_lv_total_voltage_converted_t *conversion);


int primary_lv_total_voltage_converted_to_string(primary_lv_total_voltage_converted_t *message, char *buffer);

int primary_lv_total_voltage_converted_to_string_file(primary_lv_total_voltage_converted_t *message, FILE *buffer);

int primary_lv_total_voltage_fields(char *buffer);

int primary_lv_total_voltage_fields_file(FILE *buffer);

/**
 * Pack message LV_TOTAL_VOLTAGE.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_lv_total_voltage_pack(
    uint8_t *dst_p,
    const primary_lv_total_voltage_t *src_p,
    size_t bit_size);

/**
 * Unpack message LV_TOTAL_VOLTAGE.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_lv_total_voltage_unpack(
    primary_lv_total_voltage_t *dst_p,
    const uint8_t *src_p,
    size_t bit_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t primary_lv_total_voltage_total_voltage_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_lv_total_voltage_total_voltage_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_total_voltage_total_voltage_is_in_range(uint32_t value);


void primary_lv_temperature_raw_to_conversion(
    primary_lv_temperature_converted_t *conversion,
    float bp_temperature_1,
    float bp_temperature_2,
    float dcdc12_temperature,
    float dcdc24_temperature
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_lv_temperature_conversion_to_raw(
    primary_lv_temperature_t *raw,
    float bp_temperature_1,
    float bp_temperature_2,
    float dcdc12_temperature,
    float dcdc24_temperature
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_lv_temperature_raw_to_conversion_struct(
    primary_lv_temperature_converted_t *conversion, 
    const primary_lv_temperature_t *raw);


void primary_lv_temperature_conversion_to_raw_struct(
    primary_lv_temperature_t *raw,
    const primary_lv_temperature_converted_t *conversion);


int primary_lv_temperature_converted_to_string(primary_lv_temperature_converted_t *message, char *buffer);

int primary_lv_temperature_converted_to_string_file(primary_lv_temperature_converted_t *message, FILE *buffer);

int primary_lv_temperature_fields(char *buffer);

int primary_lv_temperature_fields_file(FILE *buffer);

/**
 * Pack message LV_TEMPERATURE.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_lv_temperature_pack(
    uint8_t *dst_p,
    const primary_lv_temperature_t *src_p,
    size_t bit_size);

/**
 * Unpack message LV_TEMPERATURE.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_lv_temperature_unpack(
    primary_lv_temperature_t *dst_p,
    const uint8_t *src_p,
    size_t bit_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_lv_temperature_bp_temperature_1_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_lv_temperature_bp_temperature_1_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_temperature_bp_temperature_1_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_lv_temperature_bp_temperature_2_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_lv_temperature_bp_temperature_2_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_temperature_bp_temperature_2_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_lv_temperature_dcdc12_temperature_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_lv_temperature_dcdc12_temperature_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_temperature_dcdc12_temperature_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_lv_temperature_dcdc24_temperature_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_lv_temperature_dcdc24_temperature_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_temperature_dcdc24_temperature_is_in_range(uint16_t value);


void primary_cooling_status_raw_to_conversion(
    primary_cooling_status_converted_t *conversion,
    float radiators_speed,
    float pumps_speed
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_cooling_status_conversion_to_raw(
    primary_cooling_status_t *raw,
    float radiators_speed,
    float pumps_speed
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_cooling_status_raw_to_conversion_struct(
    primary_cooling_status_converted_t *conversion, 
    const primary_cooling_status_t *raw);


void primary_cooling_status_conversion_to_raw_struct(
    primary_cooling_status_t *raw,
    const primary_cooling_status_converted_t *conversion);


int primary_cooling_status_converted_to_string(primary_cooling_status_converted_t *message, char *buffer);

int primary_cooling_status_converted_to_string_file(primary_cooling_status_converted_t *message, FILE *buffer);

int primary_cooling_status_fields(char *buffer);

int primary_cooling_status_fields_file(FILE *buffer);

/**
 * Pack message COOLING_STATUS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_cooling_status_pack(
    uint8_t *dst_p,
    const primary_cooling_status_t *src_p,
    size_t bit_size);

/**
 * Unpack message COOLING_STATUS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_cooling_status_unpack(
    primary_cooling_status_t *dst_p,
    const uint8_t *src_p,
    size_t bit_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_cooling_status_radiators_speed_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_cooling_status_radiators_speed_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_cooling_status_radiators_speed_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_cooling_status_pumps_speed_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_cooling_status_pumps_speed_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_cooling_status_pumps_speed_is_in_range(uint16_t value);


void primary_set_radiator_speed_raw_to_conversion(
    primary_set_radiator_speed_converted_t *conversion,
    float radiators_speed
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_set_radiator_speed_conversion_to_raw(
    primary_set_radiator_speed_t *raw,
    float radiators_speed
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_set_radiator_speed_raw_to_conversion_struct(
    primary_set_radiator_speed_converted_t *conversion, 
    const primary_set_radiator_speed_t *raw);


void primary_set_radiator_speed_conversion_to_raw_struct(
    primary_set_radiator_speed_t *raw,
    const primary_set_radiator_speed_converted_t *conversion);


int primary_set_radiator_speed_converted_to_string(primary_set_radiator_speed_converted_t *message, char *buffer);

int primary_set_radiator_speed_converted_to_string_file(primary_set_radiator_speed_converted_t *message, FILE *buffer);

int primary_set_radiator_speed_fields(char *buffer);

int primary_set_radiator_speed_fields_file(FILE *buffer);

/**
 * Pack message SET_RADIATOR_SPEED.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_set_radiator_speed_pack(
    uint8_t *dst_p,
    const primary_set_radiator_speed_t *src_p,
    size_t bit_size);

/**
 * Unpack message SET_RADIATOR_SPEED.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_set_radiator_speed_unpack(
    primary_set_radiator_speed_t *dst_p,
    const uint8_t *src_p,
    size_t bit_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_set_radiator_speed_radiators_speed_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_set_radiator_speed_radiators_speed_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_set_radiator_speed_radiators_speed_is_in_range(uint16_t value);


void primary_set_pumps_speed_raw_to_conversion(
    primary_set_pumps_speed_converted_t *conversion,
    float pumps_speed
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_set_pumps_speed_conversion_to_raw(
    primary_set_pumps_speed_t *raw,
    float pumps_speed
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_set_pumps_speed_raw_to_conversion_struct(
    primary_set_pumps_speed_converted_t *conversion, 
    const primary_set_pumps_speed_t *raw);


void primary_set_pumps_speed_conversion_to_raw_struct(
    primary_set_pumps_speed_t *raw,
    const primary_set_pumps_speed_converted_t *conversion);


int primary_set_pumps_speed_converted_to_string(primary_set_pumps_speed_converted_t *message, char *buffer);

int primary_set_pumps_speed_converted_to_string_file(primary_set_pumps_speed_converted_t *message, FILE *buffer);

int primary_set_pumps_speed_fields(char *buffer);

int primary_set_pumps_speed_fields_file(FILE *buffer);

/**
 * Pack message SET_PUMPS_SPEED.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_set_pumps_speed_pack(
    uint8_t *dst_p,
    const primary_set_pumps_speed_t *src_p,
    size_t bit_size);

/**
 * Unpack message SET_PUMPS_SPEED.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_set_pumps_speed_unpack(
    primary_set_pumps_speed_t *dst_p,
    const uint8_t *src_p,
    size_t bit_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_set_pumps_speed_pumps_speed_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_set_pumps_speed_pumps_speed_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_set_pumps_speed_pumps_speed_is_in_range(uint16_t value);


void primary_set_inverter_connection_status_raw_to_conversion(
    primary_set_inverter_connection_status_converted_t *conversion,
    primary_set_inverter_connection_status_status status
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_set_inverter_connection_status_conversion_to_raw(
    primary_set_inverter_connection_status_t *raw,
    primary_set_inverter_connection_status_status status
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_set_inverter_connection_status_raw_to_conversion_struct(
    primary_set_inverter_connection_status_converted_t *conversion, 
    const primary_set_inverter_connection_status_t *raw);


void primary_set_inverter_connection_status_conversion_to_raw_struct(
    primary_set_inverter_connection_status_t *raw,
    const primary_set_inverter_connection_status_converted_t *conversion);

int primary_set_inverter_connection_status_status_enum_to_string(primary_set_inverter_connection_status_status value, char *buffer);

int primary_set_inverter_connection_status_to_string(primary_set_inverter_connection_status_t *message, char *buffer);

int primary_set_inverter_connection_status_to_string_file(primary_set_inverter_connection_status_t *message, FILE *buffer);

int primary_set_inverter_connection_status_fields(char *buffer);

int primary_set_inverter_connection_status_fields_file(FILE *buffer);

/**
 * Pack message SET_INVERTER_CONNECTION_STATUS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_set_inverter_connection_status_pack(
    uint8_t *dst_p,
    const primary_set_inverter_connection_status_t *src_p,
    size_t bit_size);

/**
 * Unpack message SET_INVERTER_CONNECTION_STATUS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_set_inverter_connection_status_unpack(
    primary_set_inverter_connection_status_t *dst_p,
    const uint8_t *src_p,
    size_t bit_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_set_inverter_connection_status_status_is_in_range(uint8_t value);


void primary_inverter_connection_status_raw_to_conversion(
    primary_inverter_connection_status_converted_t *conversion,
    primary_inverter_connection_status_status status
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_inverter_connection_status_conversion_to_raw(
    primary_inverter_connection_status_t *raw,
    primary_inverter_connection_status_status status
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_inverter_connection_status_raw_to_conversion_struct(
    primary_inverter_connection_status_converted_t *conversion, 
    const primary_inverter_connection_status_t *raw);


void primary_inverter_connection_status_conversion_to_raw_struct(
    primary_inverter_connection_status_t *raw,
    const primary_inverter_connection_status_converted_t *conversion);

int primary_inverter_connection_status_status_enum_to_string(primary_inverter_connection_status_status value, char *buffer);

int primary_inverter_connection_status_to_string(primary_inverter_connection_status_t *message, char *buffer);

int primary_inverter_connection_status_to_string_file(primary_inverter_connection_status_t *message, FILE *buffer);

int primary_inverter_connection_status_fields(char *buffer);

int primary_inverter_connection_status_fields_file(FILE *buffer);

/**
 * Pack message INVERTER_CONNECTION_STATUS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_inverter_connection_status_pack(
    uint8_t *dst_p,
    const primary_inverter_connection_status_t *src_p,
    size_t bit_size);

/**
 * Unpack message INVERTER_CONNECTION_STATUS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_inverter_connection_status_unpack(
    primary_inverter_connection_status_t *dst_p,
    const uint8_t *src_p,
    size_t bit_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inverter_connection_status_status_is_in_range(uint8_t value);


void primary_lv_errors_raw_to_conversion(
    primary_lv_errors_converted_t *conversion,
    uint8_t warnings_cell_undervoltage,
    uint8_t warnings_cell_overvoltage,
    uint8_t warnings_open_wire,
    uint8_t warnings_can,
    uint8_t warnings_spi,
    uint8_t warnings_over_current,
    uint8_t warnings_dcdc12_under_temperature,
    uint8_t warnings_dcdc12_over_temperature,
    uint8_t warnings_dcdc24_under_temperature,
    uint8_t warnings_dcdc24_over_temperature,
    uint8_t warnings_cell_under_temperature,
    uint8_t warnings_cell_over_temperature,
    uint8_t warnings_relay,
    uint8_t warnings_ltc6810,
    uint8_t warnings_voltages_not_ready,
    uint8_t warnings_mcp23017,
    uint8_t warnings_radiator,
    uint8_t warnings_fan,
    uint8_t warnings_pump,
    uint8_t warnings_adc_init,
    uint8_t warnings_dcdc12,
    uint8_t warnings_dcdc24,
    uint8_t errors_cell_undervoltage,
    uint8_t errors_cell_overvoltage,
    uint8_t errors_open_wire,
    uint8_t errors_can,
    uint8_t errors_spi,
    uint8_t errors_over_current,
    uint8_t errors_dcdc12_under_temperature,
    uint8_t errors_dcdc12_over_temperature,
    uint8_t errors_dcdc24_under_temperature,
    uint8_t errors_dcdc24_over_temperature,
    uint8_t errors_cell_under_temperature,
    uint8_t errors_cell_over_temperature,
    uint8_t errors_relay,
    uint8_t errors_ltc6810,
    uint8_t errors_voltages_not_ready,
    uint8_t errors_mcp23017,
    uint8_t errors_radiator,
    uint8_t errors_fan,
    uint8_t errors_pump,
    uint8_t errors_adc_init,
    uint8_t errors_dcdc12,
    uint8_t errors_dcdc24
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_lv_errors_conversion_to_raw(
    primary_lv_errors_t *raw,
    uint8_t warnings_cell_undervoltage,
    uint8_t warnings_cell_overvoltage,
    uint8_t warnings_open_wire,
    uint8_t warnings_can,
    uint8_t warnings_spi,
    uint8_t warnings_over_current,
    uint8_t warnings_dcdc12_under_temperature,
    uint8_t warnings_dcdc12_over_temperature,
    uint8_t warnings_dcdc24_under_temperature,
    uint8_t warnings_dcdc24_over_temperature,
    uint8_t warnings_cell_under_temperature,
    uint8_t warnings_cell_over_temperature,
    uint8_t warnings_relay,
    uint8_t warnings_ltc6810,
    uint8_t warnings_voltages_not_ready,
    uint8_t warnings_mcp23017,
    uint8_t warnings_radiator,
    uint8_t warnings_fan,
    uint8_t warnings_pump,
    uint8_t warnings_adc_init,
    uint8_t warnings_dcdc12,
    uint8_t warnings_dcdc24,
    uint8_t errors_cell_undervoltage,
    uint8_t errors_cell_overvoltage,
    uint8_t errors_open_wire,
    uint8_t errors_can,
    uint8_t errors_spi,
    uint8_t errors_over_current,
    uint8_t errors_dcdc12_under_temperature,
    uint8_t errors_dcdc12_over_temperature,
    uint8_t errors_dcdc24_under_temperature,
    uint8_t errors_dcdc24_over_temperature,
    uint8_t errors_cell_under_temperature,
    uint8_t errors_cell_over_temperature,
    uint8_t errors_relay,
    uint8_t errors_ltc6810,
    uint8_t errors_voltages_not_ready,
    uint8_t errors_mcp23017,
    uint8_t errors_radiator,
    uint8_t errors_fan,
    uint8_t errors_pump,
    uint8_t errors_adc_init,
    uint8_t errors_dcdc12,
    uint8_t errors_dcdc24
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_lv_errors_raw_to_conversion_struct(
    primary_lv_errors_converted_t *conversion, 
    const primary_lv_errors_t *raw);


void primary_lv_errors_conversion_to_raw_struct(
    primary_lv_errors_t *raw,
    const primary_lv_errors_converted_t *conversion);


int primary_lv_errors_to_string(primary_lv_errors_t *message, char *buffer);

int primary_lv_errors_to_string_file(primary_lv_errors_t *message, FILE *buffer);

int primary_lv_errors_fields(char *buffer);

int primary_lv_errors_fields_file(FILE *buffer);

/**
 * Pack message LV_ERRORS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_lv_errors_pack(
    uint8_t *dst_p,
    const primary_lv_errors_t *src_p,
    size_t bit_size);

/**
 * Unpack message LV_ERRORS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_lv_errors_unpack(
    primary_lv_errors_t *dst_p,
    const uint8_t *src_p,
    size_t bit_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_errors_warnings_cell_undervoltage_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_errors_warnings_cell_overvoltage_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_errors_warnings_open_wire_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_errors_warnings_can_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_errors_warnings_spi_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_errors_warnings_over_current_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_errors_warnings_dcdc12_under_temperature_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_errors_warnings_dcdc12_over_temperature_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_errors_warnings_dcdc24_under_temperature_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_errors_warnings_dcdc24_over_temperature_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_errors_warnings_cell_under_temperature_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_errors_warnings_cell_over_temperature_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_errors_warnings_relay_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_errors_warnings_ltc6810_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_errors_warnings_voltages_not_ready_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_errors_warnings_mcp23017_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_errors_warnings_radiator_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_errors_warnings_fan_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_errors_warnings_pump_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_errors_warnings_adc_init_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_errors_warnings_dcdc12_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_errors_warnings_dcdc24_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_errors_errors_cell_undervoltage_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_errors_errors_cell_overvoltage_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_errors_errors_open_wire_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_errors_errors_can_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_errors_errors_spi_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_errors_errors_over_current_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_errors_errors_dcdc12_under_temperature_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_errors_errors_dcdc12_over_temperature_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_errors_errors_dcdc24_under_temperature_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_errors_errors_dcdc24_over_temperature_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_errors_errors_cell_under_temperature_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_errors_errors_cell_over_temperature_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_errors_errors_relay_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_errors_errors_ltc6810_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_errors_errors_voltages_not_ready_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_errors_errors_mcp23017_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_errors_errors_radiator_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_errors_errors_fan_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_errors_errors_pump_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_errors_errors_adc_init_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_errors_errors_dcdc12_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_lv_errors_errors_dcdc24_is_in_range(uint8_t value);


void primary_shutdown_status_raw_to_conversion(
    primary_shutdown_status_converted_t *conversion,
    uint8_t input,
    uint8_t output
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_shutdown_status_conversion_to_raw(
    primary_shutdown_status_t *raw,
    uint8_t input,
    uint8_t output
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_shutdown_status_raw_to_conversion_struct(
    primary_shutdown_status_converted_t *conversion, 
    const primary_shutdown_status_t *raw);


void primary_shutdown_status_conversion_to_raw_struct(
    primary_shutdown_status_t *raw,
    const primary_shutdown_status_converted_t *conversion);


int primary_shutdown_status_to_string(primary_shutdown_status_t *message, char *buffer);

int primary_shutdown_status_to_string_file(primary_shutdown_status_t *message, FILE *buffer);

int primary_shutdown_status_fields(char *buffer);

int primary_shutdown_status_fields_file(FILE *buffer);

/**
 * Pack message SHUTDOWN_STATUS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_shutdown_status_pack(
    uint8_t *dst_p,
    const primary_shutdown_status_t *src_p,
    size_t bit_size);

/**
 * Unpack message SHUTDOWN_STATUS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_shutdown_status_unpack(
    primary_shutdown_status_t *dst_p,
    const uint8_t *src_p,
    size_t bit_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_shutdown_status_input_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_shutdown_status_output_is_in_range(uint8_t value);


;


;


void primary_marker_raw_to_conversion_struct(
    primary_marker_converted_t *conversion, 
    const primary_marker_t *raw);


void primary_marker_conversion_to_raw_struct(
    primary_marker_t *raw,
    const primary_marker_converted_t *conversion);


int primary_marker_to_string(primary_marker_t *message, char *buffer);

int primary_marker_to_string_file(primary_marker_t *message, FILE *buffer);

int primary_marker_fields(char *buffer);

int primary_marker_fields_file(FILE *buffer);

/**
 * Pack message MARKER.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_marker_pack(
    uint8_t *dst_p,
    const primary_marker_t *src_p,
    size_t bit_size);

/**
 * Unpack message MARKER.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_marker_unpack(
    primary_marker_t *dst_p,
    const uint8_t *src_p,
    size_t bit_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


void primary_hv_cells_voltage_raw_to_conversion(
    primary_hv_cells_voltage_converted_t *conversion,
    uint8_t start_index,
    float voltage_0,
    float voltage_1,
    float voltage_2
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_hv_cells_voltage_conversion_to_raw(
    primary_hv_cells_voltage_t *raw,
    uint8_t start_index,
    float voltage_0,
    float voltage_1,
    float voltage_2
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_hv_cells_voltage_raw_to_conversion_struct(
    primary_hv_cells_voltage_converted_t *conversion, 
    const primary_hv_cells_voltage_t *raw);


void primary_hv_cells_voltage_conversion_to_raw_struct(
    primary_hv_cells_voltage_t *raw,
    const primary_hv_cells_voltage_converted_t *conversion);


int primary_hv_cells_voltage_converted_to_string(primary_hv_cells_voltage_converted_t *message, char *buffer);

int primary_hv_cells_voltage_converted_to_string_file(primary_hv_cells_voltage_converted_t *message, FILE *buffer);

int primary_hv_cells_voltage_fields(char *buffer);

int primary_hv_cells_voltage_fields_file(FILE *buffer);

/**
 * Pack message HV_CELLS_VOLTAGE.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_hv_cells_voltage_pack(
    uint8_t *dst_p,
    const primary_hv_cells_voltage_t *src_p,
    size_t bit_size);

/**
 * Unpack message HV_CELLS_VOLTAGE.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_hv_cells_voltage_unpack(
    primary_hv_cells_voltage_t *dst_p,
    const uint8_t *src_p,
    size_t bit_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_cells_voltage_start_index_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_hv_cells_voltage_voltage_0_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_hv_cells_voltage_voltage_0_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_cells_voltage_voltage_0_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_hv_cells_voltage_voltage_1_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_hv_cells_voltage_voltage_1_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_cells_voltage_voltage_1_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_hv_cells_voltage_voltage_2_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_hv_cells_voltage_voltage_2_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_cells_voltage_voltage_2_is_in_range(uint16_t value);


void primary_hv_cells_temp_raw_to_conversion(
    primary_hv_cells_temp_converted_t *conversion,
    uint8_t start_index,
    float temp_0,
    float temp_1,
    float temp_2,
    float temp_3,
    float temp_4,
    float temp_5
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_hv_cells_temp_conversion_to_raw(
    primary_hv_cells_temp_t *raw,
    uint8_t start_index,
    float temp_0,
    float temp_1,
    float temp_2,
    float temp_3,
    float temp_4,
    float temp_5
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_hv_cells_temp_raw_to_conversion_struct(
    primary_hv_cells_temp_converted_t *conversion, 
    const primary_hv_cells_temp_t *raw);


void primary_hv_cells_temp_conversion_to_raw_struct(
    primary_hv_cells_temp_t *raw,
    const primary_hv_cells_temp_converted_t *conversion);


int primary_hv_cells_temp_converted_to_string(primary_hv_cells_temp_converted_t *message, char *buffer);

int primary_hv_cells_temp_converted_to_string_file(primary_hv_cells_temp_converted_t *message, FILE *buffer);

int primary_hv_cells_temp_fields(char *buffer);

int primary_hv_cells_temp_fields_file(FILE *buffer);

/**
 * Pack message HV_CELLS_TEMP.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_hv_cells_temp_pack(
    uint8_t *dst_p,
    const primary_hv_cells_temp_t *src_p,
    size_t bit_size);

/**
 * Unpack message HV_CELLS_TEMP.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_hv_cells_temp_unpack(
    primary_hv_cells_temp_t *dst_p,
    const uint8_t *src_p,
    size_t bit_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_cells_temp_start_index_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t primary_hv_cells_temp_temp_0_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_hv_cells_temp_temp_0_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_cells_temp_temp_0_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t primary_hv_cells_temp_temp_1_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_hv_cells_temp_temp_1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_cells_temp_temp_1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t primary_hv_cells_temp_temp_2_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_hv_cells_temp_temp_2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_cells_temp_temp_2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t primary_hv_cells_temp_temp_3_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_hv_cells_temp_temp_3_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_cells_temp_temp_3_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t primary_hv_cells_temp_temp_4_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_hv_cells_temp_temp_4_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_cells_temp_temp_4_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t primary_hv_cells_temp_temp_5_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_hv_cells_temp_temp_5_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_cells_temp_temp_5_is_in_range(uint8_t value);


void primary_hv_cell_balancing_status_raw_to_conversion(
    primary_hv_cell_balancing_status_converted_t *conversion,
    primary_hv_cell_balancing_status_balancing_status balancing_status
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_hv_cell_balancing_status_conversion_to_raw(
    primary_hv_cell_balancing_status_t *raw,
    primary_hv_cell_balancing_status_balancing_status balancing_status
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_hv_cell_balancing_status_raw_to_conversion_struct(
    primary_hv_cell_balancing_status_converted_t *conversion, 
    const primary_hv_cell_balancing_status_t *raw);


void primary_hv_cell_balancing_status_conversion_to_raw_struct(
    primary_hv_cell_balancing_status_t *raw,
    const primary_hv_cell_balancing_status_converted_t *conversion);

int primary_hv_cell_balancing_status_balancing_status_enum_to_string(primary_hv_cell_balancing_status_balancing_status value, char *buffer);

int primary_hv_cell_balancing_status_to_string(primary_hv_cell_balancing_status_t *message, char *buffer);

int primary_hv_cell_balancing_status_to_string_file(primary_hv_cell_balancing_status_t *message, FILE *buffer);

int primary_hv_cell_balancing_status_fields(char *buffer);

int primary_hv_cell_balancing_status_fields_file(FILE *buffer);

/**
 * Pack message HV_CELL_BALANCING_STATUS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_hv_cell_balancing_status_pack(
    uint8_t *dst_p,
    const primary_hv_cell_balancing_status_t *src_p,
    size_t bit_size);

/**
 * Unpack message HV_CELL_BALANCING_STATUS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_hv_cell_balancing_status_unpack(
    primary_hv_cell_balancing_status_t *dst_p,
    const uint8_t *src_p,
    size_t bit_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_hv_cell_balancing_status_balancing_status_is_in_range(uint8_t value);


void primary_set_cell_balancing_status_raw_to_conversion(
    primary_set_cell_balancing_status_converted_t *conversion,
    primary_set_cell_balancing_status_set_balancing_status set_balancing_status
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_set_cell_balancing_status_conversion_to_raw(
    primary_set_cell_balancing_status_t *raw,
    primary_set_cell_balancing_status_set_balancing_status set_balancing_status
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_set_cell_balancing_status_raw_to_conversion_struct(
    primary_set_cell_balancing_status_converted_t *conversion, 
    const primary_set_cell_balancing_status_t *raw);


void primary_set_cell_balancing_status_conversion_to_raw_struct(
    primary_set_cell_balancing_status_t *raw,
    const primary_set_cell_balancing_status_converted_t *conversion);

int primary_set_cell_balancing_status_set_balancing_status_enum_to_string(primary_set_cell_balancing_status_set_balancing_status value, char *buffer);

int primary_set_cell_balancing_status_to_string(primary_set_cell_balancing_status_t *message, char *buffer);

int primary_set_cell_balancing_status_to_string_file(primary_set_cell_balancing_status_t *message, FILE *buffer);

int primary_set_cell_balancing_status_fields(char *buffer);

int primary_set_cell_balancing_status_fields_file(FILE *buffer);

/**
 * Pack message SET_CELL_BALANCING_STATUS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_set_cell_balancing_status_pack(
    uint8_t *dst_p,
    const primary_set_cell_balancing_status_t *src_p,
    size_t bit_size);

/**
 * Unpack message SET_CELL_BALANCING_STATUS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_set_cell_balancing_status_unpack(
    primary_set_cell_balancing_status_t *dst_p,
    const uint8_t *src_p,
    size_t bit_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_set_cell_balancing_status_set_balancing_status_is_in_range(uint8_t value);


void primary_handcart_status_raw_to_conversion(
    primary_handcart_status_converted_t *conversion,
    uint8_t connected
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_handcart_status_conversion_to_raw(
    primary_handcart_status_t *raw,
    uint8_t connected
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_handcart_status_raw_to_conversion_struct(
    primary_handcart_status_converted_t *conversion, 
    const primary_handcart_status_t *raw);


void primary_handcart_status_conversion_to_raw_struct(
    primary_handcart_status_t *raw,
    const primary_handcart_status_converted_t *conversion);


int primary_handcart_status_to_string(primary_handcart_status_t *message, char *buffer);

int primary_handcart_status_to_string_file(primary_handcart_status_t *message, FILE *buffer);

int primary_handcart_status_fields(char *buffer);

int primary_handcart_status_fields_file(FILE *buffer);

/**
 * Pack message HANDCART_STATUS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_handcart_status_pack(
    uint8_t *dst_p,
    const primary_handcart_status_t *src_p,
    size_t bit_size);

/**
 * Unpack message HANDCART_STATUS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_handcart_status_unpack(
    primary_handcart_status_t *dst_p,
    const uint8_t *src_p,
    size_t bit_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_handcart_status_connected_is_in_range(uint8_t value);


void primary_speed_raw_to_conversion(
    primary_speed_converted_t *conversion,
    float encoder_r,
    float encoder_l,
    float inverter_r,
    float inverter_l
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_speed_conversion_to_raw(
    primary_speed_t *raw,
    float encoder_r,
    float encoder_l,
    float inverter_r,
    float inverter_l
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_speed_raw_to_conversion_struct(
    primary_speed_converted_t *conversion, 
    const primary_speed_t *raw);


void primary_speed_conversion_to_raw_struct(
    primary_speed_t *raw,
    const primary_speed_converted_t *conversion);


int primary_speed_converted_to_string(primary_speed_converted_t *message, char *buffer);

int primary_speed_converted_to_string_file(primary_speed_converted_t *message, FILE *buffer);

int primary_speed_fields(char *buffer);

int primary_speed_fields_file(FILE *buffer);

/**
 * Pack message SPEED.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_speed_pack(
    uint8_t *dst_p,
    const primary_speed_t *src_p,
    size_t bit_size);

/**
 * Unpack message SPEED.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_speed_unpack(
    primary_speed_t *dst_p,
    const uint8_t *src_p,
    size_t bit_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_speed_encoder_r_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_speed_encoder_r_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_speed_encoder_r_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_speed_encoder_l_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_speed_encoder_l_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_speed_encoder_l_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_speed_inverter_r_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_speed_inverter_r_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_speed_inverter_r_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_speed_inverter_l_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_speed_inverter_l_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_speed_inverter_l_is_in_range(uint16_t value);


void primary_inv_l_request_raw_to_conversion(
    primary_inv_l_request_converted_t *conversion,
    uint8_t data_0,
    uint8_t data_1,
    uint8_t data_2,
    uint8_t data_3,
    uint8_t data_4,
    uint8_t data_5,
    uint8_t data_6,
    uint8_t data_7
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_inv_l_request_conversion_to_raw(
    primary_inv_l_request_t *raw,
    uint8_t data_0,
    uint8_t data_1,
    uint8_t data_2,
    uint8_t data_3,
    uint8_t data_4,
    uint8_t data_5,
    uint8_t data_6,
    uint8_t data_7
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_inv_l_request_raw_to_conversion_struct(
    primary_inv_l_request_converted_t *conversion, 
    const primary_inv_l_request_t *raw);


void primary_inv_l_request_conversion_to_raw_struct(
    primary_inv_l_request_t *raw,
    const primary_inv_l_request_converted_t *conversion);


int primary_inv_l_request_to_string(primary_inv_l_request_t *message, char *buffer);

int primary_inv_l_request_to_string_file(primary_inv_l_request_t *message, FILE *buffer);

int primary_inv_l_request_fields(char *buffer);

int primary_inv_l_request_fields_file(FILE *buffer);

/**
 * Pack message INV_L_REQUEST.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_inv_l_request_pack(
    uint8_t *dst_p,
    const primary_inv_l_request_t *src_p,
    size_t bit_size);

/**
 * Unpack message INV_L_REQUEST.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_inv_l_request_unpack(
    primary_inv_l_request_t *dst_p,
    const uint8_t *src_p,
    size_t bit_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inv_l_request_data_0_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inv_l_request_data_1_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inv_l_request_data_2_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inv_l_request_data_3_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inv_l_request_data_4_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inv_l_request_data_5_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inv_l_request_data_6_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inv_l_request_data_7_is_in_range(uint8_t value);


void primary_inv_r_request_raw_to_conversion(
    primary_inv_r_request_converted_t *conversion,
    uint8_t data_0,
    uint8_t data_1,
    uint8_t data_2,
    uint8_t data_3,
    uint8_t data_4,
    uint8_t data_5,
    uint8_t data_6,
    uint8_t data_7
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_inv_r_request_conversion_to_raw(
    primary_inv_r_request_t *raw,
    uint8_t data_0,
    uint8_t data_1,
    uint8_t data_2,
    uint8_t data_3,
    uint8_t data_4,
    uint8_t data_5,
    uint8_t data_6,
    uint8_t data_7
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_inv_r_request_raw_to_conversion_struct(
    primary_inv_r_request_converted_t *conversion, 
    const primary_inv_r_request_t *raw);


void primary_inv_r_request_conversion_to_raw_struct(
    primary_inv_r_request_t *raw,
    const primary_inv_r_request_converted_t *conversion);


int primary_inv_r_request_to_string(primary_inv_r_request_t *message, char *buffer);

int primary_inv_r_request_to_string_file(primary_inv_r_request_t *message, FILE *buffer);

int primary_inv_r_request_fields(char *buffer);

int primary_inv_r_request_fields_file(FILE *buffer);

/**
 * Pack message INV_R_REQUEST.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_inv_r_request_pack(
    uint8_t *dst_p,
    const primary_inv_r_request_t *src_p,
    size_t bit_size);

/**
 * Unpack message INV_R_REQUEST.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_inv_r_request_unpack(
    primary_inv_r_request_t *dst_p,
    const uint8_t *src_p,
    size_t bit_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inv_r_request_data_0_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inv_r_request_data_1_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inv_r_request_data_2_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inv_r_request_data_3_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inv_r_request_data_4_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inv_r_request_data_5_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inv_r_request_data_6_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inv_r_request_data_7_is_in_range(uint8_t value);


void primary_inv_l_response_raw_to_conversion(
    primary_inv_l_response_converted_t *conversion,
    uint8_t reg_id,
    uint8_t data_0,
    uint8_t data_1,
    uint8_t data_2,
    uint8_t data_3,
    uint8_t data_4,
    uint8_t data_5,
    uint8_t data_6
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_inv_l_response_conversion_to_raw(
    primary_inv_l_response_t *raw,
    uint8_t reg_id,
    uint8_t data_0,
    uint8_t data_1,
    uint8_t data_2,
    uint8_t data_3,
    uint8_t data_4,
    uint8_t data_5,
    uint8_t data_6
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_inv_l_response_raw_to_conversion_struct(
    primary_inv_l_response_converted_t *conversion, 
    const primary_inv_l_response_t *raw);


void primary_inv_l_response_conversion_to_raw_struct(
    primary_inv_l_response_t *raw,
    const primary_inv_l_response_converted_t *conversion);


int primary_inv_l_response_to_string(primary_inv_l_response_t *message, char *buffer);

int primary_inv_l_response_to_string_file(primary_inv_l_response_t *message, FILE *buffer);

int primary_inv_l_response_fields(char *buffer);

int primary_inv_l_response_fields_file(FILE *buffer);

/**
 * Pack message INV_L_RESPONSE.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_inv_l_response_pack(
    uint8_t *dst_p,
    const primary_inv_l_response_t *src_p,
    size_t bit_size);

/**
 * Unpack message INV_L_RESPONSE.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_inv_l_response_unpack(
    primary_inv_l_response_t *dst_p,
    const uint8_t *src_p,
    size_t bit_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inv_l_response_reg_id_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inv_l_response_data_0_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inv_l_response_data_1_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inv_l_response_data_2_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inv_l_response_data_3_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inv_l_response_data_4_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inv_l_response_data_5_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inv_l_response_data_6_is_in_range(uint8_t value);


void primary_inv_r_response_raw_to_conversion(
    primary_inv_r_response_converted_t *conversion,
    uint8_t reg_id,
    uint8_t data_0,
    uint8_t data_1,
    uint8_t data_2,
    uint8_t data_3,
    uint8_t data_4,
    uint8_t data_5,
    uint8_t data_6
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_inv_r_response_conversion_to_raw(
    primary_inv_r_response_t *raw,
    uint8_t reg_id,
    uint8_t data_0,
    uint8_t data_1,
    uint8_t data_2,
    uint8_t data_3,
    uint8_t data_4,
    uint8_t data_5,
    uint8_t data_6
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_inv_r_response_raw_to_conversion_struct(
    primary_inv_r_response_converted_t *conversion, 
    const primary_inv_r_response_t *raw);


void primary_inv_r_response_conversion_to_raw_struct(
    primary_inv_r_response_t *raw,
    const primary_inv_r_response_converted_t *conversion);


int primary_inv_r_response_to_string(primary_inv_r_response_t *message, char *buffer);

int primary_inv_r_response_to_string_file(primary_inv_r_response_t *message, FILE *buffer);

int primary_inv_r_response_fields(char *buffer);

int primary_inv_r_response_fields_file(FILE *buffer);

/**
 * Pack message INV_R_RESPONSE.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_inv_r_response_pack(
    uint8_t *dst_p,
    const primary_inv_r_response_t *src_p,
    size_t bit_size);

/**
 * Unpack message INV_R_RESPONSE.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_inv_r_response_unpack(
    primary_inv_r_response_t *dst_p,
    const uint8_t *src_p,
    size_t bit_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inv_r_response_reg_id_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inv_r_response_data_0_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inv_r_response_data_1_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inv_r_response_data_2_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inv_r_response_data_3_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inv_r_response_data_4_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inv_r_response_data_5_is_in_range(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_inv_r_response_data_6_is_in_range(uint8_t value);


;


;


void primary_flash_cellboard_0_tx_raw_to_conversion_struct(
    primary_flash_cellboard_0_tx_converted_t *conversion, 
    const primary_flash_cellboard_0_tx_t *raw);


void primary_flash_cellboard_0_tx_conversion_to_raw_struct(
    primary_flash_cellboard_0_tx_t *raw,
    const primary_flash_cellboard_0_tx_converted_t *conversion);


int primary_flash_cellboard_0_tx_to_string(primary_flash_cellboard_0_tx_t *message, char *buffer);

int primary_flash_cellboard_0_tx_to_string_file(primary_flash_cellboard_0_tx_t *message, FILE *buffer);

int primary_flash_cellboard_0_tx_fields(char *buffer);

int primary_flash_cellboard_0_tx_fields_file(FILE *buffer);

/**
 * Pack message FLASH_CELLBOARD_0_TX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_flash_cellboard_0_tx_pack(
    uint8_t *dst_p,
    const primary_flash_cellboard_0_tx_t *src_p,
    size_t bit_size);

/**
 * Unpack message FLASH_CELLBOARD_0_TX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_flash_cellboard_0_tx_unpack(
    primary_flash_cellboard_0_tx_t *dst_p,
    const uint8_t *src_p,
    size_t bit_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void primary_flash_cellboard_0_rx_raw_to_conversion_struct(
    primary_flash_cellboard_0_rx_converted_t *conversion, 
    const primary_flash_cellboard_0_rx_t *raw);


void primary_flash_cellboard_0_rx_conversion_to_raw_struct(
    primary_flash_cellboard_0_rx_t *raw,
    const primary_flash_cellboard_0_rx_converted_t *conversion);


int primary_flash_cellboard_0_rx_to_string(primary_flash_cellboard_0_rx_t *message, char *buffer);

int primary_flash_cellboard_0_rx_to_string_file(primary_flash_cellboard_0_rx_t *message, FILE *buffer);

int primary_flash_cellboard_0_rx_fields(char *buffer);

int primary_flash_cellboard_0_rx_fields_file(FILE *buffer);

/**
 * Pack message FLASH_CELLBOARD_0_RX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_flash_cellboard_0_rx_pack(
    uint8_t *dst_p,
    const primary_flash_cellboard_0_rx_t *src_p,
    size_t bit_size);

/**
 * Unpack message FLASH_CELLBOARD_0_RX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_flash_cellboard_0_rx_unpack(
    primary_flash_cellboard_0_rx_t *dst_p,
    const uint8_t *src_p,
    size_t bit_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void primary_flash_cellboard_1_tx_raw_to_conversion_struct(
    primary_flash_cellboard_1_tx_converted_t *conversion, 
    const primary_flash_cellboard_1_tx_t *raw);


void primary_flash_cellboard_1_tx_conversion_to_raw_struct(
    primary_flash_cellboard_1_tx_t *raw,
    const primary_flash_cellboard_1_tx_converted_t *conversion);


int primary_flash_cellboard_1_tx_to_string(primary_flash_cellboard_1_tx_t *message, char *buffer);

int primary_flash_cellboard_1_tx_to_string_file(primary_flash_cellboard_1_tx_t *message, FILE *buffer);

int primary_flash_cellboard_1_tx_fields(char *buffer);

int primary_flash_cellboard_1_tx_fields_file(FILE *buffer);

/**
 * Pack message FLASH_CELLBOARD_1_TX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_flash_cellboard_1_tx_pack(
    uint8_t *dst_p,
    const primary_flash_cellboard_1_tx_t *src_p,
    size_t bit_size);

/**
 * Unpack message FLASH_CELLBOARD_1_TX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_flash_cellboard_1_tx_unpack(
    primary_flash_cellboard_1_tx_t *dst_p,
    const uint8_t *src_p,
    size_t bit_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void primary_flash_cellboard_1_rx_raw_to_conversion_struct(
    primary_flash_cellboard_1_rx_converted_t *conversion, 
    const primary_flash_cellboard_1_rx_t *raw);


void primary_flash_cellboard_1_rx_conversion_to_raw_struct(
    primary_flash_cellboard_1_rx_t *raw,
    const primary_flash_cellboard_1_rx_converted_t *conversion);


int primary_flash_cellboard_1_rx_to_string(primary_flash_cellboard_1_rx_t *message, char *buffer);

int primary_flash_cellboard_1_rx_to_string_file(primary_flash_cellboard_1_rx_t *message, FILE *buffer);

int primary_flash_cellboard_1_rx_fields(char *buffer);

int primary_flash_cellboard_1_rx_fields_file(FILE *buffer);

/**
 * Pack message FLASH_CELLBOARD_1_RX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_flash_cellboard_1_rx_pack(
    uint8_t *dst_p,
    const primary_flash_cellboard_1_rx_t *src_p,
    size_t bit_size);

/**
 * Unpack message FLASH_CELLBOARD_1_RX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_flash_cellboard_1_rx_unpack(
    primary_flash_cellboard_1_rx_t *dst_p,
    const uint8_t *src_p,
    size_t bit_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void primary_flash_cellboard_2_tx_raw_to_conversion_struct(
    primary_flash_cellboard_2_tx_converted_t *conversion, 
    const primary_flash_cellboard_2_tx_t *raw);


void primary_flash_cellboard_2_tx_conversion_to_raw_struct(
    primary_flash_cellboard_2_tx_t *raw,
    const primary_flash_cellboard_2_tx_converted_t *conversion);


int primary_flash_cellboard_2_tx_to_string(primary_flash_cellboard_2_tx_t *message, char *buffer);

int primary_flash_cellboard_2_tx_to_string_file(primary_flash_cellboard_2_tx_t *message, FILE *buffer);

int primary_flash_cellboard_2_tx_fields(char *buffer);

int primary_flash_cellboard_2_tx_fields_file(FILE *buffer);

/**
 * Pack message FLASH_CELLBOARD_2_TX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_flash_cellboard_2_tx_pack(
    uint8_t *dst_p,
    const primary_flash_cellboard_2_tx_t *src_p,
    size_t bit_size);

/**
 * Unpack message FLASH_CELLBOARD_2_TX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_flash_cellboard_2_tx_unpack(
    primary_flash_cellboard_2_tx_t *dst_p,
    const uint8_t *src_p,
    size_t bit_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void primary_flash_cellboard_2_rx_raw_to_conversion_struct(
    primary_flash_cellboard_2_rx_converted_t *conversion, 
    const primary_flash_cellboard_2_rx_t *raw);


void primary_flash_cellboard_2_rx_conversion_to_raw_struct(
    primary_flash_cellboard_2_rx_t *raw,
    const primary_flash_cellboard_2_rx_converted_t *conversion);


int primary_flash_cellboard_2_rx_to_string(primary_flash_cellboard_2_rx_t *message, char *buffer);

int primary_flash_cellboard_2_rx_to_string_file(primary_flash_cellboard_2_rx_t *message, FILE *buffer);

int primary_flash_cellboard_2_rx_fields(char *buffer);

int primary_flash_cellboard_2_rx_fields_file(FILE *buffer);

/**
 * Pack message FLASH_CELLBOARD_2_RX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_flash_cellboard_2_rx_pack(
    uint8_t *dst_p,
    const primary_flash_cellboard_2_rx_t *src_p,
    size_t bit_size);

/**
 * Unpack message FLASH_CELLBOARD_2_RX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_flash_cellboard_2_rx_unpack(
    primary_flash_cellboard_2_rx_t *dst_p,
    const uint8_t *src_p,
    size_t bit_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void primary_flash_cellboard_3_tx_raw_to_conversion_struct(
    primary_flash_cellboard_3_tx_converted_t *conversion, 
    const primary_flash_cellboard_3_tx_t *raw);


void primary_flash_cellboard_3_tx_conversion_to_raw_struct(
    primary_flash_cellboard_3_tx_t *raw,
    const primary_flash_cellboard_3_tx_converted_t *conversion);


int primary_flash_cellboard_3_tx_to_string(primary_flash_cellboard_3_tx_t *message, char *buffer);

int primary_flash_cellboard_3_tx_to_string_file(primary_flash_cellboard_3_tx_t *message, FILE *buffer);

int primary_flash_cellboard_3_tx_fields(char *buffer);

int primary_flash_cellboard_3_tx_fields_file(FILE *buffer);

/**
 * Pack message FLASH_CELLBOARD_3_TX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_flash_cellboard_3_tx_pack(
    uint8_t *dst_p,
    const primary_flash_cellboard_3_tx_t *src_p,
    size_t bit_size);

/**
 * Unpack message FLASH_CELLBOARD_3_TX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_flash_cellboard_3_tx_unpack(
    primary_flash_cellboard_3_tx_t *dst_p,
    const uint8_t *src_p,
    size_t bit_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void primary_flash_cellboard_3_rx_raw_to_conversion_struct(
    primary_flash_cellboard_3_rx_converted_t *conversion, 
    const primary_flash_cellboard_3_rx_t *raw);


void primary_flash_cellboard_3_rx_conversion_to_raw_struct(
    primary_flash_cellboard_3_rx_t *raw,
    const primary_flash_cellboard_3_rx_converted_t *conversion);


int primary_flash_cellboard_3_rx_to_string(primary_flash_cellboard_3_rx_t *message, char *buffer);

int primary_flash_cellboard_3_rx_to_string_file(primary_flash_cellboard_3_rx_t *message, FILE *buffer);

int primary_flash_cellboard_3_rx_fields(char *buffer);

int primary_flash_cellboard_3_rx_fields_file(FILE *buffer);

/**
 * Pack message FLASH_CELLBOARD_3_RX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_flash_cellboard_3_rx_pack(
    uint8_t *dst_p,
    const primary_flash_cellboard_3_rx_t *src_p,
    size_t bit_size);

/**
 * Unpack message FLASH_CELLBOARD_3_RX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_flash_cellboard_3_rx_unpack(
    primary_flash_cellboard_3_rx_t *dst_p,
    const uint8_t *src_p,
    size_t bit_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void primary_flash_cellboard_4_tx_raw_to_conversion_struct(
    primary_flash_cellboard_4_tx_converted_t *conversion, 
    const primary_flash_cellboard_4_tx_t *raw);


void primary_flash_cellboard_4_tx_conversion_to_raw_struct(
    primary_flash_cellboard_4_tx_t *raw,
    const primary_flash_cellboard_4_tx_converted_t *conversion);


int primary_flash_cellboard_4_tx_to_string(primary_flash_cellboard_4_tx_t *message, char *buffer);

int primary_flash_cellboard_4_tx_to_string_file(primary_flash_cellboard_4_tx_t *message, FILE *buffer);

int primary_flash_cellboard_4_tx_fields(char *buffer);

int primary_flash_cellboard_4_tx_fields_file(FILE *buffer);

/**
 * Pack message FLASH_CELLBOARD_4_TX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_flash_cellboard_4_tx_pack(
    uint8_t *dst_p,
    const primary_flash_cellboard_4_tx_t *src_p,
    size_t bit_size);

/**
 * Unpack message FLASH_CELLBOARD_4_TX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_flash_cellboard_4_tx_unpack(
    primary_flash_cellboard_4_tx_t *dst_p,
    const uint8_t *src_p,
    size_t bit_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void primary_flash_cellboard_4_rx_raw_to_conversion_struct(
    primary_flash_cellboard_4_rx_converted_t *conversion, 
    const primary_flash_cellboard_4_rx_t *raw);


void primary_flash_cellboard_4_rx_conversion_to_raw_struct(
    primary_flash_cellboard_4_rx_t *raw,
    const primary_flash_cellboard_4_rx_converted_t *conversion);


int primary_flash_cellboard_4_rx_to_string(primary_flash_cellboard_4_rx_t *message, char *buffer);

int primary_flash_cellboard_4_rx_to_string_file(primary_flash_cellboard_4_rx_t *message, FILE *buffer);

int primary_flash_cellboard_4_rx_fields(char *buffer);

int primary_flash_cellboard_4_rx_fields_file(FILE *buffer);

/**
 * Pack message FLASH_CELLBOARD_4_RX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_flash_cellboard_4_rx_pack(
    uint8_t *dst_p,
    const primary_flash_cellboard_4_rx_t *src_p,
    size_t bit_size);

/**
 * Unpack message FLASH_CELLBOARD_4_RX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_flash_cellboard_4_rx_unpack(
    primary_flash_cellboard_4_rx_t *dst_p,
    const uint8_t *src_p,
    size_t bit_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void primary_flash_cellboard_5_tx_raw_to_conversion_struct(
    primary_flash_cellboard_5_tx_converted_t *conversion, 
    const primary_flash_cellboard_5_tx_t *raw);


void primary_flash_cellboard_5_tx_conversion_to_raw_struct(
    primary_flash_cellboard_5_tx_t *raw,
    const primary_flash_cellboard_5_tx_converted_t *conversion);


int primary_flash_cellboard_5_tx_to_string(primary_flash_cellboard_5_tx_t *message, char *buffer);

int primary_flash_cellboard_5_tx_to_string_file(primary_flash_cellboard_5_tx_t *message, FILE *buffer);

int primary_flash_cellboard_5_tx_fields(char *buffer);

int primary_flash_cellboard_5_tx_fields_file(FILE *buffer);

/**
 * Pack message FLASH_CELLBOARD_5_TX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_flash_cellboard_5_tx_pack(
    uint8_t *dst_p,
    const primary_flash_cellboard_5_tx_t *src_p,
    size_t bit_size);

/**
 * Unpack message FLASH_CELLBOARD_5_TX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_flash_cellboard_5_tx_unpack(
    primary_flash_cellboard_5_tx_t *dst_p,
    const uint8_t *src_p,
    size_t bit_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void primary_flash_cellboard_5_rx_raw_to_conversion_struct(
    primary_flash_cellboard_5_rx_converted_t *conversion, 
    const primary_flash_cellboard_5_rx_t *raw);


void primary_flash_cellboard_5_rx_conversion_to_raw_struct(
    primary_flash_cellboard_5_rx_t *raw,
    const primary_flash_cellboard_5_rx_converted_t *conversion);


int primary_flash_cellboard_5_rx_to_string(primary_flash_cellboard_5_rx_t *message, char *buffer);

int primary_flash_cellboard_5_rx_to_string_file(primary_flash_cellboard_5_rx_t *message, FILE *buffer);

int primary_flash_cellboard_5_rx_fields(char *buffer);

int primary_flash_cellboard_5_rx_fields_file(FILE *buffer);

/**
 * Pack message FLASH_CELLBOARD_5_RX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_flash_cellboard_5_rx_pack(
    uint8_t *dst_p,
    const primary_flash_cellboard_5_rx_t *src_p,
    size_t bit_size);

/**
 * Unpack message FLASH_CELLBOARD_5_RX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_flash_cellboard_5_rx_unpack(
    primary_flash_cellboard_5_rx_t *dst_p,
    const uint8_t *src_p,
    size_t bit_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void primary_flash_bms_hv_tx_raw_to_conversion_struct(
    primary_flash_bms_hv_tx_converted_t *conversion, 
    const primary_flash_bms_hv_tx_t *raw);


void primary_flash_bms_hv_tx_conversion_to_raw_struct(
    primary_flash_bms_hv_tx_t *raw,
    const primary_flash_bms_hv_tx_converted_t *conversion);


int primary_flash_bms_hv_tx_to_string(primary_flash_bms_hv_tx_t *message, char *buffer);

int primary_flash_bms_hv_tx_to_string_file(primary_flash_bms_hv_tx_t *message, FILE *buffer);

int primary_flash_bms_hv_tx_fields(char *buffer);

int primary_flash_bms_hv_tx_fields_file(FILE *buffer);

/**
 * Pack message FLASH_BMS_HV_TX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_flash_bms_hv_tx_pack(
    uint8_t *dst_p,
    const primary_flash_bms_hv_tx_t *src_p,
    size_t bit_size);

/**
 * Unpack message FLASH_BMS_HV_TX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_flash_bms_hv_tx_unpack(
    primary_flash_bms_hv_tx_t *dst_p,
    const uint8_t *src_p,
    size_t bit_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void primary_flash_bms_hv_rx_raw_to_conversion_struct(
    primary_flash_bms_hv_rx_converted_t *conversion, 
    const primary_flash_bms_hv_rx_t *raw);


void primary_flash_bms_hv_rx_conversion_to_raw_struct(
    primary_flash_bms_hv_rx_t *raw,
    const primary_flash_bms_hv_rx_converted_t *conversion);


int primary_flash_bms_hv_rx_to_string(primary_flash_bms_hv_rx_t *message, char *buffer);

int primary_flash_bms_hv_rx_to_string_file(primary_flash_bms_hv_rx_t *message, FILE *buffer);

int primary_flash_bms_hv_rx_fields(char *buffer);

int primary_flash_bms_hv_rx_fields_file(FILE *buffer);

/**
 * Pack message FLASH_BMS_HV_RX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_flash_bms_hv_rx_pack(
    uint8_t *dst_p,
    const primary_flash_bms_hv_rx_t *src_p,
    size_t bit_size);

/**
 * Unpack message FLASH_BMS_HV_RX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_flash_bms_hv_rx_unpack(
    primary_flash_bms_hv_rx_t *dst_p,
    const uint8_t *src_p,
    size_t bit_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void primary_flash_bms_lv_tx_raw_to_conversion_struct(
    primary_flash_bms_lv_tx_converted_t *conversion, 
    const primary_flash_bms_lv_tx_t *raw);


void primary_flash_bms_lv_tx_conversion_to_raw_struct(
    primary_flash_bms_lv_tx_t *raw,
    const primary_flash_bms_lv_tx_converted_t *conversion);


int primary_flash_bms_lv_tx_to_string(primary_flash_bms_lv_tx_t *message, char *buffer);

int primary_flash_bms_lv_tx_to_string_file(primary_flash_bms_lv_tx_t *message, FILE *buffer);

int primary_flash_bms_lv_tx_fields(char *buffer);

int primary_flash_bms_lv_tx_fields_file(FILE *buffer);

/**
 * Pack message FLASH_BMS_LV_TX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_flash_bms_lv_tx_pack(
    uint8_t *dst_p,
    const primary_flash_bms_lv_tx_t *src_p,
    size_t bit_size);

/**
 * Unpack message FLASH_BMS_LV_TX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_flash_bms_lv_tx_unpack(
    primary_flash_bms_lv_tx_t *dst_p,
    const uint8_t *src_p,
    size_t bit_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void primary_flash_bms_lv_rx_raw_to_conversion_struct(
    primary_flash_bms_lv_rx_converted_t *conversion, 
    const primary_flash_bms_lv_rx_t *raw);


void primary_flash_bms_lv_rx_conversion_to_raw_struct(
    primary_flash_bms_lv_rx_t *raw,
    const primary_flash_bms_lv_rx_converted_t *conversion);


int primary_flash_bms_lv_rx_to_string(primary_flash_bms_lv_rx_t *message, char *buffer);

int primary_flash_bms_lv_rx_to_string_file(primary_flash_bms_lv_rx_t *message, FILE *buffer);

int primary_flash_bms_lv_rx_fields(char *buffer);

int primary_flash_bms_lv_rx_fields_file(FILE *buffer);

/**
 * Pack message FLASH_BMS_LV_RX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_flash_bms_lv_rx_pack(
    uint8_t *dst_p,
    const primary_flash_bms_lv_rx_t *src_p,
    size_t bit_size);

/**
 * Unpack message FLASH_BMS_LV_RX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_flash_bms_lv_rx_unpack(
    primary_flash_bms_lv_rx_t *dst_p,
    const uint8_t *src_p,
    size_t bit_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void primary_brusa_nlg5_ctl_raw_to_conversion_struct(
    primary_brusa_nlg5_ctl_converted_t *conversion, 
    const primary_brusa_nlg5_ctl_t *raw);


void primary_brusa_nlg5_ctl_conversion_to_raw_struct(
    primary_brusa_nlg5_ctl_t *raw,
    const primary_brusa_nlg5_ctl_converted_t *conversion);


int primary_brusa_nlg5_ctl_to_string(primary_brusa_nlg5_ctl_t *message, char *buffer);

int primary_brusa_nlg5_ctl_to_string_file(primary_brusa_nlg5_ctl_t *message, FILE *buffer);

int primary_brusa_nlg5_ctl_fields(char *buffer);

int primary_brusa_nlg5_ctl_fields_file(FILE *buffer);

/**
 * Pack message BRUSA_NLG5_CTL.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_brusa_nlg5_ctl_pack(
    uint8_t *dst_p,
    const primary_brusa_nlg5_ctl_t *src_p,
    size_t bit_size);

/**
 * Unpack message BRUSA_NLG5_CTL.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_brusa_nlg5_ctl_unpack(
    primary_brusa_nlg5_ctl_t *dst_p,
    const uint8_t *src_p,
    size_t bit_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void primary_brusa_st_raw_to_conversion_struct(
    primary_brusa_st_converted_t *conversion, 
    const primary_brusa_st_t *raw);


void primary_brusa_st_conversion_to_raw_struct(
    primary_brusa_st_t *raw,
    const primary_brusa_st_converted_t *conversion);


int primary_brusa_st_to_string(primary_brusa_st_t *message, char *buffer);

int primary_brusa_st_to_string_file(primary_brusa_st_t *message, FILE *buffer);

int primary_brusa_st_fields(char *buffer);

int primary_brusa_st_fields_file(FILE *buffer);

/**
 * Pack message BRUSA_ST.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_brusa_st_pack(
    uint8_t *dst_p,
    const primary_brusa_st_t *src_p,
    size_t bit_size);

/**
 * Unpack message BRUSA_ST.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_brusa_st_unpack(
    primary_brusa_st_t *dst_p,
    const uint8_t *src_p,
    size_t bit_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void primary_brusa_act_i_raw_to_conversion_struct(
    primary_brusa_act_i_converted_t *conversion, 
    const primary_brusa_act_i_t *raw);


void primary_brusa_act_i_conversion_to_raw_struct(
    primary_brusa_act_i_t *raw,
    const primary_brusa_act_i_converted_t *conversion);


int primary_brusa_act_i_to_string(primary_brusa_act_i_t *message, char *buffer);

int primary_brusa_act_i_to_string_file(primary_brusa_act_i_t *message, FILE *buffer);

int primary_brusa_act_i_fields(char *buffer);

int primary_brusa_act_i_fields_file(FILE *buffer);

/**
 * Pack message BRUSA_ACT_I.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_brusa_act_i_pack(
    uint8_t *dst_p,
    const primary_brusa_act_i_t *src_p,
    size_t bit_size);

/**
 * Unpack message BRUSA_ACT_I.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_brusa_act_i_unpack(
    primary_brusa_act_i_t *dst_p,
    const uint8_t *src_p,
    size_t bit_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void primary_brusa_act_ii_raw_to_conversion_struct(
    primary_brusa_act_ii_converted_t *conversion, 
    const primary_brusa_act_ii_t *raw);


void primary_brusa_act_ii_conversion_to_raw_struct(
    primary_brusa_act_ii_t *raw,
    const primary_brusa_act_ii_converted_t *conversion);


int primary_brusa_act_ii_to_string(primary_brusa_act_ii_t *message, char *buffer);

int primary_brusa_act_ii_to_string_file(primary_brusa_act_ii_t *message, FILE *buffer);

int primary_brusa_act_ii_fields(char *buffer);

int primary_brusa_act_ii_fields_file(FILE *buffer);

/**
 * Pack message BRUSA_ACT_II.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_brusa_act_ii_pack(
    uint8_t *dst_p,
    const primary_brusa_act_ii_t *src_p,
    size_t bit_size);

/**
 * Unpack message BRUSA_ACT_II.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_brusa_act_ii_unpack(
    primary_brusa_act_ii_t *dst_p,
    const uint8_t *src_p,
    size_t bit_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void primary_brusa_temp_raw_to_conversion_struct(
    primary_brusa_temp_converted_t *conversion, 
    const primary_brusa_temp_t *raw);


void primary_brusa_temp_conversion_to_raw_struct(
    primary_brusa_temp_t *raw,
    const primary_brusa_temp_converted_t *conversion);


int primary_brusa_temp_to_string(primary_brusa_temp_t *message, char *buffer);

int primary_brusa_temp_to_string_file(primary_brusa_temp_t *message, FILE *buffer);

int primary_brusa_temp_fields(char *buffer);

int primary_brusa_temp_fields_file(FILE *buffer);

/**
 * Pack message BRUSA_TEMP.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_brusa_temp_pack(
    uint8_t *dst_p,
    const primary_brusa_temp_t *src_p,
    size_t bit_size);

/**
 * Unpack message BRUSA_TEMP.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_brusa_temp_unpack(
    primary_brusa_temp_t *dst_p,
    const uint8_t *src_p,
    size_t bit_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


;


;


void primary_brusa_err_raw_to_conversion_struct(
    primary_brusa_err_converted_t *conversion, 
    const primary_brusa_err_t *raw);


void primary_brusa_err_conversion_to_raw_struct(
    primary_brusa_err_t *raw,
    const primary_brusa_err_converted_t *conversion);


int primary_brusa_err_to_string(primary_brusa_err_t *message, char *buffer);

int primary_brusa_err_to_string_file(primary_brusa_err_t *message, FILE *buffer);

int primary_brusa_err_fields(char *buffer);

int primary_brusa_err_fields_file(FILE *buffer);

/**
 * Pack message BRUSA_ERR.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_brusa_err_pack(
    uint8_t *dst_p,
    const primary_brusa_err_t *src_p,
    size_t bit_size);

/**
 * Unpack message BRUSA_ERR.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_brusa_err_unpack(
    primary_brusa_err_t *dst_p,
    const uint8_t *src_p,
    size_t bit_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );


void primary_control_output_raw_to_conversion(
    primary_control_output_converted_t *conversion,
    float estimated_velocity,
    float tmax_r,
    float tmax_l,
    float torque_l,
    float torque_r
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_control_output_conversion_to_raw(
    primary_control_output_t *raw,
    float estimated_velocity,
    float tmax_r,
    float tmax_l,
    float torque_l,
    float torque_r
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAM
);


void primary_control_output_raw_to_conversion_struct(
    primary_control_output_converted_t *conversion, 
    const primary_control_output_t *raw);


void primary_control_output_conversion_to_raw_struct(
    primary_control_output_t *raw,
    const primary_control_output_converted_t *conversion);


int primary_control_output_converted_to_string(primary_control_output_converted_t *message, char *buffer);

int primary_control_output_converted_to_string_file(primary_control_output_converted_t *message, FILE *buffer);

int primary_control_output_fields(char *buffer);

int primary_control_output_fields_file(FILE *buffer);

/**
 * Pack message CONTROL_OUTPUT.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_control_output_pack(
    uint8_t *dst_p,
    const primary_control_output_t *src_p,
    size_t bit_size);

/**
 * Unpack message CONTROL_OUTPUT.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_control_output_unpack(
    primary_control_output_t *dst_p,
    const uint8_t *src_p,
    size_t bit_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_control_output_estimated_velocity_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_control_output_estimated_velocity_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_control_output_estimated_velocity_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t primary_control_output_tmax_r_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_control_output_tmax_r_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_control_output_tmax_r_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t primary_control_output_tmax_l_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_control_output_tmax_l_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_control_output_tmax_l_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_control_output_torque_l_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_control_output_torque_l_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_control_output_torque_l_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t primary_control_output_torque_r_encode(float value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
float primary_control_output_torque_r_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool primary_control_output_torque_r_is_in_range(uint16_t value);


;


;


void primary_lc_reset_raw_to_conversion_struct(
    primary_lc_reset_converted_t *conversion, 
    const primary_lc_reset_t *raw);


void primary_lc_reset_conversion_to_raw_struct(
    primary_lc_reset_t *raw,
    const primary_lc_reset_converted_t *conversion);


int primary_lc_reset_to_string(primary_lc_reset_t *message, char *buffer);

int primary_lc_reset_to_string_file(primary_lc_reset_t *message, FILE *buffer);

int primary_lc_reset_fields(char *buffer);

int primary_lc_reset_fields_file(FILE *buffer);

/**
 * Pack message LC_RESET.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int primary_lc_reset_pack(
    uint8_t *dst_p,
    const primary_lc_reset_t *src_p,
    size_t bit_size);

/**
 * Unpack message LC_RESET.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int primary_lc_reset_unpack(
    primary_lc_reset_t *dst_p,
    const uint8_t *src_p,
    size_t bit_size
    #ifdef CANLIB_TIMESTAMP
        , uint64_t _timestamp
    #endif // CANLIB_TIMESTAMP
    );

bool primary_id_is_message(uint16_t id);

int primary_to_string_from_id(uint16_t message_id, void* message, char* buffer);
int primary_fields_from_id(uint16_t message_id, char* buffer);
int primary_to_string_file_from_id(uint16_t message_id, void* message, FILE* buffer);
int primary_fields_file_from_id(uint16_t message_id, FILE* buffer);

#ifdef __cplusplus
}
#endif

#endif
